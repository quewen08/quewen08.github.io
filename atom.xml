<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南山结庐</title>
  
  <subtitle>宁愿花时间去修炼不完美的自己&amp;#44;也不要浪费时间去期待完美的别人。</subtitle>
  <link href="https://www.buerya.cn/atom.xml" rel="self"/>
  
  <link href="https://www.buerya.cn/"/>
  <updated>2023-05-05T14:38:51.953Z</updated>
  <id>https://www.buerya.cn/</id>
  
  <author>
    <name>东篱先生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之建造者模式</title>
    <link href="https://www.buerya.cn/2023/design-builder-pattern/index/"/>
    <id>https://www.buerya.cn/2023/design-builder-pattern/index/</id>
    <published>2023-04-29T03:29:48.000Z</published>
    <updated>2023-05-05T14:38:51.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建造者模式是什么？"><a href="#建造者模式是什么？" class="headerlink" title="建造者模式是什么？"></a>建造者模式是什么？</h2><ul><li>建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。</li><li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ul><p><strong>建造者模式所完成的内容就是通过将多个简单对象通过一步步的组装构建出一个复杂对象的过程。</strong></p><blockquote><p>那么，哪有这样的场景呢？<br>如你玩王者荣耀的时的初始化界面；有三条路、有树、有怪、有守卫塔等等，甚至依赖于你的网络情况会控制清晰度。当你换一个场景进行其他不同模式的选择时，同样会建设道路、树、怪等等，但是他们的摆放和大小都有不同。这里就可以用到建造者模式来初始化游戏元素。<br>而这样的根据相同的 物料 ，不同的组装所产生出的具体的内容，就是建造者模式的最终意图，也就是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><h2 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h2><p>这里我们模拟装修公司对于设计出一些套餐装修服务的场景。</p><h3 id="物料"><a href="#物料" class="headerlink" title="物料"></a>物料</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="comment">// 场景；地板、地砖、涂料、吊顶</span></span><br><span class="line">    String <span class="title function_">scene</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 品牌</span></span><br><span class="line">    String <span class="title function_">brand</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 型号</span></span><br><span class="line">    String <span class="title function_">model</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    BigDecimal <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    String <span class="title function_">desc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="吊顶"><a href="#吊顶" class="headerlink" title="吊顶"></a>吊顶</h4><ol><li>一级吊顶</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LevelOneCeiling</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;吊顶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;装修公司自带&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一级顶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        rerturn <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">260</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;造型只做低一级，只有一个层次的吊顶，一般离顶120-150mm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二级吊顶</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LevelOneCeiling</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;吊顶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;装修公司自带&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;二级顶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        rerturn <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">850</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;两个层次的吊顶，二级吊顶高度一般就往下吊20cm，要是层高很高，也可增加每级的厚度&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="涂料"><a href="#涂料" class="headerlink" title="涂料"></a>涂料</h4><ul><li>多乐士</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuluxCOat</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;涂料&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;多乐士(Dulux)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;第二代&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        rerturn <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">719</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;多乐士是阿克苏诺尔旗下的著名建筑装饰油漆品牌，产品畅销于全球100个国 家，每年全球有5000万户家庭使⽤多乐士油漆.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>立邦</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiBangCoat</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;涂料&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;立邦&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;默认级别&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">650</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;立邦始终以开发绿色产品、注重高科技、高品质为目标，以技术力量不断推进科研和开发，满足消费者需求。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="地板"><a href="#地板" class="headerlink" title="地板"></a>地板</h4><ul><li>德尔</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DerFloor</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;地板&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;德尔(Der)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A+&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">119</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DER德尔集团是全球领先的专业木地板制造商，北京2008年奥运会家装和公装地板供应商&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>圣象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShengXiangFloor</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;地板&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;圣象&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一级&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">318</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;圣象地板是中国地板行业著名品牌。圣象地板拥有中国驰名商标、中国名牌、国家免检、中国环境标志认证等多项荣誉。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="地砖"><a href="#地砖" class="headerlink" title="地砖"></a>地砖</h4><ul><li>东鹏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DongPengTile</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;地砖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;东鹏瓷砖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;10001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">102</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;东鹏瓷砖以品质铸就品牌，科技推动品牌，口碑传播品牌为宗旨，2014年品牌价值132 .35 亿元，位列建陶业榜第一。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>马可波罗</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarcoPoloTile</span> <span class="keyword">implements</span> <span class="title class_">Matter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">scene</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;地砖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">brand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;马可波罗(MARCO POLO)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">model</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;缺省&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">140</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;“马可波罗”品牌诞生于1996年，作为国内最早品牌化的建陶品牌，以“文化陶瓷”占领市场，享有“仿古砖至尊”的美誉。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="材料构建完成，使用建造者模式"><a href="#材料构建完成，使用建造者模式" class="headerlink" title="材料构建完成，使用建造者模式"></a>材料构建完成，使用建造者模式</h3><blockquote><p>工程中有三个核心类和一个测试类，核心类是建造者模式的具体实现。具体功能如下；<br>Builder ，建造者类具体的各种组装由此类实现。<br>DecorationPackageMenu ，是 IMenu 接口的实现类，主要是承载建造过程中的填充器。相当于<br>这是一套承载物料和创建者中间衔接的内容。</p></blockquote><p>好，那么接下来会分别讲解每个类的具体实现。</p><h4 id="定义装修包接口"><a href="#定义装修包接口" class="headerlink" title="定义装修包接口"></a>定义装修包接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMenu</span> &#123;</span><br><span class="line">            </span><br><span class="line">    IMenu <span class="title function_">appendCeiling</span><span class="params">(Matter matter)</span>; <span class="comment">// 吊顶</span></span><br><span class="line">    </span><br><span class="line">    IMenu <span class="title function_">appendCoat</span><span class="params">(Matter matter)</span>; <span class="comment">// 涂料</span></span><br><span class="line">    </span><br><span class="line">    IMenu <span class="title function_">appendFloor</span><span class="params">(Matter matter)</span>; <span class="comment">// 地板</span></span><br><span class="line">    </span><br><span class="line">    IMenu <span class="title function_">appendTile</span><span class="params">(Matter matter)</span>; <span class="comment">// 地砖</span></span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">getDetail</span><span class="params">()</span>; <span class="comment">// 明细</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装修包实现"><a href="#装修包实现" class="headerlink" title="装修包实现"></a>装修包实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecorationPackageMenu</span> <span class="keyword">implements</span> <span class="title class_">IMenu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Matter&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Matter&gt;(); <span class="comment">// 装修清单</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal area; <span class="comment">// ⾯积</span></span><br><span class="line">    <span class="keyword">private</span> String grade; <span class="comment">// 装修等级；豪华欧式、轻奢⽥园、现代简约</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DecorationPackageMenu</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecorationPackageMenu</span><span class="params">(Double area, String grade)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.area = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(area);</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IMenu <span class="title function_">appendCeiling</span><span class="params">(Matter matter)</span> &#123;</span><br><span class="line">        list.add(matter);</span><br><span class="line">        price = price.add(area.multiply(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>)).multiply(matter.price()));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IMenu <span class="title function_">appendCoat</span><span class="params">(Matter matter)</span> &#123;</span><br><span class="line">        list.add(matter);</span><br><span class="line">        price = price.add(area.multiply(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.4&quot;</span>)).multiply(matter.price()));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IMenu <span class="title function_">appendFloor</span><span class="params">(Matter matter)</span> &#123;</span><br><span class="line">        list.add(matter);</span><br><span class="line">        price = price.add(area.multiply(matter.price()));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IMenu <span class="title function_">appendTile</span><span class="params">(Matter matter)</span> &#123;</span><br><span class="line">        list.add(matter);</span><br><span class="line">        price = price.add(area.multiply(matter.price()));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDetail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;\r\n--------------------</span></span><br><span class="line"><span class="string">                -----------------------------------\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;装修清单&quot;</span> + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;套餐等级：&quot;</span> + grade + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;套餐价格：&quot;</span> + price.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP) +</span><br><span class="line">                        <span class="string">&quot; 元\r\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;房屋面积：&quot;</span> + area.doubleValue() + <span class="string">&quot; 平米\r\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;材料清单：\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Matter matter: list) &#123;</span><br><span class="line">            detail.append(matter.scene()).append(<span class="string">&quot;：&quot;</span>).append(matter.brand()).append( <span class="string">&quot;、&quot;</span>).append(matter.model())</span><br><span class="line">                    .append(<span class="string">&quot;、平米价格：&quot;</span>).append(matter.price()).append(<span class="string">&quot; 元。\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> detail.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建造者方法"><a href="#建造者方法" class="headerlink" title="建造者方法"></a>建造者方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IMenu <span class="title function_">levelOne</span><span class="params">(Double area)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DecorationPackageMenu</span>(area, <span class="string">&quot;豪华欧式&quot;</span>)</span><br><span class="line">        .appendCeiling(<span class="keyword">new</span> <span class="title class_">LevelTwoCeiling</span>()) <span class="comment">// 吊顶，二级顶</span></span><br><span class="line">        .appendCoat(<span class="keyword">new</span> <span class="title class_">DuluxCoat</span>()) <span class="comment">// 涂料，多乐士</span></span><br><span class="line">        .appendFloor(<span class="keyword">new</span> <span class="title class_">ShengXiangFloor</span>()); <span class="comment">// 地板，圣象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IMenu <span class="title function_">levelTwo</span><span class="params">(Double area)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DecorationPackageMenu</span>(area, <span class="string">&quot;轻奢田园&quot;</span>)</span><br><span class="line">        .appendCeiling(<span class="keyword">new</span> <span class="title class_">LevelTwoCeiling</span>()) <span class="comment">// 吊顶，二级顶</span></span><br><span class="line">        .appendCoat(<span class="keyword">new</span> <span class="title class_">LiBangCoat</span>()) <span class="comment">// 涂料，立邦</span></span><br><span class="line">        .appendTile(<span class="keyword">new</span> <span class="title class_">MarcoPoloTile</span>()); <span class="comment">// 地砖，马可波罗</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IMenu <span class="title function_">levelThree</span><span class="params">(Double area)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DecorationPackageMenu</span>(area, <span class="string">&quot;现代简约&quot;</span>)</span><br><span class="line">        .appendCeiling(<span class="keyword">new</span> <span class="title class_">LevelOneCeiling</span>()) <span class="comment">// 吊顶，二级顶</span></span><br><span class="line">        .appendCoat(<span class="keyword">new</span> <span class="title class_">LiBangCoat</span>()) <span class="comment">// 涂料，立邦</span></span><br><span class="line">        .appendTile(<span class="keyword">new</span> <span class="title class_">DongPengTile</span>()); <span class="comment">// 地砖，东鹏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Builder</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>();</span><br><span class="line">    <span class="comment">// 豪华欧式</span></span><br><span class="line">    System.out.println(builder.levelOne(<span class="number">132.52D</span>).getDetail());</span><br><span class="line">    <span class="comment">// 轻奢⽥园</span></span><br><span class="line">    System.out.println(builder.levelTwo(<span class="number">98.25D</span>).getDetail());</span><br><span class="line">    <span class="comment">// 现代简约</span></span><br><span class="line">    System.out.println(builder.levelThree(<span class="number">85.43D</span>).getDetail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是建造者模式的一个例子</p><h2 id="建造者模式的注意细节"><a href="#建造者模式的注意细节" class="headerlink" title="建造者模式的注意细节"></a>建造者模式的注意细节</h2><p>客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象<br>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同<br>的产品对象<br>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程<br>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合<code>开闭原则</code></p>]]></content>
    
    
    <summary type="html">建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。</summary>
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="设计模式" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.buerya.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="建造者模式" scheme="https://www.buerya.cn/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络管理</title>
    <link href="https://www.buerya.cn/2022/docker-network/index/"/>
    <id>https://www.buerya.cn/2022/docker-network/index/</id>
    <published>2022-10-21T12:11:19.000Z</published>
    <updated>2022-10-21T11:30:25.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><p>容器的网络通信可以分为两大方面：单主机上的容器之间相互通信和跨主机的容器相互通信。</p><p>docker 的单主机通信基于 Network Namespace 实现，它可以为容器创建隔离的网络环境。docker 官方本身提供了 5 种网络模式，可以基本满足日常开发中的需求：</p><table><thead><tr><th>网络模式</th><th>说明</th></tr></thead><tbody><tr><td>bridge</td><td>默认，为每个容器分配一个 IP，该 IP 会连接到 docker 宿主机的 docker0 虚拟网卡</td></tr><tr><td>host</td><td>容器不会拥有自己的虚拟网卡和 IP，而是直接使用宿主机的 IP 和端口</td></tr><tr><td>none</td><td>为容器创建独立网络名称空间，但不做任何网络配置，容器中只有 lo，用户可以就此对容器网络做任意定制</td></tr><tr><td>container</td><td>类似 host，容器不会拥有自己的网卡和 IP，而是和一个指定的容器共享 IP，端口等</td></tr><tr><td>用户自定义</td><td>在 docker 1.9 以后新增的特性，允许容器使用第三方的网络实现或者创建单独的 bridge 网络，提供网络隔离能力</td></tr></tbody></table><p>在安装完成 docker 之后，会默认创建三种网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-network/979767-20220704091535994-104412335.png"></p><p>在运行容器时，可以使用 <code>--network</code> 或者 <code>--net</code> 指定容器使用的网络模式，如：<code>--net bridge</code></p><p>同时也可以使用命令查看网络模式下有哪些容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>bridge 模式是 docker 默认的网络模式，也是开发者最常使用的网络模式。</p><p>在这种模式下，docker 为容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，实现容器与容器之间、容器与宿主机之间的网络栈隔离。</p><p>同时，通过宿主机上的 docker0 网桥，容器可以与宿主机乃至外界进行网络通信。其网络模型可以参考下图：</p><p><img src="/img/2022/docker-network/979767-20220704091606017-359286512.png"></p><p>大致流程如下：</p><ol><li><p>docker 先创建一对虚拟网卡 <code>veth pair</code> 设备（其特征为：成对出现，数据从一个设备进入，就会从另一个设备出来，常用于实现数据通道）。</p></li><li><p>docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0。</p></li><li><p>docker 将 veth pair 设备的另一端放在宿主机中，以 vethxxx 格式命名，并将它加入到 docker0 网桥中（可通过 brctl show 命令查看到）。</p></li><li><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 为容器的默认网关。</p></li></ol><h4 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h4><h5 id="查看本机网络情况："><a href="#查看本机网络情况：" class="headerlink" title="查看本机网络情况："></a>查看本机网络情况：</h5><p><img src="/img/2022/docker-network/979767-20220704091633136-860769745.png"></p><p>docker 安装完后会在宿主机创建一个 <code>docker0</code> 虚拟网卡。其作用类似于网络交换设备，用于实现容器之间，容器与宿主机之间甚至容器与外部主机之间的通信</p><p>docker0 网桥的 IP 一般会是 docker 配置网段的第一个 IP，且这个 IP 会作为 bridge 网络模式的容器的网关使用。</p><p>本文由于我们在配置 docker 时有另外指定了 IP 网段，所以这里看到的网段为：<code>172.16.0.0/16</code> 而不是 docker 默认的网段 <code>172.17.0.0/16</code>。</p><h5 id="新建两个容器并查看其网络情况："><a href="#新建两个容器并查看其网络情况：" class="headerlink" title="新建两个容器并查看其网络情况："></a>新建两个容器并查看其网络情况：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端 1</span></span><br><span class="line">docker container run --<span class="built_in">rm</span> -it --name demo01 busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端 2</span></span><br><span class="line">docker container run --<span class="built_in">rm</span> -it --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>终端 1：</p><p><img src="/img/2022/docker-network/979767-20220704091656783-1241667431.png"></p><p>终端 2:</p><p><img src="/img/2022/docker-network/979767-20220704091704333-641634607.png"></p><h5 id="查看此时宿主机网络情况："><a href="#查看此时宿主机网络情况：" class="headerlink" title="查看此时宿主机网络情况："></a>查看此时宿主机网络情况：</h5><p><img src="/img/2022/docker-network/979767-20220704091721008-803339553.png"></p><p>宿主机多了两个 veth 网卡，这两个网卡就是和容器内部的 eth0 成对出现的，通过 <code>bridge-utils</code> 提供的命令也可以看到它们和 docker0 的连接关系。</p><h5 id="查看任意容器的详细信息："><a href="#查看任意容器的详细信息：" class="headerlink" title="查看任意容器的详细信息："></a>查看任意容器的详细信息：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect demo01</span><br></pre></td></tr></table></figure><p>找到网络配置部分，如下图所示：</p><p><img src="/img/2022/docker-network/979767-20220704091744085-427117787.png"></p><p>docker0 网卡的 IP 地址被作为容器的网关。</p><h5 id="测试容器和外部连通性："><a href="#测试容器和外部连通性：" class="headerlink" title="测试容器和外部连通性："></a>测试容器和外部连通性：</h5><p><img src="/img/2022/docker-network/979767-20220704091754258-1370297203.png"></p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host 网络模式的容器可直接使用宿主机的 IP 与外界通信，同时容器内的端口也直接使用宿主机的端口，无需额外 NAT 转换。创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定。</p><p><img src="/img/2022/docker-network/979767-20220704091804590-1310706088.png"></p><h4 id="测试示例"><a href="#测试示例" class="headerlink" title="测试示例"></a>测试示例</h4><h5 id="创建一个-Nginx-容器："><a href="#创建一个-Nginx-容器：" class="headerlink" title="创建一个 Nginx 容器："></a>创建一个 Nginx 容器：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --net host --<span class="built_in">rm</span> --name demo01 nginx</span><br></pre></td></tr></table></figure><p>查看端口使用情况：</p><p><img src="/img/2022/docker-network/979767-20220704091823317-1908177264.png"></p><p>可以发现 80 端口已经在宿主机启动。</p><h5 id="查看容器的网络信息："><a href="#查看容器的网络信息：" class="headerlink" title="查看容器的网络信息："></a>查看容器的网络信息：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect demo01</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-network/979767-20220704091834984-308810944.png"></p><p>网络模式已经成为 host，且本身没有 IP 信息。</p><h5 id="测试端口占用信息："><a href="#测试端口占用信息：" class="headerlink" title="测试端口占用信息："></a>测试端口占用信息：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --net host --<span class="built_in">rm</span> --name demo02 nginx</span><br></pre></td></tr></table></figure><p>容器无法运行，查看日志提示端口被占用。</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>none 网络模式是指禁用网络功能，只有 lo 本地环回接口。在创建容器时通过参数 <code>--net none</code> 或 <code>--network none</code> 指定。</p><p>创建一个测试容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it --<span class="built_in">rm</span> none --name demo01 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>查看网络信息：</p><p><img src="/img/2022/docker-network/979767-20220704091946328-1290620573.png"></p><p>该容器无法和宿主机通信。</p><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>Container 网络模式是 docker 中一种较为特别的网络的模式。在创建容器时通过参数 –net container:已运行的容器名称|ID 或者 –network container:已运行的容器名称|ID 指定。</p><p>处于这个模式下的容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。</p><p>Container 网络模式下，新创建的容器不会创建自己的网卡，而是和一个指定的容器共享 IP、端口范围等。除了网络方面相同之外，其它都是隔离的。</p><p>其原理大致如下：</p><p><img src="/img/2022/docker-network/979767-20220704091956538-381437287.png"></p><h4 id="测试示例-1"><a href="#测试示例-1" class="headerlink" title="测试示例"></a>测试示例</h4><h5 id="创建一个-bridge-网络模式的容器："><a href="#创建一个-bridge-网络模式的容器：" class="headerlink" title="创建一个 bridge 网络模式的容器："></a>创建一个 bridge 网络模式的容器：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --name demo01 nginx</span><br><span class="line">docker container inspect demo01</span><br></pre></td></tr></table></figure><p>网络配置如下所示：</p><p><img src="/img/2022/docker-network/979767-20220704092014851-2142729234.png"></p><h5 id="创建一个-container-网络模式的容器："><a href="#创建一个-container-网络模式的容器：" class="headerlink" title="创建一个 container 网络模式的容器："></a>创建一个 container 网络模式的容器：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --<span class="built_in">rm</span> -it --net container:demo01 --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>网络信息如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092044531-1942375962.png"></p><h5 id="此时删除-demo01-容器再查看-demo02-的网络："><a href="#此时删除-demo01-容器再查看-demo02-的网络：" class="headerlink" title="此时删除 demo01 容器再查看 demo02 的网络："></a>此时删除 demo01 容器再查看 demo02 的网络：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">rm</span> -f demo01</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-network/979767-20220704092105202-406328144.png"></p><p>网卡只剩下 lo 回环网卡。</p><p><code>docker container run --link</code></p><p>可以用来连接两个容器，能够实现被链接的容器（源容器）和主动去链接的容器（接收容器）之间互相通信，并且接收容器可以获取源容器的一些数据，如环境变量。不过该方法将来可能被 docker 废弃。</p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>docker 提供的默认网络模式使用起来比较简单，但是在实际应用中，为了保证应用的安全性，还是更推荐自定义网络来进行容器管理。并启用容器名称到容器 IP 的自动 DNS 解析。</p><blockquote><p>从 docker 1.10 版本开始，docker daemon 实现了一个内嵌 DNS Server，但只能在用户自定义的网络模式使用，它可以实现直接使用容器的名称进行通信。</p></blockquote><h4 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h4><p>使用命令直接创建一个自定义的 bridge 网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge hello_bridge</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092119145-1396915150.png"></p><p><code>-d，--driver</code> 参数可以指定网络模式，默认不指定就是 bridge 模式。</p><h4 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h4><p>再次创建一个自定义网络协助测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge world_bridge</span><br></pre></td></tr></table></figure><p>创建相关的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认网络</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --name demo01 busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># hello_bridge 网络</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --net hello_bridge --name demo02 busybox sh</span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --net hello_bridge --name demo03 busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># world_bridge 网络</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --net world_bridge --name demo04 busybox sh</span><br></pre></td></tr></table></figure><p>查看此时的网络情况</p><p><img src="/img/2022/docker-network/979767-20220704092152957-641815307.png"></p><p>可以发现 IP 多了一些的新的网段，同一网络模式的容器处于同一网段。</p><p>此时查看本机的网络情况：</p><p><img src="/img/2022/docker-network/979767-20220704092220944-1730385068.png"></p><p>可以发现多了两个类似于 docker0 网桥的网卡，都分配了新的网段。由此可以知道，每新建一个 bridge 网络，就会在宿主机新建一个 bridge 网桥，并分配一个新的网段。</p><p>测试网络连通性：</p><p>demo01 测试：</p><p><img src="/img/2022/docker-network/979767-20220704092233837-1409078039.png" alt="demo01 测试"></p><p>demo02 测试：</p><p><img src="/img/2022/docker-network/979767-20220704092243092-165781342.png" alt="demo02 测试"></p><p>剩下的就不做测试了，但是大致能得出以下结论：</p><ol><li>不同的网络之间是隔离的，无法互相通信。</li><li>在自定义网络中，容器可以使用容器名称直接通信。</li></ol><h4 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h4><p>可以将现有的容器连接到其它网络中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect bridge demo04</span><br></pre></td></tr></table></figure><p>此时查看网络情况：</p><p><img src="/img/2022/docker-network/979767-20220704092255464-1585960726.png"></p><p>可以发现限制 demo04 容器既属于默认 bridge 网络，也属于 world_bridge 网络了，这也就能和默认网络的 demo01 进行通信。</p><h4 id="断开网络"><a href="#断开网络" class="headerlink" title="断开网络"></a>断开网络</h4><p>可以连接网络自然也可以断开网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect bridge demo04</span><br><span class="line">docker network disconnect world_bridge demo04</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092305846-1244327742.png"></p><p>当连接的网络都断开之后，它的网络模式就像 none 网络了。</p><h4 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h4><p>对于没有使用的网络也可以进行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> world_bridge</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092318259-979745258.png"></p><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>当容器内部应用想要暴露给外部访问，就需要使用到 <code>-P</code> 或者 <code>-p</code> 参数来进行端口映射。</p><p>随机映射（-P）</p><p>使用 <code>-P</code> 参数能够随机映射一个 <code>32768</code> 以上的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --<span class="built_in">rm</span> -P --name demo01 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时查看容器详情：</p><p><img src="/img/2022/docker-network/979767-20220704092332863-390921249.png"></p><p>能够看到容器内部 nginx 的 80 端口以及被随机映射到了 49153 端口，可以使用宿主机加这个随机端口在浏览器进行访问。</p><h4 id="指定映射（-p）"><a href="#指定映射（-p）" class="headerlink" title="指定映射（-p）"></a>指定映射（-p）</h4><p>使用 <code>-p</code> 参数能够指定映射的端口，它的格式为：<code>监听IP:宿主机端口:容器端口</code>，<code>监听IP::容器端口</code>，<code>宿主机端口:容器端口</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整的监听映射</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;0.0.0.0:8080:80&quot;</span> --name demo01 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机映射</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;0.0.0.0::80&quot;</span> --name demo02 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通监听映射</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;8081:80&quot;</span> --name demo03 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口协议</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;0.0.0.0:8080:80/udp&quot;</span> --name demo04 nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092343147-280600039.png"></p><p>如果有多个端口需要映射则指定多个 -p 即可。</p><p>也可以通过命令反查容器映射了哪些端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container port demo01</span><br><span class="line">docker container port demo01 80</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092355495-1641775382.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络模式&quot;&gt;&lt;a href=&quot;#网络模式&quot; class=&quot;headerlink&quot; title=&quot;网络模式&quot;&gt;&lt;/a&gt;网络模式&lt;/h3&gt;&lt;p&gt;容器的网络通信可以分为两大方面：单主机上的容器之间相互通信和跨主机的容器相互通信。&lt;/p&gt;
&lt;p&gt;docker 的单主机通信</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>资源限制</title>
    <link href="https://www.buerya.cn/2022/docker-assets/index/"/>
    <id>https://www.buerya.cn/2022/docker-assets/index/</id>
    <published>2022-10-20T13:39:39.000Z</published>
    <updated>2022-10-20T13:28:49.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p><code>cgroup</code>（control group，控制组） 是 Linux 内核的一个功能，可以用来限制、控制与分离一个进程组。Docker 就是通过 cgroup 来控制容器的 CPU、内存、磁盘输入输出等资源。</p><p>在默认情况下，Docker 容器是没有资源限制的，它会尽可能地使用宿主机能够分配给它的资源。如果不对容器资源进行限制，容器之间就会相互影响，一些占用硬件资源较高的容器会吞噬掉所有的硬件资源，从而导致其它容器无硬件资源可用，发生停服。</p><p>Docker 提供了限制内存，CPU 或磁盘 IO 的方法， 在 docker create 或者 docker run 的时候可以对容器所占用的硬件资源大小以及多少进行限制。</p><h3 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h3><p>默认情况下，所有容器可以平等地使用宿主机的 CPU 资源，如果想要限制 CPU 资源，可以使用以下参数进行限制。</p><h4 id="相对限制"><a href="#相对限制" class="headerlink" title="相对限制"></a>相对限制</h4><ul><li><p><code>-c</code> 或 <code>--cpu-shares</code>：用于多个容器运行时设置容器对于 CPU 的使用权重比例（共享权值）。</p><ul><li><p>Docker 默认每个容器的权值为<code>1024</code>。如果不指定或将其设置为 0，都将使用默认值。</p></li><li><p>当系统上运行了两容器，第一个权重是 1024，第二个权重是 512。第二个启动后没运行任何进程，第一个的进程很多。此时，第一个完全可以占用第二个的 CPU 空闲资源，这就是共享式 CPU 资源。如果第二个也跑了进程，那么就会把自己的 512 给要回来，按照正常权重1024:512 划分。</p></li><li><p>CPU 共享式证明了 CPU 为可压缩性资源。</p></li></ul></li><li><p><code>--cpus</code>：用于限制容器运行的核数。</p><ul><li>从 1.13 版本之后开始支持限定容器能使用的 CPU 核数，属于常用的限制手段之一。</li></ul></li><li><p><code>--cpuset-cpus</code>：用于限制容器运行的 CPU 核心。</p><ul><li>例如，主机有 4 个 CPU 核心，CPU 核心标识为 0-3，可以指定容器只在标识 0 和 3 的两个 CPU 核心上运行。</li></ul></li></ul><blockquote><p>通过 -c 设置的并不是 CPU 资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的 CPU 资源取决于它的分配的权重占所有容器总和的比例。换句话说，通过 -c 参数可以设置容器使用 CPU 的优先级。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定权重</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> -c 1024 --name demo01 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定核数，可以是 1.5 之类的小数</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --cpus=2 --name demo02 busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器在 CPU-1 和 CPU-3 上执行</span></span><br><span class="line">docker container run -it --cpuset-cpus=<span class="string">&quot;1,3&quot;</span> --name demo03 busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器在 CPU-0、CPU-1 及 CPU-2 上执行</span></span><br><span class="line">docker container run -it --cpuset-cpus=<span class="string">&quot;0-2&quot;</span> --name demo04 busybox /bin/sh</span><br></pre></td></tr></table></figure><h4 id="绝对限制"><a href="#绝对限制" class="headerlink" title="绝对限制"></a>绝对限制</h4><p>Linux 通过 <code>CFS</code>（Completely Fair Scheduler，完全公平调度器）来调度各个进程对 CPU 的使用。CFS 默认的调度周期是 <code>100ms</code>。</p><p>我们可以通过设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少 CPU 时间来达到限制 CPU 的目的。具体参数如下：</p><ul><li><p><code>--cpu-period</code>：设置每个容器进程的调度周期，单位 us。</p></li><li><p><code>--cpu-quota</code>：设置在每个周期内容器能使用的 CPU 时间，单位 us。</p></li></ul><p>示例 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 CFS 调度周期设为 50000，将每个周期内的 CPU 配额设置为 25000</span></span><br><span class="line">docker run -it --cpu-period=50000 --cpu-quota=25000 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>该配置表示该容器每 50ms 可以得到 50% 的 CPU 运行时间。</p><p>示例 2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器的 CPU 配额设置为 CFS 周期的两倍</span></span><br><span class="line">docker run -it --cpu-period=10000 --cpu-quota=20000 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>CPU 使用时间是周期的两倍，意味着给容器分配了两个 CPU。容器可以在每个周期内使用两个 CPU 的 100% 时间。</p><p>CFS 周期的有效范围是 1ms<del>1s，对应的 –cpu-period 的数值范围是 1000</del>1000000。</p><p>容器的 CPU 配额必须不小于 1ms，即 –cpu-quota 的值必须 &gt;&#x3D; 1000。</p><p>–cpu-quota 设置容器在一个调度周期内能使用的 CPU 时间实际上是一个上限时间，并不是说容器一定会使用这么长的 CPU 时间。</p><h3 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h3><p>在默认的情况下，容器的内存是没有限制的。也是就说，如果不限制，容器将能使用宿主机能够调用的最大内存。</p><p>这在生产环境是非常危险的行为，很容易造成宿主机 OOM（内存溢出），然后为了释放内存空间而杀掉一些其它进程，这其中可能包含 docker daemon 进程（docker 对优先级做了调整，一般杀不到它）。但这在生产中是绝对不允许的。</p><p>可以通过两个参数限制内存：</p><ul><li><code>-m，--memory</code>：设置内存使用限额，例如：100MB，1GB。</li><li><code>--memory-swap</code>：设置内存 + Swap 的是使用限额。<br>默认情况下，两个参数的值都是<code>-1</code>。但是如果在启动是指定了<code>-m</code>，那么<code>--memory-swap</code>会是<code>-m</code>的两倍。</li></ul><p>限制内存使用的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许容器使用 100M 内存和 100M Swap</span></span><br><span class="line">docker container run -d -m 100m --name demo01 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许容器使用 100M 内存和 200M Swap</span></span><br><span class="line">docker container run -d -m 100m --memory-swap 300m --name demo02 nginx</span><br></pre></td></tr></table></figure><p>如果发生内存溢出错误，内核将 kill 掉容器中的进程。可以使用 <code>--oom-kill-disable</code> 参数控制。</p><h3 id="磁盘-IO-限制"><a href="#磁盘-IO-限制" class="headerlink" title="磁盘 IO 限制"></a>磁盘 IO 限制</h3><p>Block IO 是另一种可以限制容器使用的资源。Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽。</p><ul><li><code>bps</code>： byte per second，表示每秒读写的数据量。</li><li><code>iops</code>：io per second，表示每秒的输入输出量（或读写次数）。<br>目前 Block IO 限额只对 direct IO（不使用文件缓存）有效。</li></ul><p>支持如下参数：</p><ul><li><code>--blkio-weight</code>：用于改变容器的权重，类似于 CPU 限制的 -c 参数，默认值为 500。</li><li><code>--device-read-bps</code>：限制读某个设备的 bps。</li><li><code>--device-write-bps</code>：限制写某个设备的 bps。</li><li><code>--device-read-iops</code>：限制读某个设备的 iops。</li><li><code>--device-write-iops</code>：限制写某个设备的 iops。</li></ul><p>使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制读写权重</span></span><br><span class="line">docker container run -d --blkio-weight 500 --name demo01 nginx</span><br><span class="line">docker container run -d --blkio-weight 250 --name demo02 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制磁盘 /dev/sda 写带宽为 30M</span></span><br><span class="line">docker container run -d --device-write-bps /dev/sda:30MB --name demo03 nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;资源限制&quot;&gt;&lt;a href=&quot;#资源限制&quot; class=&quot;headerlink&quot; title=&quot;资源限制&quot;&gt;&lt;/a&gt;资源限制&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cgroup&lt;/code&gt;（control group，控制组） 是 Linux 内核的一个功能，可以用来限制、</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据持久化</title>
    <link href="https://www.buerya.cn/2022/docker-volume/index/"/>
    <id>https://www.buerya.cn/2022/docker-volume/index/</id>
    <published>2022-09-21T13:39:39.000Z</published>
    <updated>2022-10-20T13:28:49.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>默认情况下，容器被删除，容器中数据也会随着一起删除。这对于某些重要的数据是绝对不允许的。此时就需要对数据进行持久化。<br><code>数据卷</code>是一个可以提供给一个或者多个容器使用的特殊目录，它绕过 UFS，能提供以下特性：</p><ul><li>多个容器可以共享和重用。</li><li>对数据卷的修改会马上生效。</li><li>对数据卷的更新不会影响镜像。</li><li>数据卷会一直存在，即使删除容器。</li></ul><p>常用的数据卷操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个数据卷</span></span><br><span class="line">docker volume create demo_volume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据卷详情</span></span><br><span class="line">docker volume inspect demo_volume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> demo_volume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除没用的数据卷</span></span><br><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-volume/979767-20220616225959742-922397250.png"></p><p>启动一个挂载了数据卷的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --mount <span class="built_in">source</span>=demo02_volume,target=/usr/share/nginx/html --name demo02 nginx</span><br></pre></td></tr></table></figure><p>如图所示 ：</p><p><img src="/img/2022/docker-volume/979767-20220616230012670-157780076.png"></p><p>配置说明：</p><ul><li><code>--mount</code>：用于标记挂载数据卷到容器中，可以有多个。</li><li><code>source</code>：指定数据卷，如果数据卷不存在，则会自动创建。</li><li><code>target</code>：指定容器内挂载的目录。</li></ul><p>查看容器相关信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect demo02</span><br></pre></td></tr></table></figure><p>其中挂载部分内容如下</p><p><img src="/img/2022/docker-volume/979767-20220616230025341-858480054.png"></p><blockquote><p>数据卷是用来持久化容器数据的，它的生命周期独立于容器之外。</p></blockquote><p>如果在删除容器的时候想要一并删除存储卷的话，只需要<code>docker container rm -v</code>即可。</p><h3 id="挂载主机目录和文件"><a href="#挂载主机目录和文件" class="headerlink" title="挂载主机目录和文件"></a>挂载主机目录和文件</h3><p>使用<code>--mount</code>参数除了能够挂载数据卷，还能挂载本机的目录到容器中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp,target=/usr/share/nginx/html,<span class="built_in">readonly</span> --name demo03 nginx</span><br></pre></td></tr></table></figure><p>需要注意：</p><ul><li>默认情况下，<code>--mount</code>挂载的数据卷<code>volume</code>，如果需要挂载目录，需要指定<code>type=bind</code>。</li><li>source 在 bind 挂载中必须事先存在。</li><li>在挂载最后可以加上<code>readonly</code>，标识容器对该目录只读。</li></ul><p>此时进入容器测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">exec</span> -it demo03 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-volume/979767-20220616230042565-21286420.png"></p><p>可以发现，文件是宿主机的 &#x2F;tmp 下面的文件，并且只读无法创建文件。</p><p>当然，也可以单独只挂载某个文件，但是前提是这个文件事先得存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp/1.txt,target=/root/.bash_history --name demo04 nginx</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-volume/979767-20220616230056286-1861018710.png"></p><p>历史命令就能被记录到本地。</p><h3 id="其它挂载方式"><a href="#其它挂载方式" class="headerlink" title="其它挂载方式"></a>其它挂载方式</h3><p>除了<code>--mount</code>以外，还有<code>-v</code>，<code>--volume</code>的方式挂载数据卷，使用方法类似。示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载目录并只读</span></span><br><span class="line">docker container run -d -v /tmp:/usr/share/nginx/html:ro --name demo05 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载文件</span></span><br><span class="line">docker container run -d -v /tmp/1.txt:/root/.bash_history --name demo08 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载一个随机生成的数据卷到指定目录</span></span><br><span class="line">docker container run -d -v /usr/share/nginx/html --name demo06 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载一个已经存在的数据卷到指定目录</span></span><br><span class="line">docker container run -d -v demo02_volume:/usr/share/nginx/html --name demo07 nginx</span><br></pre></td></tr></table></figure><p>使用方法类似，而且在<code>Dockerfile</code>中的<code>VOLUME</code>指令就能定义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据卷&quot;&gt;&lt;a href=&quot;#数据卷&quot; class=&quot;headerlink&quot; title=&quot;数据卷&quot;&gt;&lt;/a&gt;数据卷&lt;/h3&gt;&lt;p&gt;默认情况下，容器被删除，容器中数据也会随着一起删除。这对于某些重要的数据是绝对不允许的。此时就需要对数据进行持久化。&lt;br&gt;&lt;cod</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>镜像制作</title>
    <link href="https://www.buerya.cn/2022/docker-image/index/"/>
    <id>https://www.buerya.cn/2022/docker-image/index/</id>
    <published>2022-08-20T13:29:39.000Z</published>
    <updated>2022-10-20T13:28:49.301Z</updated>
    
    <content type="html"><![CDATA[<h4 id="利用-Commit-制作镜像"><a href="#利用-Commit-制作镜像" class="headerlink" title="利用 Commit 制作镜像"></a>利用 Commit 制作镜像</h4><p>在容器管理章节有提到使用现有的容器制作镜像，但是这在真正的工作中明显是不合适的。使用<code>docker commit</code>意味着所有对镜像的操作都是黑箱操作，生成的镜像被称为<code>黑箱镜像</code>。</p><p>换句话说，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。即使是制作人，过段时间后也无法记清具体的操作。这种镜像维护起来非常痛苦。</p><p>而且，由于镜像分层存储的特点，除当前层外，之前的每一层都是不会发生改变的，这意味着任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。即使是删除，上一层的东西也并不会丢失。镜像会越来越臃肿。</p><p>同时还有另外一个问题，容器中某些进程可能是动态的，过段时间会退出。如果使用 commit 制作镜像，这些进程可能不会保存到镜像中。</p><h4 id="利用-Dockerfile-制作镜像"><a href="#利用-Dockerfile-制作镜像" class="headerlink" title="利用 Dockerfile 制作镜像"></a>利用 Dockerfile 制作镜像</h4><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果能把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那之前 Commit 的无法重复、镜像构建透明性、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code>。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<code>指令（Instruction）</code>，每一条指令构建一层。</p><p>以定制一个 <code>nginx</code> 镜像为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录专门用于存放相关的 Dockerfile</span></span><br><span class="line"><span class="built_in">mkdir</span> -p nginx/v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Dockerfile</span></span><br><span class="line"><span class="built_in">cd</span> nginx/v1.0/</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello Docker&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>这就是一个最简单的 Dockerfile，以 nginx 镜像为基础镜像，然后修改镜像中的 html 文件，形成新的镜像。</p><p>上面提到了基础镜像，我们可以以任何镜像为基础镜像，在它的上面进行操作形成新的镜像，Docker 官方也提供了很多精简的基础镜像，可以拿来直接使用。</p><p>在编辑好 Dockerfile 之后，就进入镜像制作的步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t trover/nginx:v1.0 .</span><br></pre></td></tr></table></figure><p>注意最后那个<code>.</code>不能掉。</p><p><img src="/img/2022/docker-image/979767-20220615225133950-1185740767.png"></p><p>可以发现，镜像构建的时候有两层，一层是<code>FROM</code>，一层是<code>RUN</code>。这也印证了上面说的每一个关键字就是一层。</p><h4 id="镜像构建上下文"><a href="#镜像构建上下文" class="headerlink" title="镜像构建上下文"></a>镜像构建上下文</h4><p>关于 build 命令最后那个<code>.</code>，其实不是指 Dockerfile 的路径，而是指定<code>上下文路径</code>。</p><p>想要理解上下文，首先要理解<code>docker build</code>的工作原理：</p><p>Docker 的运行分为服务端 Docker 引擎（守护进程）和客户端工具。服务端 Docker 引擎提供了一组 REST API，称为<code>Docker Remote API</code>。docker 命令这样的客户端工具就是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p><p>虽然表面上是在本机执行的各种 docker 功能，但实际上一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让操作远程服务器的 Docker 引擎变得轻而易举。</p><p>在进行镜像构建时，并非所有定制都会通过<code>RUN</code>指令完成，经常会需要将一些本地文件复制进镜像，比如通过<code>COPY</code>指令、<code>ADD</code>指令等。而 build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>以 Dockerfile 为例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure><p>该指定并不是复制当前目录的 package.json 文件，也不是 Dockerfile 所在目录的 package.json 文件，而是上下文目录中的 package.json。</p><p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是为何<code>COPY ../package.json /app</code>或者<code>COPY /opt/xxxx /app</code>无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>通过 build 命令输出的第一行也可以看到发送上下文的过程：</p><blockquote><p>Sending build context to Docker daemon 2.048 kB</p></blockquote><p>所以，制作 Dockerfile 的目录尽量满足以下需求：</p><ul><li>一个空目录。</li><li>将所有需要的文件都复制一份到当前目录。</li><li>如果目录下有文件不需要被发送到 Docker 引擎，可以创建一个类似<code>.gitignore</code>一样语法的文件<code>.dockerignore</code>。<br>默认情况下，如果不特殊指定 Dockerfile 路径，默认会将上下文路径中的名为 Dockerfile 的文件作为 Dockerfile。</li></ul><p>Dockerfile 也并非文件就要叫 Dockerfile，可以通过 -f 指定其它文件，但是一般不这样做。</p><h4 id="Dockerfile（FROM）"><a href="#Dockerfile（FROM）" class="headerlink" title="Dockerfile（FROM）"></a>Dockerfile（FROM）</h4><p>FROM 指令是 Dockerfile 最基础的关键字，用于指定基础镜像。格式为：<code>FROM &lt;基础镜像&gt;</code></p><p>如果你自己想做一个基础镜像，则可以使用<code>FROM scratch</code>，scratch 镜像是 Docker 官方提供的一个虚拟空白镜像。</p><p>基础镜像意味着不以任何系统为基础，直接将可执行文件复制到镜像中，该文件包含了运行所需的所有库。这样镜像会更小，非常适合 Go 语言开发的程序。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br></pre></td></tr></table></figure><h4 id="Dockerfile（LABEL）"><a href="#Dockerfile（LABEL）" class="headerlink" title="Dockerfile（LABEL）"></a>Dockerfile（LABEL）</h4><p>LABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata），在旧版本中叫 MATAINER。格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p><p>通过 LABEL 标签能够让别人更清楚你这镜像。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> name=<span class="string">&quot;Trover&quot;</span> \</span></span><br><span class="line"><span class="language-bash">email=<span class="string">&quot;admin@buerya.cn&quot;</span></span></span><br><span class="line">desc=<span class="string">&quot;Dockerfile demo&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（RUN）"><a href="#Dockerfile（RUN）" class="headerlink" title="Dockerfile（RUN）"></a>Dockerfile（RUN）</h4><p>RUN 指令用来执行命令行命令。由于命令行的强大能力，<code>RUN</code>指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li>shell 格式：<code>RUN 命令</code></li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code><br>由于 Dockerfile 中每个关键字就是一层，Union FS 会有最大层数限制，以 AUFS 为例，最大支持 127 层。为了减少镜像的层数，一般使用<code>&amp;&amp;</code>连接多个命令，<code>\</code>进行换行，提高阅读性。</li></ul><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> / &amp;&amp; yum -y install nginx \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">cd</span> /etc/nginx \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">rm</span> -f nginx.conf</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（WORKDIR）"><a href="#Dockerfile（WORKDIR）" class="headerlink" title="Dockerfile（WORKDIR）"></a>Dockerfile（WORKDIR）</h4><p>WORKDIR 指令用于指定工作目录（或称当前目录），以后各层的当前目录就被改为指定的目录，如果该目录不存在，WORKDIR 会自动创建。格式为：WORKDIR &lt;工作目录路径&gt;</p><blockquote><p>WORKDIR 目录 不等于 RUN cd 目录，前者会对后面的所有镜像层产生影响，后者只对当前层，对于下一层并不会 cd 进目录。</p></blockquote><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br><span class="line"><span class="comment"># 最后输出目录为 /a/b/c</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（COPY）"><a href="#Dockerfile（COPY）" class="headerlink" title="Dockerfile（COPY）"></a>Dockerfile（COPY）</h4><p>COPY 指令用于将构建上下文目录中的源文件或目录拷贝到镜像中的指定目录，支持两种格式。</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code><br>源路径可以是多个，甚至使用通配符。目标路径可以是容器中绝对路径，也可以是 WORKDIR 的相对路径。目标路径不存在会自动创建。</li></ul><p>COPY 指令能保留文件的各种元数据，比如创建时间，读写权限等。如果源文件为目录，其实质是将目录中的文件拷贝到镜像中的新目录中。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /usr/src/app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝多个文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package* /usr/src/app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝并修改权限</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=myuser:mygroup package* /usr/src/app/</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ADD）"><a href="#Dockerfile（ADD）" class="headerlink" title="Dockerfile（ADD）"></a>Dockerfile（ADD）</h4><p>ADD 指令和 COPY 类似，但不推荐使用，因为没有 COPY 定义明确。格式为：<code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></p><p>ADD 源路径支持 URL，Docker 会去指定的 URL 下载文件，并保存成 600 权限，如果 URL 是压缩也文件不会解压。所以这种需求使用 RUN 指令更好。</p><p>如果本地源文件是 tar，gzip，bzip2，xz 等格式的压缩文件，ADD 会自动解压。但如果只想复制一个压缩文件进去，则不能使用 ADD 指令。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ubuntu.tar.gz /app/</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ENV）"><a href="#Dockerfile（ENV）" class="headerlink" title="Dockerfile（ENV）"></a>Dockerfile（ENV）</h4><p>ENV 指令用于设置环境变量，在后面的指令中可以直接使用<code>$&#123;变量名&#125;</code>的方式引用，容器中也可以看到。支持两种格式。</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code><br>通过环境变量的定义能够使 Dockerfile 更加灵活。</li></ul><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="string">&quot;1.0&quot;</span> \</span><br><span class="line">NAME=<span class="string">&quot;Dy1an&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span></span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ARG）"><a href="#Dockerfile（ARG）" class="headerlink" title="Dockerfile（ARG）"></a>Dockerfile（ARG）</h4><p>ARG 指令功能和 ENV 类似，用于定义构建参数。不同在于 ARG 设置的是构建环境的环境变量，在容器运行时这些变量不会存在。格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>该默认值可以在<code>docker build</code>中使用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖，起到传参构建的目的。</p><p>ARG 指令有作用范围，如果是在 FROM 之前使用，则只能 FROM 指令中使用该变量。想要继续使用就得重新定义。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br></pre></td></tr></table></figure><h4 id="Dockerfile（USER）"><a href="#Dockerfile（USER）" class="headerlink" title="Dockerfile（USER）"></a>Dockerfile（USER）</h4><p>USER 指令指定当前用户和用户组，影响范围和 WORKDIR 类似。格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p>USER 指令只是切换用户，所以这个用户必须先创建好。</p><p>如果脚本是 root 运行，但是容器中启动服务需要使用其他用户，建议下载<code>gosu</code>代替原本的 su 或者 sudo，可以避免很多问题。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -r -g nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nginx <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;nginx&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（EXPOSE）"><a href="#Dockerfile（EXPOSE）" class="headerlink" title="Dockerfile（EXPOSE）"></a>Dockerfile（EXPOSE）</h4><p>EXPOSE 指令用于声明容器运行时提供服务的端口，只是声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p><p>在 Dockerfile 中写入这样的声明有两个好处：</p><p>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口。<br>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（CMD）"><a href="#Dockerfile（CMD）" class="headerlink" title="Dockerfile（CMD）"></a>Dockerfile（CMD）</h4><p><code>CMD</code> 指令用于指定容器默认的主进程启动命令。和 RUN 类似，支持两种格式：</p><ul><li>shell 格式：<code>CMD &lt;命令&gt;</code></li><li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code><br>推荐使用 exec 格式，因为 shell 格式也会被 docker 转换成 exec 格式，比如：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"><span class="comment"># 会被转换成</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;Hello&#x27;&quot;</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>exec 格式在解析时会被解析为 JSON 数组，因此一定要使用双引号<code>&quot;</code>，而不要使用单引号。</p></blockquote><p>在容器运行时，可以指定新的命令来替代镜像中设置的 CMD 默认命令。</p><p>比如：ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，run -it 启动会直接进入容器的 bash。可以在运行时指定其它命令，如<code>docker run -it ubuntu cat /etc/os-release</code>的方式替换掉默认的<code>/bin/bash</code>命令。</p><p>注意：</p><blockquote><p>docker 不是虚拟机，容器中的应用都应该以前台执行，不能用 systemd 去启动后台服务，容器内没有后台服务的概念。</p></blockquote><p>如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> service nginx start</span></span><br></pre></td></tr></table></figure><p>这样的容器启动后立即退出，即使是进入容器内使用<code>systemctl</code>也一样。</p><p>对于容器而言，启动命令就是容器的应用进程，容器为主进程而存在，主进程退出，容器就失去了存在的意义，从而跟着退出，其它进程它不关心。</p><p>所以，使用<code>service nginx start</code>命令希望以后台守护进程形式启动 nginx。而 CMD 会被转换成<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>。此时主进程实际上是<code>sh</code>。那么当 service nginx start 命令结束后，sh 主进程也就结束了，容器自然就会跟着退出。</p><p>正确的做法是以前台的方式直接启动：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ENTRYPOINT）"><a href="#Dockerfile（ENTRYPOINT）" class="headerlink" title="Dockerfile（ENTRYPOINT）"></a>Dockerfile（ENTRYPOINT）</h4><p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。它的启动命令也是可以被替换的，不过比 CMD 繁琐，需要通过 docker run 的参数 –entrypoint 来指定。和 RUN 一样，也是支持两种格式。</p><p>相较于 CMD，ENTRYPOINT 常用于解决以下问题：</p><h5 id="1-能够实现灵活的传参功能"><a href="#1-能够实现灵活的传参功能" class="headerlink" title="1. 能够实现灵活的传参功能"></a>1. 能够实现灵活的传参功能</h5><p>一个简单的 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该镜像用于输出当前公网 IP</span></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>使用<code>docker build -t myip</code>. 生成 myip 镜像，然后使用 <code>docker run myip</code> 运行。这个 docker 就能变成一个类似于查询公网 IP 的命令。</p><p>但是如果此时需求变得复杂，需要在镜像的 curl 中加入<code>-i</code>参数输出请求头信息。</p><p>直接使用<code>docker run myip -i</code>会报错：executable file not found。原因在于镜像后面的参数会被当成命令替换掉 CMD 中的内容，而 CMD 第一个参数是可执行文件，-i 显然不是可执行文件，所以报错。</p><p>如果将 CMD 换成 ENTRYPOINT：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该镜像用于输出当前公网 IP</span></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>此时再次执行 <code>docker run myip -i</code> 就能正常使用。原因在于，-i 参数会替换 CMD 中的内容，但是在定义了 ENTRYPOINT 的 Dockerfile 中，CMD 中的所有内容会成为参数传递给 ENTRYPOINT，这就实现了灵活参数的功能。</p><h5 id="2-通过判断不同的传参干不同的事情"><a href="#2-通过判断不同的传参干不同的事情" class="headerlink" title="2. 通过判断不同的传参干不同的事情"></a>2. 通过判断不同的传参干不同的事情</h5><p>生产中有这样一类场景，某些镜像的运行方案可能不一定，用户可以传递相关的参数修改容器的运行方式。由于在 ENTRYPOINT 加入了逻辑判断等操作，再写命令或者 exec 格式显然不适合，所以需要使用脚本的格式。 然后将 CMD 的内容作为参数传给它。</p><p>一个简单的 Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝脚本到镜像中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-entrypoint.sh /usr/local/bin/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>docker-entrypoint.sh：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;hello&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（VOLUME）"><a href="#Dockerfile（VOLUME）" class="headerlink" title="Dockerfile（VOLUME）"></a>Dockerfile（VOLUME）</h4><p>VOLUME 指令用于挂在一个或多个存储卷，格式如下：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code><br>容器运行时应尽量保持容器存储层不发生写操作，但数据写入往往又是不可避免的。</li></ul><p>为了防止运行时用户忘记将动态文件所保存的目录挂载为卷，可以在<code>Dockerfile</code>中事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br></pre></td></tr></table></figure><p>这里的<code>/data</code>目录就会在容器运行时自动挂载为匿名卷，任何向<code>/data</code>中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以通过<code>-v</code>参数覆盖这个挂载设置。</p><p>后面会对存储卷进行详细的说明。</p><h4 id="Dockerfile（HEALTHCHECK）"><a href="#Dockerfile（HEALTHCHECK）" class="headerlink" title="Dockerfile（HEALTHCHECK）"></a>Dockerfile（HEALTHCHECK）</h4><p>HEALTHCHECK 指令用于告诉 Docker 应该如何进行判断容器的状态是否正常，在 Docker 1.12 引入。支持以下格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br>在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁或死循环状态，应用进程并不会退出，容器已经无法提供服务，却并不会被重新调度。HEALTHCHECK 指令的价值就在于能够比较真实的反应容器实际状态。</li></ul><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 后，用其启动容器，初始状态会为<code>starting</code>，在 <code>HEALTHCHECK</code> 检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。</p><p>HEALTHCHECK 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为<code>unhealthy</code>，默认 3 次<br>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</li></ul><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>容器运行后，使用 docker container ls 就可以看到健康状态。使用 docker container inspect xxx 可以看到检测信息。</p><h4 id="Dockerfile（SHELL）"><a href="#Dockerfile（SHELL）" class="headerlink" title="Dockerfile（SHELL）"></a>Dockerfile（SHELL）</h4><p>SHELL 指令用于指定 RUN，ENTRYPOINT，CMD 指令的 shell，Linux 中默认为<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>。格式为：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br></pre></td></tr></table></figure><pre><code># 命令最终会被解析为：/bin/sh -cex &quot;nginx&quot;ENTRYPOINT nginx</code></pre><h4 id="Dockerfile（ONBUILD）"><a href="#Dockerfile（ONBUILD）" class="headerlink" title="Dockerfile（ONBUILD）"></a>Dockerfile（ONBUILD）</h4><p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等。这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile-建议"><a href="#Dockerfile-建议" class="headerlink" title="Dockerfile 建议"></a>Dockerfile 建议</h4><p>在制作 Dockerfile 的时候，应该尽可能的遵守一些约定俗称的方法和建议：</p><ul><li>容器应该是短暂的<ul><li>通过 Dockerfile 构建的镜像生命周期不宜过长，容器从销毁到创建都应该将工作量将到最小。</li></ul></li><li>增加 .dockerigonre 文件<ul><li>每一个单独的项目都应该有一个单独的目录并创建一个 .dockerignore 文件用于忽略不需要的文件或目录，构建镜像所需的文件都应该存放到该目录下。</li></ul></li><li>避免不必要的文件，使用多阶段构建<ul><li>在 Dockerfile 的每一层定义中，在进入下一层之前，都需要删除掉其它不需要的文件，以此尽可能的减小镜像的体积。</li><li>比如通过 Dockerfile 直接完成打包，运行，打包这一步除了打出来的包其它的文件其实都是没用的，此时就是和多阶段构建。</li><li>示例：</li></ul></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段，打包。使用 as 对阶段进行命名，每一个 FROM 就是一个阶段</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.7</span>.<span class="number">3</span> as build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v golang.org/x/net/html  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go    .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段，运行。</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"><span class="comment"># 从第一阶段中拷贝打好的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>] </span></span><br></pre></td></tr></table></figure><pre><code>此时 build 镜像的话，镜像中就不会包含第一节点的内容，包也尽可能的减小了。</code></pre><ul><li>一个容器只运行一个进程<ul><li>应该保证每个容器只有一个进程，多个进程解耦到不同容器中，便于后续的扩展。</li></ul></li><li>将多行参数排序<ul><li>某些参数太多太长需要换行的，尽可能按照字母顺序排序，这样可以避免重复。</li></ul></li><li>使用构建缓存<ul><li>在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 –no-cache&#x3D;true 选项。</li></ul></li></ul><h4 id="完整的-Dockerfile-示例"><a href="#完整的-Dockerfile-示例" class="headerlink" title="完整的 Dockerfile 示例"></a>完整的 Dockerfile 示例</h4><p>以下是一些常见的 Dockerfile 示例：</p><ol><li>TOMCAT部署镜像：</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础就像</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义元数据</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> auhtor=<span class="string">&quot;Dy1an&quot;</span> \</span></span><br><span class="line"><span class="language-bash">email=<span class="string">&quot;1214966109@qq.com&quot;</span> \</span></span><br><span class="line"><span class="language-bash">desc=<span class="string">&quot;TOMCAT demo Dockerfile&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH=/ops \</span><br><span class="line">ENV_PATH=$&#123;WORK_PATH&#125;/<span class="keyword">env</span> \</span><br><span class="line">SERVICE_PATH=$&#123;WORK_PATH&#125;/service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 JDK</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u11-linux-x64.tar.gz <span class="variable">$&#123;ENV_PATH&#125;</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 TOMCAT</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.22.tar.gz <span class="variable">$&#123;SERVICE_PATH&#125;</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ROOT.war <span class="variable">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压安装包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> unzip ROOT.war -d ROOT &amp;&amp; <span class="built_in">rm</span> -f ROOT.war</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$&#123;ENV_PATH&#125;/jdk1.<span class="number">8.0</span>_11 \</span><br><span class="line">CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar \</span><br><span class="line">CATALINA_HOME=$&#123;SERVICE_PATH&#125;/apache-tomcat-<span class="number">9.0</span>.<span class="number">22</span> \</span><br><span class="line">PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="variable">$&#123;CATALINA_HOME&#125;</span>/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -f <span class="variable">$&#123;CATALINA_HOME&#125;</span>/logs/catalina.out</span></span><br></pre></td></tr></table></figure><ol start="2"><li>我参与的一个github项目 <a href="https://github.com/BaoXuebin/beancount-gs/issues/23#issuecomment-1194917665">beancount-gs</a></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> BEANCOUNT_VERSION=<span class="number">2.3</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">ARG</span> GOLANG_VERSION=<span class="number">1.17</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> golang:$&#123;GOLANG_VERSION&#125; AS go_build_env</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct \</span><br><span class="line">    GIN_MODE=release \</span><br><span class="line">    CGO_ENABLED=<span class="number">0</span> \</span><br><span class="line">    PORT=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> https://github.com/BaoXuebin/beancount-gs.git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build/beancount-gs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p public/default_icons &amp;&amp; <span class="built_in">cp</span> -rn public/icons/* public/default_icons</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:latest as build_env</span><br><span class="line"><span class="keyword">ARG</span> BEANCOUNT_VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH <span class="string">&quot;/app/bin:$PATH&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 -mvenv /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> https://github.com/beancount/beancount</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build/beancount</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git checkout <span class="variable">$&#123;BEANCOUNT_VERSION&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CFLAGS=-s pip3 install -U /tmp/build/beancount</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 uninstall -y pip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> find /app -name __pycache__ -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf -v &#123;&#125; +</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build_env /app /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=go_build_env /tmp/build/beancount-gs /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -rn /app/public/default_icons/* /app/public/icons</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH <span class="string">&quot;/app/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/app/beancount-gs&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;80&quot;</span>]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;利用-Commit-制作镜像&quot;&gt;&lt;a href=&quot;#利用-Commit-制作镜像&quot; class=&quot;headerlink&quot; title=&quot;利用 Commit 制作镜像&quot;&gt;&lt;/a&gt;利用 Commit 制作镜像&lt;/h4&gt;&lt;p&gt;在容器管理章节有提到使用现有的容器制作镜像，</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>容器管理</title>
    <link href="https://www.buerya.cn/2022/docker-container/index/"/>
    <id>https://www.buerya.cn/2022/docker-container/index/</id>
    <published>2022-07-19T13:29:39.000Z</published>
    <updated>2022-10-20T13:28:49.301Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查看容器-ps"><a href="#查看容器-ps" class="headerlink" title="查看容器(ps)"></a>查看容器(ps)</h4><p>在运行容器之前，我们需要知道如何查看运行中的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker container ps</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>使用此方法只能看到运行中的容器，对于以及停止的容器，还需要使用<code>-a</code>参数，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ps -a</span><br></pre></td></tr></table></figure><h4 id="容器运行-run-无参数"><a href="#容器运行-run-无参数" class="headerlink" title="容器运行(run, 无参数)"></a>容器运行(run, 无参数)</h4><p>前面有说过，容器是镜像的实例。学习 docker 最终目的就是就是运行它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>运行第一个测试容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker container run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230044356-1739155940.png"></p><p>hello-world 容器是一个测试容器，在输出一些文字之后就会退出，通过这个过程，我们可以发现：</p><ol><li>对于运行容器，如果镜像不存在，则会去 registry 中自动下载。</li><li>使用 ps 查看容器的时候，如果不使用 -a 参数是看不到状态属于 Exited 的容器的。</li><li>使用 ps 可以简单的看到容器的 ID，使用的镜像，执行的命令，创建时间，运行状态，端口，容器的名字等信息。</li></ol><h4 id="容器运行（run-d，守护态）"><a href="#容器运行（run-d，守护态）" class="headerlink" title="容器运行（run -d，守护态）"></a>容器运行（run -d，守护态）</h4><p>在运行容器时，需要确定这个容器是运行在前台模式还是后台模式。</p><p><code>-d，--detach</code>，守护态运行。能够将容器运行在后台模式。这样所有的 IO 都只能通过网络资源或存储卷来进行交互。容器不再监听执行 docker run 这个命令行的窗口。有点类似于 Linux 启动程序时候的<code>nohup</code>或者<code> &amp;</code>组合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d hello-world</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230101520-12884147.png"></p><p>可以发现，hello-world 容器加了 -d 参数后不在输出它的信息，只是返回了一长串字符，其实就是完整的 Container ID，用法类似 Image ID。</p><p>同时由于 hello-world 容器本身的特性，程序在后台执行完成之后就直接退出了，容器也跟着退出了。</p><p>再次运行以 nginx 容器为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230115647-335897184.png"></p><p>可以发现以下信息：</p><ol><li>由于没有跟 TAG，默认会以 latest 版本执行。在 docker 中，如果是运行 latest 版本，docker 都会去仓库试着拉取，而不是直接使用本地的镜像，因为本地的 latest 不一定是真正的 latest。</li><li>容器在运行之后会以前台模式运行，所有它 hung 在了命令行。</li><li>此时如果我们新开一个窗口来查看，可以发现容器处于 Up 状态，如下图所示：</li></ol><p><img src="/img/2022/docker-container/979767-20220613230139284-2045625911.png"></p><ol start="4"><li>如果我们去 docker run 的窗口使用 Ctrl + c 中断，然后再次查看容器运行状态，可以发现容器已经退出，这就是前台运行的问题，如图所示：</li></ol><p><img src="/img/2022/docker-container/979767-20220613230148765-1700841146.png"></p><p>如果使用后台运行模式运行该容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d nginx</span><br></pre></td></tr></table></figure><p>运行效果如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230204245-595295977.png"></p><p>容器被放在了后台运行，不会 hung 在命令行。当然所有的输出信息也不能直接看到了。</p><h4 id="容器运行（run-it，交互式运行）"><a href="#容器运行（run-it，交互式运行）" class="headerlink" title="容器运行（run -it，交互式运行）"></a>容器运行（run -it，交互式运行）</h4><p>在使用 -d 参数之后，容器就不会 hung 在命令行窗口，而是以后台方式运行。但是这同时也有一个问题，某些时候我们是需要进入容器查看相关启动等信息的。此时就需要另外的参数配合使用：</p><ul><li><code>-i，--interactive</code>：打开一个交互式界面。</li><li><code>-t，--tty</code>：打开一个 TTY 终端。<br>将这个两个参数结合就是打开一个交互式的 TTY 终端。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it nginx /bin/bash</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230217469-498760333.png"></p><p>通过该方法在创建容器的时候指定运行命令，然后以 bash 进入容器内部的命令行。可以发现：</p><ol><li>容器内部就是 linux 的目录结构，但是是一个很简化的 linux，很多基础命令都没有。</li><li>当退出容器命令行，容器也跟着退出。原因是我们重写容器内部的命令为 bash 之后，nginx 就没有启动了，当退出 bash 之后，容器内部就没有进程了，所有容器就退出了。</li><li>这种方式用的比较少，一般都是容器运行之后，使用专门的命令进入容器。</li></ol><h4 id="容器运行（run-–name，容器命名）"><a href="#容器运行（run-–name，容器命名）" class="headerlink" title="容器运行（run –name，容器命名）"></a>容器运行（run –name，容器命名）</h4><p>在创建容器的时候，如果不给容器指定一个名字，容器会生成一个随机的名字，一般都是以 xxx_xxx 的格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --name demo01 nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230241715-1635978379.png"></p><p>针对容器的名字，我们可以根据自己的需求指定相关的命名规范，以此来实现统一管理的目的。</p><h4 id="容器运行（run-–rm，退出删除）"><a href="#容器运行（run-–rm，退出删除）" class="headerlink" title="容器运行（run –rm，退出删除）"></a>容器运行（run –rm，退出删除）</h4><p>某些容器可能是一次性容器，在运行之后，容器退出。同时不保留在 ps 中，此时就需要使用到 <code>--rm</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --<span class="built_in">rm</span> --name rm_test hello-world</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230301553-222894916.png"></p><h4 id="容器运行（run-–restart，重启规则）"><a href="#容器运行（run-–restart，重启规则）" class="headerlink" title="容器运行（run –restart，重启规则）"></a>容器运行（run –restart，重启规则）</h4><p>为了保障在以外的停止之后能够自动恢复，就需要对它配置相关<code>--restart</code>规则：</p><ul><li><code>on-failure</code>：容器停止时，容器出现报错，则容器会被重启。但是如果 docker 服务被重启了该配置就不会生效。</li><li><code>unless-stopped</code>：容器停止，如果没有报错，则容器会被重启。即使重启了 docker 服务，该配置也生效。</li><li><code>always</code>：不管如何，容器只要停止就重启。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --restart always --name busybox_test busybox /bin/sh -c <span class="string">&quot;sleep 60&quot;</span></span><br></pre></td></tr></table></figure><p><code>busybox</code> 镜像是一个精简的 Linux，非常小，适合用来做测试。结果如下：</p><p><img src="/img/2022/docker-container/979767-20220613230318144-1256119776.png"></p><p>通过过一段时间查看，发现在容器内部 sleep 60 之后退出，然后被重启拉起一个新的。</p><p>以上就是容器运行的基本参数，至于容器的存储卷，网络等内容，后面会单独分节介绍。</p><h4 id="查看详情（inspect）"><a href="#查看详情（inspect）" class="headerlink" title="查看详情（inspect）"></a>查看详情（inspect）</h4><p>通过该命令可以查看容器的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect busybox_test</span><br></pre></td></tr></table></figure><p>详细信息中需要关注的点包括：</p><ul><li><code>Image</code>：使用的镜像。</li><li><code>Volumes</code>：数据存储卷。</li><li><code>IPAddress</code>：容器的 IP 地址。</li><li><code>Ports</code>：端口信息。</li></ul><h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h4><p>通过该命令可以查看容器的运行时状态，如 Up，Exited 等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器但不运行</span></span><br><span class="line">docker container create --name demo02 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker container start demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停容器</span></span><br><span class="line">docker container pause demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续运行容器</span></span><br><span class="line">docker container unpause demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker container stop demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker container restart demo02</span><br></pre></td></tr></table></figure><p>结果如图所示</p><p><img src="/img/2022/docker-container/979767-20220613230341164-1246990897.png"></p><h4 id="进入容器（attach）"><a href="#进入容器（attach）" class="headerlink" title="进入容器（attach）"></a>进入容器（attach）</h4><p>通过该命令可以连接到一个运行中的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container attach --sig-proxy=<span class="literal">false</span> demo02</span><br></pre></td></tr></table></figure><p>使用<code>--sig-proxy=false</code>的目的是为了避免<code>Ctrl + C</code>或者<code>Ctrl + D</code>使容器退出。</p><p>该命令会对容器进行监听，命令行处于交互式界面，此时从新窗口请求该容器的 nginx：</p><p><img src="/img/2022/docker-container/979767-20220613230358617-1596296745.png"></p><p>可以看到日志直接输出到屏幕，<code>Ctrl + C</code>就可以退出该界面且保持容器继续运行。</p><h4 id="进入容器（exec）"><a href="#进入容器（exec）" class="headerlink" title="进入容器（exec）"></a>进入容器（exec）</h4><p>上面的方法是将输出直接输出到屏幕上，无法操作，如果想将容器当虚拟机一样使用，则需要 exec：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it demo02 /bin/bash</span><br></pre></td></tr></table></figure><p>注意，exec 后面需要跟执行命令，由于是命令行，则需要使用 &#x2F;bin&#x2F;bash 或者 &#x2F;bin&#x2F;sh。</p><p><img src="/img/2022/docker-container/979767-20220613230414251-864497271.png"></p><h4 id="查看日志（logs）"><a href="#查看日志（logs）" class="headerlink" title="查看日志（logs）"></a>查看日志（logs）</h4><p>通过该命令可以实时查看容器运行的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs -f demo02</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230425653-1546012181.png"></p><p>使用<code>-f</code>的参数可以让它像linux中的<code>tail</code>命令一样。否则就是一次性查看，跟<code>cat</code>一样。</p><h4 id="文件拷贝（cp）"><a href="#文件拷贝（cp）" class="headerlink" title="文件拷贝（cp）"></a>文件拷贝（cp）</h4><p>通过该命令可以实现容器和宿主机之间文件传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝文件到容器</span></span><br><span class="line">docker container <span class="built_in">cp</span> anaconda-ks.cfg demo02:/tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件到容器并改名</span></span><br><span class="line">docker container <span class="built_in">cp</span> anaconda-ks.cfg demo02:/tmp/1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝目录到容器</span></span><br><span class="line">docker container <span class="built_in">cp</span> demo demo02:/tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件到本地</span></span><br><span class="line">docker container <span class="built_in">cp</span> demo02:/tmp/1.txt .</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230443140-850543444.png"></p><h4 id="查看端口-port"><a href="#查看端口-port" class="headerlink" title="查看端口(port)"></a>查看端口(port)</h4><p>通过该命令可以查看容器和宿主机的端口映射关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container port demo02</span><br></pre></td></tr></table></figure><h4 id="查看状态-stats"><a href="#查看状态-stats" class="headerlink" title="查看状态(stats)"></a>查看状态(stats)</h4><p>通过该命令可以查看容器内部系统资源使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stats demo02</span><br></pre></td></tr></table></figure><p>如图所示</p><p><img src="/img/2022/docker-container/979767-20220613230456764-365638708.png"></p><h4 id="查看进程（top）"><a href="#查看进程（top）" class="headerlink" title="查看进程（top）"></a>查看进程（top）</h4><p>通过该命令可以查看到容器内部运行的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container top demo02</span><br></pre></td></tr></table></figure><p>如图所示</p><p><img src="/img/2022/docker-container/979767-20220613230514143-33194940.png"></p><h4 id="提交镜像（commit）"><a href="#提交镜像（commit）" class="headerlink" title="提交镜像（commit）"></a>提交镜像（commit）</h4><p>该命令可以将现有的容器提交成镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container commit -a <span class="string">&quot;Trover &lt;admin@buerya.cn&gt;&quot;</span> -m <span class="string">&quot;Copy file&quot;</span> -p demo02 trover/nginx-copy-file:v1.0</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-a</code>：作者信息。</li><li><code>-m</code>：提交信息，有点像 <code>git commit -m</code>。</li><li><code>-p</code>：生成镜像时容器暂停。<br>如图所示：</li></ul><p><img src="/img/2022/docker-container/979767-20220613230526915-1148740640.png"></p><h4 id="停止容器（kill）"><a href="#停止容器（kill）" class="headerlink" title="停止容器（kill）"></a>停止容器（kill）</h4><p>该命令相较于 stop 更暴力杀死一个或多个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">kill</span> demo02</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230542052-1112346775.png"></p><h4 id="重命名容器（rename）"><a href="#重命名容器（rename）" class="headerlink" title="重命名容器（rename）"></a>重命名容器（rename）</h4><p>该命令可以对容器重命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rename demo02 demo03</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230553943-1837768949.png"></p><h4 id="导出容器（export）"><a href="#导出容器（export）" class="headerlink" title="导出容器（export）"></a>导出容器（export）</h4><p>该命令可以将容器当前的状态导出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">export</span> -o /tmp/demo03.tar demo03</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230607064-1784552793.png"></p><h4 id="查看系统变化（diff）"><a href="#查看系统变化（diff）" class="headerlink" title="查看系统变化（diff）"></a>查看系统变化（diff）</h4><p>该命令可以查看容器目前的文件和文件系统本身的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container diff demo03</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230619331-869669860.png"></p><h4 id="删除容器（rm）"><a href="#删除容器（rm）" class="headerlink" title="删除容器（rm）"></a>删除容器（rm）</h4><p>该命令可以删除指定的一个或多个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除停止的容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> a7851616b54c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除运行中的容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> -f 338a3419e42e</span><br></pre></td></tr></table></figure><p>如果容器在运行，需要使用<code>-f</code>强制删除：</p><p><img src="/img/2022/docker-container/979767-20220613230641212-907588129.png"></p><h4 id="批量删除（rm）"><a href="#批量删除（rm）" class="headerlink" title="批量删除（rm）"></a>批量删除（rm）</h4><p>对于容器或者镜像，都可以使用条件筛选的方式对它进行批量删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> $(docker container <span class="built_in">ls</span> -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有 redis 镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -aq redis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有在 mongo:3.2 之前的镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -aq -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><p>使用<code>-q</code>参数能够增加筛选条件。</p><h4 id="删除容器（prune）"><a href="#删除容器（prune）" class="headerlink" title="删除容器（prune）"></a>删除容器（prune）</h4><p>该命令可以删除没有使用的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><p>可以通过<code>-f</code>参数直接删除，不用确认。</p><p><img src="/img/2022/docker-container/979767-20220613230700355-227583119.png"></p><p>到此，容器的大部分操作都已经体验完毕。接下来将讲解如何制作镜像！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;查看容器-ps&quot;&gt;&lt;a href=&quot;#查看容器-ps&quot; class=&quot;headerlink&quot; title=&quot;查看容器(ps)&quot;&gt;&lt;/a&gt;查看容器(ps)&lt;/h4&gt;&lt;p&gt;在运行容器之前，我们需要知道如何查看运行中的容器：&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>镜像管理</title>
    <link href="https://www.buerya.cn/2022/docker-hub/index/"/>
    <id>https://www.buerya.cn/2022/docker-hub/index/</id>
    <published>2022-06-13T05:34:34.000Z</published>
    <updated>2022-10-19T14:40:00.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p><code>docker hub</code>作为默认的注册点，不管是官方还是第三方都上传了很多人们可以直接拿来使用的镜像。</p><blockquote><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p></blockquote><p>通过搜索功能可以直接搜索到相关的镜像：</p><p><img src="/img/2022/docker-hub/979767-20220612181114029-1547561283.png"></p><p>这里以 Nginx 为例：</p><p><img src="/img/2022/docker-hub/979767-20220612181125322-23214919.png"></p><p>通过在 <code>registry</code> 上面搜索可以发现：</p><ol><li>仓库前面没有用户名，一般都是官方镜像仓库。后面会有 <code>DOCKER OFFICIAL IMAGE</code> 的标识。这意味着我们大概率可以放心大胆的直接拿来使用。</li><li>仓库前面有用户名，一般都第三方的镜像仓库。后面会有 <code>VERIFIED PUBLISHER</code> 的标识（已经验证的开发者）或 <code>OPEN SOURCE PROGRAM</code> 标识（开源项目）。这两者的安全优先级相对于较低，使用需要谨慎。</li><li>右边 <code>Downloads</code> 标识该仓库被下载了多少次，下载次数越多表示用户越多，有问题被发现的概率越大。可以作为镜像是否靠谱的参考依据。</li><li>右边 <code>Stars</code> 也和 Downloads 有着类似的功能。</li><li>通过左边的筛选栏可以对仓库进行筛选。</li></ol><p>点击进入一个仓库可以看到相关详细信息：</p><p><img src="/img/2022/docker-hub/979767-20220612181143608-2120734119.png"></p><p>常见的功能包括：</p><ol><li>怎么下载镜像。</li><li>关于这个仓库的说明介绍与配置使用方法。</li><li>关于这个仓库的用户评价。</li><li>该仓库中的镜像支持的版本，我们可以通过标版编号，下载指定版本。</li></ol><p>除了在页面上查询镜像以外，docker 本身命令行也提供了查询方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181201719-136720622.png"></p><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>docker 所有支持的命令都可以使用 <code>docker --help</code> 看到。同时通过该命令，我们也可以发现，docker 的命令分为两大类：<code>Management Commands</code> 和 <code>Commands</code>。</p><p>在 docker 设置之初是没有分类这一概念，到后面因为命令多了加入了分类。所以在学习 docker 命令的时候，建议养成使用 Management Commands 的习惯。虽然命令可能更复杂一点，但是说不定单纯的 Commands 说不定哪天就被删除了。</p><p>对于镜像支持的操作，我们可以使用命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181240712-106763821.png"></p><h2 id="拉取镜像（pull）"><a href="#拉取镜像（pull）" class="headerlink" title="拉取镜像（pull）"></a>拉取镜像（pull）</h2><p>docker 安装之后本身是没有镜像的，需要从 registry 中下载镜像才能使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载指定版本</span></span><br><span class="line">docker image pull nginx:1.22.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181257167-639154413.png"></p><p>从整个镜像的下载信息可以看出：</p><ol><li>如果没有跟版本号，默认下载 <code>latest</code> 版本。</li><li>镜像是分层结构，一个完整的镜像一般都是一层一层分开 pull 的。<br>查</li></ol><h2 id="查看本地镜像（ls）"><a href="#查看本地镜像（ls）" class="headerlink" title="查看本地镜像（ls）"></a>查看本地镜像（ls）</h2><p>镜像下载完成之后就可以使用相关命令查看它在服务器上面的保存信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker images</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181314136-1294251006.png"></p><p>通过该命令可以了解镜像的相关信息：</p><ol><li>想要唯一标识一个镜像可以有两种方法：<REPOSITORY>:<TAG> 或者 <code>IMAGE ID</code>。</li><li>通过该命令看到的 IAMGE ID 并非是完整的，但是显示部分一般已经足够区分不同镜像。</li><li>可以看到镜像的大小。</li></ol><h2 id="查看镜像详情（inspect）"><a href="#查看镜像详情（inspect）" class="headerlink" title="查看镜像详情（inspect）"></a>查看镜像详情（inspect）</h2><p>ls 查看到的镜像信息只是很少的一部分，如果想了解更详细的镜像信息，需要使用其他命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要关注以下输出的信息中的以下项目：</p><ul><li>Id：完整的 IMAGE ID，ls 展示的只是这个 ID 的开始部分。</li><li>ExposedPorts：镜像中的服务运行端口。</li><li>Env：镜像中定义的环境变量。</li><li>Cmd：启动镜像中服务所使用的命令。</li><li>Volumes：镜像挂载的持久化数据卷。</li></ul><h2 id="删除指定镜像（rm）"><a href="#删除指定镜像（rm）" class="headerlink" title="删除指定镜像（rm）"></a>删除指定镜像（rm）</h2><p>如果下载错了镜像或者需要为了清理磁盘空间而删除不需要的镜像，可以执行以下命令进行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image <span class="built_in">rm</span> nginx:1.22.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker rmi nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过 ID 镜像删除</span></span><br><span class="line">docker image <span class="built_in">rm</span> 605c77e624dd</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181338631-1279399900.png"></p><p>删除和拉取镜像类似，也是一层一层的删除。</p><blockquote><p>注意，如果有通过该镜像创建的容器正在运行，则无法直接删除镜像。需要先删除容器或者加入 <code>-f</code> 参数强制删除，容器也会跟着删除。</p></blockquote><h2 id="镜像导出（save）"><a href="#镜像导出（save）" class="headerlink" title="镜像导出（save）"></a>镜像导出（save）</h2><p>在没有私有 registry 或者没有外网环境的机器之间想要运行别的机器上面的镜像，就需要将镜像导出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mamagement Commands（推荐）</span></span><br><span class="line">docker image save nginx:1.22.0 nginx:latest -o /tmp/nginx-image.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker save nginx:1.22.0 nginx:latest -o /tmp/nginx-image-2.tar</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181357799-2107861404.png"></p><h2 id="镜像导入（load）"><a href="#镜像导入（load）" class="headerlink" title="镜像导入（load）"></a>镜像导入（load）</h2><p>为了测试导入，需要先删除所有镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image load -i /tmp/nginx-image.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker load -i /tmp/nginx-image.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181409536-1292770390.png"></p><h2 id="镜像打标签（tag）"><a href="#镜像打标签（tag）" class="headerlink" title="镜像打标签（tag）"></a>镜像打标签（tag）</h2><p>镜像在下载的时候有自己的 TAG，某些时候可能需要对其进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image tag nginx:1.20.0 nginx:<span class="built_in">history</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker tag nginx:1.20.0 nginx:<span class="built_in">history</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181435230-234859769.png"></p><p>可以发现，打 TAG 其实就是在原来的镜像基础上重新增加一个 TAG 指向该镜像 ID。</p><p>当删除某个 TAG 的时候，镜像并不会跟着全部删除。当然直接删除镜像 ID 除外。</p><h2 id="删除未使用镜像（prune）"><a href="#删除未使用镜像（prune）" class="headerlink" title="删除未使用镜像（prune）"></a>删除未使用镜像（prune）</h2><p>某些镜像在服务器中保存是没用的，如果有很多的话，可以直接使用以下命令全部清理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181449476-939906458.png"></p><p>关于更多镜像相关操作需要等后面容器相关知识整理了之后结合着使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker-Hub&quot;&gt;&lt;a href=&quot;#Docker-Hub&quot; class=&quot;headerlink&quot; title=&quot;Docker Hub&quot;&gt;&lt;/a&gt;Docker Hub&lt;/h2&gt;&lt;p&gt;&lt;code&gt;docker hub&lt;/code&gt;作为默认的注册点，不管是官方还</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>安装Docker</title>
    <link href="https://www.buerya.cn/2022/docker-install/index/"/>
    <id>https://www.buerya.cn/2022/docker-install/index/</id>
    <published>2022-06-11T03:11:19.000Z</published>
    <updated>2022-10-19T14:40:00.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>本次作为测试安装，我这里使用的是一台虚拟机，具体配置如下：</p><table><thead><tr><th>主机名</th><th>IP 地址</th><th>系统版本</th><th>内存（G）</th><th>CPU（核）</th><th>硬盘（G）</th></tr></thead><tbody><tr><td>node-01</td><td>192.168.200.101</td><td>CentOS Linux release 7.9.2009</td><td>4</td><td>4</td><td>20</td></tr></tbody></table><ol><li>关闭防火墙和 Selinux</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 Selinux</span></span><br><span class="line">sed -i <span class="string">&quot;s#^SELINUX=.*#SELINUX=disabled#g&quot;</span> /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 swap 分区</span></span><br><span class="line">swapoff -a &amp;&amp; sysctl -w vm.swappiness=0</span><br><span class="line">sed -ri <span class="string">&#x27;/^[^#]*swap/s@^@#@&#x27;</span> /etc/fstab</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>配置 yum 源（云服务器不需要）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份旧的 yum 源</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"><span class="built_in">mkdir</span> backup-$(<span class="built_in">date</span> +%F)</span><br><span class="line"><span class="built_in">mv</span> *repo backup-$(<span class="built_in">date</span> +%F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加阿里云 yum 源</span></span><br><span class="line">curl http://mirrors.aliyun.com/repo/Centos-7.repo -o ali.repo</span><br></pre></td></tr></table></figure><ol start="3"><li>安装基础依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 epel 源</span></span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装常用依赖</span></span><br><span class="line">yum -y install gcc glibc gcc-c++ make cmake net-tools screen vim lrzsz tree dos2unix lsof \</span><br><span class="line">    tcpdump bash-completion wget ntp setuptool openssl openssl-devel bind-utils traceroute \</span><br><span class="line">    bash-completion bash-completion-extras glib2 glib2-devel unzip bzip2 bzip2-devel libevent libevent-devel \</span><br><span class="line">    ntp expect pcre pcre-devel zlib zlib-devel jq psmisc tcping yum-utils device-mapper-persistent-data \</span><br><span class="line">    lvm2 git device-mapper-persistent-data bridge-utils container-selinux binutils-devel \</span><br><span class="line">    ncurses ncurses-devel elfutils-libelf-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级服务器</span></span><br><span class="line">yum update</span><br></pre></td></tr></table></figure><ol start="4"><li>时间同步</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# 互联网时间同步&quot;</span> &gt;&gt; /var/spool/cron/root</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*/5 * * * * /usr/sbin/ntpdate time2.aliyun.com &gt;/dev/null 2&gt;&amp;1&quot;</span> &gt;&gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><ol start="5"><li>打开文件数优化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/security/limits.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 打开文件优化配置</span></span><br><span class="line"><span class="string">* soft nofile 655360</span></span><br><span class="line"><span class="string">* hard nofile 131072</span></span><br><span class="line"><span class="string">* soft nproc 655350</span></span><br><span class="line"><span class="string">* hard nproc 655350</span></span><br><span class="line"><span class="string">* soft memlock unlimited</span></span><br><span class="line"><span class="string">* hard memlock unlimited</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ol start="6"><li>内核优化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/sysctl.d/user.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 内核调优</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">fs.may_detach_mounts = 1</span></span><br><span class="line"><span class="string">vm.overcommit_memory=1</span></span><br><span class="line"><span class="string">vm.panic_on_oom=0</span></span><br><span class="line"><span class="string">fs.inotify.max_user_watches=89100</span></span><br><span class="line"><span class="string">fs.file-max=52706963</span></span><br><span class="line"><span class="string">fs.nr_open=52706963</span></span><br><span class="line"><span class="string">net.netfilter.nf_conntrack_max=2310720</span></span><br><span class="line"><span class="string">net.ipv4.tcp_keepalive_time = 600</span></span><br><span class="line"><span class="string">net.ipv4.tcp_keepalive_probes = 3</span></span><br><span class="line"><span class="string">net.ipv4.tcp_keepalive_intvl =15</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_tw_buckets = 36000</span></span><br><span class="line"><span class="string">net.ipv4.tcp_tw_reuse = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_orphans = 327680</span></span><br><span class="line"><span class="string">net.ipv4.tcp_orphan_retries = 3</span></span><br><span class="line"><span class="string">net.ipv4.tcp_syncookies = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_syn_backlog = 16384</span></span><br><span class="line"><span class="string">net.ipv4.ip_conntrack_max = 65536</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_syn_backlog = 16384</span></span><br><span class="line"><span class="string">net.ipv4.tcp_timestamps = 0</span></span><br><span class="line"><span class="string">net.core.somaxconn = 16384</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ol start="7"><li>内核升级</li></ol><p>docker 对于 CentOS 的要求为内核版本不低于 <code>3.10</code>，尽管 7.9 已经是 3.10 版本，但还是有升级的必要。</p><p>同时作为生产环境，一般不会选择安装最新版本。但官方仓库中提供的 rpm 一般只会有一个 lt 和一个 ml 版本，所以需要从第三方下载想要的版本，统一服务器的内核版本，可以避免出现未知 BUG。</p><blockquote><p><a href="http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/">http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/</a></p></blockquote><p>本次使用的是 4 版本最后一版：<code>4.20</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载内核 rpm 包</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/</span><br><span class="line">wget http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-4.20.13-1.el7.elrepo.x86_64.rpm</span><br><span class="line">wget http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-devel-4.20.13-1.el7.elrepo.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装内核</span></span><br><span class="line">yum -y localinstall kernel-ml-*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看顺序</span></span><br><span class="line">awk -F\<span class="string">&#x27; &#x27;</span><span class="variable">$1</span>==<span class="string">&quot;menuentry &quot;</span> &#123;<span class="built_in">print</span> i++ <span class="string">&quot; : &quot;</span> <span class="variable">$2</span>&#125;<span class="string">&#x27; /etc/grub2.cfg</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置默认启动内核，上面的命令可以看到最新内核的序号是 0</span></span><br><span class="line"><span class="string">grub2-set-default 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 重启系统</span></span><br><span class="line"><span class="string">reboot</span></span><br></pre></td></tr></table></figure><p>系统启动完成之后，查看内核情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><p>到此，系统初始化完成！</p><h2 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h2><p>docker 目前有三种版本可供选择：<code>nightly（开发版）</code>，<code>test（测试版）</code>，<code>stable（稳定版）</code>。</p><p>对于生产环境，为了避免因为版本不同导致集群出现未知 BUG，建议手动下载 rpm 包安装。本次安装版本为 <code>20.10.9</code>,下载地址：</p><blockquote><p><a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></p></blockquote><p>如果觉得下载慢，可以使用国内的镜像地址：</p><blockquote><p><a href="http://mirrors.ustc.edu.cn/docker-ce/linux/centos/7/x86_64/stable/Packages/">http://mirrors.ustc.edu.cn/docker-ce/linux/centos/7/x86_64/stable/Packages/</a></p></blockquote><p>需要下载的安装包如下：</p><ol><li>docker-ce-20.10.9-3.el7.x86_64.rpm（docker 引擎）</li><li>docker-ce-cli-20.10.9-3.el7.x86_64.rpm（docker 引擎的命令行）</li><li>containerd.io-1.6.6-3.1.el7.x86_64.rpm（守护进程，独立于 docker 工作，管理容器的生命周期）</li><li>docker-ce-rootless-extras-20.10.9-3.el7.x86_64.rpm（ce 需要的依赖）</li><li>docker-scan-plugin-0.9.0-3.el7.x86_64.rpm（cli 需要的依赖）</li></ol><h2 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h2><p>事先使用 lrzsz 将下载的安装包上传到 <code>/usr/local/src/</code> 目录然后开始进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载可能存在的旧版本 docker</span></span><br><span class="line">yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装新版本</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/</span><br><span class="line">yum -y localinstall docker* containerd*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>查看 docker 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/img/2022/install-docker/979767-20220611152733982-509376277.png"></p><h2 id="服务优化"><a href="#服务优化" class="headerlink" title="服务优化"></a>服务优化</h2><p>由于 docker 默认的 registry 是 docker hub，而 docker hub 又是外网的服务，可能因为网络原因访问，下载都会非常慢。所以需要将 registry 调整为国内的。</p><p>国内常用的 registry 有以下一些：</p><ul><li>阿里云（需要注册用户）：<code>https://&lt;你的ID&gt;.mirror.aliyuncs.com</code></li><li>网易：<code>http://hub-mirror.c.163.com</code></li><li>中科大：<code>https://docker.mirrors.ustc.edu.cn</code></li></ul><p>通过增加配置来修改 docker 默认的 registry 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 docker 数据目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /ops/&#123;data,service,<span class="built_in">log</span>,backup,shell,package&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p /ops/data/docker/&#123;run,lib&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="comment"># exec-opts：调整 docker 为 systemd 管理</span></span><br><span class="line"><span class="comment"># registry-mirrors：设置注册点</span></span><br><span class="line"><span class="comment"># bip：修改 docker 的网段</span></span><br><span class="line"><span class="comment"># exec-root：重新定义 docker 的运行目录</span></span><br><span class="line"><span class="comment"># data-root：重新定义 docker 的数据目录</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;],</span></span><br><span class="line"><span class="string">    &quot;bip&quot;: &quot;172.16.0.1/16&quot;,</span></span><br><span class="line"><span class="string">    &quot;exec-root&quot;: &quot;/ops/data/docker/run&quot;,</span></span><br><span class="line"><span class="string">    &quot;data-root&quot;: &quot;/ops/data/docker/lib&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>如果不清楚网段划分，可以使用工具查看：</p><blockquote><p><a href="http://tools.jb51.net/aideddesign/ip_net_calc/">http://tools.jb51.net/aideddesign/ip_net_calc/</a></p></blockquote><p>重启完成后查看 docker 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/install-docker/979767-20220611152714666-1498814086.png"></p><h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><p>docker 在停止的时候可能会出现提醒：</p><blockquote><p>Warning: Stopping docker.service, but it can still be activated by: docker.socket</p></blockquote><p>告警的意思为：如果你试图连接到 docker socket，而 docker 服务没有运行，系统将自动启动 docker。</p><p>该配置是在 <code>/lib/systemd/system/docker.service</code> 中配置的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>所以这个告警可以忽略掉。</p><p>重启失败，大概可能是 &#x2F;etc&#x2F;docker&#x2F;daemon.json 存在报错，可以通过错误日志查看信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -1000f /var/log/messages</span><br></pre></td></tr></table></figure><ul><li>故障问题 1</li></ul><blockquote><p>unable to configure the Docker daemon with file &#x2F;etc&#x2F;docker&#x2F;daemon.json: invalid character ‘Â’ looking for beginning of value</p></blockquote><p>查看配置文件没有问题，但是一直这个错误，所以我怀疑里面的 tab 或者空格存在问题，通过执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -A /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>发现文件中确实有很多特殊的字符，因为配置是网上复制的。通过将里面空格和 tab 替换成空格之后故障解决。</p><ul><li>故障问题 2</li></ul><blockquote><p>unable to configure the Docker daemon with file &#x2F;etc&#x2F;docker&#x2F;daemon.json: invalid character ‘}’ looking for beginning of object key string</p></blockquote><p>原因是我在 json 最后一个值后面也加了 , 符号的缘故，删除了就好了。</p><h2 id="daemon-json"><a href="#daemon-json" class="headerlink" title="daemon.json"></a>daemon.json</h2><p>配置文件 <code>daemon.json</code> 参数详解：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 在引擎 API 中设置 CORS 标头</span></span><br><span class="line">    <span class="attr">&quot;api-cors-header&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 要加载的授权插件</span></span><br><span class="line">    <span class="attr">&quot;authorization-plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 将容器附加到网桥</span></span><br><span class="line">    <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 指定网桥 IP</span></span><br><span class="line">    <span class="attr">&quot;bip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.88.0/22&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 为所有容器设置父 cgroup</span></span><br><span class="line">    <span class="attr">&quot;cgroup-parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 分布式存储后端的 URL</span></span><br><span class="line">    <span class="attr">&quot;cluster-store&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置集群存储选项（默认map []）</span></span><br><span class="line">    <span class="attr">&quot;cluster-store-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 要通告的地址或接口名称</span></span><br><span class="line">    <span class="attr">&quot;cluster-advertise&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用调试模式，启用后，可以看到很多的启动信息。默认 false</span></span><br><span class="line">    <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器默认网关 IPv4 地址</span></span><br><span class="line">    <span class="attr">&quot;default-gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器默认网关 IPv6 地址</span></span><br><span class="line">    <span class="attr">&quot;default-gateway-v6&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器的默认 OCI 运行时，默认为 runc</span></span><br><span class="line">    <span class="attr">&quot;default-runtime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;runc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器的默认 ulimit（默认[]）</span></span><br><span class="line">    <span class="attr">&quot;default-ulimits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设定容器 DNS 的地址，在容器的 /etc/resolv.conf 文件中可查看</span></span><br><span class="line">    <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.1.1&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器 /etc/resolv.conf 文件，其他设置</span></span><br><span class="line">    <span class="attr">&quot;dns-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设定容器的搜索域。</span></span><br><span class="line">    <span class="attr">&quot;dns-search&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 运行时执行选项</span></span><br><span class="line">    <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 执行状态文件的根目录，默认 /var/run/docker</span></span><br><span class="line">    <span class="attr">&quot;exec-root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 固定 IP 的 IPv4 子网</span></span><br><span class="line">    <span class="attr">&quot;fixed-cidr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 固定 IP 的 IPv6 子网</span></span><br><span class="line">    <span class="attr">&quot;fixed-cidr-v6&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// docker 运行时使用的根路径，默认 /var/lib/docker</span></span><br><span class="line">    <span class="attr">&quot;data-root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// UNIX 接字的组，默认 docker</span></span><br><span class="line">    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置容器 hosts</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用容器间通信，默认 true</span></span><br><span class="line">    <span class="attr">&quot;icc&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 绑定容器端口时的默认 IP，默认 0.0.0.0</span></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用 iptables 规则添加，默认 true</span></span><br><span class="line">    <span class="attr">&quot;iptables&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用IPv6网络</span></span><br><span class="line">    <span class="attr">&quot;ipv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 默认 true, 启用 net.ipv4.ip_forward</span></span><br><span class="line">    <span class="attr">&quot;ip-forward&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用 IP 伪装，默认 true</span></span><br><span class="line">    <span class="attr">&quot;ip-masq&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置私有仓库地址可以设为 http</span></span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;120.123.122.123:12312&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// docker 主机的标签</span></span><br><span class="line">    <span class="attr">&quot;labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;nodeName=node-101&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 在容器仍在运行时启用 docker 的实时还原</span></span><br><span class="line">    <span class="attr">&quot;live-restore&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器日志的默认驱动程序，默认 json-file</span></span><br><span class="line">    <span class="attr">&quot;log-driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置日志记录级别：&quot;调试&quot;，&quot;信息&quot;，&quot;警告&quot;，&quot;错误&quot;，&quot;致命&quot;</span></span><br><span class="line">    <span class="attr">&quot;log-level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置每个请求的最大并发下载量，默认 3</span></span><br><span class="line">    <span class="attr">&quot;max-concurrent-downloads&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置每次推送的最大同时上传数，默认 5</span></span><br><span class="line">    <span class="attr">&quot;max-concurrent-uploads&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置容器网络 MTU</span></span><br><span class="line">    <span class="attr">&quot;mtu&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置守护程序的 oom_score_adj，默认 -500</span></span><br><span class="line">    <span class="attr">&quot;oom-score-adjust&quot;</span><span class="punctuation">:</span> <span class="number">-500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Docker 守护进程的 PID 文件</span></span><br><span class="line">    <span class="attr">&quot;pidfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 全时间戳机制</span></span><br><span class="line">    <span class="attr">&quot;raw-logs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置镜像加速</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://192.498.89.232:89&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用 selinux 支持，默认 false</span></span><br><span class="line">    <span class="attr">&quot;selinux-enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 要使用的存储驱动程序</span></span><br><span class="line">    <span class="attr">&quot;storage-driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置默认地址或群集广告地址的接口</span></span><br><span class="line">    <span class="attr">&quot;swarm-default-advertise-addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启动 TLS 认证开关，默认 false</span></span><br><span class="line">    <span class="attr">&quot;tls&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 通过 CA 认证过的 certificate 文件路径，默认 ~/.docker/ca.pem</span></span><br><span class="line">    <span class="attr">&quot;tlscacert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// TLS 的 certificate 文件路径，默认 ~/.docker/cert.pem</span></span><br><span class="line">    <span class="attr">&quot;tlscert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// TLS 的 key 文件路径，默认 ~/.docker/key.pem</span></span><br><span class="line">    <span class="attr">&quot;tlskey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 使用 TLS 并做后台进程与客户端通讯的验证，默认 false</span></span><br><span class="line">    <span class="attr">&quot;tlsverify&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 使用 userland 代理进行环回流量，默认 true</span></span><br><span class="line">    <span class="attr">&quot;userland-proxy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 用户名称空间的用户/组设置</span></span><br><span class="line">    <span class="attr">&quot;userns-remap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 存储驱动程序选项</span></span><br><span class="line">    <span class="attr">&quot;storage-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;overlay2.override_kernel_check=true&quot;</span><span class="punctuation">,</span> <span class="string">&quot;overlay2.size=15G&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器默认日志驱动程序选项</span></span><br><span class="line">    <span class="attr">&quot;log-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;max-file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max-size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10m&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;系统初始化&quot;&gt;&lt;a href=&quot;#系统初始化&quot; class=&quot;headerlink&quot; title=&quot;系统初始化&quot;&gt;&lt;/a&gt;系统初始化&lt;/h2&gt;&lt;p&gt;本次作为测试安装，我这里使用的是一台虚拟机，具体配置如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于 Docker</title>
    <link href="https://www.buerya.cn/2022/docker-about/index/"/>
    <id>https://www.buerya.cn/2022/docker-about/index/</id>
    <published>2022-06-09T13:29:39.000Z</published>
    <updated>2022-10-19T14:40:00.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>2008 年，<code>Solomon Hykes</code>和他的朋友 Kamel Founadi、Sebastien Pahl 共同创立了一家名为<code>DotCloud</code>的公司，目标是利用一种叫做容器的技术来创建一种任何人都可以使用的编程工具。</p><p>2010 年，DotCloud 获得了创业孵化器 Y Combinator 的支持，并开始吸引到一些真正的投资，在接下来的 3 年中，<code>DotCloud</code>内部孵化了一款使用 Go 语言编写，C&#x2F;S 架构，名为 Docker 的产品。</p><p>2013 年 3 月，创始人<code>Solomon Hykes</code>在 PyCon 大会上首次公开介绍了 Docker 这一产品。其<code>创新式镜像格式</code>以及<code>容器运行时</code>迅速成为社区、客户和更广泛行业的实际标准和基石。可移植的形式和易于使用的工具给应用程序和基础设施之间创造了独立性。容器技术逐渐大众化并成为主流。</p><p>docker 最初是在<code>Ubuntu 12.04</code>上开发实现的，而<code>Red Hat</code>则要从<code>6.5</code>开始才对其进行支持。</p><p><img src="/img/2022/about-docker/979767-20220608220537883-1025728940.png"></p><p>2013 年 3 月 20 日，DotCloud 发布了 Docker 的首个版本，并将 Docker 源码进行了 开源。</p><p>2013 年 9 月，红帽公司成为 Docker 的主要合作伙伴，利用 Docker 来驱动他的 OpenShift 云业务。</p><p>随后，谷歌、亚马逊以及 DigitalOcean 也迅速的在其云服务平台提供了 Docker 的支持。主流云厂商的加入，加速了 Docker 的发展，Docker 技术也至此开始风靡全球。</p><p>2013 年底，Docker 公司名称也由<code>DotCloud Inc</code>更改为<code>Docker Inc</code>，并全力的主攻到 Docker 项目开发中。</p><p>2014 年 6 月，在<code>DockerCon</code>大会上 Docker 正式发布了 1.0 版本。这意味着 Docker 的稳定性和可靠性已经基本满足了生产环境的运行需求。会议上同时也发布 Docker Image 的镜像仓库 Docker Hub。</p><p>与此同时，已经有 10 年以上容器管理编排经验的谷歌终于出手了，基于自己内部内部强大的 Borg 系统使用 Go 语言重写出来目前最火的容器编排工具：<code>Kubernetes</code>。</p><p><img src="/img/2022/about-docker/979767-20220608220555533-1493806359.png"></p><p>2014 年 8 月，Docker Inc 宣布将用于 PaaS 业务服务的 DotCloud 软件出售给德国柏林的 PaaS 服务厂商 CloudControl，自以，DotCloud 正式的和 Docker 分道扬镳。</p><p>2014 年 12 月，DockerConEU 大会上，<code>Docker Swarm</code> （Docker 集群管理工具）和 <code>Docker Machine</code> （部署 Docker 主机的命令工具）同时面世。</p><p>容器技术不只有 Docker，很早之前 Google 就投资了 CoreOS 来做竞争的容器 <code>Rocket（rkt）</code>。那时三家鼎立：Docker &#x2F; Rocket &#x2F; Warden。</p><p>2015 年 6 月，为了避免惨烈的竞争，由 Docker、IBM、微软、红帽及 Google 等厂商所组成的开放容器项目 <code>OCP</code> 联盟成立，隶属 Linux 基金会。该项目旨在建立软件容器的通用标准。Docker 将捐赠其软件容器格式，运行时以及相关规范的代码。应用容器规范（<code>appc</code>）计划的领导者，包括创始成员 CoreOS，也将把他们的技术领导力和支持带到 OCP。</p><p>2015 年，Docker 发布了 <code>runC</code> ，一个轻量级的跨平台的容器运行时命令行小工具。docker 将最初实现由 <code>LXC，0.7 版本开始去除</code> 转为自行开发的 <code>libcontainer</code>。用户可以直接利用 libcontainer 运行容器，而无需通过 docker engine。这意味着 Docker 真正解决了跨平台的问题，真正做到一次构建到处运行。</p><p>2016 年 6 月，DockerCon 大会上，Docker 宣布了 <code>Open Container Initiative，OCI</code> 正式成立 。意在业界一起合作，开发一个开放的、标准的容器格式和 Runtime。</p><p>在 OCI 标准制定后，Docker 也将 <code>Containerd</code> 独立拆分，并将其捐赠给了社区。这意味着 Docker 将容器的管理功能移出自身的核心引擎，移入了一个单独的守护进程。</p><p>同时，人们也逐渐意识到，容器技术本身的价值是在于容器的编排。然而 Docker 却放弃了自己的 Swarm 项目，想着将容器的编排和集群的管理功能添加到 Docker 自身项目当中。这和 Kubernetes 推进民主化架构，通过暴露 Kubernetes API 让更多的人来不断丰富 Kubernetes 的插件的方案截然相反，当然最终的结果大家也看到了。</p><p>2017 年 2 月， 从版本 <code>1.13</code> 开始，Docker 版本号开始遵循 <code>YY.MM-xx</code> 格式，并以每月发布一个前沿版（Edge），每季度发布一个稳定版（Stable）的进度更新。</p><p>2017 年是容器成为主流技术的一年，在 Austin 举办的 DockerCon 上，开源 Docker 项目正式命名为 <code>Moby</code> 项目。GitHub 上的 docker&#x2F;docker 库也被转移到了 moby&#x2F;moby，并且拥有了项目自己的 Logo。同时，Docker Inc 公司将 Docker 本身拆分为 <code>Docker-CE</code> 开源社区免费版和 <code>Docker-EE</code> 闭源商业版。</p><p><img src="/img/2022/about-docker/979767-20220608220621806-584954900.png"></p><p>至此，容器天下三分。其中 Moby 由社区维护，Docker-CE 由 Docker 公司维护，Docker-EE 属 Docker 公司闭源商品。</p><p>2018 年 3 月，Docker 公司创始人 Solomon Hykes 在 Docker 博客上宣布已正式从 Docker 公司离职，不再担任公司的日常运作工作。未来的身份只是 Docker 的董事会成员、主要股东，以及 Docker 维护者。</p><h2 id="为何选择"><a href="#为何选择" class="headerlink" title="为何选择"></a>为何选择</h2><p>由于硬件的飞速发展，服务器的性能也随之增强。单个业务的发布无法充分利用硬件资源，导致资源利用率较低。但是如果同一套服务器运行多个业务又可能会互相的影响，产生一系列的问题。</p><p><img src="/img/2022/about-docker/979767-20220608220643777-10168043.png"></p><p>和传统的 VM 虚拟化相比，docker 存在下面的一下优势：</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于 docker 不像传统的 VM 虚拟化需要进行硬件虚拟以及运行完整操作系统，所以系统开销更低，对系统资源的利用率自然更高。无论是应用执行速度、内存损耗还是文件存储速度，都要比传统虚拟化技术更高效。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境的不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维人员来说，最希望的就是一次创建，到处运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建测试，而运维人员则可以直接在生产环境中快速部署该镜像。由于 Dockerfile 的构建透明化，不仅开发团队可以理解应用运行环境，运维团队也可以更好的理解应用运行所需条件，帮助更好的在生产环境中部署。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此可以很轻易的将应用从一个平台迁移到另一个平台上，而且无需担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>docker 主要包含了四个核心的概念，其关系如图所示：</p><p><img src="/img/2022/about-docker/979767-20220610224042637-1318914544.png"></p><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>操作系统可以分为 <code>内核</code> 和 <code>用户空间</code>。以 Linux 为例，在内核启动后，会挂载 <code>root</code> 文件系统来提供用户空间支持。</p><p>镜像其实就相当于一个 root 文件系统。比如 ubuntu 镜像，它本身就包含了一套完整的 ubuntu 最小化文件系统。</p><p>当然，镜像是一个特殊的文件系统。除了包含文件以外，还包含了一些为容器运行时准备的配置参数，如：匿名卷，环境变量，用户等。</p><blockquote><p>镜像是不包含任何动态数据的，在镜像构建之后里面的内容就不会再发生改变。</p></blockquote><p>作为一个操作系统，即使是最小化，其大小也不小。所以 docker 在设计之时，就利用 Union FS 技术，将镜像设计为分层存储。</p><p>镜像在构建时会一层一层的叠加。前一层对于后一层都是只读的。这意味着用户想要修改镜像里面的内容，只能自己再加一层，形成一个新的镜像。所以，不管你如何修改新的镜像，其底层的镜像是不会改变的。好处在于：</p><blockquote><p>多个用到相同层级镜像的新镜像可以复用同一层，这样既能节省磁盘空间，也能提升镜像的制作速度，避免每次搞一个新的镜像就得去拉一次底层镜像。毕竟一个操作系统镜像往往都是几百 M 往上。</p></blockquote><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>镜像（Image）和容器（Container）的关系就像编程语言中常说的类和实例的关系。镜像属于静态定义，容器是镜像的运行时实体。容器可以被创建，启动，暂停，停止，删除等。</p><blockquote><p>容器的实质是进程。</p></blockquote><p>但和宿主机本身运行的进程不同，容器的进程运行在独立的名称空间中。这使得容器可以拥有自己独立的文件系统，网络，进程，用户等。</p><p>由于镜像的分层特性，每个运行的容器都相当于在镜像的基础上创建了一个当前容器的存储层用于写入数据。但这个存储层会随着容器的销毁而删除。</p><p>为了保障数据的安全，同时符合 docker 的设计规范，所有的文件，数据的写入都应该直接写入到额外挂载的 数据卷（Volume） 或者 绑定的宿主机目录 中。跳过 docker 存储层，直接持久化到宿主机本地或者外部存储，也能提升性能和稳定性。</p><blockquote><p>数据卷的生命周期独立于容器，不会随着容器的销毁而删除。</p></blockquote><h3 id="注册点（Registry）和仓库（Repository）"><a href="#注册点（Registry）和仓库（Repository）" class="headerlink" title="注册点（Registry）和仓库（Repository）"></a>注册点（Registry）和仓库（Repository）</h3><p>镜像构建完成之后可以很容易在本机运行，但是如果其他服务器想要使用该镜像，就需要另外一个服务来专门负责集中存储，分发镜像。这个服务就是 <code>注册点（Registry）</code>。</p><blockquote><p>一个注册点由一个或者多个仓库组成。</p></blockquote><p>所谓的 <code>仓库（Repository）</code>，就是用于存放同一个镜像不同版本的集合。比如：centos 仓库，它可能包含 centos:7 和 centos:8 镜像。</p><blockquote><p>一般通过 &lt;仓库名称&gt;:&lt;标签&gt; 这样的格式来区分镜像，如果没有指定标签，则默认使用 latest 标签。</p></blockquote><p>仓库名称往往也是由两段组成，比如：dylan&#x2F;centos 仓库。前者用于区分在多用户的注册点中的用户名，后者一般都是软件名。也比如：dylan&#x2F;nginx。但这并非绝对，某些仓库就没有用户名，这取决于注册点的配置。</p><p>常见的注册点分为两类：<br>    - 开放注册点：<br>      + 网上开放给用户的注册点。用户可以在上面创建自己的仓库，镜像。也可以拉取使用别人的镜像。<br>      + 最常见的 registry 就是 docker 官方提供的 Docker Hub，它也是 docker 默认的 registry。上面有着大量的官方镜像供人们使用。<br>      + 此外还有阿里云，Google 等也提供了开放的 resgistry。<br>    - 私有注册点：<br>      + 出于数据的安全性考虑，公司使用的注册点一般都是自己搭建或者云厂商们提供的私有服务。其特点在于只有授权的用户才能看到并使用它的镜像。<br>      + docker 官方开源的 docker registry 镜像能够搭建私有仓库，但是该仓库只有 API 功能，没有图形化界面。<br>      + 生产中用户一般使用 Harbor 或者 Sonatype Nexus 搭建自己的私有注册点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;发展历程&quot;&gt;&lt;a href=&quot;#发展历程&quot; class=&quot;headerlink&quot; title=&quot;发展历程&quot;&gt;&lt;/a&gt;发展历程&lt;/h2&gt;&lt;p&gt;2008 年，&lt;code&gt;Solomon Hykes&lt;/code&gt;和他的朋友 Kamel Founadi、Sebastien</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>容器技术</title>
    <link href="https://www.buerya.cn/2022/container-technology/index/"/>
    <id>https://www.buerya.cn/2022/container-technology/index/</id>
    <published>2022-06-08T13:52:44.000Z</published>
    <updated>2022-10-19T14:40:00.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>对于容器这个词，大部分人第一时间想到的肯定是生活中常见瓶瓶罐罐，用来装水的东西。它给人的第一感觉就是能 “装”。</p><p>而在<code>IT</code>领域，<code>Container</code>就被直译为容器，但<code>Container</code>本身是集装箱的意思，容器属于中国人的信雅达叫法。</p><p>可以想象一下，如果容器技术改为集装箱技术，档次一下就低了。但是为了帮助我们更好的理解容器，集装箱的翻译才能体现它的本质：</p><blockquote><p>规格标准化，层层堆叠，互相隔离，将各类零散的货物分门别类，形成统一的形状，提升运输效率，降低管理成本，保护了货物的完整性。</p></blockquote><p>在早期，<code>IT</code>领域就是通过借鉴这一思想，研发出了<code>hypervisor</code>虚拟化，将不同操作系统的虚拟机通过<code>hypervisor</code>（KVM、XEN 等）来衍生、运行、销毁。</p><p>但随着时间推移，用户也发现了<code>hypervisor</code>存在的问题：</p><blockquote><p>每次部署发布都得搞一个完整操作系统和附带的依赖环境，而用户其实更关注自己部署的应用，这导致了任务变重和性能低下。</p></blockquote><p>为此，有没有办法实现底层多余的操作系统和环境的复用就成了急需解决的问题，好比下面这个例子：</p><blockquote><p>将一辆兰博基尼（应用），打包放到一个集装箱里（容器），通过货轮轻而易举的将它从上海码头（CentOS 环境）运送到纽约码头（Ubuntu 环境）。在运输期间，兰博基尼（应用）没有受到任何的损坏，在纽约码头卸货后依然可以完美风骚的飙车（启动正常）。</p></blockquote><p><img src="/img/2022/container-technology/979767-20220608213320068-246351981.png"></p><h2 id="容器的原理"><a href="#容器的原理" class="headerlink" title="容器的原理"></a>容器的原理</h2><p><code>Linux Container</code>容器技术，简称<code>LXC</code>，是一种<code>内核轻量级的操作系统层虚拟化技术</code>，它的诞生（2008 年）解决了 IT 世界里的 “集装箱运输” 问题。</p><p>为了实现容器进程对外界的隔离，容器底层主要运用了 <code>名称空间（Namespaces）</code>、<code>控制组（Control groups）</code> 和 <code>切根（Change to root）</code>。</p><p><img src="/img/2022/container-technology/979767-20220608213342536-1386926153.png"></p><h3 id="名称空间（Namespaces）"><a href="#名称空间（Namespaces）" class="headerlink" title="名称空间（Namespaces）"></a>名称空间（Namespaces）</h3><p>每个运行的容器都有自己的名称空间（诞生于 2002 年），它主要用于实现资源的隔离。</p><p>Linux 操作系统默认提供了以下 6 个常用的 Namespace 的 API：</p><ul><li><code>PID Namespace</code>：提供进程隔离能力。<ul><li>在 Linux 系统中，有一个 PID 为 1 的进程（init&#x2F;systemd）是其他所有进程的父进程。在每个容器内也要有一个父进程来管理其下属的子进程。</li><li>不同容器就是通过 PID Namespace 隔离的，不同的名称空间中可以有相同的 pid。</li></ul></li><li><code>MNT Namespace</code>：提供磁盘挂载点和文件系统的隔离能力。<ul><li>每个容器都要有独立的根文件系统用户空间，以实现在容器里面启动服务并且使用容器的运行环境。</li><li>在容器里面不能访问宿主机的资源，宿主机使用了 chroot 技术把容器锁定到一个指的运行目录里面。</li><li>例如：宿主机是 ubuntu，里面启动一个 Centos 容器，并在容器里启动一个 Nginx，该 Nginx 运行时使用的运行环境就是 Centos 系统目录的运行环境。</li></ul></li><li><code>IPC Namespace</code>：提供进程间通信的隔离能力。<ul><li>允许一个容器内的不同进程的（内存，缓存等）数据访问，但是不能跨容器访问其他容器的数据 。</li><li>容器中进程交互还是采用 Linux 常见的进程交互方法（interprocess communication，IPC）。</li></ul></li><li><code>Net Namespace</code>：提供网络隔离能力。<ul><li>每一个容器都类似于虚拟机一样有自己的网络设备，IP地址，路由表，&#x2F;proc&#x2F;net 目录等。</li><li>以 docker 为例，使用 network namespace 启动一个 vethX 接口，这样你的容器将拥有它自己的桥接 IP 地址，通常是docker0。</li></ul></li><li><code>UTS Namespace</code>：提供主机名隔离能力。<ul><li>UNIX Time-sharing System 允许容器拥有独立的 hostname 和 domain name，使其在网络上能被视作一个独立节点而非主机的一个进程。</li></ul></li><li><code>User Namespace</code>：提供用户隔离能力。<ul><li>每个容器可以有不同的用户和组 id，也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</li></ul></li></ul><h3 id="控制组（Control-groups）"><a href="#控制组（Control-groups）" class="headerlink" title="控制组（Control groups）"></a>控制组（Control groups）</h3><p>简称<code>Cgroups</code>，是 Linux 内核提供的一种可以限制、记录、隔离进程组的物理资源的机制，由 Google 贡献，2007 年合并到 Linux Kernel。</p><p>因为 Namespace 只能改变进程的视觉范围，不能真实地对资源做出限制，所以就需要用到 Cgroup 技术。以防止某个容器把宿主机资源全部用完导致其它容器也宕掉。</p><p>在 Linux 的<code>/sys/fs/cgroup</code>目录中有 cpu、memory、devices、net_cls 等目录，可以按需修改相应的配置文件来设置某个进程 ID 对物理资源的最大使用率。</p><h3 id="切根（Change-to-root）"><a href="#切根（Change-to-root）" class="headerlink" title="切根（Change to root）"></a>切根（Change to root）</h3><p>简称<code>chroot</code>，用于改变一个程序运行时参考的根目录位置，让不同容器在不同的虚拟根目录下工作，从而相互不直接影响。</p><h2 id="容器的特点"><a href="#容器的特点" class="headerlink" title="容器的特点"></a>容器的特点</h2><p>想要更好的理解容器的特点，就需要拿跟它跟硬件抽象层虚拟化 hypervisor 技术做对比。</p><p><img src="/img/2022/container-technology/979767-20220608213409392-1087932555.png"></p><p>主要的区别如下：</p><ol><li>本质上来看，虚拟机是通过 Hypervisor 虚拟化硬件，然后在上安装不同的操作系统，而容器是宿主机上运行的不同进程。</li><li>用户体验上来看，虚拟机是重量级的，系统本身占用的物理资源多，启动时间长。而容器则相反。</li><li>隔离性上来看，虚拟机隔离的更彻底，容器则要差一些。</li></ol><p>比较得出容器主要包含以下几个特点：</p><ol><li>极其轻量：只打包了必要的 bin&#x2F;lib。</li><li>秒级部署：根据镜像的不同，容器的部署大概在毫秒与秒之间。</li><li>易于移植：<code>一次构建，到处运行</code>。</li></ol><h2 id="容器发展史"><a href="#容器发展史" class="headerlink" title="容器发展史"></a>容器发展史</h2><p>虽然现在提到容器，大家就想到<code>docker</code>，但事实上容器是从 1979 年的<code>Chroot</code>开始的。而 docker 是在 2013 年才开始推出第一个版本。具体历程如下：</p><ul><li>1979 年，<code>chroot</code>：一套 Unix 操作系统，为每个进程提供一个隔离化的磁盘空间。</li><li>2000 年，FreeBSD Jails：与 chroot 类似，增加了进程的沙箱，对制作资源进行隔离。</li><li>2001 年，Linux Vserver：每个分区被称为一套安全上下文，其中虚拟化系统被称为一套虚拟私有服务器。</li><li>2004 年，Solaris 容器：将系统资源控制与分区提供的边界结合，各分区在单一的操作系统实例之内。</li><li>2005 年，OpenVZ：安装有补丁的 Linux 内核实现虚拟化，隔离能力，资源管理以及检查点交付。</li><li>2006 年，Process 容器：对整套进程集合中的资源使用量进行限制，分配与隔离。</li><li>2007 年，<code>Control Groups</code>：谷歌实现的 Cgroups，后被合并到 Linux 内核中。</li><li>2008 年，LXC：通过 liblxc 库交付，提供可与 Python，Lua，Go 等语言对接的 API。</li><li>2011 年，Warden：不与 Linux 紧密耦合，以后台进程方式运行，并提供 API 以实现容器管理。</li><li>2013 年，<code>Docker</code>：目前最流行的容器引擎，具备完整的生态系统。</li><li>2014 年，<code>Rocket</code>：由 CoreOS 开发，专门用于解决 docker 中存在的缺陷。</li><li>2016 年，Windows 容器：docker 能够在 Windows 平台上运行。</li></ul><h2 id="容器标准化"><a href="#容器标准化" class="headerlink" title="容器标准化"></a>容器标准化</h2><blockquote><p>docker 是容器，但容器并不只有 docker。</p></blockquote><p>任何技术出现都需要一个标准来规范它，不然各搞各的很容易导致技术实现的碎片化，出现大量的冲突和冗余。所以，在 2015 年，由 Google，Docker、CoreOS、IBM、微软、红帽等厂商联合成立了<code>OCI（Open Container Initiative）</code>组织，并于 2016 年 4 月推出了第一个开放容器标准。其主要内容包括 <code>runtime 运行时标准</code> 和 <code>image 镜像标准</code>。</p><p>该标准的推出，保障了市场的稳定性，让企业能放心采用容器技术，用户在打包、部署应用程序后，可以自由选择不同的容器 Runtime。同时，镜像打包、建立、认证、部署、命名也都能按照统一的规范来做。</p><p>两种标准主要包含以下内容：</p><h3 id="容器运行时标准-（runtime-spec）"><a href="#容器运行时标准-（runtime-spec）" class="headerlink" title="容器运行时标准 （runtime spec）"></a>容器运行时标准 （runtime spec）</h3><p>规定了容器的基本操作规范。</p><ol><li>creating：使用 create 命令创建容器，这个过程称为创建中。</li><li>created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台。</li><li>running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务。</li><li>stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除。</li></ol><h3 id="容器镜像标准（image-spec）"><a href="#容器镜像标准（image-spec）" class="headerlink" title="容器镜像标准（image spec）"></a>容器镜像标准（image spec）</h3><p>定义镜像的基本格式。</p><ol><li>文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等。</li><li>config 文件：保存了文件系统的层级信息，以及容器运行时需要的一些信息，指定了镜像在某个特定平台和系统的配置。</li><li>manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，还保存了很多和当前平台有关的信息。</li><li>index 文件：可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是容器&quot;&gt;&lt;a href=&quot;#什么是容器&quot; class=&quot;headerlink&quot; title=&quot;什么是容器&quot;&gt;&lt;/a&gt;什么是容器&lt;/h2&gt;&lt;p&gt;对于容器这个词，大部分人第一时间想到的肯定是生活中常见瓶瓶罐罐，用来装水的东西。它给人的第一感觉就是能 “装”。&lt;/</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Docker" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"/>
    
    
    <category term="docker" scheme="https://www.buerya.cn/tags/docker/"/>
    
    <category term="k8s" scheme="https://www.buerya.cn/tags/k8s/"/>
    
    <category term="kubernetes" scheme="https://www.buerya.cn/tags/kubernetes/"/>
    
    <category term="容器" scheme="https://www.buerya.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="云原生" scheme="https://www.buerya.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何学习一门技术</title>
    <link href="https://www.buerya.cn/2022/how-to-learn-tech/how-to-learn-tech/"/>
    <id>https://www.buerya.cn/2022/how-to-learn-tech/how-to-learn-tech/</id>
    <published>2022-06-02T10:46:25.000Z</published>
    <updated>2022-10-19T14:40:00.255Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个<code>终身学习</code>的实践者，我经常有学习一些新技术的需求。如何学习这些新技术不同人有不同的做法，早前我也写过一篇 <a href="/2022/06/01/leran-skill/">如何快速学习一项新技能？</a> 的文章分享我学习的理论框架，但这篇文章我会以我学习WebRTC这个技术为例分享我在学习新技术时用的一些方法。</p><p>如何学习某个知识，在我看来，主要矛盾在于解决这三个问题。</p><h3 id="要学否"><a href="#要学否" class="headerlink" title="要学否"></a>要学否</h3><p>在学习一门新技术前需要解决的第一个问题是<strong>要不要投资时间去学这门技术</strong>。就像买书最大的成本并不是买书的价格，而是看书的时间。花费大量的时间去看一本没有价值的书，无异于浪费生命。正是方向搞错了，越努力越尴尬。</p><p>怎么确定一门技术的价值，可以从以下两个方面来考虑：</p><ul><li><strong>从知识体系出发</strong>：某门技术经常不是孤立存在的，而是一个积木般搭建的大厦的一部分。要学习顶部的技术，就需要掌握一定的底部技术。如果一个技术很基础很底层，被很多高层的技术所依赖，那学习这门技术就很有价值。</li><li><strong>从应用前景出发</strong>：如果一门技术很有市场“钱景”，或者有潜在的市场需求，那学习这门技术就很有价值。毕竟我们学习目的很大的一部分在于赚钱解决自己的生活问题。</li></ul><p>不过这里的难点在于从我们已知的信息来分析，很难判断某门技术的市场前景。如果分析判断错误，很可能会导致我们学习这门技术的时间被浪费。那最佳的选择的就是尽可能让自己所学的技术都满足这两点，哪怕最后没有市场前景，但如能成为我们知识体系的基础，也值得投入时间去学习。</p><p>基于这两方面的考虑，我开始学习了分布式系统的一些底层知识：</p><p><img src="/img/2022/how-to-learn-tech/578bc683-a3ba-f6f8-7c6a-965b95181c58.webp"></p><p>之后通过搜索，间接找到了基于WebRTC技术的语音聊天网站<a href="https://speakrandom.com/">speakrandom</a>，在分析这个网站技术栈的时候找到了<a href="https://github.com/pion/webrtc">pion&#x2F;webrtc</a>这个框架，最终决定从这个框架入手开始学习WebRTC。</p><h3 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h3><p>在制定了学习目标之后，剩下的问题是怎么怎么学？学习方法千万条，重要的是找到适合自己的学习方法。</p><p>我的方法是<strong>善用搜索，找到对的资料和对的人</strong>。学习本身不应是一件复杂的事情，因为它不是做研究，不是探索未知的东西，只是站在巨人的肩膀上把已经被解决的问题学习一遍。</p><p>但这里的难点在于资料千万份，一不小心就找到错误的资料，让本来简单的学习变得复杂，这就像天龙八部鸠摩智学了段誉给的错误的六脉神剑剑诀，很容易学的走火入魔。</p><h4 id="主动搜索"><a href="#主动搜索" class="headerlink" title="主动搜索"></a>主动搜索</h4><p><code>主动获取资料</code>方式的要点在于从错误少的信息库筛选、交叉对比选择要看的资料。由于很多技术资料都是用英文写的，用Google英文搜索更容易获取高质量的资料。另外使用Google图片关键词搜索可以快速获得架构方面的资料，方便从高层次理解这个技术。</p><p>一般我会从Google、YouTube、bilibili和GitHub上搜索某个技术相关的资料、视频教程和开源库。以搜索切入，找到合适的开源项目或者技术标准，然后制定学习计划。很容易通过<code>webrtc</code>关键词在这些平台上搜索得到这些资料和教程：</p><ul><li>GitHub<ul><li><a href="https://github.com/pion/webrtc">https://github.com/pion/webrtc</a></li></ul></li><li>YouTube<ul><li>WebRTC Crash Course</li></ul></li><li>Google<ul><li>Build the backend services needed for a WebRTC app: STUN, TURN, and signaling - HTML5 Rocks</li></ul></li></ul><p>从pion&#x2F;webrtc这个库上了解到作者是<a href="https://github.com/Sean-Der"><code>@Sean DuBois</code></a>，GitHub关注一波然后去YouTube搜索下他的演讲，又收获了一波高质量的教程：</p><p><img src="/img/2022/how-to-learn-tech/e0c41270-6329-edcb-815e-a83fc2ede51e.webp"></p><h4 id="技术标准"><a href="#技术标准" class="headerlink" title="技术标准"></a>技术标准</h4><p>另外一个高质量的资料是协议标准，比如<code>IETF RFC</code>文档。搜索一番后找到WebRTC相关的标准：</p><ul><li><a href="https://www.w3.org/TR/webrtc/">https://www.w3.org/TR/webrtc/</a></li></ul><p>从这个<code>W3C</code>制定的标准里又可以看到很多<code>IETF RFC</code>的资料。了解这些技术标准有助于我从高层次理解这个技术的一些特性。当然这些标准的细节我暂时不会去看，等到需要了解细节的时候再去看。</p><p>另外还可以从标准中梳理出这个技术的一些历史背景知识。</p><h4 id="技术历史"><a href="#技术历史" class="headerlink" title="技术历史"></a>技术历史</h4><p>复杂的技术不是横空出世的，而是从简单的技术逐渐根据需求而演变来的。很多时候一个技术的复杂是因为其有很多历史性而导致的，比如Java的范型之所以使用复杂并具备很多限制性是因为其为兼容老的库而妥协设计出的产物。了解这个技术的历史背景有助于降低理解这个技术的复杂度。</p><h4 id="做好笔记"><a href="#做好笔记" class="headerlink" title="做好笔记"></a>做好笔记</h4><p>搜索而来的资料如果不做整理和记录的话，时间久了就全忘了。我把这些资料整理到了<a href="https://logseq.com/"><code>Logseq</code></a> 这个双链笔记中。</p><p><img src="/img/2022/how-to-learn-tech/0cc2b35b-e70c-547c-f0fa-26a54178da87.webp"></p><p>从下面这个笔记拓扑图中可以看出我记录的分布式知识（Distributed System）和<code>WebRTC</code>间的关联关系。众所周知，学习在大脑的体现就是神经元突触之间建立新的连接，笔记间的知识通过这种方式也能帮助我们快速建立知识间的联系。</p><p><img src="/img/2022/how-to-learn-tech/feafeb84-b5f7-3b81-3b07-3bc04fa4375d.webp"></p><h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><p>记录完笔记后，我要做的就是规划时间把整理得来的资料学习消化。在这个环节可用<code>时间管理</code>的方法制定该项技术的学习计划。</p><h4 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h4><p>学习技巧千万条，但有一条是我觉得很重要的，那就是把你所学的<strong>说给别人听</strong>，从别人的反馈中了解自己对该知识掌握薄弱的点。很多时候大脑在学习的过程中会有很多模糊不清的点，如果不说出来的话，这些不清楚的点会被忽略掉，但如果要让别人听得懂，那需要我们懂的更多才行。</p><p><img src="/img/2022/how-to-learn-tech/e62f6b6b-637f-b8bc-0210-60578ba8664c.webp"></p><p>写文章其实也是说给别人听，只不过比单纯的说要更为系统。所以我一般在学习某个技术的时候会去写文章分享。一方面让自己的知识梳理的更清晰，另外一方面可以与读者交流，掌握更多的知识，这也可以解决掉那个经典的我不知道我不知道的知识，当我写出来时，会有看到的人帮我发现我不知道的知识。</p><p>当然也可以在社交网站上分享一些学习中梳理的知识点，之后方便整合成文章：</p><p><img src="/img/2022/how-to-learn-tech/7b4629f4-e36c-2af1-4385-a6f41a0f72fb.webp"></p><h4 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h4><p>找对的人解决学习中的困惑无异于能加速整个学习过程。这方面很多开源项目都有自己的讨论区，比如我在理解WebRTC SFU的过程中就有很多困惑甚至错误的理解，在社区中与作者沟通后才得到了正确的答案：</p><p><img src="/img/2022/how-to-learn-tech/e6a7869e-5cfc-6ecc-bfa5-5ebcbc7e11df.webp"></p><p>当然我们还可以在论坛、GitHub Issue、邮件组或交流群等地方中寻求帮助。</p><h4 id="心理建设"><a href="#心理建设" class="headerlink" title="心理建设"></a>心理建设</h4><p>学习里的一大难点可能是不好意思说出自己不懂的点，尤其是工作多年后，要承认自己不懂是件困难的事情。但如果你以终身学习为目标，那么这方面就没什么障碍。不懂就去学，不懂就去问。无知并不可怕，年龄大不懂也不可怕，可怕的是不懂却隐藏这一点。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>在掌握了技术的理论后，可以通过技术的实践来提高自己的技术水平，比如做一个开源项目。对技术的应用有两种方式：</p><ul><li>从零开始，一步步实现自己的系统。这种方式的问题在于，刚开始我们对技术的应用不是很熟悉，完全自己做可能无法应用一些最佳实践，摸着石头过河的成本比较高。</li><li>从现有的应用中改造。开源项目有很多好的应用，可以直接用来学习并改造。一方面可以加速应用的开发，另外还可以学习别人成熟的经验。</li></ul><p>通过一番搜索，我找到了两个不错的学习项目：</p><ul><li><a href="https://github.com/fletcherist/webtrc-voice-chat">webtrc-voice-chat</a></li><li><a href="https://github.com/MixinNetwork/kraken">kraken</a></li></ul><p>这两个都是基于pion&#x2F;webrtc库开发的语音聊天网站。基于这两个开源项目，我可以逐渐学习并开发自己的开源项目。</p><p>这个目标有点大，我会把这个业余项目作为技术试验田，把需要学习应用的技术都应用到这里。</p><p><strong>学以致用，是学习的最终目的</strong>。只有真正去用这个技术，才能真正掌握它。否则花费时间去学习，不用的话很快就忘了。</p><p>最后，能看到这里的话，希望这篇文章里提到的一些方法能让你更快速的学习某个领域的技术。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为一个&lt;code&gt;终身学习&lt;/code&gt;的实践者，我经常有学习一些新技术的需求。如何学习这些新技术不同人有不同的做法，早前我也写过一篇 &lt;a href=&quot;/2022/06/01/leran-skill/&quot;&gt;如何快速学习一项新技能？&lt;/a&gt; 的文章分享我学习的理论框架，但这</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="技术方法论" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="技术方法论" scheme="https://www.buerya.cn/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何快速学习一项新技能？</title>
    <link href="https://www.buerya.cn/2022/leran-skill/leran-skill/"/>
    <id>https://www.buerya.cn/2022/leran-skill/leran-skill/</id>
    <published>2022-06-01T03:40:07.000Z</published>
    <updated>2022-10-19T14:40:00.258Z</updated>
    
    <content type="html"><![CDATA[<p>马上就要高考了，还记得当初读高中时书店里有不少《21天学会XXX》的书，到了大学后书店里还是有不少这类型的书。今天在Quora上有一个热门问题：“如何在一晚上学会写代码？”有个高票回答大意是带着笔记本去冬天刚来临的北极，这样就有一晚上约六个月时长的时间来学习写代码了。从调侃式的回答中表明了某些领域如编程就算是一个天才也需要一定的时间来学习实践。</p><hr><p>这两件事从侧面说明大众对快速学习新技能的渴望，但是很多快速学习的书或文章一般看了都没什么效果，大多都是一堆知识的罗列，没有一套系统化的理念和执行的框架根本不可行。</p><p>社会在全球化背景下的迅速发展，互联网对各个行业的不断渗透，传统经验积累式门槛的逐渐消除，多领域降维打击般的隐形竞争，都在迫使我们需要短期内快速学习很多领域知识。</p><p>在万众创新、全民创业的号召下，我也曾经历过一段创业历程。在创业的过程中经常面临着许多变化，经常需要我快速学习、快速决策、快速改变。这段经历迫使我建立了自己的一套快速学习框架，它让我在多个需要学习的领域从容应对，我给它起了个抽象的名字：<code>元学习</code>。</p><h3 id="元学习流程"><a href="#元学习流程" class="headerlink" title="元学习流程"></a>元学习流程</h3><blockquote><p>以下工具都可以在你自认为合适的情况下替换，不接受diss</p></blockquote><ol><li><p>制定目标：确定学习目标、期望效果及学习周期</p></li><li><p>信息收集：尽可能通过多种途径搜索相关信息，如搜索引擎、社区、专业人士及书</p></li><li><p>模式匹配：综合快速对比信息，确定最优学习路径</p></li><li><p>制定计划：学习理论并制定学习执行计划</p></li><li><p>执行计划：使用OmniFocus与OneNote开始执行并实践计划</p></li><li><p>回顾计划：使用OmniFocus与OneNote每周、每月定期检查计划执行情况</p></li><li><p>优化改善：使用OneNote从结果反馈中完善技能</p></li></ol><h3 id="元学习实例"><a href="#元学习实例" class="headerlink" title="元学习实例"></a>元学习实例</h3><p>理论看着很空，我依旧拿一个简单的实例来展示我是如何实践这套框架的。需要说明的一点是这套元学习框架并不是什么新奇的东西，很多执行力强的人大多也是按这套流程来学习新领域，在这其中我认为很重要的一点是你需要通过不断的解决一个个问题来快速获得该领域的知识，该领域的理论知识你不需要学习太充分，大概理解的差不多的时候就去实践，在解决问题的过程中学习。</p><p>在昨天的时候我因为学习移动端安全的目的要研究如何反编译iOS上架App。我使用Google查找相关资料，在打开十几篇文章后我把感觉不错的资料放入OneNote学习笔记本的开发技术分区中的iOS主题分页中以便日后查看，还找到一个很短的Youtube视频讲解看了下。在大致了解了所需要的工具和流程后，我在OmniFocus中建立了初步的学习计划，这样我可以按计划去学习该领域知识，OmniFocus会在计划的时间内去提醒我当日要做的任务。</p><p>上述场景是一个非常简单的实例：</p><ol><li><p>我给自己制定了一个学习目标：在一周内研究并实践iOS反编译技术。</p></li><li><p>我用Google查找了很多相关的技术资料，了解了使用的工具及流程。</p></li><li><p>利用已有的经验和论坛上相关的讨论，我很快确定了下一步要学习的计划。</p></li><li><p>我查看了在OneNote收集的资料，并制定了学习计划。</p></li><li><p>我在OmniFocus中制定了该主题的学习计划，这样就可以利用空闲时间去学习这个领域知识，而OmniFocus也会在相应的学习周期中去提醒我当日在该领域的学习任务，我会在每天的待办事项中去执行它。</p></li><li><p>一周结束后我回去回顾这个计划，查看是否执行完毕，如果未完毕则重新调整计划。</p></li><li><p>如果该领域知识已经掌握，我会在OneNote中记录所有和这个领域知识相关的资料，这样方便我日后做进一步的完善。</p></li></ol><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><p>这套学习框架看似平淡无奇，但是会有不少人遇到问题。</p><ol><li><p>找不到合适的目标。对于这个问题来说，我觉得可以先给自己找一个学习榜样。比如在社区里遇到很厉害的高手，你想学习他的技能，那么你可以去看他的作品或履历，这样你可能会建立自己的学习目标。</p></li><li><p>无法收集有效资料。首先请提高你的信息检索能力和学会翻墙（我们是局域网，学会翻墙可以让你上真正的互联网），这方面又很多教程可以供你学习。互联网有大量的有效资料，很多时候是你搜索技术有问题而不是没有这个资料。如果实在找不到，你可以去周边大学的图书馆里去查找，那里可以找到很多学术期刊资料。</p></li><li><p>无法制定学习计划。能出现这个问题，说明你对该领域知识宏观上还是缺乏了解，所做的阅读量并不够，多研究该领域学习者的经验分享可以让你制定合理的学习计划从而少走很多弯路。</p></li><li><p>领域知识无法长久保留下去。这方面你需要把该领域相关知识建立在OneNote同一个分区下，这样方便日后查找。同时尽可能学习一些长期技能，因为最大的学习成本是时间，如果你把大量的时间都投入到用一次就不用的领域里，那你就是选择了错误的方向，而错误方向的努力反而是最大的懒惰。</p></li><li><p>没有时间去执行计划。这说明你并不了解你的时间分配，很少会出现一个人忙到没有时间去完成自己的学习计划。如果你真的觉得没有时间，那是因为你自己把它浪费掉了。这方面可以看我之前写的文章： 利用GTD理念管理你的时间</p></li><li><p>计划执行总是出现偏差。这个需要你定期会回顾这个计划，我会在每周周末和每月月末去回顾我本周和本月的计划，查看是否有的项目需要我重现做调整。很多计划无法执行下去，也是和没有做定期回顾有关。人的记忆容量有限，所以很容易忘掉很多事情，如果你定期回顾你的计划，那么执行起来也会很容易的。</p></li></ol><p>我们可以通过大量的阅读和查看多领域的信息，在每天接受信息的过程中对知识体系进行微升级并建立新的知识点连接，从而产生跨领域创作经验，这样就可以建立你自己的能力圈。这其中建立好自己的信息渠道很重要，因为当你打开你的朋友圈后看到的都是做微商广告的，你的邮箱又经常收到很多垃圾邮件，你的手机每天推送给你的都是很多垃圾资讯，这样就会导致你无法接受高质量的信息，也就很难去打造自己的知识体系。我会在日后写一篇如何构建自己的信息渠道的文章。</p><h3 id="简单技能组合"><a href="#简单技能组合" class="headerlink" title="简单技能组合"></a>简单技能组合</h3><p>在<code>UNIX</code>系统设计哲学里，推崇的是用小工具组合来解决复杂的问题：小程序之间通过管道连接，前一个程序的输出可以做后一个程序的输入，通过简单的连接打造极为强大的软件系统。</p><hr><p>这是一种优秀的设计，简单而强大。我也相信我们可以通过建立简单的长期技能，然后把不同的技能组合在一起，通过简单的技能组合你就可以解决很多复杂的问题。比如我们给公众号写一篇文章，这需要我们有阅读总结技能、设计排版技能、写作技能、运营推广技能等，每个技能不需要非常专业精通，也许你只是简单了解这个领域的知识，但是你一旦你去综合的运用这些技能的时候，你就解决了很复杂的大问题。简单的技能只需要你花不长的时间就可以掌握，如果该技能失去用途，你的时间成本损失也不是很高。如果你花了很多时间去学习了一个技能后，一旦因为大环境的改变导致这个领域知识失去用途，那你的损失将会非常之高。而经过一系列组合后，简单的技能也可以爆发出很大的威力。</p>]]></content>
    
    
    <summary type="html">马上就要高考了，还记得当初读高中时书店里有不少《21天学会XXX》的书，到了大学后书店里还是有不少这类型的书。今天在Quora上有一个热门问题：“如何在一晚上学会写代码？”有个高票回答大意是带着笔记本去冬天刚来临的北极，这样就有一晚上约六个月时长的时间来学习写代码了。从调侃式的回答中表明了某些领域如编程就算是一个天才也需要一定的时间来学习实践。</summary>
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="技术方法论" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
    <category term="技术方法论" scheme="https://www.buerya.cn/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的跨域Content Security Policy通行设置</title>
    <link href="https://www.buerya.cn/2022/nginx-content-security-policy/nginx-content-security-policy/"/>
    <id>https://www.buerya.cn/2022/nginx-content-security-policy/nginx-content-security-policy/</id>
    <published>2022-04-29T06:05:27.000Z</published>
    <updated>2022-10-19T14:40:00.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>A 站点 HTTPS，A 站点做为中心站，引用 B&#x2F;C&#x2F;D&#x2F;E&#x2F;F……站点的资源进行供给，确定的只有 A 站点是 HTTPS，其它站点可能是 HTTP 也可能是 HTTPS，文件类型不限定，包括但不限于：CSS,JS,IMAGE,MP4,MP3,RAR,ZIP,M3U8,FLV……。</p><p>如果你使用的是默认配置，那么它会提示以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://site.com/index.m3u8&#x27; from origin &#x27;http://site&#x27; has been blocked by CORS policy: The response is invalid.</span><br></pre></td></tr></table></figure><p>知道通常情况下，HTTPS 引用 HTTP 的资源就会出现跨域错误，但今天我们的要求是允许它跨域，并且尽量保证它是基本安全的。</p><p>在上周我测试过很多方案，最终使用的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;upgrade-insecure-requests&quot;;</span><br></pre></td></tr></table></figure><p>意思是将所有 HTTP 请求尽可能的转换成 HTTPS 请求，如果对方同时支持 HTTPS 和 HTTP 协议，那这没有任何问题，但如果对方只支持 HTTP，那这时候就会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Refused to load the image &#x27;http://site/file.png&#x27;</span><br><span class="line">because it violates the following Content Security Policy directive:</span><br></pre></td></tr></table></figure><p>看到提示后直觉告诉我要去放行<code>img-src</code>和<code>media-src</code>，但当我去放行设置后，问题依旧，甚至还多出了错误。</p><h3 id="Content-Security-Policy-内容安全策略"><a href="#Content-Security-Policy-内容安全策略" class="headerlink" title="Content-Security-Policy 内容安全策略"></a>Content-Security-Policy 内容安全策略</h3><p>内容安全策略（CSP）需要仔细调整和精确定义策略。如果启用，CSP 会对浏览器呈现页面的方式产生重大影响（例如，默认情况下禁用内联 JavaScript，并且必须在策略中明确允许）。CSP 可防止各种攻击，包括跨站点脚本和其他跨站点注入。</p><h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><table><thead><tr><th>Directive</th><th>Description</th></tr></thead><tbody><tr><td>base-uri</td><td>Define the base uri for relative uri.</td></tr><tr><td>default-src</td><td>Define loading policy for all resources type in case of a resource type dedicated directive is not defined (fallback).</td></tr><tr><td>script-src</td><td>Define which scripts the protected resource can execute.</td></tr><tr><td>object-src</td><td>Define from where the protected resource can load plugins.</td></tr><tr><td>style-src</td><td>Define which styles (CSS) the user applies to the protected resource.</td></tr><tr><td>img-src</td><td>Define from where the protected resource can load images.</td></tr><tr><td>media-src</td><td>Define from where the protected resource can load video and audio.</td></tr><tr><td>frame-src</td><td>Deprecated and replaced by child-src. Define from where the protected resource can embed frames.</td></tr><tr><td>child-src</td><td>Define from where the protected resource can embed frames.</td></tr><tr><td>frame-ancestors</td><td>Define from where the protected resource can be embedded in frames.</td></tr><tr><td>font-src</td><td>Define from where the protected resource can load fonts.</td></tr><tr><td>connect-src</td><td>Define which URIs the protected resource can load using script interfaces.</td></tr><tr><td>manifest-src</td><td>Define from where the protected resource can load manifest.</td></tr><tr><td>form-action</td><td>Define which URIs can be used as the action of HTML form elements.</td></tr><tr><td>sandbox</td><td>Specifies an HTML sandbox policy that the user agent applies to the protected resource.</td></tr><tr><td>script-nonce</td><td>Define script execution by requiring the presence of the specified nonce on script elements.</td></tr><tr><td>plugin-types</td><td>Define the set of plugins that can be invoked by the protected resource by limiting the types of resources that can be embedded.</td></tr><tr><td>reflected-xss</td><td>Instructs a user agent to activate or deactivate any heuristics used to filter or block reflected cross-site scripting attacks, equivalent to the effects of the non-standard X-XSS-Protection header.</td></tr><tr><td>block-all-mixed-content</td><td>Prevent user agent from loading mixed content.</td></tr><tr><td>upgrade-insecure-requests</td><td>Instructs user agent to download insecure resources using HTTPS.</td></tr><tr><td>referrer</td><td>Define information user agent must send in Referer header.</td></tr><tr><td>report-uri</td><td>Specifies a URI to which the user agent sends reports about policy violation.</td></tr><tr><td>report-to</td><td>Specifies a group (defined in Report-To header) to which the user agent sends reports about policy violation.</td></tr></tbody></table><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p><code>Content-Security-Policy: script-src &#39;self&#39;</code></p><h4 id="在经过反复测试后"><a href="#在经过反复测试后" class="headerlink" title="在经过反复测试后"></a>在经过反复测试后</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;upgrade-insecure-requests;connect-src *&quot;;</span><br></pre></td></tr></table></figure><p>解决了全部问题，即消除全部警告，同时兼容了各种协议资源。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></li><li><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#csp">https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#csp</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;场景描述&quot;&gt;&lt;/a&gt;场景描述&lt;/h3&gt;&lt;p&gt;A 站点 HTTPS，A 站点做为中心站，引用 B&amp;#x2F;C&amp;#x2F;D&amp;#x2F;E&amp;#x2F;F……站点的资源进行</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="服务器" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Nginx" scheme="https://www.buerya.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.buerya.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>版本管理操作规范及gitflow使用</title>
    <link href="https://www.buerya.cn/2022/git-flow/git-flow/"/>
    <id>https://www.buerya.cn/2022/git-flow/git-flow/</id>
    <published>2022-04-29T05:35:33.000Z</published>
    <updated>2022-10-19T14:40:00.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版本&#x2F;分支管理规范，主要包括 commit 规范，版本号管理规范，mversion 的使用方法，commitizen 的使用方法，git 常用命令收集，gitflow 使用说明</p></blockquote><h3 id="有模板的项目，要以统一的模板创建项目"><a href="#有模板的项目，要以统一的模板创建项目" class="headerlink" title="有模板的项目，要以统一的模板创建项目"></a>有模板的项目，要以统一的模板创建项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git.com:your-project/your-project.git</span><br></pre></td></tr></table></figure><h3 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h3><p>git commit 提交样式标准</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;type(scope): 描述(#issue)&quot;</span><br></pre></td></tr></table></figure><blockquote><p>git commit -m “type(类型): 描述(#issue)”</p></blockquote><h4 id="lt-类型-gt"><a href="#lt-类型-gt" class="headerlink" title="&lt;类型&gt;"></a><strong style="color: #c7254e;background-color: #f9f2f4;">&lt;类型&gt;</strong></h4><p>用于说明 commit 的类别，只允许使用下面 7 个标识。</p><ul><li>feat：新功能（feature）</li><li>fix：修补 bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><h4 id="lt-内容-gt"><a href="#lt-内容-gt" class="headerlink" title="&lt;内容&gt;"></a><strong style="color: #c7254e;background-color: #f9f2f4;">&lt;内容&gt;</strong></h4><p>对本次 commit 的详细描述，可以分成多行，可详细说明代码变动的动机</p><h4 id="lt-结尾-gt"><a href="#lt-结尾-gt" class="headerlink" title="&lt;结尾&gt;"></a><strong style="color: #c7254e;background-color: #f9f2f4;">&lt;结尾&gt;</strong></h4><p>如果当前 commit 针对某个 issue，那么可以在 Footer 部分关闭这个 issue：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #234</span><br></pre></td></tr></table></figure><blockquote><p><strong>commitizen 使用说明</strong><br>全局安装：</p><p><code>npm install -g commitizen</code></p><p>进入到<code>.git</code>目录</p><p><code>commitizen init cz-conventional-changelog --save --save-exact</code></p><p>用<code>git cz</code>命令来取代<code>git commit</code></p></blockquote><h3 id="版本号规范"><a href="#版本号规范" class="headerlink" title="版本号规范"></a>版本号规范</h3><p>初期开发版本号从 0.1.0 开始</p><p>初次上线版本号更换为 1.0.0</p><p>使用 npm install -g mversion 更新版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mversion</span><br></pre></td></tr></table></figure><p><strong>版本号修改规则及命令：</strong></p><p>v1.0.0 （主版本号.次版本号.修订版）</p><ul><li>主版本号：当功能模块有较大的变动（不向下兼容），比如增加多个模块或者整体架构有较大改动的情况<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mversion m // 1.0.0 =&gt; 2.0.0</span><br></pre></td></tr></table></figure></li><li>子版本号：当功能有一定的增加或变化（向下兼容），比如增加了对权限控制、增加登录校验……<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mversion i // 1.0.0 =&gt; 1.1.0</span><br></pre></td></tr></table></figure></li><li>修订号：一般是<code>Bug</code>修复或是一些小的变动（向下兼容），要经常发布修订版，时间间隔短<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mversion p // 1.0.0 =&gt; 1.0.1</span><br></pre></td></tr></table></figure></li></ul><p>修改完成测试通过后在项目文档中写入更新内容，新建 tag 并推送到远程分支</p><p>可在.mversionrc 中添加 hooks 自动添加 tag</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;preupdate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo &#x27;Bumping version&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;postupdate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git add package.json &amp;&amp; git commit -m v%s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;precommit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo &#x27;precommit&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;postcommit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo &#x27;postcommit&#x27;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.com/package/mversion">mversion 文档</a></p><p><code>git tag -a v1.4 -m &#39;version 1.4&#39;</code></p><p><code>git push --tags</code></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><code>commit</code>统一规范</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;type(scope): 描述(#issue)&#x27;</span><br></pre></td></tr></table></figure><p>切换到指定 tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure><p>使用<code>git tag</code>命令添加一个新的标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m &#x27;version 1.4&#x27;</span><br></pre></td></tr></table></figure><p>删除本地<code>tag</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d tag_name</span><br></pre></td></tr></table></figure><p>从指定 tag 新建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure><p>clone 指定 tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch [tags标签] [git地址]</span><br></pre></td></tr></table></figure><h3 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git flow"></a>Git flow</h3><blockquote><p>新项目第一次必须执行</p></blockquote><p><code>git flow init</code></p><h4 id="分支操作说明"><a href="#分支操作说明" class="headerlink" title="分支操作说明"></a>分支操作说明</h4><h5 id="feature-新功能开发：从-dev-新建-feature-分支-开发完成后会合并到-dev"><a href="#feature-新功能开发：从-dev-新建-feature-分支-开发完成后会合并到-dev" class="headerlink" title="feature 新功能开发：从 dev 新建 feature 分支 开发完成后会合并到 dev"></a>feature 新功能开发：从 dev 新建 feature 分支 开发完成后会合并到 dev</h5><p><code>git flow feature start [version]</code></p><p>some commit…</p><p><code>git flow feature publish [version]</code></p><p><code>git flow feature finish [version]</code></p><p><code>git push</code></p><h5 id="release：从-dev-新建-release-分支-gt-最后会合并到-master-和-dev-gt-发布新版"><a href="#release：从-dev-新建-release-分支-gt-最后会合并到-master-和-dev-gt-发布新版" class="headerlink" title="release：从 dev 新建 release 分支 -&gt; 最后会合并到 master 和 dev -&gt; 发布新版"></a>release：从 dev 新建 release 分支 -&gt; 最后会合并到 master 和 dev -&gt; 发布新版</h5><p><code>git flow release start [version]</code></p><p><code>mversion p</code> &#x2F;&#x2F; 更新版本号</p><p>some commit…</p><p><code>git flow release publish [version]</code></p><p><code>git flow release finish [version]</code></p><p><code>git push --all &amp;&amp; git push --tag</code></p><h5 id="修复线上-bug：从-master-新建-hotfix-分支-gt-合并-master-和-dev-gt-发布新版"><a href="#修复线上-bug：从-master-新建-hotfix-分支-gt-合并-master-和-dev-gt-发布新版" class="headerlink" title="修复线上 bug：从 master 新建 hotfix 分支 -&gt; 合并 master 和 dev -&gt; 发布新版"></a>修复线上 bug：从 master 新建 hotfix 分支 -&gt; 合并 master 和 dev -&gt; 发布新版</h5><p><code>git flow hotfix start [version]</code></p><p><code>mversion p</code> &#x2F;&#x2F; 更新版本号</p><p><code>some commit…</code></p><p><code>git flow hotfix publish [version]</code></p><p><code>git flow hotfix finish [version]</code></p><p><code>git push --all &amp;&amp; git push --tag</code></p><h3 id="Git-Flow-的常用分支"><a href="#Git-Flow-的常用分支" class="headerlink" title="Git Flow 的常用分支"></a>Git Flow 的常用分支</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><ul><li>主分支 , 产品的功能全部实现后 , 最终在 master 分支对外发布</li><li>该分支为只读唯一分支 , 只能从其他分支(release&#x2F;hotfix)合并 , 不能在此分支修改</li><li>另外所有在 master 分支的推送应该打标签做记录,方便追溯</li><li>例如 release 合并到 master , 或 hotfix 合并到 master</li></ul><h4 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h4><ul><li>主开发分支 , 基于 master 分支克隆</li><li>包含所有要发布到下一个 release 的代码</li><li>该分支为只读唯一分支 , 只能从其他分支合并</li><li>feature 功能分支完成 , 合并到 develop(不推送)</li><li>develop 拉取 release 分支 , 提测</li><li>release&#x2F;hotfix 分支上线完毕 , 合并到 develop 并推送</li></ul><h4 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h4><ul><li>功能开发分支 , 基于 develop 分支克隆 , 主要用于新需求新功能的开发</li><li>功能开发完毕后合到 develop 分支(未正式上线之前不推送到远程中央仓库!!!)</li><li>feature 分支可同时存在多个 , 用于团队中多个功能同时开发 , 属于临时分支 , 功能完成后可选删除</li></ul><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><ul><li>测试分支 , 基于 feature 分支合并到 develop 之后 , 从 develop 分支克隆</li><li>主要用于提交给测试人员进行功能测试 , 测试过程中发现的 BUG 在本分支进行修复 , 修复完成上线后合并到 develop&#x2F;master 分支并推送(完成功能) , 打 Tag</li><li>属于临时分支 , 功能上线后可选删除</li></ul><h4 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a>hotfix</h4><ul><li>补丁分支 , 基于 master 分支克隆 , 主要用于对线上的版本进行 BUG 修复</li><li>修复完毕后合并到 develop&#x2F;master 分支并推送 , 打 Tag</li><li>属于临时分支 , 补丁修复上线后可选删除</li><li>所有 hotfix 分支的修改会进入到下一个 release</li></ul><h3 id="Git-flow-分支流程图"><a href="#Git-flow-分支流程图" class="headerlink" title="Git flow 分支流程图"></a>Git flow 分支流程图</h3><p><img src="/img/2022/git-flow/20210720145803822.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;版本&amp;#x2F;分支管理规范，主要包括 commit 规范，版本号管理规范，mversion 的使用方法，commitizen 的使用方法，git 常用命令收集，gitflow 使用说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;有模板的</summary>
      
    
    
    
    <category term="教程分享" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    
    <category term="Git" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/Git/"/>
    
    
    <category term="Git" scheme="https://www.buerya.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>在没有父母的老屋，我只是一个过客</title>
    <link href="https://www.buerya.cn/2022/a-passer-by/a-passer-by/"/>
    <id>https://www.buerya.cn/2022/a-passer-by/a-passer-by/</id>
    <published>2022-04-28T07:59:54.000Z</published>
    <updated>2022-10-19T14:40:00.238Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我想给大家分享一篇，让我感受特别深情的散文：</p><blockquote><p>在没有父母的老屋，我只是一个过客</p><p>作者 孙道荣</p></blockquote><p style="text-indent:2em">老家亲戚的孩子结婚，邀请我回去喝喜酒，我欣然应允。</p><p style="text-indent:2em">到了故乡，从车站走出来，我却是有点儿恍惚了。喜宴是明天，我不知道是直奔亲属家好，还是该首先找个酒店住下，明天再赶过去。</p><p style="text-indent:2em">这是母亲去世之后我第一次返乡。父亲早年就已经过世了，三年前，母亲也走了。</p><p style="text-indent:2em">办完母亲的丧事，我在县城的妹妹家小住了几日。离别的时候，妹妹对我说：“哥，你以后回来就上我家来住吧。”当时我点了一点头。但是等我再次回来，站在熟悉却又陌生的车站门口之后，我忽然发现，不知道该往哪去了。</p><p><img src="/img/2022/a-passer-by/nviueafoeu.webp"></p><p style="text-indent:2em">以前当然不是这样的。</p><p style="text-indent:2em">父母在的时候，每次回来，不管多晚，我都不担心。我会搭个车，直奔县城二十里外的家，那个我从小长大的乡村。</p><p style="text-indent:2em">有些时候，我会提前告诉父母我要回来；有些时候，也会突然就出现在了家门口，让父母又惊又喜，嗔怪我搞突然袭击。有些时候并不着急回家，而是先到县城的妹妹家落个脚，然后，再和妹妹全家一大帮子人浩浩荡荡地回乡。</p><p style="text-indent:2em">一到村口，就能够看到手搭额头眺望的老母亲，露水已经打湿了她的衣脚，天知道她从几点就已经站在了村口，一定是妹妹提前告诉了老母亲。</p><p style="text-indent:2em">每次这样兴师动众地回来，这陈旧的老宅忽然被人声塞满，兴奋地吱吱作响。这老宅在我们回来的那一刻，再一次呈现出欢乐、饱满的样子。这才是我熟悉的老宅的味道，家的味道。</p><p><img src="/img/2022/a-passer-by/light.webp"></p><p style="text-indent:2em">这一次，我恍然不知所措。我自然还是可以像以前那样，先到妹妹家去。</p><p style="text-indent:2em">我和妹妹很亲，妹妹的女儿也和我这个舅舅很亲，但那终归是妹妹的家。以前落个脚甚至小住几日都没有关系，因为我有自己家的父母在家里等着我，我随时可以回家。现在去妹妹家，只能是住那儿了，而不是中转一下，我真正地成为了一个借居的客人。想到这儿，我突然提不起兴致去妹妹家，还是先回老屋看一看吧。我在心里，用了老屋这个词，而不是家。这父母不在呀，那里也不就是家了。</p><p style="text-indent:2em">我和妹妹很亲，妹妹的女儿也和我这个舅舅很亲，但那终归是妹妹的家。以前落个脚甚至小住几日都没有关系，因为我有自己家的父母在家里等着我，我随时可以回家。现在去妹妹家，只能是住那儿了，而不是中转一下，我真正地成为了一个借居的客人。想到这儿，我突然提不起兴致去妹妹家，还是先回老屋看一看吧。我在心里，用了老屋这个词，而不是家。这父母不在呀，那里也不就是家了。</p><p style="text-indent:2em">我绕着老屋转了几圈，残破的老屋，和我心中那个家，一起坍塌了一地。</p><p><img src="/img/2022/a-passer-by/ldkgao8e.webp"></p><p style="text-indent:2em">在村口我遇到了一个邻居。和邻居说了一会儿话，话说了一半儿就变成了邀请：“要不，上我家坐一坐吧。”我谢了乡邻，那一刻我意识到，对于这个从小长大的村庄来说，我已经是客了。</p><p><img src="/img/2022/a-passer-by/dsai3r8294ulke.webp"></p><p style="text-indent:2em">乘车回了城入住一家酒店。犹豫了一下，还是给妹妹打了电话，告诉她，我在县城，住在某某宾馆。妹妹嗔怪地说：“哎呀！住什么酒店呐，咋不来家里住呢？”我只能讪笑无语。妹妹又说，“那你过来吃晚饭吧。”我答应了。</p><p style="text-indent:2em">在妹妹家的楼下，遇见了买菜回来的妹妹。邻居看见了她说：“家里来客人啦？”这妹妹立刻说：“什么客人呐，这是我哥！”妹妹的话让我很感动，可是，我知道，那个邻居说的没错，在妹妹家，我是客；在故乡，我也是客。</p><p style="text-indent:2em">那一天晚上我喝了不少。回到酒店，迷迷糊糊地接到儿子的一个电话，儿子问：“爸你明天在家吗？我们明天要回家。”我告诉儿子：“我回老家了，你妈在家呢。” </p><p style="text-indent:2em">放下电话，我泪流满面。在家乡，我已是客人。但是，只要有我在，妻子在，这远方的家就还是儿子的家。</p><p style="text-indent:2em">年少不觉家乡好，年老方知乡愁长。家有父母亲常在，思乡念亲至白头。</p>]]></content>
    
    
    <summary type="html">我绕着老屋转了几圈，残破的老屋，和我心中那个家，一起坍塌了一地。</summary>
    
    
    
    <category term="日记心事" scheme="https://www.buerya.cn/categories/%E6%97%A5%E8%AE%B0%E5%BF%83%E4%BA%8B/"/>
    
    
    <category term="日记心事" scheme="https://www.buerya.cn/tags/%E6%97%A5%E8%AE%B0%E5%BF%83%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Mac】 奇怪的软件+1，用来快速查看上班进度条的「钱条」</title>
    <link href="https://www.buerya.cn/2022/moyu-qiantiao/qiantiao/"/>
    <id>https://www.buerya.cn/2022/moyu-qiantiao/qiantiao/</id>
    <published>2022-04-01T07:16:19.000Z</published>
    <updated>2022-10-19T14:40:00.260Z</updated>
    
    <content type="html"><![CDATA[<p>一个上班的进度条，开始搬砖吧。</p><p>一个可以在macOS顶部显示当日搬砖金额，点击可以显示老板当日欠你多少钱。</p><p>安装后需要简单设置下平均每日工资然后就可以显示进度和金额，然后任务栏会显示图标以及动态的计数器。</p><p>当前版本还不支持直接修改文案内容，该软件为开源软件，有能力大佬们可以自己<a href="https://github.com/Lakr233/MoneyProgress">下载源代码</a>按需进行定制。</p><p>从<code>Mac App Store</code>商店下载安装钱条：<a href="https://apps.apple.com/app/%E9%92%B1%E6%9D%A1-%E4%B8%8A%E7%8F%AD%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1/id1614349717">钱条 - 上班的进度条 </a></p><blockquote><p>钱条效果图：</p></blockquote><p><img src="/img/2022/moyu-qiantiao/MenuBarPreview.png"></p><blockquote><p>钱条设置图：</p></blockquote><p><img src="/img/2022/moyu-qiantiao/ClientPreview.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个上班的进度条，开始搬砖吧。&lt;/p&gt;
&lt;p&gt;一个可以在macOS顶部显示当日搬砖金额，点击可以显示老板当日欠你多少钱。&lt;/p&gt;
&lt;p&gt;安装后需要简单设置下平均每日工资然后就可以显示进度和金额，然后任务栏会显示图标以及动态的计数器。&lt;/p&gt;
&lt;p&gt;当前版本还不支持直接修改文</summary>
      
    
    
    
    <category term="教程分享" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="摸鱼" scheme="https://www.buerya.cn/tags/%E6%91%B8%E9%B1%BC/"/>
    
    <category term="Mac" scheme="https://www.buerya.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Vue 项目中生成类似 GitHub 的随机头像</title>
    <link href="https://www.buerya.cn/2022/random-avatar-md5/random-avatar-md5/"/>
    <id>https://www.buerya.cn/2022/random-avatar-md5/random-avatar-md5/</id>
    <published>2022-04-01T05:53:07.000Z</published>
    <updated>2022-10-19T14:40:00.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近个人项目中有头像需求，就想起<code>GitHub</code>的随机头像，通过<code>identicon.js</code>和<code>blueimp-md5</code>两个第三方库实现了，记录一下。</p></blockquote><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="/img/2022/random-avatar-md5/1.png"></p><h3 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img class=&quot;avatar&quot; :src=&quot;url&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Identicon from &#x27;identicon.js&#x27;</span><br><span class="line">  import md5 from &#x27;blueimp-md5&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      num: [Number]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      url() &#123;</span><br><span class="line">        return &#x27;data:image/png;base64,&#x27; + new Identicon(md5(this.num || 0), 420).toString()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">  .avatar &#123;</span><br><span class="line">    width: 40px;</span><br><span class="line">    height: 40px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>第15行的<code>new Identicon(...)</code>必须使用new初始化，具体原因还不清楚，如果有人清楚欢迎在下方评论。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/stewartlord/identicon.js">identicon.js</a></li><li><a href="https://github.com/blueimp/JavaScript-MD5">JavaScript-MD5</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近个人项目中有头像需求，就想起&lt;code&gt;GitHub&lt;/code&gt;的随机头像，通过&lt;code&gt;identicon.js&lt;/code&gt;和&lt;code&gt;blueimp-md5&lt;/code&gt;两个第三方库实现了，记录一下。&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    <category term="教程分享" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    
    <category term="Vue" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/Vue/"/>
    
    
    <category term="教程分享" scheme="https://www.buerya.cn/tags/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>exceljs 导出表格</title>
    <link href="https://www.buerya.cn/2022/exceljs/index/"/>
    <id>https://www.buerya.cn/2022/exceljs/index/</id>
    <published>2022-03-16T16:00:00.000Z</published>
    <updated>2022-10-19T14:40:00.248Z</updated>
    
    <content type="html"><![CDATA[<p>工作中我们可能会遇到制作表格的需求，那么针对nodejs如何制作一个汇总表格呢？今天我们就在此介绍下<a href="https://github.com/guyonroche/exceljs">exceljs</a>的基本使用，应该可以满足我们大部分的需求。</p><h3 id="第一部分-下载"><a href="#第一部分-下载" class="headerlink" title="第一部分 下载"></a>第一部分 下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install exceljs</span><br></pre></td></tr></table></figure><h3 id="第二部分-基本的配置"><a href="#第二部分-基本的配置" class="headerlink" title="第二部分 基本的配置"></a>第二部分 基本的配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Excel</span> = <span class="built_in">require</span>(<span class="string">&quot;exceljs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workbook = <span class="keyword">new</span> <span class="title class_">Excel</span>.<span class="title class_">Workbook</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本的创建信息</span></span><br><span class="line">workbook.<span class="property">creator</span> = <span class="string">&quot;Me&quot;</span>;</span><br><span class="line">workbook.<span class="property">lastModifiedBy</span> = <span class="string">&quot;Her&quot;</span>;</span><br><span class="line">workbook.<span class="property">created</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1985</span>, <span class="number">8</span>, <span class="number">30</span>);</span><br><span class="line">workbook.<span class="property">modified</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">workbook.<span class="property">lastPrinted</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图大小， 打开Excel时，整个框的位置，大小</span></span><br><span class="line">workbook.<span class="property">views</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">firstSheet</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">activeTab</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">visibility</span>: <span class="string">&quot;visible&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签创建</span></span><br><span class="line"><span class="keyword">var</span> worksheet = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第一个标签&quot;</span>);</span><br><span class="line">  <span class="comment">// 带颜色的</span></span><br><span class="line"><span class="keyword">var</span> worksheet2 = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第二个标签&quot;</span>, &#123; <span class="attr">properties</span>: &#123; <span class="attr">tabColor</span>: &#123; <span class="attr">argb</span>: <span class="string">&quot;FFC0000&quot;</span> &#125; &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历标签</span></span><br><span class="line">workbook.<span class="title function_">eachSheet</span>(<span class="function">(<span class="params">worksheet, sheetId</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;标签ID：&quot;</span>, sheetId)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(worksheet);</span></span><br><span class="line"><span class="comment">// 删除一个标签</span></span><br><span class="line">workbook.<span class="title function_">removeWorksheet</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstSheet = workbook.<span class="title function_">getWorksheet</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;标签信息-id&quot;</span>, firstSheet.<span class="property">id</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取总的：行/实际行 /列/实际列 个数： &quot;</span>, firstSheet.<span class="property">rowCount</span>, firstSheet.<span class="property">actualColumnCount</span>, firstSheet.<span class="property">columnCount</span>, firstSheet.<span class="property">actualColumnCount</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加那个筛选箭头</span></span><br><span class="line">worksheet.<span class="property">autoFilter</span> = <span class="string">&#x27;A1:C1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">worksheet.<span class="title function_">getRow</span>(<span class="number">5</span>).<span class="property">font</span> = &#123; <span class="attr">size</span>: <span class="number">14</span>, <span class="attr">bold</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&quot;A2&quot;</span>).<span class="property">value</span> = <span class="string">&quot;Site&quot;</span>;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&quot;A2&quot;</span>).<span class="property">font</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Arial Black&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: &#123; <span class="attr">argb</span>: <span class="string">&quot;FF00FF00&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">family</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">italic</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">bold</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save workbook to disk</span></span><br><span class="line">workbook.<span class="property">xlsx</span>.<span class="title function_">writeFile</span>(<span class="string">&quot;first.xlsx&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;saved&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="第三部分-行列的操作"><a href="#第三部分-行列的操作" class="headerlink" title="第三部分 行列的操作"></a>第三部分 行列的操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Excel</span> = <span class="built_in">require</span>(<span class="string">&quot;exceljs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workbook = <span class="keyword">new</span> <span class="title class_">Excel</span>.<span class="title class_">Workbook</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签创建</span></span><br><span class="line"><span class="keyword">var</span> worksheet = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第一个标签&quot;</span>);</span><br><span class="line"><span class="comment">// 带颜色的</span></span><br><span class="line"><span class="keyword">var</span> worksheet2 = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第二个标签&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">        <span class="attr">tabColor</span>: &#123;</span><br><span class="line">            <span class="attr">argb</span>: <span class="string">&quot;FFC0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置列</span></span><br><span class="line">worksheet.<span class="property">columns</span> = [&#123;</span><br><span class="line">        <span class="attr">header</span>: <span class="string">&#x27;Rating Period&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">38</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">header</span>: <span class="string">&#x27;Name&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">32</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">header</span>: <span class="string">&#x27;D.O.B.&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;DOB&#x27;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">numFmt</span>: <span class="string">&#x27;dd/mm/yyyy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 根据ID添加值</span></span><br><span class="line">worksheet.<span class="title function_">addRow</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">dob</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;);</span><br><span class="line">worksheet.<span class="title function_">addRow</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">dob</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1965</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="number">1</span>).<span class="property">value</span> = <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A6&#x27;</span>).<span class="property">value</span> = <span class="string">&quot;1989&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并单元格</span></span><br><span class="line">worksheet.<span class="title function_">mergeCells</span>(<span class="string">&#x27;A4:A7&#x27;</span>);</span><br><span class="line"><span class="comment">// 合并四个格子</span></span><br><span class="line">worksheet.<span class="title function_">mergeCells</span>(<span class="string">&#x27;A10&#x27;</span>, <span class="string">&#x27;B11&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 格式化显示，</span></span><br><span class="line"><span class="comment">// 数字 1.6 显示 &#x27;1 3/5&#x27;</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">value</span> = <span class="number">1.6</span>;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">numFmt</span> = <span class="string">&#x27;# ?/?&#x27;</span>;</span><br><span class="line"><span class="comment">// 显示 1.60%</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;B1&#x27;</span>).<span class="property">value</span> = <span class="number">0.016</span>;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;B1&#x27;</span>).<span class="property">numFmt</span> = <span class="string">&#x27;0.00%&#x27;</span>;</span><br><span class="line"><span class="comment">// ===== 字体显示</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A3&#x27;</span>).<span class="property">font</span> = &#123;</span><br><span class="line">    <span class="comment">// 字体名</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Comic Sans MS&#x27;</span>,</span><br><span class="line">    <span class="comment">// Font family for fallback. An integer value.</span></span><br><span class="line">    <span class="attr">family</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="attr">size</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="comment">// 下划线</span></span><br><span class="line">    <span class="attr">underline</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 加粗</span></span><br><span class="line">    <span class="attr">bold</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A3&#x27;</span>).<span class="property">value</span> = <span class="string">&quot;测试字体&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 对齐方式</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">alignment</span> = &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">    <span class="attr">horizontal</span>: <span class="string">&#x27;left&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;B1&#x27;</span>).<span class="property">alignment</span> = &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="string">&#x27;middle&#x27;</span>,</span><br><span class="line">    <span class="attr">horizontal</span>: <span class="string">&#x27;center&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;C1&#x27;</span>).<span class="property">alignment</span> = &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="string">&#x27;bottom&#x27;</span>,</span><br><span class="line">    <span class="attr">horizontal</span>: <span class="string">&#x27;right&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 边框</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">border</span> = &#123;</span><br><span class="line">    <span class="attr">top</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;double&#x27;</span>,</span><br><span class="line">        <span class="attr">color</span>: &#123;</span><br><span class="line">            <span class="attr">argb</span>: <span class="string">&#x27;FF00FF00&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">left</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;double&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">bottom</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;thin&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;thin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 填充颜色</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">fill</span> = &#123;</span><br><span class="line">    <span class="comment">// 模式</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;pattern&#x27;</span>,</span><br><span class="line">    <span class="comment">// 填充</span></span><br><span class="line">    <span class="attr">pattern</span>: <span class="string">&#x27;solid&#x27;</span>,</span><br><span class="line">    <span class="comment">// fgColor: &#123;</span></span><br><span class="line">    <span class="comment">//     argb: &#x27;FFFF0000&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// 背景色</span></span><br><span class="line">    <span class="attr">bgColor</span>: &#123;</span><br><span class="line">        <span class="attr">argb</span>: <span class="string">&#x27;FF0000FF&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 图片相关操作直接看GitHub就好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建一个Excel表</span></span><br><span class="line">workbook.<span class="property">xlsx</span>.<span class="title function_">writeFile</span>(<span class="string">&quot;second.xlsx&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;saved&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工作中我们可能会遇到制作表格的需求，那么针对nodejs如何制作一个汇总表格呢？今天我们就在此介绍下&lt;a href=&quot;https://github.com/guyonroche/exceljs&quot;&gt;exceljs&lt;/a&gt;的基本使用，应该可以满足我们大部分的需求。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="教程分享" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="vue" scheme="https://www.buerya.cn/tags/vue/"/>
    
    <category term="javascript" scheme="https://www.buerya.cn/tags/javascript/"/>
    
    <category term="nodejs" scheme="https://www.buerya.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>公开真题库：公务员、事业单位、教资、软考等考试题库</title>
    <link href="https://www.buerya.cn/2022/gkzjk/index/"/>
    <id>https://www.buerya.cn/2022/gkzjk/index/</id>
    <published>2022-03-15T16:00:00.000Z</published>
    <updated>2022-10-19T14:40:00.254Z</updated>
    
    <content type="html"><![CDATA[<p>公开真题库提供公务员考试、事业单位考试、教师资格考试、软考等真题整套在线打印和下载服务，包含行测、申论、面试、综合基础知识、职能测试、软考等。</p><p>真题包含答案和解析，需要的可以看看，或者发给身边需要的朋友。</p><p><img src="/img/2022/gkztk/20220316151009.png"></p><p>访问地址：<a href="https://www.gkzenti.cn/">https://www.gkzenti.cn/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;公开真题库提供公务员考试、事业单位考试、教师资格考试、软考等真题整套在线打印和下载服务，包含行测、申论、面试、综合基础知识、职能测试、软考等。&lt;/p&gt;
&lt;p&gt;真题包含答案和解析，需要的可以看看，或者发给身边需要的朋友。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2022/</summary>
      
    
    
    
    <category term="教程分享" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    
    <category term="文献资料" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/%E6%96%87%E7%8C%AE%E8%B5%84%E6%96%99/"/>
    
    
    <category term="文献资料" scheme="https://www.buerya.cn/tags/%E6%96%87%E7%8C%AE%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>文献整理中国古代气功文化资料大全</title>
    <link href="https://www.buerya.cn/2022/gudaiqigongwenhua/index/"/>
    <id>https://www.buerya.cn/2022/gudaiqigongwenhua/index/</id>
    <published>2022-03-14T16:00:00.000Z</published>
    <updated>2022-10-19T14:40:00.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>中国古代气功历史悠久，流派多，内容丰富。自先秦到清代，有气功文献数千种。以下对一些主要的气功古籍，按年代进行整理，并对主要内容进行介绍，希望能对气功爱好者有所帮助。</p></blockquote><h3 id="先秦"><a href="#先秦" class="headerlink" title="先秦"></a>先秦</h3><h4 id="周易"><a href="#周易" class="headerlink" title="周易"></a>周易</h4><p>简称《易》，分经与传两部分。传说由伏羲、周文王、孔子演络共同完成此书。它原是占筮之书，但它的丰富哲学内涵使它成为儒家群书之首。书中认为阴阳二气相互作用，是产生万物的根本，与气功内炼要求达到“阴平阳秘，精神乃治”的目的相通。书中阐述了气功意念入静的道理。后世气功家尤其是内丹家，十分重视该书。东汉魏伯阳等人依据《周易》原理，结合黄帝、老子的学说，以及炼丹的经验，著成“万古丹经王”——《周易参同契》以及北宋张伯瑞著的《悟真篇》均用卦象来说明内炼过程。后世内丹养炼的书，在理论上很少有离开易象来描述的。可以说《周易》的哲学思想是炼养内丹的原头。</p><h4 id="老子"><a href="#老子" class="headerlink" title="老子"></a>老子</h4><p>道家经典著作。分为八十一章。又名《道德经》、《老子五千文》。为周李耳著。书中提出以“道”为核心的哲学体系，主张清静无为、贵柔、守雌、返朴归真、顺其自然，含有朴素的辩证法思想。以养生的道理解释治国，以治国的道理指导养生，融汇了古代气功学说的精华，被后人尊为气功经典。北宋张伯瑞在《悟真篇》中说：“《阴符》宝字愈三百，《道德》灵文止五千。今古上仙无限数，尽从此处达真诠。”《老子》说：“谷神不死，是谓玄牝，玄牝之门，是谓天地根，绵绵若存，用之不勤”、“载形魄抱一，能无离乎”等。这些论述已成为气功实践的指导思想。尽管后世功法千变万化，但基本要点乃与《老子》相同。</p><h4 id="庄子"><a href="#庄子" class="headerlink" title="庄子"></a>庄子</h4><p>道家经典著作。为周庄周撰。又称《南华真经》，全书三十三篇，多以寓言阐述哲理，其中也有不少关于气功的论述。如“踵息”、“心斋”、“坐忘”、“缘督以为经”、“吹喣呼吸，吐故纳新”等等，对后世影响较大。</p><h4 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h4><p>道家经典著作。为周列御寇撰。又称《冲虚至德真经》，全书八篇。以“至虚”、“终天”的思想家为本，其宗旨与《老子》、《庄子》相同。书中很多阐述与气功养生有关，为后世气功重视。</p><h4 id="管子"><a href="#管子" class="headerlink" title="管子"></a>管子</h4><p>为周管仲撰。实系稷下学派论著的大汇编，全书七十六篇，内容庞杂，其中《心术》、《内业》等篇与气功有关。书中的精气学说，对气功养生有一定影响。</p><h4 id="黄帝内经"><a href="#黄帝内经" class="headerlink" title="黄帝内经"></a>黄帝内经</h4><p>中医经典著作。为黄帝撰。全书分《灵枢》与《素问》两大部分，各八十一篇。以问答形式阐述中国医学的基本理论。其学术思想，基本上是朴素的唯物论和辩证法思想。对于生命运动以及人与自然的关系、疾病的成因等都有精辟的论述，其摄生学说与气功养生的关系更为密切。《素问》中的《上古天真论》，《四气调神大论》以及《灵枢》中的《本神》等篇，提倡“恬淡虚无，真气从之，精神内守，病安从来”，任为“提挈天地，把握阴阳，呼吸精气，独立守神，肌肉若一，故能寿敝天地，无有终时”。为中国医学和气功理论的发展奠定了基础。</p><h4 id="阴符经"><a href="#阴符经" class="headerlink" title="阴符经"></a>阴符经</h4><p>道教经典著作。传为黄帝撰。全称为《黄帝阴符经》一篇。该书自唐代李筌公开传播以来，就受到道教学者的重视，各以心得注解，今存四十余种注本。书中某些论述对气功养生有指导意义。</p><h4 id="行气玉佩铭"><a href="#行气玉佩铭" class="headerlink" title="行气玉佩铭"></a>行气玉佩铭</h4><p>气功养生名篇。为战国传世实物上的铭文，共四十四字。全文描述了炼气功时，内气运行的全过程，相当系统完整。</p><h3 id="汉"><a href="#汉" class="headerlink" title="汉"></a>汉</h3><h4 id="养生方"><a href="#养生方" class="headerlink" title="养生方"></a>养生方</h4><p>气功养生著作。湖南长沙马王堆西汉古墓出土。全书分四篇，即《十问》、《合阴阳方》、《杂禁方》《天下至道谈》。内容以养生、服食、吐纳、房中为主，而尤以“房中”为详细，是研究气功养生的可贵资料。</p><h4 id="却谷食气篇"><a href="#却谷食气篇" class="headerlink" title="却谷食气篇"></a>却谷食气篇</h4><p>气功服气辟谷名篇。马王堆西汉古幕出土。全篇四百字。专门研究解绍服气辟谷，方法具体，并任为加服药饵，有相辅相成作用。</p><h4 id="淮南子"><a href="#淮南子" class="headerlink" title="淮南子"></a>淮南子</h4><p>西汉道家思想代表作。为西汉刘安等人撰。又名《淮南鸿烈》，二十一篇。此书是对西汉前期道家思想的总结。在养生方面，发展了道家清静无为的学说，可供气功研究之用。</p><h4 id="周易参同契"><a href="#周易参同契" class="headerlink" title="周易参同契"></a>周易参同契</h4><p>炼丹经典著作。东汉魏伯阳等撰。全书三篇，附《鼎器歌》一首。该书汇通“易”学理论、“黄”、“老”学说与炼丹经验，建立了一个完整的炼丹体系。后世炼丹者无一能出其范围，故称“万古丹经王”，是公认的气功内丹术的经典著作。书中论述了炼丹的三大要素：鼎炉、药物、火侯。以乾卦与坤卦代表鼎炉，以坎卦与离卦代表药物，以屯卦与蒙卦等六十卦代表火侯，药物则杂用黑白、金水、龙虎、魂魄等隐名，火侯又参用纳甲之法，真谓“词韵皆古，奥雅难通”。该书有四十多个注本，流传较广的有五代彭晓的《周易参同契分章通真义》、宋朱熹的《周易参同契考异》、元陈至虚的《周易参同契分章注》、清董德宁的《周易参同契正义》等。其中以董氏注文平实易懂，是入门者的良好读本。</p><h4 id="太平经"><a href="#太平经" class="headerlink" title="太平经"></a>太平经</h4><p>道教早期经典著作。原书一百七十卷，今存五十七卷。东汉于吉等著。该书阐述了精、气、神三者合一的长生不死的神仙思想，以及天、地、人三者合一的治国方法。此经内容庞杂，无所不包，对后世气功的发展有一定影响。</p><h4 id="大安般守意经"><a href="#大安般守意经" class="headerlink" title="大安般守意经"></a>大安般守意经</h4><p>禅观经典著作。两卷。东汉安世高译。为最早传入中国的佛教修习禅观典籍之一。主要内容为论述数息、相随、止、观还、净等六事，以及与三十七道品之关系。书中十分重视数息法，提出了“四相”之说，对后世有深远影响。</p><h3 id="晋"><a href="#晋" class="headerlink" title="晋"></a>晋</h3><h4 id="黄庭经"><a href="#黄庭经" class="headerlink" title="黄庭经"></a>黄庭经</h4><p>道教气功经典著作。书分三种：《黄庭内景经》、《黄庭外景经》、《黄庭中景经》，各一卷。《内景经》成书于西晋太康年间，《外景经》成书于东晋年间，《中景经》约成书于南北朝间，是在“内”、“外”两经的基础上综合加工而成。《黄庭经》提出的“三黄庭”、“三丹田”之说，渊源于《太平经》的“三元合一”论。黄庭即上丹田，于身指脑，为百神之主宰；中黄庭即中丹田，于身指心，为脏腑之根本；下黄庭即下丹田，于身指脐下关元穴，为阴阳之门户、精气之命脉。只要如法存想黄庭，养炼丹田，就能固精全气，长生久世。具体做法三经各有不同。</p><h4 id="抱朴子内篇"><a href="#抱朴子内篇" class="headerlink" title="抱朴子内篇"></a>抱朴子内篇</h4><p>道教仙学经典著作。二十卷。东晋葛洪撰。次书包括道教理论、神仙方药、鬼怪变化、养生延年等内容，为道教仙学集成之作。书中阐述了长生不老学说，提供了先秦以来各类内炼养生方法。其中有关气功的内容，集中地反映在《对俗》、《至理》、《释滞》、《杂应》、《地真》等篇章中。明代的刊本《抱朴子内篇》，末附《别旨》一卷，专述吐故导引，为气功专篇，极有参考价值。</p><h4 id="灵剑子"><a href="#灵剑子" class="headerlink" title="灵剑子"></a>灵剑子</h4><p>气功导引著作。一卷。东晋许逊撰。书中以四季配五脏，设计了一十六个姿式，主合成一套完整的动功功法。每个姿式详述具体炼法及功效，简单易行。许氏另撰《灵剑子引导子午记卷》，为站式功法，共有八个姿式，又称八段锦。</p><h4 id="达摩多罗禅经"><a href="#达摩多罗禅经" class="headerlink" title="达摩多罗禅经"></a>达摩多罗禅经</h4><p>禅观经典著作。二卷。东晋佛陀跋陀罗译。全书共一十七章，阐述禅观的修炼。书中“方便道”主要指数息观和不净观，“胜道”主要指心识、行持上的变化，“退、进、住”分别是指习禅上的退步、进步、定止。这些内容可作研究气功的参考。</p><h3 id="南北朝"><a href="#南北朝" class="headerlink" title="南北朝"></a>南北朝</h3><h4 id="上清握中诀"><a href="#上清握中诀" class="headerlink" title="上清握中诀"></a>上清握中诀</h4><p>道教养炼著作。三卷。梁陶弘景撰。汇道教上清派的炼养法诀，举凡存私、内视、守一、吐纳、导引等法均有记载，是研究道教气功的重要参考资料。</p><h4 id="养性延命录"><a href="#养性延命录" class="headerlink" title="养性延命录"></a>养性延命录</h4><p>道教气功养生代表作。两卷。梁陶弘景撰。全书分六篇：教戒、食戒、杂戒忌禳害祈善、服气疗病、导引按摩、御女损益。食戒篇介绍饮食宜忌，杂戒篇介绍起居言行宜忌，服气篇介绍吐纳咽津，导引篇介绍动功锻炼，御女篇介绍房中卫生。书中介绍的五禽戏为最早的文献记载。</p><h4 id="正一法文修真旨要"><a href="#正一法文修真旨要" class="headerlink" title="正一法文修真旨要"></a>正一法文修真旨要</h4><p>道教炼养著作。一卷。南北朝时著作。作者轶名。书中载有存思、服气、导引等多种功法，并主张辩证施功，以治疾病。书中对诊断、病理也有叙述，对后世的医疗气功颇有启发。</p><h4 id="太上老君养生诀"><a href="#太上老君养生诀" class="headerlink" title="太上老君养生诀"></a>太上老君养生诀</h4><p>气功养生著作。一卷。南北朝时著作。托名华佗传授吴晋作。主要内容为五禽戏的具体炼法，六字气诀结合脏腑的论述及其详细的炼法，统论养生的重要性和日常养生的要点。此书是珍贵的气功文献资料。</p><h4 id="易筋经"><a href="#易筋经" class="headerlink" title="易筋经"></a>易筋经</h4><p>武术气功代表作。一卷。北魏菩提达摩撰。全书为一套完整的动功功法，由十余种姿势组成。此功能强筋壮骨，增加体力。相传为达摩授与少林寺僧的秘法。其续篇是《洗髓经》。一卷。由五言古风组成，结合禅学静功和叩齿、咽津等保健功法，成为一套独特的动功功法。</p><h4 id="胎息经"><a href="#胎息经" class="headerlink" title="胎息经"></a>胎息经</h4><p>气功胎息经典著作。一卷。南北朝时佚名作。全文只有八十三字，论述胎息的定义、方法与作用，极为简单扼要。现存最早注本为唐朝幻真先生的《胎息经疏》，流行颇广。</p><h4 id="古文龙虎经"><a href="#古文龙虎经" class="headerlink" title="古文龙虎经"></a>古文龙虎经</h4><p>气功炼丹术著作。又名《金碧潜通诀》。三卷。南北朝刘演撰。其理论渊源于《周易参同契》，对内外丹修炼均有指导作用。</p><h4 id="禅秘要法经"><a href="#禅秘要法经" class="headerlink" title="禅秘要法经"></a>禅秘要法经</h4><p>禅观经典著作。三卷。姚秦鸠摩罗什译。共列三十三种观想法。</p><h4 id="五门禅经要法"><a href="#五门禅经要法" class="headerlink" title="五门禅经要法"></a>五门禅经要法</h4><p>禅观代表作。二卷。南北朝昙摩密多译。分述安般、不净、慈心、观缘、念佛等五门禅法。尤以观缘法论述为祥细。</p><h3 id="隋"><a href="#隋" class="headerlink" title="隋"></a>隋</h3><h4 id="诸病源候论"><a href="#诸病源候论" class="headerlink" title="诸病源候论"></a>诸病源候论</h4><p>中医症候学专著。又名《诸病源候总论》。五十卷。隋巢元方等撰。本书为我国现存第一部详细论述病因、症候的专著，对后世影响很大。书中不载治疗方药，只载气功导引方法。全书载一百五十三种疾病，采用气功导引方法二百九十余条。此后唐代王焘编撰《外台秘要》，转录了气功导引的全部内容。清末廖平则摘出汇编，后由民国曹炳章补辑，定名为《巢氏病源补养宣导法》，刊入《中国医学大成》中。</p><h4 id="内观经"><a href="#内观经" class="headerlink" title="内观经"></a>内观经</h4><p>气功存思内炼著作。又名《太上老君内观经》。一卷。隋唐间著作，不著撰人。此经强调内观澄心、恬淡虚无、精神内守，对养生长寿的积极作用。</p><h4 id="定观经"><a href="#定观经" class="headerlink" title="定观经"></a>定观经</h4><p>气功存思内炼著作。又称《洞玄灵宝定观经》。一卷。隋唐间著作，不著撰人。此经汇通道家“内观”、佛家“定慧”、儒家“中和”思想，阐述内观法修炼步骤及功后效验。</p><h4 id="太清调气经"><a href="#太清调气经" class="headerlink" title="太清调气经"></a>太清调气经</h4><p>气功服气著作。一卷。隋唐间著作，不著撰人。主要内容为讲述服气的基本要领与法则，并介绍了调气、固气、闭气、委气等具体炼功方法。</p><h4 id="太清导引养生经"><a href="#太清导引养生经" class="headerlink" title="太清导引养生经"></a>太清导引养生经</h4><p>气功导引经典著作。一卷。隋唐间著作，不著撰人。此经系搜集并精选多种气功导引文献编辑而成，内容丰富，可供取资。如赤松子导引法、宁先生导引法，蛤蟆行气法等。此外，对导引的要领、补泻原则、辩证施功等内容，有较详细的解绍。</p><h4 id="摩诃止观"><a href="#摩诃止观" class="headerlink" title="摩诃止观"></a>摩诃止观</h4><p>天台宗止观经典著作。十卷。隋智顗撰。共十章，原缺末章。其中第六章为止观的具体内容，第七章为天台一家的圆顿观行方法。本书的注释，以唐湛然的《止观辅行传弘诀》最为有名。</p><h4 id="童蒙止观"><a href="#童蒙止观" class="headerlink" title="童蒙止观"></a>童蒙止观</h4><p>天台宗止观代表作。有名《修习止观坐禅法要》、《小止观》。二卷，隋智顗撰。书分十章，即具缘、诃欲、弃盖、调和、方便行、正修、善根发、觉智魔事、治病和证果。</p><h4 id="六妙门"><a href="#六妙门" class="headerlink" title="六妙门"></a>六妙门</h4><p>天台宗禅观代表作。一卷。隋智顗撰。六妙门是由数、随、止、观、还净六个禅法组成的修持系统，适用范围广。其特色是把六妙门分作十门，各门中又摄入许多禅法，并含有巧妙的相互转变运用功能，是一套微妙的禅修法门。</p><h3 id="唐"><a href="#唐" class="headerlink" title="唐"></a>唐</h3><h4 id="千金要方"><a href="#千金要方" class="headerlink" title="千金要方"></a>千金要方</h4><p>中医综合性著作。全称《备急千金要方》。三十卷。唐孙思邈撰。作者认为“人命至重，贵于千金，一方济之，德逾于此”，故以“千金”命名。其书总结隋代以前的医学成就，为临床实用的医学百科全书。内容包括医论、医方、诊法、针灸、气功等。其中“养性”一章，堪称集唐以前医疗之大成，要言不烦，颇为实用。对六字气诀描述极其详细。</p><h4 id="存神炼气铭"><a href="#存神炼气铭" class="headerlink" title="存神炼气铭"></a>存神炼气铭</h4><p>气功养生名篇。又名《太清存神炼气五时七候诀》。唐孙思邈撰。首叙方法，先须绝粒，安心气海，存神丹田，摄心静虑，专心修炼；次分五时，条列炼功时各种不同的入静方法；末列七候，是炼功后体验到的各种身心效应。</p><h4 id="清静经"><a href="#清静经" class="headerlink" title="清静经"></a>清静经</h4><p>道教经典著作。全称《太上老君说常清静妙经》。一卷。唐代著作，不著撰人。此经本着老子“清静无为”的宗旨，认为人能清静，即可得道，住世长年。而获得清静之法，唯有观空。</p><h4 id="了心经"><a href="#了心经" class="headerlink" title="了心经"></a>了心经</h4><p>道教经典著作。全称《太上老君说了心经》。一卷。唐代著作。不著撰人。书中认为“心为神主，动静从心”，只有从澄心定神入手，修炼才能成功。</p><h4 id="天机经"><a href="#天机经" class="headerlink" title="天机经"></a>天机经</h4><p>道教经典著作。又名《阴符天机经》。一卷。唐代著作，不著撰人。此经为阐发《阴符经》而作。</p><h4 id="幻真先生服内元气诀"><a href="#幻真先生服内元气诀" class="headerlink" title="幻真先生服内元气诀"></a>幻真先生服内元气诀</h4><p>气功服气著作。一卷。唐代幻真先生撰。全书十五章，一至五章为一套完整的服气法；六至十一章是六个独立的服气功法；十二至十四章为服气注意事项；十五章为服气胎息诀，是几种功法的综合。本书自成体系，文字流畅，是唐代服气著作中的代表作。</p><h4 id="长生胎元神用经"><a href="#长生胎元神用经" class="headerlink" title="长生胎元神用经"></a>长生胎元神用经</h4><p>道教炼养著作。一卷。唐代著作，不著撰人。主要阐述气功养生的基本原理和实践方法。书中杂引各家学说为多。</p><h4 id="太上洞房内经"><a href="#太上洞房内经" class="headerlink" title="太上洞房内经"></a>太上洞房内经</h4><p>气功存思内炼著作。一卷。唐代著作，不著撰人。此经内容以存神、内视为主，其学术渊源出于《黄庭经》。经末附有平旦及日入时存想五方云气之方法。</p><h4 id="胎息精微论"><a href="#胎息精微论" class="headerlink" title="胎息精微论"></a>胎息精微论</h4><p>气功胎息著作。一卷。唐代著作，不著撰人。本书既重胎息功夫，又兼取还精补脑诸法。</p><h4 id="气法要妙至诀"><a href="#气法要妙至诀" class="headerlink" title="气法要妙至诀"></a>气法要妙至诀</h4><p>气功服气著作。一卷。唐代著作，不著撰人。书分五章。主要论述服气方法，主张结合导引是其特点。</p><h4 id="延陵先生集新旧服气经"><a href="#延陵先生集新旧服气经" class="headerlink" title="延陵先生集新旧服气经"></a>延陵先生集新旧服气经</h4><p>气功服气著作。一卷。唐延陵先生撰。全书分十五章，广集隋唐以前之多种服气、胎息方法，去伪存真，无论对理论研究或指导炼功实践，均有重要参考价值。</p><p>中山玉柜服气经气功服气著作。一卷。唐碧岩先生撰。书分四章，盛赞服气胎息为养生至宝。其法讲究“收息缩气，摄腹咽下”，直入食脉，与其他的服气功法有所不同。</p><h4 id="太清中黄真经"><a href="#太清中黄真经" class="headerlink" title="太清中黄真经"></a>太清中黄真经</h4><p>气功服气辟谷经典著作。又名《胎藏中黄经》。二卷。原题“九仙君撰，中黄真人注”，系唐代道教学者托名。全书十八章，主要论述人体生理病理及气功养生诸问题。注文详述服气胎息与绝欲辟谷的方法，以及三丹田、脏腑的关系，颇有参考价值。</p><h4 id="心印经"><a href="#心印经" class="headerlink" title="心印经"></a>心印经</h4><p>气功内丹术著作。全称《高上玉皇心印经》。一卷。唐代著作。不著撰人。此经为四言韵文，共五十句。主要讲述内丹术的基本理论，阐发精、气、神的含义及它们之间的关系，对后世有较大影响。</p><h4 id="太上九要心印经"><a href="#太上九要心印经" class="headerlink" title="太上九要心印经"></a>太上九要心印经</h4><p>气功内丹著作。一卷。唐张果撰。全书九篇，分专题论述内炼丹术中的关键文题。</p><h4 id="内丹经"><a href="#内丹经" class="headerlink" title="内丹经"></a>内丹经</h4><p>气功内丹术著作。又称《太上老君内丹经》。一卷。唐代著作，不著撰人。书中推崇内丹的长生久视作用，论述内丹基本理论及功效，重道德修养。</p><h4 id="玉轴经"><a href="#玉轴经" class="headerlink" title="玉轴经"></a>玉轴经</h4><p>气功养生著作。全称《上清黄庭五脏六府真人玉轴经》。一卷。此书以六字气诀泗、呵、嘘、呼吹、嘻，分别配合脏腑肺、心、肝、脾、肾、胆，以吐气为泻，吸气为补，结合五脏一腑（胆）之生理病理应用，极有实用价值。</p><h4 id="黄庭内景五藏六府补泻图"><a href="#黄庭内景五藏六府补泻图" class="headerlink" title="黄庭内景五藏六府补泻图"></a>黄庭内景五藏六府补泻图</h4><p>气功养生著作。一卷。唐胡惜撰。此书以《黄庭内景经》的理论为指导思想，取《玉轴经》的六字气诀为炼功基础，再参照《千金要方》等诸家养生文献，结合自己的实践经验，创编出一套完整的养生方法。书中以五脏六腑（胆）为纲，各系一图，下列六气法、修养法、相病法、治病法、食病法、导引法诸目，既可治病，又能防病强身，方便易行，故后世流行甚广。</p><h4 id="神气养形论"><a href="#神气养形论" class="headerlink" title="神气养形论"></a>神气养形论</h4><p>气功养生著作。一卷。唐代著作，不著撰人。主要阐述神、气、形的相互关系，认为只有收视返听，涵养精神，使神内守而不外扬，才能形体坚固，长生久视。</p><h4 id="将摄保命篇"><a href="#将摄保命篇" class="headerlink" title="将摄保命篇"></a>将摄保命篇</h4><p>气功养生著作。一卷。唐代著作，不著撰人。认为祛病之导，不仅要加强气功锻炼，而且还要注意精神道德修养。</p><h4 id="天隐子"><a href="#天隐子" class="headerlink" title="天隐子"></a>天隐子</h4><p>气功养生著作。又名《天隐子养生书》。一卷。唐司马承祯撰，托名天隐子。书分八章，大抵以炼形养心为宗旨。</p><h4 id="坐忘论"><a href="#坐忘论" class="headerlink" title="坐忘论"></a>坐忘论</h4><p>气功养生著作。一卷。唐司马承祯撰。作者根据《庄子大宗师》中的“坐忘”之说，加以阐述发挥，书中详细论述坐忘安心法，认为养生之关键在于静定功夫。行文流畅，影响深远。</p><h4 id="服气精义论"><a href="#服气精义论" class="headerlink" title="服气精义论"></a>服气精义论</h4><p>气功服气代表著作。一卷。唐司马承祯撰。全书九篇，此书于众多的服气著作中较少虚妄。作者主张服气与导引、符水、药物诸法相结合，与他家只重一发者有异。书中贯穿医理最为可信。正统《道藏》洞神部方法类所收者并非完本，仅原书之第一、二篇。后七篇另作《修真精义杂论》，收在洞真部众术类。《云笈七签》中所收者为完本，并明确标有序数。</p><h3 id="五代"><a href="#五代" class="headerlink" title="五代"></a>五代</h3><h4 id="入药镜"><a href="#入药镜" class="headerlink" title="入药镜"></a>入药镜</h4><p>气功内丹术经典著作。一卷。五代崔希范撰。作者“以吾心为镜，身为之台，以神为药”，入药者是将五脏所禀五行之气入于丹田，此为《入药镜》篇名之本意。全书为三言歌诀，共八十二句。每四句讲述内丹养炼中的一个重要问题。描绘内炼过程及其感受，效法天体运行规律，为唐代以后道家重视内炼奠定了理论基础。</p><h4 id="钟吕传道集"><a href="#钟吕传道集" class="headerlink" title="钟吕传道集"></a>钟吕传道集</h4><p>气功内丹术经典著作。3卷。又名《真仙传道集》或《钟吕传道记》。五代，施肩吾撰。全书以钟离权与吕岩师徒问答的形式，论述内丹术要义共18卷论真仙、大道、天地、日月、四时、五行、水火、龙虎、丹药、铅汞、抽添、河车、还丹、练形、朝元、内观、磨难、征验。全书以天人合一思想为基础，阴阳五行学说为核心，炼形炼气炼神为方法，系统完整地论述了气功学说的精华—内丹学说.建立了钟吕派内丹体系，对后世影响甚大。</p><h4 id="西山群仙真记"><a href="#西山群仙真记" class="headerlink" title="西山群仙真记"></a>西山群仙真记</h4><p>气功养生著作。5卷。五代施肩吾撰。简称《西山记》。洪州西山（今江西新建县内）乃作者隐居之处，自序称“欲论得道而超脱者，西山十余人矣。遂从前圣后圣，秘密参同契，而成此书。采遮各书，如《太上隐书》、《灵宝内观经》、《上清玄格》、《洞玄经》等，共20余种，保存不少五代迢家内丹术资料。</p><h4 id="养生辩疑诀"><a href="#养生辩疑诀" class="headerlink" title="养生辩疑诀"></a>养生辩疑诀</h4><p>气功养生著作。五代施肩吾撰。作者批评世人学养生而不知本源，因而不效，却疑得道者乃“有灵骨”之故，误以为非常人“可学而得之”的观点。</p><h4 id="灵宝毕法"><a href="#灵宝毕法" class="headerlink" title="灵宝毕法"></a>灵宝毕法</h4><p>气功内丹术经典著作。3卷。五代钟离权撰。作者称于终南山石壁间得《灵宝经》30卷：上部金浩书，元始所著，中部玉书录元皇所述，下部真源义，太上所传。共数千言。经朝暮研习，“乃悟阴中有阳，阳中有阴，本天地升降之宜；气中生水，水中生气，亦心肾交合之理”。于是摄其大要撰成此书。书中分三乘十门。小乘安乐延年法四门：匹配阴阳第一，聚散水火第二，交媾龙虎第三，烧炼丹药第四；中乘长生不死法三门：肋后飞金晶第五，玉液还丹第六，金液还丹第七；大乘超凡入圣法三门：朝元炼气第八，内观交换第九，超脱分形第十。每门中列“金诰”、“玉书”、“真源”之有关论述外，再依次分“比喻、“真诀”、“道要”等内容。本书属清净派著作，“以八卦运十二时而其要在艮位；以三田互相反复，而其要在泥丸（《道藏精华录提要》）为其特色。</p><h4 id="破迷正道歌"><a href="#破迷正道歌" class="headerlink" title="破迷正道歌"></a>破迷正道歌</h4><p>气功养生著作。1卷。五代钟离权撰。全书为五言古风1篇。凡244句，1708字。排斥各种养生方法，而独尊内丹术。</p><h4 id="纯阳真人浑成集"><a href="#纯阳真人浑成集" class="headerlink" title="纯阳真人浑成集"></a>纯阳真人浑成集</h4><p>道教炼养著作。2卷。五代吕岩撰。前有条阳清真道人何志渊序。称“于藏室中得其诗章二百有余，厘为二卷，名之曰《浑成集》，以其浑然天成，非人为所能及也。所收诗与《吕祖志》大多互见，亦有《吕祖志》中未见者。</p><h4 id="陈先生内丹诀"><a href="#陈先生内丹诀" class="headerlink" title="陈先生内丹诀"></a>陈先生内丹诀</h4><p>气功内丹术著作。1卷。五代陈朴撰。又名《九转金丹秘诀》本书世传有两种本子：一本收在《道藏太玄部》，名《陈先生内丹诀》；一本收在《道藏洞真部》中《修真十书》卷十七，名《九转金丹秘诀》。前者系分句作解，后者则每首诗词后合解。文句略有出入而各有所长，可互相参证。本书为论述九转金丹修炼方法的重要著作。九转者：一转降丹，二转交媾，三转养阳，四转养阴，五转换骨，六转换肉，七转换五脏六腑，八转育火，九转飞升。</p><h3 id="宋"><a href="#宋" class="headerlink" title="宋"></a>宋</h3><h4 id="云笈七签"><a href="#云笈七签" class="headerlink" title="云笈七签"></a>云笈七签</h4><p>道教练养类书。122卷。宋张君房编。北宋大中祥将五年（1012），张君房奉命校正秘阁道书，至天禧三年（1019）编成《大宋天宫宝藏》4565卷，再摄其精要，总万余条，辑成本书。称《云笈七签》者，“云笈”是珍藏道书的书箱，“七签”是指道书总有七大部：三洞（洞真、洞玄、洞神），四辅（太玄、太平、太清、正一）。1—28卷，总论经教宗旨及仙真位籍之事，其中涉及气功内容的，有《黄庭经》、《中黄真经》、《老君清静心经》、《洞玄灵宝定观经》等经注。29—86卷，分列道家服食练气、内丹外丹、方药符图、守庚申、尸解诸术，其中32——36卷与56——62卷所介绍的种种服气、胎息等法，皆为重要气功内容。87——122卷，则为道教文字及诗歌、传记之属，其中如《七部语录》、《七部名数要记》，均为论述养生要旨之佳作。与气功有密切关系。此书虽然摘录，不加论说，但去芜存精.分类编排，条理清楚。书中还保存了部分佚失道书的篇章，涉及气功的如《墨子闭气行气法》、《昙鸾法师服气法》等，均有研究参考价值。</p><h4 id="洞元子内丹诀"><a href="#洞元子内丹诀" class="headerlink" title="洞元子内丹诀"></a>洞元子内丹诀</h4><p>气功内丹术著作。2卷。宋洞元子撰。凡21篇，论述玄元、坎宫、离宫、既济、未济、乾宫、坤宫、兑艮二宫、变象、水火、焚魔、交媾、元火、沐浴、母子、抱元守一，道数、神光、总要、广玄等内容。除变象、总要、广玄三篇外，每论论述后以歌诀形式再作概括，除毋子篇为五言诗外，其余均为七言诗。本书主以易理、易象解说内丹修练之术，为其特色。</p><h4 id="内丹还元诀"><a href="#内丹还元诀" class="headerlink" title="内丹还元诀"></a>内丹还元诀</h4><p>气功内丹术著作。1卷。宋代著作，不题撰人。全篇约850字，简要解释内丹术语如五行（肝、肺、心、肾、脾）、四象（金翁、姹女、婴儿、黄婆）、七宝（津、水、唾、血、神、气、精）及九仙真气（口鼻谷道气之出入及嘘、呵、四、吹、呼、嘻、喜、怒）。</p><h4 id="内丹秘诀"><a href="#内丹秘诀" class="headerlink" title="内丹秘诀"></a>内丹秘诀</h4><p>气功内丹术著作。1卷。宋代著作，不题编者。系集《内丹赋》、《阴丹诗》、《海蟾子还丹赋》、《至真歌》、《中颊先生增马处士歌》、《青城山后岩栖谷子灵泉井歌》、《金虎白龙诗》（张果述，21首）成一辑，诗赋文辞华丽，有数篇属阴阳派著作。</p><h4 id="太清真人绝命诀"><a href="#太清真人绝命诀" class="headerlink" title="太清真人绝命诀"></a>太清真人绝命诀</h4><p>气功养生著作。1卷。宋太清真人撰。其法以存思为主，第一先存五兽，第二历藏，第三守地，第四守人，第五守天。兼以咽津服气，俾得益寿延年。</p><h4 id="保生要录"><a href="#保生要录" class="headerlink" title="保生要录"></a>保生要录</h4><p>气功养生著作。1卷。宋蒲虔贯撰。全书分养神气门、调肢体门、论衣服门、论饮食门、他居处门、论药食门。论述平易简明，切于实用。</p><h4 id="紫清指玄集"><a href="#紫清指玄集" class="headerlink" title="紫清指玄集"></a>紫清指玄集</h4><p>气功内丹术著作。2卷。宋白玉蟾撰。内容有玄关显秘论、修辨惑论、性命日月论、谷神不死论、阴阳升降论、金液还丹赋、学道自勉文、东楼小参文、冬至小参文、丹语法语、题张紫阳薛紫贤二真人像、谢陈仙师寄书词、鹤林问道篇，以及必竟凭地歌、快活歌等，共40余篇。作者精通内丹术，善属文辞，且喜交游。</p><h4 id="金丹直指"><a href="#金丹直指" class="headerlink" title="金丹直指"></a>金丹直指</h4><p>气功内丹术著作。1卷。宋周无所住撰。前有自序，作于淳偌庚戌（1250）年。书前胪列玄关一窍颂、真土颂、阳晶颂、玄化颂、龙虎颂、铅汞颂、真炉鼎颂、真药物颂、斤两颂、抽添颂、火候颂、法度颂、口诀颂、沫浴颂、工夫颂、温养颂，共16颂。颂中内丹术语，概从性功解释，或问中亦宜指：“金丹喻本性长存，是名金刚不坏，……性即命，命即性”。</p><h4 id="诸真论还丹诀"><a href="#诸真论还丹诀" class="headerlink" title="诸真论还丹诀"></a>诸真论还丹诀</h4><p>气功内丹术著作。1卷。宋代著作，不著撰人。杂录前人内丹歌诀。内容有玉壶颂10首、青霞子赞《金碧龙虎经》、赞魏伯阳《参同契》、容成公内丹歌诀、曹圣图铅汞歌，以及论真鼎、明水火、明火候、明至药等口诀，共18首。其中曹圣图铅汞歌为五言古风，其余均为七言，或绝句，或律、成为俚歌。所收有属双修派内容。</p><h4 id="了明篇"><a href="#了明篇" class="headerlink" title="了明篇"></a>了明篇</h4><p>气功内丹术著作。1卷。宋宋先生撰，毛日新编。首为遇真歌，自述遏钟离权授口诀得真道之情；继为解迷歌，讲述内炼要旨；未为和朗然子诗30首及其他词22首。均系论道谈玄，成言内丹炼养心得之作。</p><h4 id="修真太极混元指玄图"><a href="#修真太极混元指玄图" class="headerlink" title="修真太极混元指玄图"></a>修真太极混元指玄图</h4><p>气功内丹术著作。1卷。宋代著作，不题撰人。全书以图诀相配形式讲述内丹炼养方法，其中多涉五脏气化，为其特色。具体内容为匹配阴阳胎息诀图，真龙虎交媾内丹诀图，周天火候诀图，肘后飞金晶诀图，还丹诀图，炼形秘图，三国既济诀图，炼气成神朝元诀图，内观起火仙丹交换召，弃壳升仙人圣超凡诀图。</p><h4 id="龙虎手鉴图"><a href="#龙虎手鉴图" class="headerlink" title="龙虎手鉴图"></a>龙虎手鉴图</h4><p>气功内丹术著作。1卷。宋代著作，不题撰人。其图从《周易参同契》立论，以天地阴阳合化、乾坤门户、坎离匡郭、囊合动静等说来阐述龙虎内丹之修炼。次列龙虎、灵药、还丹、文武、神运、黄芽、白汞、金虎、玄曜、真旨、流殊、住世、成真、出世、河车等15个条目，分述内丹修炼的法则。</p><h4 id="道枢"><a href="#道枢" class="headerlink" title="道枢"></a>道枢</h4><p>道教炼养类书。42卷。宋曾糙撰。书名源于《庄子齐物论》中“彼是莫得偶，谓之道枢”，含道术真要之意。全书共108篇，广辑南宋以前道教有关文献资料而成，是研究道教史，道教的思想与方术，以及气功内丹术的重要参考书籍。其中各章。有讨论《阴符经》、《黄庭经》、《悟真篇》等典藉要旨而名阴符、黄庭、内景、外景、悟莫者，有阐释道家理论而名太极、元气、虚白、火侯、归根者，有介绍道家修炼方法而名胎息、调气、运火、大还金丹者。各篇中除引用著名道教学者之论述外，如至朴子、朝元子、纯粹子、嵩岳真人等唐宋时代隐居民间之道教学者，其遗文亦为网罗收入。篇中常有曾氏本人论述，反映了他反对双修而主清修的观点。</p><h4 id="太极图说"><a href="#太极图说" class="headerlink" title="太极图说"></a>太极图说</h4><p>儒家哲学经典著作。1卷。宋周敦颐撰。作者绘有太极图，并撰文字诠释，其所列最高哲学范畴是无极，以下依次为太极、阴阳、五行、二气交感、化生万物。万物之中，惟人最灵，而为人之最高境界，就是圣人倡导的“定之以中正仁义而主静”。自此以后，宋明理学家都重主静之说，且喜静坐。据清黄宗炎考证，周氏太极图系由北宋初著名道家学者陈传之无极图演化而来。无极图本为阐明内丹术而设，由“玄牝门”、“炼精化气”逐层而上，至顶层为“炼神还虚，复归无极”。周氏则将无极图自下而上之递进关系颠倒，作自上而下之衍化，并改换有关名称，将道家气功思想引进儒家哲学畴。</p><h4 id="调息箴"><a href="#调息箴" class="headerlink" title="调息箴"></a>调息箴</h4><p>气功养生名篇。宋朱熹撰。所调“调息”，即调整呼吸以养生之意。此箴取佛道两家气功之内容。如“鼻端有白，我其观之”，在佛典《楞严经》卷五载孙陀罗难陀“观鼻端白，我初谛观……”；面“守一处和，千二百岁”，乃源自《庄子在宥》篇。</p><h4 id="元气论"><a href="#元气论" class="headerlink" title="元气论"></a>元气论</h4><p>气功养生名篇。宋张澡撰。文中认为自然界一切均由元气化生，亦讲到人生命，“禀天地之元气为神为形，受元一气为液为精”。主张返老还童，需七返九还，而其七返九还说则与他说不同：“液化为精，精化为气，气化为神、神复化为液，液复化精，精复化为气，气复化为神”。特别推重服气法，认为“夫长生之术，莫过乎服元气，胎息内固灵液，金丹之上药”。书中对服气法有详细介绍。该论见存于《云笈七签》卷五十六。</p><h4 id="圣济总录"><a href="#圣济总录" class="headerlink" title="圣济总录"></a>圣济总录</h4><p>中医类书。200卷。宋徽宗主编，系政和年间诏命医官编纂，历时7年（1111——1117年）而成。该书广泛收集历代方书及民间方药，并摘录道家修炼方法，以供选用。属于道家气功修炼的内容有神仙导引、神仙服气、神仙炼丹等篇章。</p><h4 id="修真十书"><a href="#修真十书" class="headerlink" title="修真十书"></a>修真十书</h4><p>气功内丹术丛书。旧题宋石泰辑，不确。收书12种，共60卷。计有《杂著指玄篇》8卷，元萧廷芝《金丹大成集》5卷，唐施肩吾《钟吕传道集》3卷，《杂著捷径》9卷，宋张伯端《悟真篇》5卷，《玉隆集》6卷、《上清集》8卷、《武夷集》8卷（以上三集为宋白玉蟾撰），元王志谨《盘山语录》1卷，唐胡惜《黄庭内景五藏六府图》1卷，《黄庭外景玉经注》3卷（以上二书为唐梁丘子撰）。</p><h3 id="金元"><a href="#金元" class="headerlink" title="金元"></a>金元</h3><h4 id="重阳真人授丹阳二十四诀"><a href="#重阳真人授丹阳二十四诀" class="headerlink" title="重阳真人授丹阳二十四诀"></a>重阳真人授丹阳二十四诀</h4><p>气功内丹术著作。1卷。金王哲撰。此书是王氏答其第子马钰所提的30多个问题，主要阐述内丹术语、内炼口诀中所含的内丹理论思想。包括祖宗、性命、根蒂、龙虎、铅汞、刀圭、金公、黄婆、婴儿、姹女、龙蛇、心猿、意马、宾主、觉照、太上、三宝、九星、五刚、三才、抽添火候、金丹、七返、三命、九窍等。共内炼思想主要体现在：一少言语养内气，二戒心性养精气，三薄滋味养血气，四戒嗔怒养肺气，五养饮食养胃气，六少思虑养肝气，七寡嗜欲养心气。认为“凡人出家，绝名弃利，忘情去欲，则心虚。心虚则气住，气住则神清，神清则德合道生矣”。突出明心见性的思想。</p><h4 id="重阳真人金关五锁诀"><a href="#重阳真人金关五锁诀" class="headerlink" title="重阳真人金关五锁诀"></a>重阳真人金关五锁诀</h4><p>气功内丹术著作。1卷。金王直公撰。内容涉及较广，主要以问答方式解说全真道的内丹理论和修炼方法。书中将道教秘传内炼法分为三乘，来阐述修炼的基本过程。炼者先从小乘入手，而后入中乘、大乘。并记载了九转还丹法、黄芽穿膝法、射九重铁鼓法、太子游四门法、金鞭轮法、陈希夷大睡法、仙人钓鱼法、金关玉锁法、七返还丹法、肘后飞金晶法、搬精补脑法、三车搬运法、抽添加减法、灌想法、黄婆匹配法等治病与修炼的小、乘功法。这些法诀多为北七真所继承发挥，成为全真道内丹法的基础。</p><h4 id="丹阳真人直言"><a href="#丹阳真人直言" class="headerlink" title="丹阳真人直言"></a>丹阳真人直言</h4><p>道教炼养著作。1卷。金马钰撰。本书是作者在龙门山重阳会土讲述的内炼丹法理论与功诀的记录。作者认为修道贵在无为清静，不能急于求成。指出“长要心定，行住坐卧，皆是行道。诸公休起心动念，疾搜性命；但能澄心遣欲，便是仙”。并指出性命、龙虎、铅汞、水火、婴姥、阴阳等全是神气二字的演变，不可执著。但欲成内丹，还以清净为本，“欲要养气全神.须常屏尽万缘，表里清净，绵绵固守动。三年不漏，下丹结；六年不漏，中丹结；九年不漏，大丹结圆备。此名九转大功，亦名三千功满，三因圆奋，谓之丹法，身轻举，永为神仙。”</p><h4 id="丹阳真人语录"><a href="#丹阳真人语录" class="headerlink" title="丹阳真人语录"></a>丹阳真人语录</h4><p>道教练养著作。1卷。金马钰撰，王颐中编。主要论述全真道修心养性的理法，以清静无为、柔弱谦下为主。清为清其心源，净为净其气海。心源清则外物不能扰，故情定而神明；气海净则邪欲不能于、故精全面腹实。突出输净之法在修道中的重要性，“故道家留丹经子书，千经万论，可一言以蔽之，曰清静”。此外，还主张薄滋味以养气，去嗲怒以养性，效污下以养德，守恬淡以养性。</p><h4 id="孙不二元君法语"><a href="#孙不二元君法语" class="headerlink" title="孙不二元君法语"></a>孙不二元君法语</h4><p>气功内丹术女功代表作。1卷。金孙不二撰。专论女子内丹理论与功法。全书有神道功夫次第诗14首（收心、养气、行功、斩龙、养丹、胎息、符火、接药、练神、服食、辟谷、面壁、出神、冲举），女功内丹诗7首。为女子习炼内丹所必读之作。</p><h4 id="上清太玄九阳图"><a href="#上清太玄九阳图" class="headerlink" title="上清太玄九阳图"></a>上清太玄九阳图</h4><p>气功内丹术著作。1卷。金侯善渊撰。主要描述内丹修炼过程中的不同境界，并对练功与时辰关系作了探讨。全书以图为主，首列太玄混沌图、未见图等，次按月出、上弦、照望、平阳、下弦、月尽之序，分别配以震、兑、乾、翼、良、坤卦，及离中虚在天为日在人为目，坎中实在天为月在人为耳，亦辅以图，分述神功运移之法规；最后是太玄九阳修真图，概述炼丹的全过程。</p><h4 id="启真集"><a href="#启真集" class="headerlink" title="启真集"></a>启真集</h4><p>道教炼养著作。3卷。金刘志渊撰。主要讲述内丹修炼方法。简明易懂方法可行，对后世内丹术的发展较有影响。卷上有七言绝句71首，七言律诗4首；卷中有词56首；卷下分13章，即真心章，天中天章、真土章、心息相依章、死阴生阳章等，皆为内丹修炼之要诀。</p><h4 id="大丹直指"><a href="#大丹直指" class="headerlink" title="大丹直指"></a>大丹直指</h4><p>气功内丹术著作。2卷。元丘处机撰。本书是早期全真道最系统完备的内丹著作，发挥了王品的内丹理论，将其分为三成九法。首先阐述了内丹修炼的基本理。认为人与天地禀受一同，始因父母二气交感，混合成珠，肉藏一点元阳真气，与母命蒂相连，受母气滋养，是为先天之气。出生之后，先天之气徽于九窍，呼吸从口鼻而出入，是为后天之气。先天真气逐时耗散，以至病夭。炼内丹求长生，关键在于用神火烹炼真精实气，使气满神壮。次用图、诀、诀义的形式详述九种内丹功法的修炼，其中五行颠倒龙虎媾法、五行颠倒周天火候法、三田返复肘后飞金精法为小成法，三返复金液还丹法、五气朝元太阳炼形法、神水交合三田既济法为中成法，五气朝元炼神入顶法、内观起火炼神合道法、弃壳升仙超凡入圣法为大成法。大成法为内丹最高境界。三成九法由浅入深，较完整阐述了内丹修炼的法则，其核心是修炼性命。此外，还叙述了炼功入静时可能出现的10类幻景及排除方法。只有时闻乐声，异香阵阵，红光闪闪，状如莲花，遍身赛笼罩，色若金光，才是真境妙界。后世内丹家对此书评价甚高，誉之为“北宗丹经之首”。</p><h4 id="金丹大成集"><a href="#金丹大成集" class="headerlink" title="金丹大成集"></a>金丹大成集</h4><p>气功内丹术代表作。5卷。元萧廷芝撰。书中以无极太极之理，《周易》八卦之数，天地阴阳、水火囊合升降之机，作为说理根据，来论述内丹的修炼。其中所称“金液还丹”者，即为内丹。载有无极图、天心图、玄地图、既济鼎图、河车图、周天火候图、泄天符火候图、六十卦火候图、大衍数图、金丹囊合图等图，囊合歌、金液还丹赋、金液还丹诗、金液还丹论、金丹问答、七言绝句、乐道歌、茅庐得意歌、剑歌等文，以及崔公《入药镜》与吕公《沁园春》的注解。有图有文，便于理解。全书内容丰富，说理透彻，其中《金丹问答》一篇，尤为初习内丹术者所必读。</p><h4 id="金丹大要"><a href="#金丹大要" class="headerlink" title="金丹大要"></a>金丹大要</h4><p>气功内丹术代表作。10卷。元陈致虚撰。作者融合南北两宗内丹理论，对气功内丹术作了较为完备的阐述。书中十分重视精气神的作用，以先天精气神为本，后天精气神为用，养生内炼之士贵在宝其精、壮其气、旺其神。同时还对金丹、药物、器、采取、真土、火候、神化等内炼要诀作了详细的论述。并对内丹修炼须知作了7个方面的说明，即：运火行符、朔望弦晦、防危护失、卵酉刑德、冰浴心虑、生杀爻铢、脱胎换鼎。书中还常出现儒家伦理道德思想，又援引佛家之说来论述明心见性之理，三教合一的思想较为浓厚。是收为内丹理论较为成熟时期的著作，因此比较全面地反映了内丹术的基本内容。此书原为10卷，《道藏》本析为16卷。</p><h4 id="规中指南"><a href="#规中指南" class="headerlink" title="规中指南"></a>规中指南</h4><p>气功内丹术代表作。2卷。元陈冲素撰。上卷九章，从止念、采药、识炉鼎、入药起火、坎离交媾、乾坤交媾、攒簇火候、阳神脱胎、忘神合虚等方面，介绍具体炼养方法。下卷三论，从玄化、药物、火候等阐述内丹机理，颇为精辟。书中认为玄牝即规中，在肾之上，心之下，人身上下左右之中，是内丹炼养之处。然此又系虚设之处，故“不可以有心守，不可以无心求。以有心守之，终莫之有；以无心求之，终见其无”。并详论药物与火候的辩证关系，认为“盖采时谓之药。药之中有火焉；炼财调之火，火之中有药焉”，而火候的要诀，“尤当于真息中求之”。“盖息从心起，心停息调，息息归根，金丹之母”。此书直指内丹奥秘，要言不繁，颇受后代学者重视。</p><h4 id="中和集"><a href="#中和集" class="headerlink" title="中和集"></a>中和集</h4><p>道教炼养代表作。6卷。元李道纯撰。作者精通《周易》与《礼记》，故书中炼养虽重三教合一、性命双修的观点，但援儒入道的倾向却非常明显。卷一为玄门宗旨，卷二为金丹妙诀，卷三为问答语录全真话法，卷四为论、说、歌，卷五为诗，卷六为词及隐语。其论丹法以“守中”为要诀，“致和”为目的。具体作法强调先虚其心以修性，后保其身以修命，最终取得性命双圆、形神俱妙之正果。书中将丹法分成渐与顿两类。渐法为循序渐进之法；又分三系，下乘是安乐法，中乘是养命法，上乘是延生法，由修命入手，取得成功。顿法为最上乘法，只有非常有根基者才能修炼而有所成就，只须一直了性，则自然了命。是书之内丹学说，自成体系，极有自己的特色，具有代表性。</p><h4 id="三天易髓"><a href="#三天易髓" class="headerlink" title="三天易髓"></a>三天易髓</h4><p>道教炼养著作。1卷。元李道纯撰。主要以儒、道、释三教之理论，阐释内丹理法。共有3篇，一为“儒曰大极——火符直指”，二为“道曰金丹——金丹了然图”，三为“释曰圆党——心经直指”。书未附《阴符经》注释。</p><h4 id="还真集"><a href="#还真集" class="headerlink" title="还真集"></a>还真集</h4><p>道教练养著作。3卷。元王介撰。其内丹理论参合南北两家，强调只有性命混融，才能始成内丹。上卷为图说，中卷为论文及歌词，下卷为诗词。认为“凡诸学道至人，参禅高士，不可执著，必以性命双修，方成大事”。在具体修炼方法上，书中强调三要，“一要知鼎器，二要知药物，三要知火候。知此三者分明，方许下手修之”。并开列鼎器异名39个，药物异名46个，火候异名12个，有解疑惑，提高修炼效果之功效。</p><h4 id="悟玄篇"><a href="#悟玄篇" class="headerlink" title="悟玄篇"></a>悟玄篇</h4><p>气功内丹术著作。1卷。元余洞真撰。是书着重探讨天地阴阳交合化生之理及水火交化进退之机在内丹修炼中的作用，而特别突出玄牝的地位。认为“夫人身中窍，名曰玄牝，若人得此窍，期三才万物悉备于我矣。此之一窍，非泥于物也，其理别于他术.止不过忘形灭念，如守其中矣。久久纯熟，中宫静极，则身中阳气自然生也，阳气渐生，阴气渐剥，乃曰阳长阴消之意矣”。此外，书中对形化、气化、坐工、口诀、沐浴、药物、火候、玄关、抱一、解胎等都作了具体的分析与探讨，并附图以资补述。</p><h4 id="谷神篇"><a href="#谷神篇" class="headerlink" title="谷神篇"></a>谷神篇</h4><p>气功内丹术著作。2卷。元林辕撰。自叙中曰：“篇目之曰谷神，不过以谷养气而已。”上卷为大药还丹诗、理一真篇、火候行持绝句诗等，其论大药云：“大药其最要法，在乎神水华池，为诸丹之基，大道之祖。存守则谓之宝珠，交会则谓之金丹。”下卷为图论，计有五气朝元图、投壶口诀图、含元抱朴之图、木金间闻体用图、元气生成图及静动虚名论、元气论等。对静定、真定、入定、得性等问题进行了探讨，对元气的生成、功用及其化生变化作了阐述。</p><h4 id="析疑指迷论"><a href="#析疑指迷论" class="headerlink" title="析疑指迷论"></a>析疑指迷论</h4><p>气功内丹术著作。1卷。元牛道淳撰。书中分析疑与指述两部分，以问答形式叙述。旨在使学者明了全真性命之理和修行次第之法。其析疑主论心性万物，认为人心“元无一物，等同太虚，本来清净”，为万法之本；“心即性用，性印心体”，心性以“虚寂为体，觉照为用”。指迷则主论性命内丹，认为性命本一，故应兼修。“夫人以精为根，以命为本，以性为宗，命者气也，性者神也。失神、气、精三者，成原于一，而未尝离也”。书中将炼丹之法分为三门九品，渐次修炼，较好地体现出性命双修的内练思想。</p><h4 id="抱一子三峰老人丹诀"><a href="#抱一子三峰老人丹诀" class="headerlink" title="抱一子三峰老人丹诀"></a>抱一子三峰老人丹诀</h4><p>气功内丹术著作。1卷。元金月岩编，黄公望传。重视心肾水火，性命双修是其特点。认为炼丹要求真铅真汞，真铅真汞即是神气性命；又须明心肾水火、三宫五行变化之理。指出假性命为出阴神，是鬼仙小成之法；真性命乃出阳神，是天仙大成之法。书中还有金蝉脱壳天仙之图、尾闾骨图及七言绝句。</p><h4 id="纸舟先生全真直指"><a href="#纸舟先生全真直指" class="headerlink" title="纸舟先生全真直指"></a>纸舟先生全真直指</h4><p>气功内丹术著作。1卷。元金月崖编，黄公望传。全书分为2篇。上篇为“七返七真合同印子”，有诗（并图）7首，分述内丹修炼的7个阶段。即形神相顾、人道初真，形神相伴、名目得真，形神相入、名目守真，形神相抱、名目全真，形神俱妙、与道合真，形神双合、名曰证真，普度后学、以真觉真。下篇为“入室节目筑室阔狭各自定例”，讲入室静坐功夫及各种景验。其内丹观点仍讲求性命双修。</p><h4 id="六根归道篇"><a href="#六根归道篇" class="headerlink" title="六根归道篇"></a>六根归道篇</h4><p>气功养生著作。1卷。元代著作，不题撰人。主要论述六根清净在内丹修炼中的重要性。其方法为“守道先须守心”，在内心意不乱，则身能正于外；目视耳闻各得守，则“五色得正，而邪者不干吾之目；五声得其节，而淫者不干吾之耳”；“芬碧之馨，不可以养吾之性”，故无味无馨，则“鼻舌不为我之患矣”。</p><h4 id="真仙直指语录"><a href="#真仙直指语录" class="headerlink" title="真仙直指语录"></a>真仙直指语录</h4><p>道教练养著作。2卷。元玄全子编。系全真派师徒授课记录，卷上录有马钰语录约30条，并录谭处端、刘处玄、郝大通等人的语录及丘处机的《寄西州道友书》，卷下隶尹志平语录。所录者多为全真道修行法诀。</p><h4 id="诸真内丹集要"><a href="#诸真内丹集要" class="headerlink" title="诸真内丹集要"></a>诸真内丹集要</h4><p>气功内丹术著作。3卷。元玄全子编。卷上收有老子《函谷关记》、钟离正阳《还丹歌》、张紫阳《石桥歌》、马自然《金石诰》、吕纯阳《玄牝歌》及《大丹歌》和《性命歌》、李仙君《金丹赋》、天来子《青龙歌》和《白戊歌》、刘海蟾《还丹破迷歌》等。卷中收有《王母口诀》、《太上内观正诀》、《玄无口诀》、《鼎器歌》、《金丹火候秘诀十二句》、《金丹证验》、《金丹类名》等。卷下收有青霞真人《内用秘文》。书中广集名篇，对修炼内丹之士来说，是一部很好的参考书。</p><h4 id="三元延寿参赞书"><a href="#三元延寿参赞书" class="headerlink" title="三元延寿参赞书"></a>三元延寿参赞书</h4><p>气功养生著作。5卷。元李鹏飞撰。成书于1291年。作者自称受一官姓道人的三元养生之术，认为人之寿命分天元六十、地元六十、人元六十，三元共一百八十岁，不知保养则日益减少。如精气不固则天元之寿暗损，谋为过度则地元之寿暗损，饮食不节则人元之寿暗损。故在保养同时还宜避忌，以使精神内壮。如何趋益避损，其法在《黄帝内经》、《老子》、《庄子》并名医论著及孔孟之说中均有论述。是书禀承此旨，以医家与道家之论为主干，以各家养生精论为辅，取《中庸》“赞化育，参天地”之意而定书名。共核心内容为：“天元之寿，精气不耗者得之”，下列欲不可绝等9目；“地元之寿，起居有常者得之”，下列养生之道等23目；“人元之寿，饮食有度者得之”，下列五味等10目。另外，还分类辑录诸家养生要语，极有参考价值。</p><h4 id="泰定养生主论"><a href="#泰定养生主论" class="headerlink" title="泰定养生主论"></a>泰定养生主论</h4><p>中医气功养生著作。16卷。元王硅撰。本书是一部医道结合论述养生祛病的著作，对养生祛病之法作了较为祥尽的叙述，并涉及导引、按摩之法。“首以原心为发明之始；次序婚合、孕育、婴幼、童壮、衰老宜摄避忌，以御未然之病；次论运气、标本、阴阳、虚实、脉病、证治，以为全生去病之法；然后类方对证，以为规矩之用”（《自序》）。</p><h4 id="寿亲养老新书"><a href="#寿亲养老新书" class="headerlink" title="寿亲养老新书"></a>寿亲养老新书</h4><p>综合性养生著作。4卷。元邹铉撰。本书论述养生方法较详，主要针对老人。卷一原名《养老奉亲书》，为宋陈直撰；卷二至卷四为邹铉续增。卷一讲饮食调养、形证脉候及简妙老人备急方等15篇，共223条，节宣之法详备；卷二分保养、服药诸篇，罗列古今丸、丹、膏、散、酒、粥、糕、饼等具体方药与主治；卷三与卷四为寝、兴、器、服、饮、膳、药石之忌宜，附妇儿食治诸方，共256条。其中卷三中的“太上玉轴六字气诀，为古代记载最详细的六字气诀；尚有“食后将息法”（系摘录沈括《杯山录》，此书现很少见到，颇有参考价值）及“养性”等气功养生方面的内容。</p><h3 id="明"><a href="#明" class="headerlink" title="明"></a>明</h3><h4 id="玄要篇"><a href="#玄要篇" class="headerlink" title="玄要篇"></a>玄要篇</h4><p>气功内丹术著作。2卷。明张三丰撰。收入《张三丰全集》中。书中突出先修性后全命的观点，重视元气与真息，强调水火阴阳升降化生在内丹修练中的作用。上卷有发，尤其是强调修心养性为练丹修真之首要。“性者内也，命者外也，以内接外，合而为一，则大道成”；“大道以修心炼性为首，性在心内，心包性外，是性为定理之主人，心为牺牲之庐舍”；“学道之士，须要清心清意，方得真清之药物也”。附篇为《三丰先生辑录》，节录了白玉蟾（紫清）、陆西星（潜虚）、李西月（涵虚）等人的内丹名言，各有特色。</p><h4 id="无根树"><a href="#无根树" class="headerlink" title="无根树"></a>无根树</h4><p>气功内丹术著作。1卷。明张三丰撰。是《张三丰全集玄要篇》中的重要组成部分，也是张三丰的代表作、颇为后人所推崇。讲述阴阳匹配双修在内丹修炼中的重要作用。丹词作于武当山中，约在明太祖洪武十七年（1384）。《无根树》是道情体裁的内丹秘诀，包括自题词2首和道情24首，提出了一套“阴阳裁接”功法，在内丹功法中别树一帜。丹词中云：“无根树，花正微，材老重新接嫩枝。梅寄柳，桑接梨，传与修真作样儿”；“无根树，花正偏，离了阴阳道不全。金隔木，汞隔铅，阳寡阴孤各一边。世上阴阳男配女，生子生孙代代传。顺为凡，逆为仙，只在中间颠倒颠”；“女子无夫为怨女，男子无妻是旷夫。叹迷徒，太模糊，静坐孤修气转枯”等。都将阴阳匹配作为修练内丹、成仙成圣的重要法门和手段，可谓别开生面，另劈蹊径，自成一个流派。何西复认为《无根树》在学术地位上，与《悟真篇》先后伯仲。清代龙门派传人刘一明与西派代表人物李西月，先后给该丹词作注，有《无根树二注》行世。</p><h4 id="玄肤论"><a href="#玄肤论" class="headerlink" title="玄肤论"></a>玄肤论</h4><p>气功内丹术著作。不分卷。明陆西星撰。全书共20篇，每篇一论。系统地论述了东派丹法原理和功夫次第，具有代表性。首论三元，认为丹有三元，即天元、地元、人元，而又突出人元。人元又谓之“大丹”，乃“创鼎于外，炼药于内，取坎填离，盗机逆用之谓也”。以后19篇专论人元丹法，从内外药物、阴阳互藏、先后天论、精气神、性命等方面对其丹法作了深刻的探析。书中内丹二诀以练神调息为要，神即是性，性定则神自安，神安则精住，精住则气自生。炼神又分澄神、养神、凝神三部，缺一不可。书中力求使其丹法理论和功诀显明易懂，其丹法思想南宗，而仍主以阴阳双修。</p><h4 id="金丹就正篇"><a href="#金丹就正篇" class="headerlink" title="金丹就正篇"></a>金丹就正篇</h4><p>气功内丹术著作。不分卷。明陆西星撰。书共3篇，其要旨在阐述成大丹必须阴阳双修的观点。认为金丹之道必资阴阳相合而成，“阴阳者，一男一女也，一离一坎也，一铅一汞也，此大丹之药物也。夫坎之真气谓之铅，离之真精谓之汞，先天之精积于我，先天之气取予彼。何以故?彼坎也，外阴而内阳，于象为水为月，其于人也为女。我离也，外阳而内阴，于象为火为日，其于人也为男。故夫男女阴阳之道，顺之则生人，逆之则成丹”。同时指出男子修丹，必须得先天其一之气方成，而真一之气必须向外求之，这进一步阐明阴阳双修才为内丹之正统。</p><h4 id="性命圭旨"><a href="#性命圭旨" class="headerlink" title="性命圭旨"></a>性命圭旨</h4><p>气功内丹术代表作。不分卷。明代著作，不题撰人，相传为尹真人弟子所著。全称《性命双修万神圭旨》。全书分元、亨、利、贞四集，图文相配，以三教合一、性命双修观点介绍内丹理论及具体功法。元集多作图说，指点窍妙；亨、利、贞三集则采儒、释、道三教名家语录及口诀，编成一套完整之功法。尤侗在序中云：“至其精要，尤在真意一说。盖人身真意，是为真土，动极而静，此意属阴，是为已土；静极而动。此意属阳，是为戊土。炼已土者，得离日之汞；炼戊土者，得坎月之铅。铅汞既归，金丹自结。戊已者、重土之象也，斯其有取于圭旨者乎”。可谓对其论内丹之中心思想的高度概括。</p><h4 id="金丹真传"><a href="#金丹真传" class="headerlink" title="金丹真传"></a>金丹真传</h4><p>气功内丹术代表作。1卷。明孙汝忠撰。书中继承南家内丹学说，主张阴阳双修，认为阴阳双修是炼丹修仙的大道。全书包括《西江月词》9首、《葫芦歌》1首、《明道歌》4首及《修真入门》、《修真大略》、《金丹五百字》、《扫邪归正歌》各1篇。对筑基、得药、结丹、炼已、还丹、温养、脱胎、玄珠等丹诀作了较为详细的论述。</p><h4 id="天仙正理直论"><a href="#天仙正理直论" class="headerlink" title="天仙正理直论"></a>天仙正理直论</h4><p>气功内丹术代表作。不分卷。明伍守阳撰。是书为内丹伍柳派的代表作。前有自序，首为道原浅说篇，次为直论九章。九章包括先天后天二气、药物、鼎器、火候、炼已、筑基、炼药、伏气、胎息等内丹精要之论。其自序云：“以二气为论，所以明生人生仙佛之理也；药物为论，所以明脱死超生之功也；而火候集古为经，所以合群圣仙机列为次第之宜也；喻筑基论二气，渐证于不漏；借炼药论二气，成一而不离，阐伏气论藏之内而不驰诸外，虽反复言气而不见其繁，立一名，彰一义也；论炼已者，论其成始成终之在其我，专言神而不见其简，操一机，贯一义也；鼎器之论，见神气之互相依；胎息之论，密指胎其神而息其气，此又合神气而归其妙，化于神而虚者也”。由此可见是书之大旨。</p><h4 id="仙佛合宗语录"><a href="#仙佛合宗语录" class="headerlink" title="仙佛合宗语录"></a>仙佛合宗语录</h4><p>气功内丹术著作。不分卷。明伍守阳撰。书中以道释之论，来证性命双修之旨。前为论丹道9篇，后附门人问答29条，及评古类13条。自序云：“仙宗果位，了证长生；佛宗果位，了证无生。然而了证无生，必以了证长生为宾指；了证长生，必以了证无生为终始，所谓性命双修者也”。其内丹说以佛证仙，是明白无疑的。</p><h4 id="遵生八笺"><a href="#遵生八笺" class="headerlink" title="遵生八笺"></a>遵生八笺</h4><p>综合性养生著作。20卷。明高濂撰。全书分《清修妙论笺》、《四时调摄笺》、《起居安乐笺》、《延年却病笺》、《饮肴服食笺》、《燕闲清赏笺》、《灵秘丹药笺》、《坐外退举笺》八个部分，阐述养生祛病大旨，故称“八笺”。书中广集前人文论、诸子百家的养生名言，儒释道三教并重。内容涉及衣、食、住、行诸方面，既重视物质调养，又重视精神调摄。同时作者对自身养生心得作了总结介绍。颇有参考价值。</p><h4 id="活人心法"><a href="#活人心法" class="headerlink" title="活人心法"></a>活人心法</h4><p>气功养生著作。2卷。明朱权撰。书中强调修心养性在养生中的作用，认为“真人以道治心”、“心静可似通乎神明”。全书主要内容有养生之法、治心、导引法、去病廷藩六字法、四季养生歌，以及中和汤、和气丸等。其中导引法附有行动图8幅，颇为实用。</p><h4 id="养生肤语"><a href="#养生肤语" class="headerlink" title="养生肤语"></a>养生肤语</h4><p>气功养生著作。1卷。明陈继么儒撰。以笔记形式记叙作者本人及前辈的养生观点和实践体会，通俗简易，大要在于葆精、炼气、养神。</p><h4 id="养生四要"><a href="#养生四要" class="headerlink" title="养生四要"></a>养生四要</h4><p>气功养生著作。5卷。明万全撰。书中以医理论述气功养生之理，强调寡欲、慎动、法时的养生观。全书分寡欲、慎动、法时、却疾、养生总论5部分。所记叙的气功养生内容多为实例，不同于一般泛泛之谈，所论切实可行，无玄虚妄诞之论，很是可贵。</p><h4 id="保生心鉴"><a href="#保生心鉴" class="headerlink" title="保生心鉴"></a>保生心鉴</h4><p>气功养生著作。1卷。明铁蜂居士撰。书中以医理为主，阐述养生却疾之方法，内容充实，也较为实用。观作者所言，是书乃在《圣贤保修通鉴》一书的基础上，参详《礼记月令》及《素问》、《灵枢》、《运气论奥》、《十四经发挥》等书，反复论证，并将《活人心法》中的八幅导引图改绘成三十二幅，共成此佚。书中对练功前准备、修炼要领、五运六气枢要、脏腑配经络、经络配四时等都作了详细的图说；并重点介绍了《二十四气导引图》，分述二十四节气的练功方法及所治疾病，图文并重，简易实用，对后世医疗气功的发展有较大的影响。</p><h4 id="摄生要义"><a href="#摄生要义" class="headerlink" title="摄生要义"></a>摄生要义</h4><p>气功养生著作。1卷。明王廷相撰。全书凡十篇，所论多为日常摄生方法，且多为作者自身体验者，颇有心得。其序中云：“余自壮年以来，颇讲此术，缘动达形，缘虚达气，下不著伎，上不泥仙，似于摄生之秘，超然有得。乃会综群文，诠取要旨，以著论十篇，用发蒙学。”十篇为存想、调气、按摩、导引、形景、饮食、居处、房中、四时、杂忌。</p><h4 id="卫生真诀"><a href="#卫生真诀" class="headerlink" title="卫生真诀"></a>卫生真诀</h4><p>气功养生著作。2卷。明罗洪先撰。书中对导引、内丹、外丹、气功处方等均有论述。上卷载运气口诀、导引要法及内丹、外丹的炼法等。下卷载有气功处方49则，故又名《仙传四十九方》，每方均有名称、功法、图像、主治病证、配用方药、诗歌等。</p><h4 id="万寿仙书"><a href="#万寿仙书" class="headerlink" title="万寿仙书"></a>万寿仙书</h4><p>气功养生著作。4卷。明罗洪先撰。清曹无极增辑。卷一主要收辑历代名人的养生理论及功法要点；卷二主要收辑著名的导引功法，如六字诀、八段锦坐功捷径等；卷三为诸仙导引图，按病证开列导引处方，并附有方药；卷四为延年总论，辑前人的养生观点而成，似是曹氏所增。</p><h4 id="修龄要旨"><a href="#修龄要旨" class="headerlink" title="修龄要旨"></a>修龄要旨</h4><p>气功养生著作。1卷。明冷谦撰。全书系9篇养生诗文编集而成，分述四时调摄、起居调摄、延年六字诀、四季却病歌、长生一十六字妙诀、十六段锦、八段锦导引法、导引却病歌诀、却病八则。</p><h4 id="锦身机要"><a href="#锦身机要" class="headerlink" title="锦身机要"></a>锦身机要</h4><p>气功养生著作。3卷。明混撼沌子撰，鲁至刚注。书中完整地介绍了一套以导引术揉合内丹术及房中术的功法，共有36式。每式先列名称、图像，次列歌诀与注文。上、中、下卷各12式，内容详备。鲁氏在序中云：“其筑基之法，养生之方，龙虎争驰，内外交炼，无不备焉。”</p><h4 id="类修要诀"><a href="#类修要诀" class="headerlink" title="类修要诀"></a>类修要诀</h4><p>气功养生著作。2卷，续附3卷。明胡文焕编。书中收集了古人有关修身明性、养生却病的论述，认为养生之关键在于慎寒暑、节口腹、寡嗜欲。此外，对饮食起居、四时调摄、劳逸房室、七情忌宜、导引按摩，以及内丹术等方面的内容均有论述。</p><h4 id="养生导引法"><a href="#养生导引法" class="headerlink" title="养生导引法"></a>养生导引法</h4><p>气功导引著作。1卷。明胡文焕编。书中主要讲述导引养生祛病法。共列病症27门，每门列功法若干条，可供选用。其选功法基本上依据（诸病源侯论）中所载的“养生方导引法”。此外，补益与老人二门中还收辑了《太清导引养生经》、《通玄集》等书的部分内容。</p><h4 id="保生秘要"><a href="#保生秘要" class="headerlink" title="保生秘要"></a>保生秘要</h4><p>气功导引著作。明曹士珩撰。原书少见，佚存未知。其内容散见于《古今图书集成》及《沈氏尊生书》。一为南北规中，共列7法。其中旧元、周天为南旋式，垠背、行庭、通关、绦法、涤秽为北旋式。一为诸病导引；分述咳嗽、哮喘、伤食呕吐、噎膈、鼓胀等病证的导引治疗，有较强的实用性。</p><h4 id="赤凤髓"><a href="#赤凤髓" class="headerlink" title="赤凤髓"></a>赤凤髓</h4><p>气功导引著作。3卷。明周履清编。书中重视导引的作用，广为搜罗，图文并茂。卷一为太上玉轴六字气诀、幻真先生服内元气诀、李真人长生一十六字妙诀、胎息、秘要歌诀、去病延年六字法、五禽戏圈诀、八段锦导引图诀等；卷二为圣真秘传四十六长生图诀；卷三为华山十二睡功图诀。均较为实用，对后世气功导引术的发展与推广有较大贡献。</p><h4 id="听心斋客问"><a href="#听心斋客问" class="headerlink" title="听心斋客问"></a>听心斋客问</h4><p>气功内丹术著作。1卷。明万尚父撰。作者用简明的语言，以客问主答的形式，对65个内丹术问题进行了阐释。如元精与交感之精的区别，元神与思虑之神伪异同等等。所论准确明白，直揭底蕴，对初习内丹术之人颇为实用。</p><h4 id="脉望"><a href="#脉望" class="headerlink" title="脉望"></a>脉望</h4><p>气功内丹术著作。8卷。明赵台鼎撰。是书系作者读书练功的笔记，书中采摘了大量内炼要语，且有自己的见解，对练功中的问题作了明白的解释，有一定的参考价值。</p><h4 id="真诠"><a href="#真诠" class="headerlink" title="真诠"></a>真诠</h4><p>道教炼养著作。3卷。明阳道生传，清彭定求校刻。此书对内丹修炼的认识颇有独到之处。认为内丹的锤炼，一为虚无大道，即“虚极静至，精自然化气，气自然化神，神自然还虚”；二为以神驭气，即“虚静以为体，火符以为用，炼精成气，练气成神，炼神还虚”。两者殊途同归，相辅相成，且均能得长寿之益。鼓氏指出其父对是书的评价甚高，云：“平生阅历四方丹书甚多，迷谬错出，不如此书洁净精微。”</p><h4 id="寥阳殿问答"><a href="#寥阳殿问答" class="headerlink" title="寥阳殿问答"></a>寥阳殿问答</h4><p>气功内丹术著作。1卷。明尹实人撰。全称为《尹真人寥阳殿问答编》。书中认为内丹修炼宜治心理气为先，返观内照、凝神入气穴、聚火开关、卯酉周天为次，最后才是长养圣胎。全书共分6篇，分述内丹修练要诀，重视调息与丹田，讲究周天功夫，是其特点。</p><h4 id="静坐说"><a href="#静坐说" class="headerlink" title="静坐说"></a>静坐说</h4><p>气功静坐著作。明高攀龙撰。主说静坐功夫，静坐以平常为要诀，而平常即清静自然。“以其清静不容一物，故谓之平常”，“静中妄念即净，昏气自清，只体认本性、原来本色，还他湛然而巳”，“湛然动去，静时与动时一色，动时与静时一色，所以一色者，只是一个平常也。故曰无动无静，学者不过借静坐中认此无动无静之体云尔”。在其后的《书静坐说后》中，又把理学的“主一”观引入作者的静坐论，认为“必收敛身心，以主于——即平常之体也，主则有意存焉，如意非著意，盖心中无事之谓，一著意则非一也。”可见作者的静坐说并非一味讲静，具有以静为主，动静交养的含意。</p><h4 id="静坐要诀"><a href="#静坐要诀" class="headerlink" title="静坐要诀"></a>静坐要诀</h4><p>气功静坐著作。1卷。明袁黄撰。书中主要从佛教心法论述静坐功夫。其论以天台宗的止观法、六妙法为基础，结合云谷、妙峰二位圣僧的修习心得及作者自身的实践，对静坐进行了详细的论述。全书分辨志、修证、调息、遣欲、广爱等六篇。摄生三要气功养生著作。明袁黄撰。三要者，即聚精、养气、存神。强精强调寡欲、节劳、息怒、戒酒、慎味等；养气提倡从调息起手，并介绍了胎息、胎食之法；存神则介绍了意守各窍之效应，及佛教修禅之法。</p><h4 id="古今医统大全"><a href="#古今医统大全" class="headerlink" title="古今医统大全"></a>古今医统大全</h4><p>综合性医药著作。100卷。明徐春圃撰。简称《古今医统》。书中罗列的资料十分丰富，既引古人之说，又有已见，重点论述医药方面的内容，其中卷九十九与卷一百为养生内容。其养生宗三元之说，也重视其他炼养方法。认为“天元之寿精气不耗者得之”、“地元之寿起居有常者得之”、“人元之寿饮食有度者得之”。摄生要义章则专论存想、调气、按摩、导引等，服饵章则专论服日月、服日精月华、服三气等。</p><h4 id="医学入门"><a href="#医学入门" class="headerlink" title="医学入门"></a>医学入门</h4><p>综合性医药著作。8卷，首1卷。明李挺撰。全书重点讨论医药上的问题，对医学理论、临床各科、历代医家、本草等均有论述。首卷的保养篇中，着重讨论养生方法。集中的导引法论述颇有见地，认为“人之精神极欲静，气血极欲动”、“导引为虚损气血不同面设”，列有开关法、起脾法、开郁法、治腰痛、治积聚、治遗精、治痰壅等导引法术，较为实用。</p><h4 id="寿世保元"><a href="#寿世保元" class="headerlink" title="寿世保元"></a>寿世保元</h4><p>综合性医药著作。10卷。明龚廷贤撰。书中在大量论述医学问题的同时，十分重视气功养生的祛病延年作用。卷四补益篇中特列吕洞宾补屋修墙养生诀与呼吸静功妙诀，其“妙块”中强调“人生以气为本，以息为之，以心为根，以肾为蒂”，故“人呼吸常在心肾之间，则血气自顺，元气自固，七情不炽，百骸之病自消矣”。可见十分重祝呼吸的养生保健作用。书中并列有具体功法，也颇为实用。</p><h4 id="红炉点雪"><a href="#红炉点雪" class="headerlink" title="红炉点雪"></a>红炉点雪</h4><p>中医理虚专著。4卷。明龚居中撰。又名《痰火点雪》。书中主要讨论痰火劳损病证的鉴别与治疗，颇有特色。卷四中祛病秘诀，列举了许多对痰火虚损病证的养生调息之法。如却病延年一十六句之术、动功六字延寿诀、静坐功夫等。方法简单，易学易练，较为实用，对肺痨的防治有一定参考价值。</p><h4 id="五福全书"><a href="#五福全书" class="headerlink" title="五福全书"></a>五福全书</h4><p>气功养生著作。7卷。明末龚居中撰。论气功养生参合医理，并有图说，是其特点。卷一至卷三列有修真要图、修真至说、修真秘诀，均系内丹之论，卷四为修真金丹，是外丹之论；卷五为修真种玉；卷六、卷七论述饮食忌宜。</p><h4 id="奇经八脉考"><a href="#奇经八脉考" class="headerlink" title="奇经八脉考"></a>奇经八脉考</h4><p>中医经络学专著。1卷。明李时珍撰。书中系统地论述了奇经八脉的循行线路、功能、主治病证，对针灸、气功、中医临床各科的辨治等均有重要指导意义。同时对奇经八脉在气功养生中的作用也作了详细的论述.认为医生不知奇经八脉难以探讨病机，气功养生者不知奇经之理，则难以确立养生之法。“任督二脉，人身之子午也，乃丹家阳火阴符升降之道，坎水离火交媾之乡”，“任督二脉是元气之所由生，真息之所由起，修丹之士，不明此窍，真息不生，神化无基也”。可见奇经八脉在气功养生中的作用是很重要的。</p><h4 id="针灸大成"><a href="#针灸大成" class="headerlink" title="针灸大成"></a>针灸大成</h4><p>中医针灸学专著。10卷。明杨继洲撰。书中对针灸学进行全面而系统的论述，对针灸学的发展有较大的影响。同时对气功祛病方面的知识也进行了介绍，如将小周天功法进行仔细的分新，“默想黍米之珠……徐徐咽气一口，缓缓纳入丹田，冲起命门，引督脉过尾闾，而上升泥丸，追动性元，引任脉降重楼，而下返气海。二脉上下，旋转如圆，前降后升，络绎不绝”。此外，还记述了不少与道家气功有关的内容，如吐纳、六害、十少等。将调神、调息法用于针刺疗法中，也是其特色。</p><h4 id="道藏"><a href="#道藏" class="headerlink" title="道藏"></a>道藏</h4><p>道教典籍总汇。收书1426种.共计1305卷。明张宇初主编，张字清续成。明成祖朱隶初即位时，即下诏编修，直至英宗朱祁镇正统十年（l445），才全部刻成。按三洞四辅十二类分类，用千字文编号，分装48O函。内容十分庞杂。除道教经书外，还收入诸子百家文集，保留了许多珍贵的科技史料。在此之前，历史上还有唐玄宗时的《开元道藏》、宋初的《大宋天宫宝藏》和《崇宁重校道藏》，藏经刊印始于宋徽宗政和中的《万寿道藏》，金元时期都以此为蓝本，金代有《大金玄都宝藏》，元代增订后仍称《会都宝藏》等，这些《道藏》现皆不存。</p><h4 id="续道藏"><a href="#续道藏" class="headerlink" title="续道藏"></a>续道藏</h4><p>道教典籍总汇。收书50种，共计180卷。明张国祥编。明神宗万历三十五年，为了弥补《正统道藏》的不足而下诏编修。分装32函，仍以千中文编号，起“杜”字，迄“缨”字，上接《正统道藏》。</p><h4 id="诸真玄奥集成"><a href="#诸真玄奥集成" class="headerlink" title="诸真玄奥集成"></a>诸真玄奥集成</h4><p>气功内丹术丛书。明涵蟾子编。收书9种，共计9卷。卷一为黄自如的《金丹四百字解》，卷二为石泰的《还源篇》，卷三为薛式的《还丹复命篇》，卷四为陈楠的《翠虚篇》，卷五为涵蟾子的《金液还丹思金图发摄》，卷六为白玉蟾的《指玄篇》，卷七为萧廷芝的《金丹大成集》，卷八为赵友钦的《仙佛同源》，卷九为许逊的《石函记》，均为内丹名著，很有参考价值。</p><h4 id="道言内外秘诀全书"><a href="#道言内外秘诀全书" class="headerlink" title="道言内外秘诀全书"></a>道言内外秘诀全书</h4><p>道教炼养全书。收书56种，共计63卷。明彭好古编。所收均为道教练养名著，如《阴符经》、《道德经》、《胎息经》、《钟吕二仙传道集》、《金丹歌》、《得道歌》、《古文参同契》等。其中《参同契》、《入药镜》、《悟真篇》、《金丹四百字》、《金碧古文龙虎上经》等，均系彭氏自注，有其自己的心得和见解。</p><h4 id="方壶外史"><a href="#方壶外史" class="headerlink" title="方壶外史"></a>方壶外史</h4><p>气功内丹术丛书。收书15种，共计8卷。明陆西星撰。又名《方壶外史丛编》。陆西星为内丹东派之领袖，著述颇多。万历初年，赵宋汇集陆氏著作10种，分为8卷刊印，名曰《方壶外史》，后陆续有补刻。然而流传时久。逐渐散佚。民国4年，郑观应等据明版《方壶外史丛编》目录，重新排印，将书依乾、坤、离、坎、屯、蒙、既、未八字分为8集，共收陆氏著述15种。曰《无上玉皇心印妙经测疏》、《黄帝阴符经测疏》、《老子道德经玄览》、《周易参同契测疏》、《周易参同契口义》、《张紫阳悟真篇小序》、《崔公入药镜测疏》、《吕真人百字碑测疏》、《张紫阳金丹四百字测疏》、《龙眉子金丹印证测疏》、《丘真人青天歌测疏》、《玄肤论》、《金丹就正篇》、《金丹大旨图》、《七破论》。或阐释丹经，或答疑解惑，其论精当全面，直揭丹道玄奥，颇具特色。</p><h3 id="清"><a href="#清" class="headerlink" title="清"></a>清</h3><h4 id="金仙证论"><a href="#金仙证论" class="headerlink" title="金仙证论"></a>金仙证论</h4><p>气功内丹术著作。不分卷。清柳华阳撰注。柳华阳为伍守阳弟子，世称“伍柳派”。此书共20篇，专论小周天功夫，自称“又恐学者错认门户，重加亲注，道合仙佛之真机，工用自己之效验，诚为二门登堂入室之良方者矣”。可见作者颇为自信。柳华阳继承师说，亦以火候为小周天功夫的要领，特撰《风火经》（第六章）大书特书，确实做到了无幽不阐、无微不显的程度。由于此书比较浅显明白，容易读懂，并且步骤井然，易学易练，因此受到后世的普遍欢迎。</p><h4 id="慧命经"><a href="#慧命经" class="headerlink" title="慧命经"></a>慧命经</h4><p>气功内丹术著作。不分卷。清柳华阳撰注。全书共20篇，图文并茂，内容精细。全经强调性命双修，《正道禅机直论》指出：“不识性命.则大道无所成。”又曰：“佛道性命喻龙虎，龙虎喻动静，动静喻禅机。”性指心与神，命指身与气，心肾相交，水火既济，阴平阳秘，则慧命而不外耗，以风喻呼吸，以火喻意念，凝神气穴，风吹火炼而成真神，这是全书的要点，故曰《慧命经》。</p><h4 id="金华宗旨"><a href="#金华宗旨" class="headerlink" title="金华宗旨"></a>金华宗旨</h4><p>气功内丹术著作。1卷。清代著作，托名于吕岩。又名《太乙金华宗旨》。论气功静坐要旨，共13篇。书中称“法子欲入静，先调摄身心，自在安和，放下万缘，一丝不挂，天心正位乎中。然后两目垂帘，……次以二目内照坎宫（腹），光华所到。真阳即出以应之。……诶其冥冥中，忽然天心一动，此则一阳来复，活子时也。……天心一动，即以真意上升乾宫（首），面神光视顶，为导引焉。此动而应时者也。天心既升乾顶，游扬自得，忽而欲寂，急以真意引入黄庭，而目光视中黄神室焉。……即此便是凝神入气穴”（《逍遥决第八》）。入手工夫，不外乎此。总之，强调“心传”、“心法”，简明直截，不似伍柳派内丹功法的节目繁多，这是它的特点。书未附有（金华宗旨阐幽问答）1卷。不题撰人。共20条，独标心学，是气功中受禅学、陆王心学影响后的作品，对理解《金华宗旨》有一定帮助。</p><h4 id="天仙金丹心法"><a href="#天仙金丹心法" class="headerlink" title="天仙金丹心法"></a>天仙金丹心法</h4><p>气功内丹术著作。2卷。清代著作，托名吕岩等撰，八洞仙祖合注。卷首有托名张道陵等序及心法发凡等17篇，卷未有抑守元等后跋8窟。正文16藏：立志、端品、悔过、迁善、筑基、炼已、安炉、采药、起火、熄火、结胎、养婴、积行、行动、面壁、飞升。主张性命双修，培补后天以复先天。</p><h4 id="玄宗正旨"><a href="#玄宗正旨" class="headerlink" title="玄宗正旨"></a>玄宗正旨</h4><p>道教炼养著作。1卷。清代著作，托名吕岩等仙真降笔。前有柳守元题词，称此书“于以见南北玄学宗旨在是。凡金丹至秘之诀，妙道至极之功，无不备载于此中”，可谓推崇备至。其书虽系伪托，然说理明白。功法简要，对于初学较为便捷，因此流传颇广。</p><h4 id="唱道真言"><a href="#唱道真言" class="headerlink" title="唱道真言"></a>唱道真言</h4><p>道教炼养著作。5卷。清鹤曜子编录。此书系乱坛降笔，首言炼心，次炼命，次炼丹、炼气、炼神、炼形等，终至于还虚成功。此书强调炼心的重要性，认为必须炼得方寸之间，如一粒水晶珠子，如一座琉璃宝瓶。无穷妙义，便从自已心源悟出，念念圆通，心心朗彻，则自古来仙家不传之秘，至此无不了然，结丹在此，玄关一窍亦在此。其学术思想渊源于道家北宗，而侧重融禅入玄，尤具自己特色。陈樱宁先生对此书评价颇高，认为“书中道理讲得不错，自成一家言，比较现在的乩坛文章，真有霄壤之别”（《道教与养生答复苏州张道初君十五问》）。</p><h4 id="乐育堂语录"><a href="#乐育堂语录" class="headerlink" title="乐育堂语录"></a>乐育堂语录</h4><p>气功内丹术著作。5卷。清黄元吉撰。作者在清代道光、咸丰年间（1821—1860）讲道于四川乐育堂，传授进门心法，由其弟子记录，并经核正而刊为此书。其书授儒入道，因佛证真，理事兼举，性命并重。始则修性以立命，继则修命以了性，终则福慧双圆，性命合一，而证入圣登真之功。道家传授气功内丹修炼的典籍，古称“丹经”，为数虽然不少，然而大多隐晦曲折，奥雅难通。往往不病于偏执枯滞，即病于玄奥幽眇，不隐于龙虎铅汞，即遁于坎离水火，使读者不穷毕生之精力，即难得融会贯通，不获明师之指点，即难以心领神会。本书则一扫此弊，说理朴实而不奥，述义精细而易明，对于行功次第，更是步骤井然。道教学者萧天石先生认为此书：“深者能得其深，浅者能得其浅，无论上智下愚，皆可循此而升堂入室，诚性学之梯航，命家之津逮也”。</p><h4 id="道窍谈"><a href="#道窍谈" class="headerlink" title="道窍谈"></a>道窍谈</h4><p>气功内丹术著作。不分卷。清李西月撰。全书共40章，详论西派丹法要抄。计有藐诸友书、开关问答、后天集解、筑基炼已、养已炼已、后天次序、内外二药、药物相类、三品互养、炼功五关、产药层次、药物层次、丹砂二种、神气性命、先天直指、神气精论、精气神论、性命顺逆、玄关一窍、玄关再说、两孔穴法、玄牡根基、中字直指、药物直陈、铅汞的辩、鼎器直说、乾坤离坎、采炼炒用、河车细旨、真心论、心神直说、神息妙用、神意再论、气息妙用、神意妙用等章。这些内容基本上包括了内丹修炼中的各种技术问题，故对初学者有入门引路的作用。</p><h4 id="三车秘旨"><a href="#三车秘旨" class="headerlink" title="三车秘旨"></a>三车秘旨</h4><p>气功内丹术著作。不分卷。清李西月撰。书中论述了以下问题：入门初步收心法、第一河车、第二河车、第三河车、河车细旨、勤字说、共争不朽之论等。所言三车，是指三件河车：第一件运气，即小周天，子午运火也；第二件运精，即玉液河车，运水温养也；第三件精气兼运，即大周天，运先天金汞，七返还丹，九还大丹也。此三车者，皆以其神真意斡乎其中，人能知三车秘谛，则精、气、神三品圆全，天、地、人三仙成就。该书对内丹修炼中河车理论抉幽发微，阐述透彻，颇能给人以启迪。</p><h4 id="玄微心印"><a href="#玄微心印" class="headerlink" title="玄微心印"></a>玄微心印</h4><p>气功内丹术著作。2卷。清喻太真等合撰。全书本东派宗旨而论阴阳双修丹法。卷上有论阴阳门户、黄金土釜、奇经八脉、任督两脉等37章；卷下有胎息、铸剑、筑基等7章。</p><h4 id="元真录"><a href="#元真录" class="headerlink" title="元真录"></a>元真录</h4><p>气功内丹术著作。3卷。清董德宁撰。内收《丹道发微》、《仙传宗源》、《性学筌蹄》各1卷。收入《道贯真源》中。</p><h4 id="试金石"><a href="#试金石" class="headerlink" title="试金石"></a>试金石</h4><p>气功内丹术著作。1卷。清傅金铨撰。该书篇首强调内丹长生之道，以炼已筑基，修复巳损元体为本。认为“筑基成则具六通之一，所谓无漏尽通，即可以长生不死”。特别是对老年体衰之人，男子精枯气竭.须要使其无精而复有精，然后由有精而炼至无精，“并无精窍，小便缩如童子”；女子气血久亏，要使无血而生血，复有月信，然后由有经水而炼至无经水，“斩断赤龙，身如处女”，精血皆得化气，则筑基之功成矣。论述筑基之法，力主“神仙栽接”之双修，以为“只知独坐孤修，不知离宫入定，坎府求玄”，是“爱身家而不惜性命”、难得长生。书中通过与弟子答问的形式，就双修、可笑、心肾、家中、黄婆、伴侣、炉鼎、铅汞、火药、子时、潮信、卯酉、沐浴等24个方面的问题，引经据典，证诸圣真，作了具体的阐述。</p><h4 id="修真辩难"><a href="#修真辩难" class="headerlink" title="修真辩难"></a>修真辩难</h4><p>气功内丹术著作。2卷。清刘一明撰。其书以师徒问答形式，阐述内丹功理。作者认为内丹乃性命凝结而成，所以必须性命双修，指出性命之道与阴阳之道密切相关，性命为阴阳之体，阴阳为性命之用。性即理，命即气，气不离理，理不离气，因此性不离命，命不离性，浑然一体，不容分割。修性即能立命，所以修行者必须重视修性，“不能修性，焉能立命?益性者命之寄，命者性之存，性命原是一家，焉得不修性?”要求性命双修而侧重先性后命。</p><h4 id="修真九要"><a href="#修真九要" class="headerlink" title="修真九要"></a>修真九要</h4><p>道教炼养著作。1卷。清刘一明撰。此书系作者传述其师砻谷老人之说。共九要为：勘破世事第一，积德修行第二，尽心穷理第三.访求真师第四，练已筑基第五，和合阴阳第六，审明火候第七，外药了命第八，内药了性第九。作者认为修真之道，乃天下至大至难大事，非深明造化，洞晓阴阳，存经久不易之志。循序渐进者不能行之，故提出修真纲领由浅入深，总为九条。</p><h4 id="上品丹法节次"><a href="#上品丹法节次" class="headerlink" title="上品丹法节次"></a>上品丹法节次</h4><p>气功内丹术著作。1卷。清闵一得编撰。本书论述内丹功法层次，简明扼要，全书共12篇。前3篇系李德洽原著，文未均有闵一得详细注释。所论上品丹法实熔道教南北宗之内丹功法。作者以儒合道，从养生角度来谈内丹修炼，强调“存诚”。后9篇系闵氏所撰，基本属于《性命圭旨》所架设的内丹体系。</p><h4 id="女宗双修宝筏"><a href="#女宗双修宝筏" class="headerlink" title="女宗双修宝筏"></a>女宗双修宝筏</h4><p>内丹术女功著作。1卷。清沈一炳撰。全称《泥丸李祖师女宗双修宝筏》，原书有副标题《女功指南》。作者述其师李泥丸女丹要诀，再传弟子闵一得重订。陈樱宁论女子修炼有六派，其中“孙不二元君派”以“斩赤龙”下手为特征《教道与养生》。本书即属此体系。全书共分9节每节先列“泥丸氏曰”为正文再低一字列“大虚氏（沈一炳号）曰”为法文。书未有闵一得跋。</p><h4 id="女修正途"><a href="#女修正途" class="headerlink" title="女修正途"></a>女修正途</h4><p>内丹术女功著作。1卷。清闵一得编撰。全称《西王母女修正途十则》。原题吕祖师申正重题，孙元君遵剔补述大虚翁沈太师授，受业弟子闵一得注。本书系道教北宗龙门派女子内丹功法之一，属“孙不二元君派”体系，全书10则，每则皆冠“若曰”二字。每则正文之后皆有闵一得的注文，以“谨接”二字识之。</p><h4 id="养生十三则阐微"><a href="#养生十三则阐微" class="headerlink" title="养生十三则阐微"></a>养生十三则阐微</h4><p>气功养生著作。1卷。清闵一得撰。内容为两手握固、舌抵上腭、神游水府等13则。前1O则内容与传统的八段锦、十二段锦相似；后3则强调练功时静态要求。</p><h4 id="梅华问答编"><a href="#梅华问答编" class="headerlink" title="梅华问答编"></a>梅华问答编</h4><p>气功内丹术著作。1卷。清薛阳桂撰。作者为闵一得弟子，此书即禀承师说，发挥北宗龙门派内丹术的理论与功法。书中实为作者与来客陶既若、韩洞然、僧慧澈、许洞雷诸人，于八月望日赏桂于竹影梅华馆讨论内丹术。由作者记录上述诸人之发言，编成此书。</p><h4 id="大成捷要"><a href="#大成捷要" class="headerlink" title="大成捷要"></a>大成捷要</h4><p>气功内丹术著作。3卷。清代著作，不题撰人。据说此书原为柳华阳的修道练功笔记，亦有可能是民国时人精选各种丹经要语汇编而成。此书原藏于河南登封县嵩山崇福官，后道士王乾一云游至该宫，从常住马宇秀炼师处获观此书，抄录一通携归，藏于山东崂山太清宫。于民国初年传出。本书编排虽欠清整，然其“节次功夫戌臻玄妙，拟义立论尤其精工”，从下手以迄成功，一一详细说明，颇有参考价值。</p><h4 id="老老恒言"><a href="#老老恒言" class="headerlink" title="老老恒言"></a>老老恒言</h4><p>气功养生著作。清曹庭栋撰。又名《养生随笔》。作者参阅三百余家有关养生的著作，并结合日常生活衣食住行等方面，总结出一整套简便易行的养生方法。书中详细介绍了老年人的安寝、晨兴、梳洗、饮食、散步等饮食起居、养生导引方法。作者认为“静养为摄生首务”，但也强调老年人必须经常修炼气功或运动，借以活动关节，强壮筋骨。</p><h4 id="勿药元诠"><a href="#勿药元诠" class="headerlink" title="勿药元诠"></a>勿药元诠</h4><p>气功养生著作。清汪昂撰。作者为明末诸生入请弃举子业而潜心医学。撰有医学普及著作多种。《勿药元诠》为《医方集解》之附录，介绍养生修炼方法，其中如调息、小周天等，经此书介绍流传日广。</p><h4 id="寿世青编"><a href="#寿世青编" class="headerlink" title="寿世青编"></a>寿世青编</h4><p>气功养生著作。2卷。清尤乘撰。上卷为“勿药须知”主要讨论气功养生方法；下卷为“服药须知”，主要讨论服药却病忌宜。书未附有“病后调理服食法”。“勿药须知”主要强调通过调心神、养性情来修身防病，达到长寿的目的。书中对有关保健内容作了专题论述。还载有导引却病法、小周天法等气功内容。</p><h4 id="寿世传真"><a href="#寿世传真" class="headerlink" title="寿世传真"></a>寿世传真</h4><p>气功养生著作。8卷。清徐文弼撰。作者主张气功导引应与综合调摄并重，提出修养宜行内外功，要宝精宝气宝神，还须知要知忌知伤，注意四时调理和饮食调理。在外功方面，有针对五官、四肢、腰背的按摩之术，及提倡应用十二段锦、八段锦和六字真言。内功则是静坐运气方法。本书内容涉及广泛，收罗前人经验甚多对后世的保健养生有一定的影响。</p><h4 id="陆地仙经"><a href="#陆地仙经" class="headerlink" title="陆地仙经"></a>陆地仙经</h4><p>气功养生著作。清马齐撰。本书由五言二十句组成，共计百字，作者通过注解，介绍了养生调摄及气功导引的体方法。</p><h4 id="内功图说"><a href="#内功图说" class="headerlink" title="内功图说"></a>内功图说</h4><p>气功养生著作。1卷。清潘霓撰。原名《卫生要术》，1935年韩慕侠重印此书，改名《健康之路》。内收十二段锦、分行内外功、易筋经、却病延年法等功法，载有姿式图35帧并配以简单的文字说明，图文并茂，易于摹仿学习。故历年来翻印较多。</p><h4 id="彩墨导引图"><a href="#彩墨导引图" class="headerlink" title="彩墨导引图"></a>彩墨导引图</h4><p>气功导引图谱。1卷。清昆岚编绘。此书按病证设问以导引治法及简要治疗机理作答。并按式绘图，施以彩色，墨线勾勒，颇为细致。其中坐式9幅，立式、卧式各6幅，蹲式2幅，跪式1幅，共计24幅。</p><h4 id="寿人经"><a href="#寿人经" class="headerlink" title="寿人经"></a>寿人经</h4><p>气功导引著作。清汪思撰。内容包括：理脾土诀、理肺金诀、理肾水诀、理肝木诀、理心火诀、坐功诀、导引诀。介绍了一套调治五脏为主的动功锻炼养生方法。</p><h4 id="延年九转法"><a href="#延年九转法" class="headerlink" title="延年九转法"></a>延年九转法</h4><p>气功按摩著作。清方开撰。此法以转摩腹脘为特色，共计九法，每法均有图与图解。最后“全图说”指出：“摩腹之法，以动化静，以静运动，合乎阴阳，顺乎五行，发其生机，神其变化。故能通和上下，分理阴阳，去旧生新，充实五脏，驱外感之诸邪，清内生之百证，补不足，泻有余，消食之道，妙应无穷，何须借药烧丹，自有却病延年实效耳”。</p><h4 id="调气圭臬图说"><a href="#调气圭臬图说" class="headerlink" title="调气圭臬图说"></a>调气圭臬图说</h4><p>气功养生著作。清李九华撰。全套功法共46式，配图32幅。前23式以导引配合深呼吸中4式以导引配合自然呼吸，末19式以自我捶打导气。所有功式均以禽鸟动态命名，如风翥鸾停等。本功取《拳经》壮气强筋之要诀，导源于武术。</p><h4 id="张氏医通"><a href="#张氏医通" class="headerlink" title="张氏医通"></a>张氏医通</h4><p>综合性医药著作。16卷。清张潞撰。本书“神志门”中详尽描述了“走火入魔”的原因、表现与药物治疗。作者认为炼士坐功运气之走火与常人有别，但遍考方书，从无及此，故详推治例，撰成此篇。此外、作者<br>对养性也颇有见地。</p><h4 id="杂病源流考"><a href="#杂病源流考" class="headerlink" title="杂病源流考"></a>杂病源流考</h4><p>中医内科专著。30卷。清沈金鳌撰。为丛书《沈氏尊生书》中之一种。作者认为“导引运功本养生家修炼要诀，但欲长生，必先却病，其所导所运，皆属却病之法，令附于篇未，病者遵而行之，实可佐参药力所不逮”。对于疾病治疗，罗列方药、导引、运功各项治法。卷首总论脉象，并附录明曹士珩《保生秘要》运功规法，相当于练功原则与通用功法。</p><h4 id="重刊道藏辑要"><a href="#重刊道藏辑要" class="headerlink" title="重刊道藏辑要"></a>重刊道藏辑要</h4><p>道教要籍丛书。收书300余种，共计若干卷。清彭定求编。光绪三十三年（1906），成都二仙庵重刻，由阎永和删除2种，增加20种，并新增贺龙壤所编《重刊道藏辑要总目》1卷、《重刊道藏辑要子目初编》及《续篇》一卷，《道门一切经总目》4卷。全书按二十八宿字号分为28集，择要收录道教重要经典、历代祖师著作、科仪戒律、碑传谱记、气功摄生诸类著作。不仅深得《道藏》之精要，而且保存了不少明清两代道教的重要著作。</p><h4 id="古书隐楼藏书"><a href="#古书隐楼藏书" class="headerlink" title="古书隐楼藏书"></a>古书隐楼藏书</h4><p>道教炼养丛书。收书38种，共计51卷。清闵一得编。这是一部著名的气功学文献丛书。多数由编者自撰。计有《碧菀坛经》5卷、《修真辩难参证》2卷、《阴符经玄解正义》l卷、《金丹四百字注解》1卷、《太乙金华宗旨》1卷、《吕祖师三尼医世说述》1卷、《吕祖师三尼医世功诀》1卷、《皇极阐辟证道仙经》3卷、《寥阳殿问答编》1卷，等等。全书内容复杂，既有对道佛气功经典的注释，又有个人修炼心得的阐述；既对各种丹家邪说加以大力批驳，又对学道修炼的各种清规戒律作详尽论述。提倡三教功法合一，而于道教功法尤为推崇，故于道教内炼之法，论述特别详尽。</p><h4 id="道统大成"><a href="#道统大成" class="headerlink" title="道统大成"></a>道统大成</h4><p>气功内丹术丛书。收书10种，共计25卷。清汪启菱编。计有《周易参同契阐幽》3卷、《周易参同契测疏》3卷、《周易参同契口义》2卷、《中和集》6卷、《规中指南》6卷、《入药镜》1卷、《金丹四百字测疏》1卷、《明道篇》1卷、《列位女真诗歌》1卷、《坤道丹诀》1卷。</p><h4 id="张三丰全集"><a href="#张三丰全集" class="headerlink" title="张三丰全集"></a>张三丰全集</h4><p>道教炼养丛书。收书近2O种，共计8卷。清李西月编。原书卷一为序、浩、传、仙派、正讹、显迹；卷二为古文、隐鉴；卷三为大道论、玄机直讲、道言浅近说；卷四为玄要篇；卷五为云水集；卷六为天口篇、训世文，卷七为九皇经、三教经、度人经、菩提经、钟揭；卷八为水石闲谈、古今题赠、隐镜、汇记。</p><h4 id="道贯真源"><a href="#道贯真源" class="headerlink" title="道贯真源"></a>道贯真源</h4><p>气功内丹术丛书。收书9种，共计28卷。清董德宁编撰。作者自撰的有《用易参同契正义》3卷，《悟真篇正义》3卷、《元丹篇》1卷、《大上黄庭经发微》2卷、《黄帝阴符经本义》2卷、《老子道德经本义》2卷、《元真录》3卷（含《丹道发微》、《仙传宗源》、《性学筌蹄》各1卷）。辑录的有《修真六书》9卷，还有章世乾的《元丹篇约注》3卷。所收多为内丹术要籍。</p><h4 id="修真六书"><a href="#修真六书" class="headerlink" title="修真六书"></a>修真六书</h4><p>气功内丹术丛书。收书6种，共计8巷。靖董德宁编。该书收入了道教南宗五祖及其传人最著名的内丹文献，计有张伯端《悟真外篇》2卷，石泰《还源篇》1卷，薛式《复命篇》1卷，陈楠《翠虚篇》1卷，白玉蟾《紫清指玄集》2卷，以及白玉蟾的再传弟子萧廷芝的《金丹大成集》2卷。</p><h4 id="道言五种"><a href="#道言五种" class="headerlink" title="道言五种"></a>道言五种</h4><p>气功内丹术丛书。收书5种，共计11卷。清陶素耜编撰。其中作者自撰的为《周易参同契脉望》3卷，《悟真篇约注》3卷，《承志录》3卷，订定的为《金丹就正篇玄肤论》1卷，《金丹大要》1卷。作者反映南宗中双修一派观点。</p><h4 id="证道秘书"><a href="#证道秘书" class="headerlink" title="证道秘书"></a>证道秘书</h4><p>气功内丹术丛书。收书10种，共计17卷。清傅金铨编撰。其中自撰的有《杯溪录》3卷，《赤水吟》1卷，《丹经示读》1卷，《天仙正理读法点睛》1卷，《道海津梁》1卷。他人所撰的有邱处机的《邱祖全书》1卷，喻太真等的《玄微心印》2卷，张三丰的《三丰丹诀》1卷，以及不署撰人姓名的《外金丹》、《内金丹》各1卷。</p><h4 id="济一子道书"><a href="#济一子道书" class="headerlink" title="济一子道书"></a>济一子道书</h4><p>道教炼养丛书。收书7种，共计32卷。清傅金铨撰。其中为《一贯真机易简录》12卷，《度人梯经》8卷，《自题所画》1卷，《性天正皓》1卷，《摄阳经》1卷《附集1卷》，《心学》3卷，《道书五篇注》5卷（含《黄鹤赋》、《百句章》、《真经歌》、《鼎器歌》、《采金歌》各1卷）。其主要内容是将道教前贤有关修身养性及内炼的语录分门别类加以集录，并作注解。民国时上海江左书林留将该书与《证道秘书》合刊，题名《道书十七种》印行。</p><h4 id="道书十二种"><a href="#道书十二种" class="headerlink" title="道书十二种"></a>道书十二种</h4><p>道教炼养丛书。收书12种，共计39卷。清刘一明撰。计有《周易阐真》4卷，《卦图》1卷，《孔易阐真》2卷，《参同契经文直指》2卷，《参同契直指笺注》2卷，《参同契直指三相类》2卷，《悟真直指》4卷，《会心集内集》2卷，《会心集外集》2卷，《指南针》12卷（含《阴符经注》等10种），《象言破疑》2卷，《通关文》2卷，《悟道录》2卷。</p><h4 id="伍柳仙宗"><a href="#伍柳仙宗" class="headerlink" title="伍柳仙宗"></a>伍柳仙宗</h4><p>气功内丹术丛书。收书4种。清邓徽绩编。内收明伍守阳的《天仙正理直论》、《仙佛合宗语录》和清柳华阳的《慧命经》、《金仙证论》。该书汇集了伍柳派气功内丹术的精华，刊行之后风行遐迩，影响甚大，甚至远及日本与东南亚。</p><h4 id="女丹合编"><a href="#女丹合编" class="headerlink" title="女丹合编"></a>女丹合编</h4><p>气功内丹术女功丛书。收书17种，共计19卷。清贺龙骧编，计有孙不二撰《坤元经》1卷，《坤诀》1卷，《女修程途》1卷（即《不二元君法语》），清烈古佛撰《女丹十则》1卷，周中贞撰《女金丹》2卷，傅金铨述《樵阳经女工修炼》1卷，不著撰人《坤宁经》1卷，二蛾山人述《女工炼已还丹田说》1卷等。</p><h4 id="颐身集"><a href="#颐身集" class="headerlink" title="颐身集"></a>颐身集</h4><p>气功养生丛书。收书5种，共计5卷。清叶志铣编。计收邱处机撰《摄生消息论》1卷，冷谦撰《修龄要旨》1卷，汪昂撰《勿药元论》1卷，汪政撰《寿人经》1卷，方开撰《延年九转法》1卷，均为气功养生名著。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;中国古代气功历史悠久，流派多，内容丰富。自先秦到清代，有气功文献数千种。以下对一些主要的气功古籍，按年代进行整理，并对主要内容进行介绍，希望能对气功爱好者有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;先秦&quot;&gt;&lt;a href=&quot;#先</summary>
      
    
    
    
    <category term="教程分享" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
    
    <category term="文献资料" scheme="https://www.buerya.cn/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/%E6%96%87%E7%8C%AE%E8%B5%84%E6%96%99/"/>
    
    
    <category term="文献资料" scheme="https://www.buerya.cn/tags/%E6%96%87%E7%8C%AE%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
</feed>
