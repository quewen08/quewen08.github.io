<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2018年Android面试题整理 | 南山结庐</title><meta name="author" content="东篱先生"><meta name="copyright" content="东篱先生"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="这是我近段时间收集的面试题，献给打算年后找工作的同学们。文中涉及的知识比较广也可能比较零散，并且一些较为基础的知识我都略去了（比如Android四大组件是什么这类问题），有些我附上了自己的理解，有些附上了详细的相关文章链接。大家挑自己感兴趣的内容查看即可，后期我也会继续不断补充。 基础组件篇横竖屏切换时Activity的生命周期变化 如果自己没有配置android:ConfigChanges，这时">
<meta property="og:type" content="article">
<meta property="og:title" content="2018年Android面试题整理">
<meta property="og:url" content="https://www.buerya.cn/2018/questioninterview2018/index/index.html">
<meta property="og:site_name" content="南山结庐">
<meta property="og:description" content="这是我近段时间收集的面试题，献给打算年后找工作的同学们。文中涉及的知识比较广也可能比较零散，并且一些较为基础的知识我都略去了（比如Android四大组件是什么这类问题），有些我附上了自己的理解，有些附上了详细的相关文章链接。大家挑自己感兴趣的内容查看即可，后期我也会继续不断补充。 基础组件篇横竖屏切换时Activity的生命周期变化 如果自己没有配置android:ConfigChanges，这时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.buerya.cn/img/avatar.png">
<meta property="article:published_time" content="2018-09-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-19T14:40:00.262Z">
<meta property="article:author" content="东篱先生">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.buerya.cn/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.buerya.cn/2018/questioninterview2018/index/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="ar7mIVYsjkAi2k9jIuWk34S9A2aVwBdQqFkfL4AKEBQ"/><meta name="qihu_site_verification" content="d182b3f28525f2db83acfaaf6e696dba"/><meta name="baidu-site-verification" content="code-HKm4Y74Eag"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?201056ecd8ffd09f6d28ab64cfa95a00";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2018年Android面试题整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-19 22:40:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/assets/fonts/font.css"> <link rel="stylesheet" href="/assets/css/import_style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="南山结庐" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-table-list"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-cubes"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/memos/"><i class="fa-fw fa fa-cloud-rain"></i><span> 说说</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://p2.ssl.qhimg.com/bdr/__85/t0123d36a2655435cb9.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="南山结庐"><span class="site-name">南山结庐</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-table-list"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-cubes"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/memos/"><i class="fa-fw fa fa-cloud-rain"></i><span> 说说</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2018年Android面试题整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-09-04T16:00:00.000Z" title="发表于 2018-09-05 00:00:00">2018-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-19T14:40:00.262Z" title="更新于 2022-10-19 22:40:00">2022-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/">教程分享</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2018年Android面试题整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这是我近段时间收集的面试题，献给打算年后找工作的同学们。文中涉及的知识比较广也可能比较零散，并且一些较为基础的知识我都略去了（比如Android四大组件是什么这类问题），有些我附上了自己的理解，有些附上了详细的相关文章链接。大家挑自己感兴趣的内容查看即可，后期我也会继续不断补充。</p>
<h2 id="基础组件篇"><a href="#基础组件篇" class="headerlink" title="基础组件篇"></a>基础组件篇</h2><h3 id="横竖屏切换时Activity的生命周期变化"><a href="#横竖屏切换时Activity的生命周期变化" class="headerlink" title="横竖屏切换时Activity的生命周期变化"></a>横竖屏切换时Activity的生命周期变化</h3><ul>
<li>如果自己没有配置<code>android:ConfigChanges</code>，这时默认让系统处理，就会重建Activity，此时Activity的生命周期会走一遍。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/img/questioninterview2018/161bb552a99f8490_tplv-t2oaga2asx-watermark.awebp"></p>
<blockquote>
<h2 id="onSaveInstanceState-与-onRestoreIntanceState"><a href="#onSaveInstanceState-与-onRestoreIntanceState" class="headerlink" title="onSaveInstanceState() 与 onRestoreIntanceState()"></a><code>onSaveInstanceState() 与 onRestoreIntanceState()</code></h2><p>资源相关的系统配置发生改变或者资源不足：例如屏幕旋转，当前Activity会销毁，并且在onStop之前回调onSaveInstanceState保存数据，在重新创建Activity的时候在onStart之后回调onRestoreInstanceState。其中Bundle数据会传到onCreate（不一定有数据）和onRestoreInstanceState（一定有数据）。<br>用户或者程序员主动去销毁一个Activity的时候不会回调，其他情况都会调用，来保存界面信息。如代码中finish（）或用户按下back，不会回调。</p>
</blockquote>
<ul>
<li>如果设置<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</code>，此时Activity的生命周期不会重走一遍，Activity不会重建，只会回调onConfigurationChanged方法。</li>
</ul>
<h3 id="activity的startActivity和context的startActivity的区别"><a href="#activity的startActivity和context的startActivity的区别" class="headerlink" title="activity的startActivity和context的startActivity的区别"></a>activity的startActivity和context的startActivity的区别</h3><ol>
<li>从Activity中启动新的Activity时可直接mContext.startActivity(intent)就好；</li>
<li>如果从其他Context中启动Activity则必须给intent设置Flag:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">mContext.startActivity(intent);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="介绍下Android应用程序启动过程"><a href="#介绍下Android应用程序启动过程" class="headerlink" title="介绍下Android应用程序启动过程"></a>介绍下Android应用程序启动过程</h3><p>整个应用程序的启动过程要执行很多步骤，但是整体来看，主要分为以下五个阶段：</p>
<blockquote>
<ol>
<li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</li>
<li>ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</li>
<li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</li>
<li>ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</li>
<li>ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</li>
</ol>
</blockquote>
<h3 id="如何保证Service不被杀死？"><a href="#如何保证Service不被杀死？" class="headerlink" title="如何保证Service不被杀死？"></a>如何保证Service不被杀死？</h3><ul>
<li><p>提供进程优先级，降低进程被杀死的概率<br>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。<br>方法二：启动前台service。<br>方法三：提升service优先级：<br>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority &#x3D; “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>
</li>
<li><p>在进程被杀死后，进行拉活<br>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等<br>方法二：双进程相互唤起。<br>方法三：依靠系统唤起。<br>方法四：onDestroy方法里重启service：service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>
</li>
<li><p>依靠第三方 根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A&#x2F;B Test。</p>
</li>
</ul>
<h3 id="简述下Activity任务栈和使用方法"><a href="#简述下Activity任务栈和使用方法" class="headerlink" title="简述下Activity任务栈和使用方法"></a>简述下Activity任务栈和使用方法</h3><p>任务栈是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名.</p>
<ol>
<li><code>standard</code> <strong>默认模式</strong> 每次启动都会创建一个新的Activity对象，放到目标任务栈中。</li>
<li><code>singleTop</code> 判断当前的任务栈顶是否存在相同的activity对象，如果存在，则直接使用，如果不存在，那么创建新的activity对象放入栈中</li>
<li><code>singleTask</code> 在任务栈中会判断是否存在相同的activity，如果存在，那么会清除该activity之上的其他activity对象显示，如果不存在，则会创建一个新的activity放入栈顶</li>
<li><code>singleIntance</code> 会在一个新的任务栈中创建activity，并且该任务栈种只允许存在一个activity实例，其他调用该activity的组件会直接使用该任务栈种的activity对象</li>
</ol>
<p>方法一： 使用android:launchMode&#x3D;”standard|singleInstance|single Task|singleTop”来控制Acivity任务栈。<br>方法二： Intent Flags：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Intent intent=<span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClass(MainActivity.<span class="built_in">this</span>, MainActivity2.class);</span><br><span class="line">intent.addFlags(Intent. FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Flags有很多，比如：<br>Intent.FLAG_ACTIVITY_NEW_TASK 相当于singleTask<br>Intent. FLAG_ACTIVITY_CLEAR_TOP 相当于singleTop</p>
<h3 id="Context相关问题"><a href="#Context相关问题" class="headerlink" title="Context相关问题"></a>Context相关问题</h3><p>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper.<br>每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象<br>getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法.getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。</p>
<p>Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application.<br>那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。</p>
<h3 id="怎么在Service中创建Dialog对话框"><a href="#怎么在Service中创建Dialog对话框" class="headerlink" title="怎么在Service中创建Dialog对话框"></a>怎么在Service中创建Dialog对话框</h3><ol>
<li>在我们取得Dialog对象后，需给它设置类型，即：<br><code>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)</code></li>
<li>在Manifest中加上权限:<br><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code></li>
</ol>
<h2 id="View篇"><a href="#View篇" class="headerlink" title="View篇"></a>View篇</h2><h3 id="非UI线程可以更新UI吗？"><a href="#非UI线程可以更新UI吗？" class="headerlink" title="非UI线程可以更新UI吗？"></a>非UI线程可以更新UI吗？</h3><p>可以<br>当访问UI时，<code>ViewRootImpl</code>会调用<code>checkThread()</code>方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常<br>执行<code>onCreate</code>方法的那个时候<code>ViewRootImpl</code>还没创建，无法去检查当前线程<code>ViewRootImpl</code>的创建在<code>onResume()</code>方法回调之后.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非UI线程是可以刷新UI的，前提是它要拥有自己的<code>ViewRoot</code>,即更新UI的线程和创建<code>ViewRoot</code>是同一个,或者在执行<code>checkThread()</code>前更新UI.</p>
<h3 id="解决ScrollView嵌套ListView和GridView冲突的方法"><a href="#解决ScrollView嵌套ListView和GridView冲突的方法" class="headerlink" title="解决ScrollView嵌套ListView和GridView冲突的方法"></a>解决ScrollView嵌套ListView和GridView冲突的方法</h3><p>重写ListView的onMeasure方法，来自定义高度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">expandSpec</span> <span class="operator">=</span> MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; <span class="number">2</span>, MeasureSpec.AT_MOST);</span><br><span class="line">    <span class="built_in">super</span>.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要考察对MeasureSpec的三种模式的理解,<a target="_blank" rel="noopener external nofollow noreferrer" href="http://blog.csdn.net/btt2013/article/details/53447649">相关文章</a>.</p>
<h3 id="自定义View优化策略"><a href="#自定义View优化策略" class="headerlink" title="自定义View优化策略"></a>自定义View优化策略</h3><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>
<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>
<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>
<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>
<h2 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h2><h3 id="Handler、Message、Looper、MessageQueue"><a href="#Handler、Message、Looper、MessageQueue" class="headerlink" title="Handler、Message、Looper、MessageQueue"></a>Handler、Message、Looper、MessageQueue</h3><h4 id="相关概念的解释"><a href="#相关概念的解释" class="headerlink" title="相关概念的解释"></a>相关概念的解释</h4><ul>
<li>主线程（UI线程）<br>定义：当程序第一次启动时，Android会同时启动一条主线程（Main Thread）<br>作用：主线程主要负责处理与UI相关的事件</li>
<li>Message（消息）<br>定义：Handler接收和处理的消息对象（Bean对象）<br>作用：通信时相关信息的存放和传递</li>
<li>ThreadLocal<br>定义：ThreadLocal是线程内部的存储类，通过它可以实现在每个线程中存储自己的私有数据。即数据存储以后，只能在指定的线程中获取这个存储的对象，而其它线程则不能获取到当前线程存储的这个对象。<br>作用：负责存储和获取本线程的Looper</li>
<li>MessageQueue（消息队列）<br>定义：采用单链表的数据结构来存储消息列表<br>作用：用来存放通过Handler发过来的Message，按照先进先出执行</li>
<li>Handler（处理者）<br>定义：Message的主要处理者<br>作用：负责发送Message到消息队列&amp;处理Looper分派过来的Message</li>
<li>Looper（循环器）<br>定义：扮演Message Queue和Handler之间桥梁的角色<br>作用：<br>消息循环：循环取出Message Queue的Message<br>消息派发：将取出的Message交付给相应的Handler</li>
</ul>
<h4 id="自己画下图解"><a href="#自己画下图解" class="headerlink" title="自己画下图解"></a>自己画下图解</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/img/questioninterview2018/fff72bb7eec021cd437e03e0f655152d.jfif"></p>
<h4 id="Handler发送消息有哪几种方式？"><a href="#Handler发送消息有哪几种方式？" class="headerlink" title="Handler发送消息有哪几种方式？"></a>Handler发送消息有哪几种方式？</h4><ul>
<li>sendMessage(Message msg)</li>
<li>post(Runnable r)</li>
</ul>
<h4 id="Handler处理消息有哪几种方式"><a href="#Handler处理消息有哪几种方式" class="headerlink" title="Handler处理消息有哪几种方式"></a>Handler处理消息有哪几种方式</h4><p>直接看源码<code>dispatchMessage()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1. post()方法的处理方法</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. sendMessage()方法的处理方法</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. post()方法的最终处理方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. sendMessage()方法的最终处理方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Message、Handler、MessageQueue、Looper的之间的关系？"><a href="#Message、Handler、MessageQueue、Looper的之间的关系？" class="headerlink" title="Message、Handler、MessageQueue、Looper的之间的关系？"></a>Message、Handler、MessageQueue、Looper的之间的关系？</h4><p>首先，是这个MessagQueue，MessageQueue是一个消息队列，它可以存储Handler发送过来的消息，其内部提供了进队和出队的方法来管理这个消息队列，其出队和进队的原理是采用单链表的数据结构进行插入和删除的，即enqueueMessage()方法和next()方法。这里提到的Message，其实就是一个Bean对象，里面的属性用来记录Message的各种信息。</p>
<p>然后，是这个Looper，Looper是一个循环器，它可以循环的取出MessageQueue中的Message，其内部提供了Looper的初始化和循环出去Message的方法，即prepare()方法和loop()方法。在prepare()方法中，Looper会关联一个MessageQueue，而且将Looper存进一个ThreadLocal中，在loop()方法中，通过ThreadLocal取出Looper，使用MessageQueue的next()方法取出Message后，判断Message是否为空，如果是则Looper阻塞，如果不是，则通过dispatchMessage()方法分发该Message到Handler中，而Handler执行handlerMessage()方法，由于handlerMessage()方法是个空方法，这也是为什么需要在Handler中重写handlerMessage()方法的原因。这里要注意的是Looper只能在一个线程中只能存在一个。这里提到的ThreadLocal，其实就是一个对象，用来在不同线程中存放对应线程的Looper。</p>
<p>最后，是这个Handler，Handler是Looper和MessageQueue的桥梁，Handler内部提供了发送Message的一系列方法，最终会通过MessageQueue的enqueueMessage()方法将Message存进MessageQueue中。我们平时可以直接在主线程中使用Handler，那是因为在应用程序启动时，在入口的main方法中已经默认为我们创建好了Looper。</p>
<h4 id="为什么在子线程中创建Handler会抛异常？"><a href="#为什么在子线程中创建Handler会抛异常？" class="headerlink" title="为什么在子线程中创建Handler会抛异常？"></a>为什么在子线程中创建Handler会抛异常？</h4><p>Handler的工作是依赖于Looper的，而Looper（与消息队列）又是属于某一个线程（ThreadLocal是线程内部的数据存储类，通过它可以在指定线程中存储数据，其他线程则无法获取到），其他线程不能访问。因此Handler就是间接跟线程是绑定在一起了。因此要使用Handler必须要保证Handler所创建的线程中有Looper对象并且启动循环。因为子线程中默认是没有Looper的，所以会报错。<br>正确的使用方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Handler <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> mHandler;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">          mHandler.getLooper().quit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.run();</span><br><span class="line">          <span class="comment">//创建该线程对应的Looper,</span></span><br><span class="line">          <span class="comment">// 内部实现</span></span><br><span class="line">          <span class="comment">// 1。new Looper（）</span></span><br><span class="line">          <span class="comment">// 2。将1步中的lopper 放在ThreadLocal里，ThreadLocal是保存数据的，主要应用场景是：线程间数据互不影响的情况</span></span><br><span class="line">          <span class="comment">// 3。在1步中的Looper的构造函数中new MessageQueue();</span></span><br><span class="line">          <span class="comment">//其实就是创建了该线程对用的Looper，Looper里创建MessageQueue来实现消息机制</span></span><br><span class="line">          <span class="comment">//对消息机制不懂得同学可以查阅资料，网上很多也讲的很不错。</span></span><br><span class="line">          Looper.prepare();</span><br><span class="line">          mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                  <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">                  Log.d(<span class="string">&quot;WorkThread&quot;</span>, (Looper.getMainLooper() == Looper.myLooper()) + <span class="string">&quot;,&quot;</span> + msg.what);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="comment">//开启消息的死循环处理即：dispatchMessage</span></span><br><span class="line">          Looper.loop();</span><br><span class="line">          <span class="comment">//注意这3个的顺序不能颠倒</span></span><br><span class="line">          Log.d(<span class="string">&quot;WorkThread&quot;</span>, <span class="string">&quot;end&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><ol>
<li><p>HandlerThread作用<br>当系统有多个耗时任务需要执行时，每个任务都会开启一个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题，Google提供了HandlerThread，HandlerThread是在线程中创建一个Looper循环器，让Looper轮询消息队列，当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞。</p>
</li>
<li><p>HanlderThread的优缺点</p>
</li>
</ol>
<ul>
<li>HandlerThread本质上是一个线程类，它继承了Thread；</li>
<li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li>
<li>通过获取HandlerThread的looper对象传递给Handler对象，可以在<code>handleMessage()</code>方法中执行异步任务。</li>
<li>创建HandlerThread后必须先调用<code>HandlerThread.start()</code>方法，Thread会先调用run方法，创建Looper对象。</li>
<li>HandlerThread优点是异步不会堵塞，减少对性能的消耗</li>
<li>HandlerThread缺点是不能同时继续进行多任务处理，需要等待进行处理，处理效率较低</li>
<li>HandlerThread与线程池不同，HandlerThread是一个串行队列，背后只有一个线程。</li>
</ul>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><ul>
<li><p>它本质是一种特殊的Service,继承自Service并且本身就是一个抽象类</p>
</li>
<li><p>它可以用于在后台执行耗时的异步任务，当任务完成后会自动停止</p>
</li>
<li><p>它拥有较高的优先级，不易被系统杀死（继承自Service的缘故），因此比较适合执行一些高优先级的异步任务<br>它内部通过HandlerThread和Handler实现异步操作</p>
</li>
<li><p>创建IntentService时，只需实现onHandleIntent和构造方法，onHandleIntent为异步方法，可以执行耗时操作</p>
</li>
<li><p>即使我们多次启动IntentService，但IntentService的实例只有一个，这跟传统的Service是一样的，最终IntentService会去调用onHandleIntent执行异步任务。</p>
</li>
<li><p>当任务完成后，IntentService会自动停止，而不需要手动调用<code>stopSelf()</code>。另外，可以多次启动IntentService，每个耗时操作都会以工作队列的方式在<code>IntentService</code>中<code>onHandlerIntent()</code>回调方法中执行，并且每次只会执行一个工作线程。</p>
</li>
</ul>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>1、AsyncTask是什么</p>
<p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并主线程中更新UI，通过AsyncTask可以更加方便执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的后台任务，对于特别耗时的任务来说，建议使用线程池。</p>
<p>2、AsyncTask使用方法</p>
<p>三个参数<br><code>Params</code>：表示后台任务执行时的参数类型，该参数会传给AysncTask的<code>doInBackground()</code>方法<br><code>Progress</code>：表示后台任务的执行进度的参数类型，该参数会作为<code>onProgressUpdate()</code>方法的参数<br><code>Result</code>：表示后台任务的返回结果的参数类型，该参数会作为<code>onPostExecute()</code>方法的参数<br>五个方法<br><code>onPreExecute()</code>：异步任务开启之前回调，在主线程中执行<br><code>doInBackground()</code>：执行异步任务，在线程池中执行<br><code>onProgressUpdate()</code>：当doInBackground中调用publishProgress时回调，在主线程中执行<br><code>onPostExecute()</code>：在异步任务执行之后回调，在主线程中执行<br><code>onCancelled()</code>：在异步任务被取消时回调</p>
<p>3、AsyncTask引起的内存泄漏<br>原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放<br>解决：<br>AsyncTask内部持有外部Activity的弱引用<br>AsyncTask改为静态内部类<br>Activity的<code>onDestory()</code>中调用<code>AsyncTask.cancel()</code></p>
<p>4.结果丢失<br>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用<code>onPostExecute()</code>再去更新界面将不再生效。</p>
<p>5、AsyncTask并行or串行<br>AsyncTask在Android 2.3之前默认采用并行执行任务，AsyncTask在Android 2.3之后默认采用串行执行任务<br>如果需要在Android 2.3之后采用并行执行任务，可以调用AsyncTask的<code>executeOnExecutor()</code>;</p>
<p>6.AsyncTask内部的线程池<br><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</code><br><code>sDefaultExecutor</code>是<code>SerialExecutor</code>的一个实例，而且它是个静态变量。也就是说，一个进程里面所有AsyncTask对象都共享同一个<code>SerialExecutor</code>对象。</p>
<h2 id="一些面试心经"><a href="#一些面试心经" class="headerlink" title="一些面试心经"></a>一些面试心经</h2><p>一般情况下第一轮都是基础面试，需要扎实的基础</p>
<p>最常用的Android 基础知识<br>Java 基础知识<br>了解一些 常用东西的原理，例如：handler， thread 等<br>项目中的技术点</p>
<p>第二轮的时候需要了解更深层次的东西</p>
<p>Android 事件分发机制原理<br>Android 绘图机制原理<br>WindowManager 的相关知识<br>进程间传输方式<br>Java 内存管理机制<br>一些常用的 list,map 原理，以及子类之间的差别</p>
<p>能进入第三轮基本没什么问题，但是要注意以下问题</p>
<p>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度<br>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</p>
<p>我们的面试原则就是拿到合理薪资，得到 offer<br>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。<br>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.buerya.cn">东篱先生</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.buerya.cn/2018/questioninterview2018/index/">https://www.buerya.cn/2018/questioninterview2018/index/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.buerya.cn" target="_blank">南山结庐</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2018/android-best-practices/index/" title="Android 开发最佳实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android 开发最佳实践</div></div></a></div><div class="next-post pull-right"><a href="/2018/adifficultlogcat/index/" title="給你一個優雅性感的Logcat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">給你一個優雅性感的Logcat</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">东篱先生</div><div class="author-info__description">宁愿花时间去修炼不完美的自己&#44;也不要浪费时间去期待完美的别人。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/quewen08"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:trover@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fa fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="Atom"><i class="fa fa-rss" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新的一年，感謝訪問本站，若喜歡請收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基础组件篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E6%97%B6Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%98%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">横竖屏切换时Activity的生命周期变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#onSaveInstanceState-%E4%B8%8E-onRestoreIntanceState"><span class="toc-number">2.</span> <span class="toc-text">onSaveInstanceState() 与 onRestoreIntanceState()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#activity%E7%9A%84startActivity%E5%92%8Ccontext%E7%9A%84startActivity%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">activity的startActivity和context的startActivity的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BAndroid%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">介绍下Android应用程序启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Service%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">如何保证Service不被杀死？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8BActivity%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">简述下Activity任务栈和使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">Context相关问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8Service%E4%B8%AD%E5%88%9B%E5%BB%BADialog%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">2.6.</span> <span class="toc-text">怎么在Service中创建Dialog对话框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">View篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9EUI%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%96%B0UI%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">非UI线程可以更新UI吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3ScrollView%E5%B5%8C%E5%A5%97ListView%E5%92%8CGridView%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">解决ScrollView嵌套ListView和GridView冲突的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">自定义View优化策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AF%87"><span class="toc-number">4.</span> <span class="toc-text">线程篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler%E3%80%81Message%E3%80%81Looper%E3%80%81MessageQueue"><span class="toc-number">4.1.</span> <span class="toc-text">Handler、Message、Looper、MessageQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">4.1.1.</span> <span class="toc-text">相关概念的解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%94%BB%E4%B8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">4.1.2.</span> <span class="toc-text">自己画下图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.1.3.</span> <span class="toc-text">Handler发送消息有哪几种方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.4.</span> <span class="toc-text">Handler处理消息有哪几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Message%E3%80%81Handler%E3%80%81MessageQueue%E3%80%81Looper%E7%9A%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">4.1.5.</span> <span class="toc-text">Message、Handler、MessageQueue、Looper的之间的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BAHandler%E4%BC%9A%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">4.1.6.</span> <span class="toc-text">为什么在子线程中创建Handler会抛异常？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerThread"><span class="toc-number">4.2.</span> <span class="toc-text">HandlerThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntentService"><span class="toc-number">4.3.</span> <span class="toc-text">IntentService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTask"><span class="toc-number">4.4.</span> <span class="toc-text">AsyncTask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E5%BF%83%E7%BB%8F"><span class="toc-number">5.</span> <span class="toc-text">一些面试心经</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/docker-network/index/" title="网络管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2022/about-docker/979767-20220608220537883-1025728940.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络管理"/></a><div class="content"><a class="title" href="/2022/docker-network/index/" title="网络管理">网络管理</a><time datetime="2022-10-21T12:11:19.000Z" title="发表于 2022-10-21 20:11:19">2022-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/docker-assets/index/" title="资源限制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2022/about-docker/979767-20220608220537883-1025728940.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="资源限制"/></a><div class="content"><a class="title" href="/2022/docker-assets/index/" title="资源限制">资源限制</a><time datetime="2022-10-20T13:39:39.000Z" title="发表于 2022-10-20 21:39:39">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/docker-volume/index/" title="数据持久化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2022/about-docker/979767-20220608220537883-1025728940.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据持久化"/></a><div class="content"><a class="title" href="/2022/docker-volume/index/" title="数据持久化">数据持久化</a><time datetime="2022-09-21T13:39:39.000Z" title="发表于 2022-09-21 21:39:39">2022-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/docker-image/index/" title="镜像制作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2022/about-docker/979767-20220608220537883-1025728940.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="镜像制作"/></a><div class="content"><a class="title" href="/2022/docker-image/index/" title="镜像制作">镜像制作</a><time datetime="2022-08-20T13:29:39.000Z" title="发表于 2022-08-20 21:29:39">2022-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/docker-container/index/" title="容器管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2022/about-docker/979767-20220608220537883-1025728940.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="容器管理"/></a><div class="content"><a class="title" href="/2022/docker-container/index/" title="容器管理">容器管理</a><time datetime="2022-07-19T13:29:39.000Z" title="发表于 2022-07-19 21:29:39">2022-07-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2023 By 东篱先生</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener external nofollow noreferrer" href="http://buerya.cn/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'LoojPRMy175IgqwnQtytrgOY-9Nh9j0Va',
      appKey: '45VXhysB6in2v1IOL1kaC5tQ',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script data-pjax src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/echarts/5.3.0-rc.1/echarts.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>