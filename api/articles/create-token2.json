{"title":"实现一个可管理、增发、兑换、冻结等高级功能的代币","slug":"create-token2","date":"2018-03-10T09:02:22.000Z","updated":"2022-10-19T14:40:00.245Z","comments":true,"path":"api/articles/create-token2.json","realPath":"/2018/create-token2/index/","excerpt":null,"covers":["/img/create_adv_token.jpg"],"cover":"/img/create_adv_token.jpg","content":"<p>本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>在上一篇：<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html\">一步步教你创建自己的数字货币（代币）进行ICO</a>中我们实现一个最基本功能的代币，本文将在上一遍文章的基础上，讲解如果添加更多的高级功能。</p>\n<h2 id=\"实现代币的管理者\"><a href=\"#实现代币的管理者\" class=\"headerlink\" title=\"实现代币的管理者\"></a>实现代币的管理者</h2><p>虽然区块链是去中心化的，但是实现对代币（合约）的管理，也在许多应用中有需求，为了对代币进行管理，首先需要给合约添加一个管理者。</p>\n<p>我们来看看如果实现，先创建一个_owned_ 合约。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract owned &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    function owned() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 实现所有权转移</span><br><span class=\"line\">    function transferOwnership(address newOwner) onlyOwner &#123;</span><br><span class=\"line\">        owner = newOwner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个合约重要的是加入了一个函数修改器（Function Modifiers）onlyOwner，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MyToken is owned &#123;</span><br><span class=\"line\">    function MyToken(</span><br><span class=\"line\">        uint256 initialSupply,</span><br><span class=\"line\">        string tokenName,</span><br><span class=\"line\">        uint8 decimalUnits,</span><br><span class=\"line\">        string tokenSymbol,</span><br><span class=\"line\">        address centralMinter</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">        if(centralMinter != 0 ) owner = centralMinter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代币增发\"><a href=\"#代币增发\" class=\"headerlink\" title=\"代币增发\"></a>代币增发</h2><p>实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。</p>\n<p>给合约添加以下的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mintToken(address target, uint256 mintedAmount) onlyOwner &#123;</span><br><span class=\"line\">        balanceOf[target] += mintedAmount;</span><br><span class=\"line\">        totalSupply += mintedAmount;</span><br><span class=\"line\">        Transfer(0, owner, mintedAmount);</span><br><span class=\"line\">        Transfer(owner, target, mintedAmount);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意onlyOwner修改器添加在函数末尾，这表示只有ower才能调用这用函数。<br>他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。</p>\n<h2 id=\"资产冻结\"><a href=\"#资产冻结\" class=\"headerlink\" title=\"资产冻结\"></a>资产冻结</h2><p>有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。<br>给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把mapping加到和其他mapping一起，event也是如此）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping (address =&gt; bool) public frozenAccount;</span><br><span class=\"line\">event FrozenFunds(address target, bool frozen);</span><br><span class=\"line\"></span><br><span class=\"line\">function freezeAccount(address target, bool freeze) onlyOwner &#123;</span><br><span class=\"line\">    frozenAccount[target] = freeze;</span><br><span class=\"line\">    FrozenFunds(target, freeze);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单单以上的代码还无法冻结，需要把他加入到transfer函数中才能真正生效，因此修改transfer函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">        require(!frozenAccount[msg.sender]);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。</p>\n<h2 id=\"代币买卖（兑换）\"><a href=\"#代币买卖（兑换）\" class=\"headerlink\" title=\"代币买卖（兑换）\"></a>代币买卖（兑换）</h2><p>可以自己的货币中实现代币与其他数字货币（ether 或其他tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。</p>\n<p>先来设置下买卖价格</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 public sellPrice;</span><br><span class=\"line\">uint256 public buyPrice;</span><br><span class=\"line\"></span><br><span class=\"line\">function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner &#123;</span><br><span class=\"line\">    sellPrice = newSellPrice;</span><br><span class=\"line\">    buyPrice = newBuyPrice;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>setPrices()添加了onlyOwner修改器，注意买卖的价格单位是wei（最小的货币单位： 1 eth &#x3D; 1000000000000000000 wei)</p>\n<p>现在来添加买卖函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function buy() payable returns (uint amount)&#123;</span><br><span class=\"line\">    amount = msg.value / buyPrice;                    // calculates the amount</span><br><span class=\"line\">    require(balanceOf[this] &gt;= amount);               // checks if it has enough to sell</span><br><span class=\"line\">    balanceOf[msg.sender] += amount;                  // adds the amount to buyer&#x27;s balance</span><br><span class=\"line\">    balanceOf[this] -= amount;                        // subtracts amount from seller&#x27;s balance</span><br><span class=\"line\">    Transfer(this, msg.sender, amount);               // execute an event reflecting the change</span><br><span class=\"line\">    return amount;                                    // ends function and returns</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sell(uint amount) returns (uint revenue)&#123;</span><br><span class=\"line\">    require(balanceOf[msg.sender] &gt;= amount);         // checks if the sender has enough to sell</span><br><span class=\"line\">    balanceOf[this] += amount;                        // adds the amount to owner&#x27;s balance</span><br><span class=\"line\">    balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller&#x27;s balance</span><br><span class=\"line\">    revenue = amount * sellPrice;</span><br><span class=\"line\">    msg.sender.transfer(revenue);                     // sends ether to the seller: it&#x27;s important to do this last to prevent recursion attacks</span><br><span class=\"line\">    Transfer(msg.sender, this, amount);               // executes an event reflecting on the change</span><br><span class=\"line\">    return revenue;                                   // ends function and returns</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。</p>\n<h2 id=\"实现Gas的自动补充\"><a href=\"#实现Gas的自动补充\" class=\"headerlink\" title=\"实现Gas的自动补充\"></a>实现Gas的自动补充</h2><p>以太坊中的交易时需要gas（支付给矿工的费用，费用以ether来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充gas的功能。这个功能将使我们代币更加好用。</p>\n<p>自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。</p>\n<p>先来设定余额阈值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint minBalanceForAccounts;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setMinBalance(uint minimumBalanceInFinney) onlyOwner &#123;</span><br><span class=\"line\">         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>finney 是货币单位<br>1 finney &#x3D; 0.001eth<br>然后交易中加入对用户的余额的判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    if(msg.sender.balance &lt; minBalanceForAccounts)</span><br><span class=\"line\">        sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);</span><br><span class=\"line\">    if(_to.balance&lt;minBalanceForAccounts)   // 可选，让接受者也补充余额，以便接受者使用代币。</span><br><span class=\"line\">        _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码部署\"><a href=\"#代码部署\" class=\"headerlink\" title=\"代码部署\"></a>代码部署</h2><p>项目的完整的部署方法参考<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html\">上一篇</a>，不同的是创建合约时需要预存余额，如图：</p>\n<p><img src=\"/img/create_adv_token.jpg\"></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2>","more":"<p>本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>在上一篇：<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html\">一步步教你创建自己的数字货币（代币）进行ICO</a>中我们实现一个最基本功能的代币，本文将在上一遍文章的基础上，讲解如果添加更多的高级功能。</p>\n<h2 id=\"实现代币的管理者\"><a href=\"#实现代币的管理者\" class=\"headerlink\" title=\"实现代币的管理者\"></a>实现代币的管理者</h2><p>虽然区块链是去中心化的，但是实现对代币（合约）的管理，也在许多应用中有需求，为了对代币进行管理，首先需要给合约添加一个管理者。</p>\n<p>我们来看看如果实现，先创建一个_owned_ 合约。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract owned &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    function owned() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 实现所有权转移</span><br><span class=\"line\">    function transferOwnership(address newOwner) onlyOwner &#123;</span><br><span class=\"line\">        owner = newOwner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个合约重要的是加入了一个函数修改器（Function Modifiers）onlyOwner，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MyToken is owned &#123;</span><br><span class=\"line\">    function MyToken(</span><br><span class=\"line\">        uint256 initialSupply,</span><br><span class=\"line\">        string tokenName,</span><br><span class=\"line\">        uint8 decimalUnits,</span><br><span class=\"line\">        string tokenSymbol,</span><br><span class=\"line\">        address centralMinter</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">        if(centralMinter != 0 ) owner = centralMinter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代币增发\"><a href=\"#代币增发\" class=\"headerlink\" title=\"代币增发\"></a>代币增发</h2><p>实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。</p>\n<p>给合约添加以下的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mintToken(address target, uint256 mintedAmount) onlyOwner &#123;</span><br><span class=\"line\">        balanceOf[target] += mintedAmount;</span><br><span class=\"line\">        totalSupply += mintedAmount;</span><br><span class=\"line\">        Transfer(0, owner, mintedAmount);</span><br><span class=\"line\">        Transfer(owner, target, mintedAmount);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意onlyOwner修改器添加在函数末尾，这表示只有ower才能调用这用函数。<br>他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。</p>\n<h2 id=\"资产冻结\"><a href=\"#资产冻结\" class=\"headerlink\" title=\"资产冻结\"></a>资产冻结</h2><p>有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。<br>给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把mapping加到和其他mapping一起，event也是如此）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping (address =&gt; bool) public frozenAccount;</span><br><span class=\"line\">event FrozenFunds(address target, bool frozen);</span><br><span class=\"line\"></span><br><span class=\"line\">function freezeAccount(address target, bool freeze) onlyOwner &#123;</span><br><span class=\"line\">    frozenAccount[target] = freeze;</span><br><span class=\"line\">    FrozenFunds(target, freeze);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单单以上的代码还无法冻结，需要把他加入到transfer函数中才能真正生效，因此修改transfer函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">        require(!frozenAccount[msg.sender]);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。</p>\n<h2 id=\"代币买卖（兑换）\"><a href=\"#代币买卖（兑换）\" class=\"headerlink\" title=\"代币买卖（兑换）\"></a>代币买卖（兑换）</h2><p>可以自己的货币中实现代币与其他数字货币（ether 或其他tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。</p>\n<p>先来设置下买卖价格</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 public sellPrice;</span><br><span class=\"line\">uint256 public buyPrice;</span><br><span class=\"line\"></span><br><span class=\"line\">function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner &#123;</span><br><span class=\"line\">    sellPrice = newSellPrice;</span><br><span class=\"line\">    buyPrice = newBuyPrice;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>setPrices()添加了onlyOwner修改器，注意买卖的价格单位是wei（最小的货币单位： 1 eth &#x3D; 1000000000000000000 wei)</p>\n<p>现在来添加买卖函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function buy() payable returns (uint amount)&#123;</span><br><span class=\"line\">    amount = msg.value / buyPrice;                    // calculates the amount</span><br><span class=\"line\">    require(balanceOf[this] &gt;= amount);               // checks if it has enough to sell</span><br><span class=\"line\">    balanceOf[msg.sender] += amount;                  // adds the amount to buyer&#x27;s balance</span><br><span class=\"line\">    balanceOf[this] -= amount;                        // subtracts amount from seller&#x27;s balance</span><br><span class=\"line\">    Transfer(this, msg.sender, amount);               // execute an event reflecting the change</span><br><span class=\"line\">    return amount;                                    // ends function and returns</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sell(uint amount) returns (uint revenue)&#123;</span><br><span class=\"line\">    require(balanceOf[msg.sender] &gt;= amount);         // checks if the sender has enough to sell</span><br><span class=\"line\">    balanceOf[this] += amount;                        // adds the amount to owner&#x27;s balance</span><br><span class=\"line\">    balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller&#x27;s balance</span><br><span class=\"line\">    revenue = amount * sellPrice;</span><br><span class=\"line\">    msg.sender.transfer(revenue);                     // sends ether to the seller: it&#x27;s important to do this last to prevent recursion attacks</span><br><span class=\"line\">    Transfer(msg.sender, this, amount);               // executes an event reflecting on the change</span><br><span class=\"line\">    return revenue;                                   // ends function and returns</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。</p>\n<h2 id=\"实现Gas的自动补充\"><a href=\"#实现Gas的自动补充\" class=\"headerlink\" title=\"实现Gas的自动补充\"></a>实现Gas的自动补充</h2><p>以太坊中的交易时需要gas（支付给矿工的费用，费用以ether来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充gas的功能。这个功能将使我们代币更加好用。</p>\n<p>自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。</p>\n<p>先来设定余额阈值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint minBalanceForAccounts;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setMinBalance(uint minimumBalanceInFinney) onlyOwner &#123;</span><br><span class=\"line\">         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>finney 是货币单位<br>1 finney &#x3D; 0.001eth<br>然后交易中加入对用户的余额的判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    if(msg.sender.balance &lt; minBalanceForAccounts)</span><br><span class=\"line\">        sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);</span><br><span class=\"line\">    if(_to.balance&lt;minBalanceForAccounts)   // 可选，让接受者也补充余额，以便接受者使用代币。</span><br><span class=\"line\">        _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码部署\"><a href=\"#代码部署\" class=\"headerlink\" title=\"代码部署\"></a>代码部署</h2><p>项目的完整的部署方法参考<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html\">上一篇</a>，不同的是创建合约时需要预存余额，如图：</p>\n<p><img src=\"/img/create_adv_token.jpg\"></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2>","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"区块链","path":"api/tags/区块链.json"},{"name":"以太坊","path":"api/tags/以太坊.json"}]}