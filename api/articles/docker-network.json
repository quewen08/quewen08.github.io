{"title":"网络管理","slug":"docker-network","date":"2022-10-21T12:11:19.000Z","updated":"2022-10-21T11:30:25.197Z","comments":true,"path":"api/articles/docker-network.json","realPath":"/2022/docker-network/index/","excerpt":null,"covers":["/img/2022/docker-network/979767-20220704091535994-104412335.png","/img/2022/docker-network/979767-20220704091606017-359286512.png","/img/2022/docker-network/979767-20220704091633136-860769745.png","/img/2022/docker-network/979767-20220704091656783-1241667431.png","/img/2022/docker-network/979767-20220704091704333-641634607.png","/img/2022/docker-network/979767-20220704091721008-803339553.png","/img/2022/docker-network/979767-20220704091744085-427117787.png","/img/2022/docker-network/979767-20220704091754258-1370297203.png","/img/2022/docker-network/979767-20220704091804590-1310706088.png","/img/2022/docker-network/979767-20220704091823317-1908177264.png","/img/2022/docker-network/979767-20220704091834984-308810944.png","/img/2022/docker-network/979767-20220704091946328-1290620573.png","/img/2022/docker-network/979767-20220704091956538-381437287.png","/img/2022/docker-network/979767-20220704092014851-2142729234.png","/img/2022/docker-network/979767-20220704092044531-1942375962.png","/img/2022/docker-network/979767-20220704092105202-406328144.png","/img/2022/docker-network/979767-20220704092119145-1396915150.png","/img/2022/docker-network/979767-20220704092152957-641815307.png","/img/2022/docker-network/979767-20220704092220944-1730385068.png","/img/2022/docker-network/979767-20220704092233837-1409078039.png","/img/2022/docker-network/979767-20220704092243092-165781342.png","/img/2022/docker-network/979767-20220704092255464-1585960726.png","/img/2022/docker-network/979767-20220704092305846-1244327742.png","/img/2022/docker-network/979767-20220704092318259-979745258.png","/img/2022/docker-network/979767-20220704092332863-390921249.png","/img/2022/docker-network/979767-20220704092343147-280600039.png","/img/2022/docker-network/979767-20220704092355495-1641775382.png"],"cover":"/img/2022/docker-network/979767-20220704091535994-104412335.png","content":"<h3 id=\"网络模式\"><a href=\"#网络模式\" class=\"headerlink\" title=\"网络模式\"></a>网络模式</h3><p>容器的网络通信可以分为两大方面：单主机上的容器之间相互通信和跨主机的容器相互通信。</p>\n<p>docker 的单主机通信基于 Network Namespace 实现，它可以为容器创建隔离的网络环境。docker 官方本身提供了 5 种网络模式，可以基本满足日常开发中的需求：</p>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bridge</td>\n<td>默认，为每个容器分配一个 IP，该 IP 会连接到 docker 宿主机的 docker0 虚拟网卡</td>\n</tr>\n<tr>\n<td>host</td>\n<td>容器不会拥有自己的虚拟网卡和 IP，而是直接使用宿主机的 IP 和端口</td>\n</tr>\n<tr>\n<td>none</td>\n<td>为容器创建独立网络名称空间，但不做任何网络配置，容器中只有 lo，用户可以就此对容器网络做任意定制</td>\n</tr>\n<tr>\n<td>container</td>\n<td>类似 host，容器不会拥有自己的网卡和 IP，而是和一个指定的容器共享 IP，端口等</td>\n</tr>\n<tr>\n<td>用户自定义</td>\n<td>在 docker 1.9 以后新增的特性，允许容器使用第三方的网络实现或者创建单独的 bridge 网络，提供网络隔离能力</td>\n</tr>\n</tbody></table>\n<p>在安装完成 docker 之后，会默认创建三种网络：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/2022/docker-network/979767-20220704091535994-104412335.png\"></p>\n<p>在运行容器时，可以使用 <code>--network</code> 或者 <code>--net</code> 指定容器使用的网络模式，如：<code>--net bridge</code></p>\n<p>同时也可以使用命令查看网络模式下有哪些容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network inspect bridge</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a>bridge</h3><p>bridge 模式是 docker 默认的网络模式，也是开发者最常使用的网络模式。</p>\n<p>在这种模式下，docker 为容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，实现容器与容器之间、容器与宿主机之间的网络栈隔离。</p>\n<p>同时，通过宿主机上的 docker0 网桥，容器可以与宿主机乃至外界进行网络通信。其网络模型可以参考下图：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091606017-359286512.png\"></p>\n<p>大致流程如下：</p>\n<ol>\n<li><p>docker 先创建一对虚拟网卡 <code>veth pair</code> 设备（其特征为：成对出现，数据从一个设备进入，就会从另一个设备出来，常用于实现数据通道）。</p>\n</li>\n<li><p>docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0。</p>\n</li>\n<li><p>docker 将 veth pair 设备的另一端放在宿主机中，以 vethxxx 格式命名，并将它加入到 docker0 网桥中（可通过 brctl show 命令查看到）。</p>\n</li>\n<li><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 为容器的默认网关。</p>\n</li>\n</ol>\n<h4 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h4><h5 id=\"查看本机网络情况：\"><a href=\"#查看本机网络情况：\" class=\"headerlink\" title=\"查看本机网络情况：\"></a>查看本机网络情况：</h5><p><img src=\"/img/2022/docker-network/979767-20220704091633136-860769745.png\"></p>\n<p>docker 安装完后会在宿主机创建一个 <code>docker0</code> 虚拟网卡。其作用类似于网络交换设备，用于实现容器之间，容器与宿主机之间甚至容器与外部主机之间的通信</p>\n<p>docker0 网桥的 IP 一般会是 docker 配置网段的第一个 IP，且这个 IP 会作为 bridge 网络模式的容器的网关使用。</p>\n<p>本文由于我们在配置 docker 时有另外指定了 IP 网段，所以这里看到的网段为：<code>172.16.0.0/16</code> 而不是 docker 默认的网段 <code>172.17.0.0/16</code>。</p>\n<h5 id=\"新建两个容器并查看其网络情况：\"><a href=\"#新建两个容器并查看其网络情况：\" class=\"headerlink\" title=\"新建两个容器并查看其网络情况：\"></a>新建两个容器并查看其网络情况：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 终端 1</span></span><br><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> -it --name demo01 busybox /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 终端 2</span></span><br><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> -it --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>终端 1：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091656783-1241667431.png\"></p>\n<p>终端 2:</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091704333-641634607.png\"></p>\n<h5 id=\"查看此时宿主机网络情况：\"><a href=\"#查看此时宿主机网络情况：\" class=\"headerlink\" title=\"查看此时宿主机网络情况：\"></a>查看此时宿主机网络情况：</h5><p><img src=\"/img/2022/docker-network/979767-20220704091721008-803339553.png\"></p>\n<p>宿主机多了两个 veth 网卡，这两个网卡就是和容器内部的 eth0 成对出现的，通过 <code>bridge-utils</code> 提供的命令也可以看到它们和 docker0 的连接关系。</p>\n<h5 id=\"查看任意容器的详细信息：\"><a href=\"#查看任意容器的详细信息：\" class=\"headerlink\" title=\"查看任意容器的详细信息：\"></a>查看任意容器的详细信息：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container inspect demo01</span><br></pre></td></tr></table></figure>\n<p>找到网络配置部分，如下图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091744085-427117787.png\"></p>\n<p>docker0 网卡的 IP 地址被作为容器的网关。</p>\n<h5 id=\"测试容器和外部连通性：\"><a href=\"#测试容器和外部连通性：\" class=\"headerlink\" title=\"测试容器和外部连通性：\"></a>测试容器和外部连通性：</h5><p><img src=\"/img/2022/docker-network/979767-20220704091754258-1370297203.png\"></p>\n<h3 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h3><p>host 网络模式的容器可直接使用宿主机的 IP 与外界通信，同时容器内的端口也直接使用宿主机的端口，无需额外 NAT 转换。创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定。</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091804590-1310706088.png\"></p>\n<h4 id=\"测试示例\"><a href=\"#测试示例\" class=\"headerlink\" title=\"测试示例\"></a>测试示例</h4><h5 id=\"创建一个-Nginx-容器：\"><a href=\"#创建一个-Nginx-容器：\" class=\"headerlink\" title=\"创建一个 Nginx 容器：\"></a>创建一个 Nginx 容器：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --net host --<span class=\"built_in\">rm</span> --name demo01 nginx</span><br></pre></td></tr></table></figure>\n\n<p>查看端口使用情况：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091823317-1908177264.png\"></p>\n<p>可以发现 80 端口已经在宿主机启动。</p>\n<h5 id=\"查看容器的网络信息：\"><a href=\"#查看容器的网络信息：\" class=\"headerlink\" title=\"查看容器的网络信息：\"></a>查看容器的网络信息：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container inspect demo01</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/2022/docker-network/979767-20220704091834984-308810944.png\"></p>\n<p>网络模式已经成为 host，且本身没有 IP 信息。</p>\n<h5 id=\"测试端口占用信息：\"><a href=\"#测试端口占用信息：\" class=\"headerlink\" title=\"测试端口占用信息：\"></a>测试端口占用信息：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --net host --<span class=\"built_in\">rm</span> --name demo02 nginx</span><br></pre></td></tr></table></figure>\n\n<p>容器无法运行，查看日志提示端口被占用。</p>\n<h3 id=\"none\"><a href=\"#none\" class=\"headerlink\" title=\"none\"></a>none</h3><p>none 网络模式是指禁用网络功能，只有 lo 本地环回接口。在创建容器时通过参数 <code>--net none</code> 或 <code>--network none</code> 指定。</p>\n<p>创建一个测试容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> none --name demo01 busybox /bin/sh</span><br></pre></td></tr></table></figure>\n<p>查看网络信息：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091946328-1290620573.png\"></p>\n<p>该容器无法和宿主机通信。</p>\n<h3 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container\"></a>container</h3><p>Container 网络模式是 docker 中一种较为特别的网络的模式。在创建容器时通过参数 –net container:已运行的容器名称|ID 或者 –network container:已运行的容器名称|ID 指定。</p>\n<p>处于这个模式下的容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。</p>\n<p>Container 网络模式下，新创建的容器不会创建自己的网卡，而是和一个指定的容器共享 IP、端口范围等。除了网络方面相同之外，其它都是隔离的。</p>\n<p>其原理大致如下：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091956538-381437287.png\"></p>\n<h4 id=\"测试示例-1\"><a href=\"#测试示例-1\" class=\"headerlink\" title=\"测试示例\"></a>测试示例</h4><h5 id=\"创建一个-bridge-网络模式的容器：\"><a href=\"#创建一个-bridge-网络模式的容器：\" class=\"headerlink\" title=\"创建一个 bridge 网络模式的容器：\"></a>创建一个 bridge 网络模式的容器：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --name demo01 nginx</span><br><span class=\"line\">docker container inspect demo01</span><br></pre></td></tr></table></figure>\n\n<p>网络配置如下所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092014851-2142729234.png\"></p>\n<h5 id=\"创建一个-container-网络模式的容器：\"><a href=\"#创建一个-container-网络模式的容器：\" class=\"headerlink\" title=\"创建一个 container 网络模式的容器：\"></a>创建一个 container 网络模式的容器：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> -it --net container:demo01 --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>网络信息如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092044531-1942375962.png\"></p>\n<h5 id=\"此时删除-demo01-容器再查看-demo02-的网络：\"><a href=\"#此时删除-demo01-容器再查看-demo02-的网络：\" class=\"headerlink\" title=\"此时删除 demo01 容器再查看 demo02 的网络：\"></a>此时删除 demo01 容器再查看 demo02 的网络：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container <span class=\"built_in\">rm</span> -f demo01</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/2022/docker-network/979767-20220704092105202-406328144.png\"></p>\n<p>网卡只剩下 lo 回环网卡。</p>\n<p><code>docker container run --link</code></p>\n<p>可以用来连接两个容器，能够实现被链接的容器（源容器）和主动去链接的容器（接收容器）之间互相通信，并且接收容器可以获取源容器的一些数据，如环境变量。不过该方法将来可能被 docker 废弃。</p>\n<h3 id=\"自定义网络\"><a href=\"#自定义网络\" class=\"headerlink\" title=\"自定义网络\"></a>自定义网络</h3><p>docker 提供的默认网络模式使用起来比较简单，但是在实际应用中，为了保证应用的安全性，还是更推荐自定义网络来进行容器管理。并启用容器名称到容器 IP 的自动 DNS 解析。</p>\n<blockquote>\n<p>从 docker 1.10 版本开始，docker daemon 实现了一个内嵌 DNS Server，但只能在用户自定义的网络模式使用，它可以实现直接使用容器的名称进行通信。</p>\n</blockquote>\n<h4 id=\"创建自定义网络\"><a href=\"#创建自定义网络\" class=\"headerlink\" title=\"创建自定义网络\"></a>创建自定义网络</h4><p>使用命令直接创建一个自定义的 bridge 网络：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create -d bridge hello_bridge</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092119145-1396915150.png\"></p>\n<p><code>-d，--driver</code> 参数可以指定网络模式，默认不指定就是 bridge 模式。</p>\n<h4 id=\"测试网络\"><a href=\"#测试网络\" class=\"headerlink\" title=\"测试网络\"></a>测试网络</h4><p>再次创建一个自定义网络协助测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create -d bridge world_bridge</span><br></pre></td></tr></table></figure>\n\n<p>创建相关的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认网络</span></span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --name demo01 busybox sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># hello_bridge 网络</span></span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --net hello_bridge --name demo02 busybox sh</span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --net hello_bridge --name demo03 busybox sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># world_bridge 网络</span></span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --net world_bridge --name demo04 busybox sh</span><br></pre></td></tr></table></figure>\n\n<p>查看此时的网络情况</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092152957-641815307.png\"></p>\n<p>可以发现 IP 多了一些的新的网段，同一网络模式的容器处于同一网段。</p>\n<p>此时查看本机的网络情况：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092220944-1730385068.png\"></p>\n<p>可以发现多了两个类似于 docker0 网桥的网卡，都分配了新的网段。由此可以知道，每新建一个 bridge 网络，就会在宿主机新建一个 bridge 网桥，并分配一个新的网段。</p>\n<p>测试网络连通性：</p>\n<p>demo01 测试：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092233837-1409078039.png\" alt=\"demo01 测试\"></p>\n<p>demo02 测试：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092243092-165781342.png\" alt=\"demo02 测试\"></p>\n<p>剩下的就不做测试了，但是大致能得出以下结论：</p>\n<ol>\n<li>不同的网络之间是隔离的，无法互相通信。</li>\n<li>在自定义网络中，容器可以使用容器名称直接通信。</li>\n</ol>\n<h4 id=\"连接网络\"><a href=\"#连接网络\" class=\"headerlink\" title=\"连接网络\"></a>连接网络</h4><p>可以将现有的容器连接到其它网络中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network connect bridge demo04</span><br></pre></td></tr></table></figure>\n<p>此时查看网络情况：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092255464-1585960726.png\"></p>\n<p>可以发现限制 demo04 容器既属于默认 bridge 网络，也属于 world_bridge 网络了，这也就能和默认网络的 demo01 进行通信。</p>\n<h4 id=\"断开网络\"><a href=\"#断开网络\" class=\"headerlink\" title=\"断开网络\"></a>断开网络</h4><p>可以连接网络自然也可以断开网络：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network disconnect bridge demo04</span><br><span class=\"line\">docker network disconnect world_bridge demo04</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092305846-1244327742.png\"></p>\n<p>当连接的网络都断开之后，它的网络模式就像 none 网络了。</p>\n<h4 id=\"删除网络\"><a href=\"#删除网络\" class=\"headerlink\" title=\"删除网络\"></a>删除网络</h4><p>对于没有使用的网络也可以进行删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">rm</span> world_bridge</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092318259-979745258.png\"></p>\n<h3 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h3><p>当容器内部应用想要暴露给外部访问，就需要使用到 <code>-P</code> 或者 <code>-p</code> 参数来进行端口映射。</p>\n<p>随机映射（-P）</p>\n<p>使用 <code>-P</code> 参数能够随机映射一个 <code>32768</code> 以上的端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -P --name demo01 nginx</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此时查看容器详情：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092332863-390921249.png\"></p>\n<p>能够看到容器内部 nginx 的 80 端口以及被随机映射到了 49153 端口，可以使用宿主机加这个随机端口在浏览器进行访问。</p>\n<h4 id=\"指定映射（-p）\"><a href=\"#指定映射（-p）\" class=\"headerlink\" title=\"指定映射（-p）\"></a>指定映射（-p）</h4><p>使用 <code>-p</code> 参数能够指定映射的端口，它的格式为：<code>监听IP:宿主机端口:容器端口</code>，<code>监听IP::容器端口</code>，<code>宿主机端口:容器端口</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 完整的监听映射</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;0.0.0.0:8080:80&quot;</span> --name demo01 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 随机映射</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;0.0.0.0::80&quot;</span> --name demo02 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 普通监听映射</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;8081:80&quot;</span> --name demo03 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定端口协议</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;0.0.0.0:8080:80/udp&quot;</span> --name demo04 nginx</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092343147-280600039.png\"></p>\n<p>如果有多个端口需要映射则指定多个 -p 即可。</p>\n<p>也可以通过命令反查容器映射了哪些端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container port demo01</span><br><span class=\"line\">docker container port demo01 80</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092355495-1641775382.png\"></p>\n","more":"<h3 id=\"网络模式\"><a href=\"#网络模式\" class=\"headerlink\" title=\"网络模式\"></a>网络模式</h3><p>容器的网络通信可以分为两大方面：单主机上的容器之间相互通信和跨主机的容器相互通信。</p>\n<p>docker 的单主机通信基于 Network Namespace 实现，它可以为容器创建隔离的网络环境。docker 官方本身提供了 5 种网络模式，可以基本满足日常开发中的需求：</p>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bridge</td>\n<td>默认，为每个容器分配一个 IP，该 IP 会连接到 docker 宿主机的 docker0 虚拟网卡</td>\n</tr>\n<tr>\n<td>host</td>\n<td>容器不会拥有自己的虚拟网卡和 IP，而是直接使用宿主机的 IP 和端口</td>\n</tr>\n<tr>\n<td>none</td>\n<td>为容器创建独立网络名称空间，但不做任何网络配置，容器中只有 lo，用户可以就此对容器网络做任意定制</td>\n</tr>\n<tr>\n<td>container</td>\n<td>类似 host，容器不会拥有自己的网卡和 IP，而是和一个指定的容器共享 IP，端口等</td>\n</tr>\n<tr>\n<td>用户自定义</td>\n<td>在 docker 1.9 以后新增的特性，允许容器使用第三方的网络实现或者创建单独的 bridge 网络，提供网络隔离能力</td>\n</tr>\n</tbody></table>\n<p>在安装完成 docker 之后，会默认创建三种网络：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/2022/docker-network/979767-20220704091535994-104412335.png\"></p>\n<p>在运行容器时，可以使用 <code>--network</code> 或者 <code>--net</code> 指定容器使用的网络模式，如：<code>--net bridge</code></p>\n<p>同时也可以使用命令查看网络模式下有哪些容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network inspect bridge</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a>bridge</h3><p>bridge 模式是 docker 默认的网络模式，也是开发者最常使用的网络模式。</p>\n<p>在这种模式下，docker 为容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，实现容器与容器之间、容器与宿主机之间的网络栈隔离。</p>\n<p>同时，通过宿主机上的 docker0 网桥，容器可以与宿主机乃至外界进行网络通信。其网络模型可以参考下图：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091606017-359286512.png\"></p>\n<p>大致流程如下：</p>\n<ol>\n<li><p>docker 先创建一对虚拟网卡 <code>veth pair</code> 设备（其特征为：成对出现，数据从一个设备进入，就会从另一个设备出来，常用于实现数据通道）。</p>\n</li>\n<li><p>docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0。</p>\n</li>\n<li><p>docker 将 veth pair 设备的另一端放在宿主机中，以 vethxxx 格式命名，并将它加入到 docker0 网桥中（可通过 brctl show 命令查看到）。</p>\n</li>\n<li><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 为容器的默认网关。</p>\n</li>\n</ol>\n<h4 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h4><h5 id=\"查看本机网络情况：\"><a href=\"#查看本机网络情况：\" class=\"headerlink\" title=\"查看本机网络情况：\"></a>查看本机网络情况：</h5><p><img src=\"/img/2022/docker-network/979767-20220704091633136-860769745.png\"></p>\n<p>docker 安装完后会在宿主机创建一个 <code>docker0</code> 虚拟网卡。其作用类似于网络交换设备，用于实现容器之间，容器与宿主机之间甚至容器与外部主机之间的通信</p>\n<p>docker0 网桥的 IP 一般会是 docker 配置网段的第一个 IP，且这个 IP 会作为 bridge 网络模式的容器的网关使用。</p>\n<p>本文由于我们在配置 docker 时有另外指定了 IP 网段，所以这里看到的网段为：<code>172.16.0.0/16</code> 而不是 docker 默认的网段 <code>172.17.0.0/16</code>。</p>\n<h5 id=\"新建两个容器并查看其网络情况：\"><a href=\"#新建两个容器并查看其网络情况：\" class=\"headerlink\" title=\"新建两个容器并查看其网络情况：\"></a>新建两个容器并查看其网络情况：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 终端 1</span></span><br><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> -it --name demo01 busybox /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 终端 2</span></span><br><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> -it --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>终端 1：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091656783-1241667431.png\"></p>\n<p>终端 2:</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091704333-641634607.png\"></p>\n<h5 id=\"查看此时宿主机网络情况：\"><a href=\"#查看此时宿主机网络情况：\" class=\"headerlink\" title=\"查看此时宿主机网络情况：\"></a>查看此时宿主机网络情况：</h5><p><img src=\"/img/2022/docker-network/979767-20220704091721008-803339553.png\"></p>\n<p>宿主机多了两个 veth 网卡，这两个网卡就是和容器内部的 eth0 成对出现的，通过 <code>bridge-utils</code> 提供的命令也可以看到它们和 docker0 的连接关系。</p>\n<h5 id=\"查看任意容器的详细信息：\"><a href=\"#查看任意容器的详细信息：\" class=\"headerlink\" title=\"查看任意容器的详细信息：\"></a>查看任意容器的详细信息：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container inspect demo01</span><br></pre></td></tr></table></figure>\n<p>找到网络配置部分，如下图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091744085-427117787.png\"></p>\n<p>docker0 网卡的 IP 地址被作为容器的网关。</p>\n<h5 id=\"测试容器和外部连通性：\"><a href=\"#测试容器和外部连通性：\" class=\"headerlink\" title=\"测试容器和外部连通性：\"></a>测试容器和外部连通性：</h5><p><img src=\"/img/2022/docker-network/979767-20220704091754258-1370297203.png\"></p>\n<h3 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h3><p>host 网络模式的容器可直接使用宿主机的 IP 与外界通信，同时容器内的端口也直接使用宿主机的端口，无需额外 NAT 转换。创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定。</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091804590-1310706088.png\"></p>\n<h4 id=\"测试示例\"><a href=\"#测试示例\" class=\"headerlink\" title=\"测试示例\"></a>测试示例</h4><h5 id=\"创建一个-Nginx-容器：\"><a href=\"#创建一个-Nginx-容器：\" class=\"headerlink\" title=\"创建一个 Nginx 容器：\"></a>创建一个 Nginx 容器：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --net host --<span class=\"built_in\">rm</span> --name demo01 nginx</span><br></pre></td></tr></table></figure>\n\n<p>查看端口使用情况：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091823317-1908177264.png\"></p>\n<p>可以发现 80 端口已经在宿主机启动。</p>\n<h5 id=\"查看容器的网络信息：\"><a href=\"#查看容器的网络信息：\" class=\"headerlink\" title=\"查看容器的网络信息：\"></a>查看容器的网络信息：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container inspect demo01</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/2022/docker-network/979767-20220704091834984-308810944.png\"></p>\n<p>网络模式已经成为 host，且本身没有 IP 信息。</p>\n<h5 id=\"测试端口占用信息：\"><a href=\"#测试端口占用信息：\" class=\"headerlink\" title=\"测试端口占用信息：\"></a>测试端口占用信息：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --net host --<span class=\"built_in\">rm</span> --name demo02 nginx</span><br></pre></td></tr></table></figure>\n\n<p>容器无法运行，查看日志提示端口被占用。</p>\n<h3 id=\"none\"><a href=\"#none\" class=\"headerlink\" title=\"none\"></a>none</h3><p>none 网络模式是指禁用网络功能，只有 lo 本地环回接口。在创建容器时通过参数 <code>--net none</code> 或 <code>--network none</code> 指定。</p>\n<p>创建一个测试容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> none --name demo01 busybox /bin/sh</span><br></pre></td></tr></table></figure>\n<p>查看网络信息：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091946328-1290620573.png\"></p>\n<p>该容器无法和宿主机通信。</p>\n<h3 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container\"></a>container</h3><p>Container 网络模式是 docker 中一种较为特别的网络的模式。在创建容器时通过参数 –net container:已运行的容器名称|ID 或者 –network container:已运行的容器名称|ID 指定。</p>\n<p>处于这个模式下的容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。</p>\n<p>Container 网络模式下，新创建的容器不会创建自己的网卡，而是和一个指定的容器共享 IP、端口范围等。除了网络方面相同之外，其它都是隔离的。</p>\n<p>其原理大致如下：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704091956538-381437287.png\"></p>\n<h4 id=\"测试示例-1\"><a href=\"#测试示例-1\" class=\"headerlink\" title=\"测试示例\"></a>测试示例</h4><h5 id=\"创建一个-bridge-网络模式的容器：\"><a href=\"#创建一个-bridge-网络模式的容器：\" class=\"headerlink\" title=\"创建一个 bridge 网络模式的容器：\"></a>创建一个 bridge 网络模式的容器：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --name demo01 nginx</span><br><span class=\"line\">docker container inspect demo01</span><br></pre></td></tr></table></figure>\n\n<p>网络配置如下所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092014851-2142729234.png\"></p>\n<h5 id=\"创建一个-container-网络模式的容器：\"><a href=\"#创建一个-container-网络模式的容器：\" class=\"headerlink\" title=\"创建一个 container 网络模式的容器：\"></a>创建一个 container 网络模式的容器：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> -it --net container:demo01 --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>网络信息如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092044531-1942375962.png\"></p>\n<h5 id=\"此时删除-demo01-容器再查看-demo02-的网络：\"><a href=\"#此时删除-demo01-容器再查看-demo02-的网络：\" class=\"headerlink\" title=\"此时删除 demo01 容器再查看 demo02 的网络：\"></a>此时删除 demo01 容器再查看 demo02 的网络：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container <span class=\"built_in\">rm</span> -f demo01</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/2022/docker-network/979767-20220704092105202-406328144.png\"></p>\n<p>网卡只剩下 lo 回环网卡。</p>\n<p><code>docker container run --link</code></p>\n<p>可以用来连接两个容器，能够实现被链接的容器（源容器）和主动去链接的容器（接收容器）之间互相通信，并且接收容器可以获取源容器的一些数据，如环境变量。不过该方法将来可能被 docker 废弃。</p>\n<h3 id=\"自定义网络\"><a href=\"#自定义网络\" class=\"headerlink\" title=\"自定义网络\"></a>自定义网络</h3><p>docker 提供的默认网络模式使用起来比较简单，但是在实际应用中，为了保证应用的安全性，还是更推荐自定义网络来进行容器管理。并启用容器名称到容器 IP 的自动 DNS 解析。</p>\n<blockquote>\n<p>从 docker 1.10 版本开始，docker daemon 实现了一个内嵌 DNS Server，但只能在用户自定义的网络模式使用，它可以实现直接使用容器的名称进行通信。</p>\n</blockquote>\n<h4 id=\"创建自定义网络\"><a href=\"#创建自定义网络\" class=\"headerlink\" title=\"创建自定义网络\"></a>创建自定义网络</h4><p>使用命令直接创建一个自定义的 bridge 网络：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create -d bridge hello_bridge</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092119145-1396915150.png\"></p>\n<p><code>-d，--driver</code> 参数可以指定网络模式，默认不指定就是 bridge 模式。</p>\n<h4 id=\"测试网络\"><a href=\"#测试网络\" class=\"headerlink\" title=\"测试网络\"></a>测试网络</h4><p>再次创建一个自定义网络协助测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create -d bridge world_bridge</span><br></pre></td></tr></table></figure>\n\n<p>创建相关的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认网络</span></span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --name demo01 busybox sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># hello_bridge 网络</span></span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --net hello_bridge --name demo02 busybox sh</span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --net hello_bridge --name demo03 busybox sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># world_bridge 网络</span></span><br><span class=\"line\">docker container run -it --<span class=\"built_in\">rm</span> --net world_bridge --name demo04 busybox sh</span><br></pre></td></tr></table></figure>\n\n<p>查看此时的网络情况</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092152957-641815307.png\"></p>\n<p>可以发现 IP 多了一些的新的网段，同一网络模式的容器处于同一网段。</p>\n<p>此时查看本机的网络情况：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092220944-1730385068.png\"></p>\n<p>可以发现多了两个类似于 docker0 网桥的网卡，都分配了新的网段。由此可以知道，每新建一个 bridge 网络，就会在宿主机新建一个 bridge 网桥，并分配一个新的网段。</p>\n<p>测试网络连通性：</p>\n<p>demo01 测试：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092233837-1409078039.png\" alt=\"demo01 测试\"></p>\n<p>demo02 测试：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092243092-165781342.png\" alt=\"demo02 测试\"></p>\n<p>剩下的就不做测试了，但是大致能得出以下结论：</p>\n<ol>\n<li>不同的网络之间是隔离的，无法互相通信。</li>\n<li>在自定义网络中，容器可以使用容器名称直接通信。</li>\n</ol>\n<h4 id=\"连接网络\"><a href=\"#连接网络\" class=\"headerlink\" title=\"连接网络\"></a>连接网络</h4><p>可以将现有的容器连接到其它网络中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network connect bridge demo04</span><br></pre></td></tr></table></figure>\n<p>此时查看网络情况：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092255464-1585960726.png\"></p>\n<p>可以发现限制 demo04 容器既属于默认 bridge 网络，也属于 world_bridge 网络了，这也就能和默认网络的 demo01 进行通信。</p>\n<h4 id=\"断开网络\"><a href=\"#断开网络\" class=\"headerlink\" title=\"断开网络\"></a>断开网络</h4><p>可以连接网络自然也可以断开网络：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network disconnect bridge demo04</span><br><span class=\"line\">docker network disconnect world_bridge demo04</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092305846-1244327742.png\"></p>\n<p>当连接的网络都断开之后，它的网络模式就像 none 网络了。</p>\n<h4 id=\"删除网络\"><a href=\"#删除网络\" class=\"headerlink\" title=\"删除网络\"></a>删除网络</h4><p>对于没有使用的网络也可以进行删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">rm</span> world_bridge</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092318259-979745258.png\"></p>\n<h3 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h3><p>当容器内部应用想要暴露给外部访问，就需要使用到 <code>-P</code> 或者 <code>-p</code> 参数来进行端口映射。</p>\n<p>随机映射（-P）</p>\n<p>使用 <code>-P</code> 参数能够随机映射一个 <code>32768</code> 以上的端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -P --name demo01 nginx</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此时查看容器详情：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092332863-390921249.png\"></p>\n<p>能够看到容器内部 nginx 的 80 端口以及被随机映射到了 49153 端口，可以使用宿主机加这个随机端口在浏览器进行访问。</p>\n<h4 id=\"指定映射（-p）\"><a href=\"#指定映射（-p）\" class=\"headerlink\" title=\"指定映射（-p）\"></a>指定映射（-p）</h4><p>使用 <code>-p</code> 参数能够指定映射的端口，它的格式为：<code>监听IP:宿主机端口:容器端口</code>，<code>监听IP::容器端口</code>，<code>宿主机端口:容器端口</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 完整的监听映射</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;0.0.0.0:8080:80&quot;</span> --name demo01 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 随机映射</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;0.0.0.0::80&quot;</span> --name demo02 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 普通监听映射</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;8081:80&quot;</span> --name demo03 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定端口协议</span></span><br><span class=\"line\">docker container run -d --<span class=\"built_in\">rm</span> -p <span class=\"string\">&quot;0.0.0.0:8080:80/udp&quot;</span> --name demo04 nginx</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092343147-280600039.png\"></p>\n<p>如果有多个端口需要映射则指定多个 -p 即可。</p>\n<p>也可以通过命令反查容器映射了哪些端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container port demo01</span><br><span class=\"line\">docker container port demo01 80</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-network/979767-20220704092355495-1641775382.png\"></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"Docker","path":"api/categories/Docker.json"}],"tags":[{"name":"docker","path":"api/tags/docker.json"},{"name":"k8s","path":"api/tags/k8s.json"},{"name":"kubernetes","path":"api/tags/kubernetes.json"},{"name":"容器","path":"api/tags/容器.json"},{"name":"云原生","path":"api/tags/云原生.json"}]}