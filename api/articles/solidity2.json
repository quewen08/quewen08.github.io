{"title":"智能合约语言 Solidity 教程系列2 - 类型介绍","slug":"solidity2","date":"2018-03-04T16:00:00.000Z","updated":"2022-10-19T14:40:00.268Z","comments":true,"path":"api/articles/solidity2.json","realPath":"/2018/solidity2/index/","excerpt":null,"covers":null,"cover":null,"content":"<p>Solidity教程系列第二篇 - Solidity地址类型介绍.<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"地址类型（Address）\"><a href=\"#地址类型（Address）\" class=\"headerlink\" title=\"地址类型（Address）\"></a>地址类型（Address）</h2><p>地址类型address是一个值类型，</p>\n<p><strong>地址</strong> ： 20字节（一个以太坊地址的长度），地址类型也有成员，地址是所有合约的基础<br>支持的运算符：</p>\n<pre><code>&lt;=, &lt;, ==, !=, &gt;= 和 &gt;\n&gt; 注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址。\n</code></pre>\n<h3 id=\"地址类型的成员\"><a href=\"#地址类型的成员\" class=\"headerlink\" title=\"地址类型的成员\"></a>地址类型的成员</h3><ul>\n<li><p>balance 属性及transfer() 函数<br>这里是地址类型相关成员的快速索引<br>balance用来查询账户余额，transfer()用来发送以太币（以wei为单位）。<br>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address x = 0x123;</span><br><span class=\"line\">address myAddress = this;</span><br><span class=\"line\">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注解</strong> ：如果x是合约地址，合约的回退函数（fallback 函数）会随transfer调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。</p>\n<blockquote>\n<p>关于回退函数（fallback 函数），简单来说它是合约中无函数名函数，下面代码事例中，进进一步讲解回退函数（fallback） 的使用。</p>\n</blockquote>\n</li>\n<li><p>send() 函数<br>send 与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。</p>\n<blockquote>\n<p><strong>警告</strong> ：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p>\n</blockquote>\n</li>\n<li><p>call(), callcode() 和 delegatecall() 函数<br>为了和非ABI协议的合约进行交互，可以使用call() 函数, 它用来向另一个合约发送原始数据，支持任何类型任意数量的参数，每个参数会按规则(ABI协议)打包成32字节并一一拼接到一起。一个例外是：如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名而直接使用。如果仅想发送消息体，需要避免第一个参数是4个字节。如下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class=\"line\">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class=\"line\">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure>\n\n<p>call函数返回一个bool值，以表明执行成功与否。正常结束返回true，异常终止返回false。但无法获取到结果数据，因为需要提前知道返回的数据的编码和数据大小（因不知道对方使用的协议格式，所以也不会知道返回的结果如何解析）。<br>还可以提供.gas()修饰器进行调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>类似还可以提供附带以太币：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>修饰器可以混合使用，修饰器调用顺序无所谓。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注解：目前还不能在重载函数上使用gas或value修饰符，A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.（这句我怕翻译的不准确，引用原文）</p>\n</blockquote>\n<p>同样我们也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的库代码。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。在homestead阶段之前，仅有一个受限的callcode()方法可用，但callcode未提供对msg.sender，msg.value的访问权限。</p>\n<p>上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。<br>.gas() 在call(), callcode() 和 delegatecall() 函数下都可以使用， delegatecall()不支持.value()</p>\n<blockquote>\n<p>注解：所有合约都继承了address的成员，因此可以使用this.balance查询余额。<br>callcode不鼓励使用，以后会移除。</p>\n</blockquote>\n<blockquote>\n<p>警告：上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"地址常量（Address-Literals）\"><a href=\"#地址常量（Address-Literals）\" class=\"headerlink\" title=\"地址常量（Address Literals）\"></a>地址常量（Address Literals）</h2><p>一个能通过地址合法性检查（address checksum test）十六进制常量就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。而不能通过地址合法性检查的39到41位长的十六进制常量，会提示一个警告，被视为普通的有理数常量。</p>\n<blockquote>\n<p>地址合法性检查定义在<a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md\">EIP-55</a></p>\n</blockquote>\n<h2 id=\"合约事例讲解\"><a href=\"#合约事例讲解\" class=\"headerlink\" title=\"合约事例讲解\"></a>合约事例讲解</h2><h3 id=\"合约事例代码\"><a href=\"#合约事例代码\" class=\"headerlink\" title=\"合约事例代码\"></a>合约事例代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AddrTest&#123;</span><br><span class=\"line\">    event logdata(bytes data);</span><br><span class=\"line\">    function() payable &#123;</span><br><span class=\"line\">        logdata(msg.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getBalance() returns (uint) &#123;</span><br><span class=\"line\">        return this.balance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint score = 0;</span><br><span class=\"line\">    function setScore(uint s) public &#123;</span><br><span class=\"line\">        score = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getScore() returns ( uint)&#123;</span><br><span class=\"line\">        return score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CallTest&#123;</span><br><span class=\"line\">    function deposit() payable &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    event logSendEvent(address to, uint value);</span><br><span class=\"line\">    function transferEther(address towho) payable &#123;</span><br><span class=\"line\">        towho.transfer(10);</span><br><span class=\"line\">        logSendEvent(towho, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function callNoFunc(address addr) returns (bool)&#123;</span><br><span class=\"line\">        return addr.call(&quot;tinyxiong&quot;, 1234);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function callfunc(address addr) returns (bool)&#123;</span><br><span class=\"line\">        bytes4 methodId = bytes4(keccak256(&quot;setScore(uint256)&quot;));</span><br><span class=\"line\">        return addr.call(methodId, 100);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getBalance() returns (uint) &#123;</span><br><span class=\"line\">        return this.balance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码运行及讲解\"><a href=\"#代码运行及讲解\" class=\"headerlink\" title=\"代码运行及讲解\"></a>代码运行及讲解</h3><p>代码运行及讲解，请订阅<a href=\"https://xiaozhuanlan.com/blockchaincore\">区块链技术</a>查看</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html\">Solidity官方文档-类型</a></p>\n<p>s</p>\n","more":"<p>Solidity教程系列第二篇 - Solidity地址类型介绍.<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"地址类型（Address）\"><a href=\"#地址类型（Address）\" class=\"headerlink\" title=\"地址类型（Address）\"></a>地址类型（Address）</h2><p>地址类型address是一个值类型，</p>\n<p><strong>地址</strong> ： 20字节（一个以太坊地址的长度），地址类型也有成员，地址是所有合约的基础<br>支持的运算符：</p>\n<pre><code>&lt;=, &lt;, ==, !=, &gt;= 和 &gt;\n&gt; 注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址。\n</code></pre>\n<h3 id=\"地址类型的成员\"><a href=\"#地址类型的成员\" class=\"headerlink\" title=\"地址类型的成员\"></a>地址类型的成员</h3><ul>\n<li><p>balance 属性及transfer() 函数<br>这里是地址类型相关成员的快速索引<br>balance用来查询账户余额，transfer()用来发送以太币（以wei为单位）。<br>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address x = 0x123;</span><br><span class=\"line\">address myAddress = this;</span><br><span class=\"line\">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注解</strong> ：如果x是合约地址，合约的回退函数（fallback 函数）会随transfer调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。</p>\n<blockquote>\n<p>关于回退函数（fallback 函数），简单来说它是合约中无函数名函数，下面代码事例中，进进一步讲解回退函数（fallback） 的使用。</p>\n</blockquote>\n</li>\n<li><p>send() 函数<br>send 与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。</p>\n<blockquote>\n<p><strong>警告</strong> ：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p>\n</blockquote>\n</li>\n<li><p>call(), callcode() 和 delegatecall() 函数<br>为了和非ABI协议的合约进行交互，可以使用call() 函数, 它用来向另一个合约发送原始数据，支持任何类型任意数量的参数，每个参数会按规则(ABI协议)打包成32字节并一一拼接到一起。一个例外是：如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名而直接使用。如果仅想发送消息体，需要避免第一个参数是4个字节。如下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class=\"line\">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class=\"line\">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure>\n\n<p>call函数返回一个bool值，以表明执行成功与否。正常结束返回true，异常终止返回false。但无法获取到结果数据，因为需要提前知道返回的数据的编码和数据大小（因不知道对方使用的协议格式，所以也不会知道返回的结果如何解析）。<br>还可以提供.gas()修饰器进行调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>类似还可以提供附带以太币：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>修饰器可以混合使用，修饰器调用顺序无所谓。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注解：目前还不能在重载函数上使用gas或value修饰符，A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.（这句我怕翻译的不准确，引用原文）</p>\n</blockquote>\n<p>同样我们也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的库代码。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。在homestead阶段之前，仅有一个受限的callcode()方法可用，但callcode未提供对msg.sender，msg.value的访问权限。</p>\n<p>上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。<br>.gas() 在call(), callcode() 和 delegatecall() 函数下都可以使用， delegatecall()不支持.value()</p>\n<blockquote>\n<p>注解：所有合约都继承了address的成员，因此可以使用this.balance查询余额。<br>callcode不鼓励使用，以后会移除。</p>\n</blockquote>\n<blockquote>\n<p>警告：上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"地址常量（Address-Literals）\"><a href=\"#地址常量（Address-Literals）\" class=\"headerlink\" title=\"地址常量（Address Literals）\"></a>地址常量（Address Literals）</h2><p>一个能通过地址合法性检查（address checksum test）十六进制常量就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。而不能通过地址合法性检查的39到41位长的十六进制常量，会提示一个警告，被视为普通的有理数常量。</p>\n<blockquote>\n<p>地址合法性检查定义在<a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md\">EIP-55</a></p>\n</blockquote>\n<h2 id=\"合约事例讲解\"><a href=\"#合约事例讲解\" class=\"headerlink\" title=\"合约事例讲解\"></a>合约事例讲解</h2><h3 id=\"合约事例代码\"><a href=\"#合约事例代码\" class=\"headerlink\" title=\"合约事例代码\"></a>合约事例代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AddrTest&#123;</span><br><span class=\"line\">    event logdata(bytes data);</span><br><span class=\"line\">    function() payable &#123;</span><br><span class=\"line\">        logdata(msg.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getBalance() returns (uint) &#123;</span><br><span class=\"line\">        return this.balance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint score = 0;</span><br><span class=\"line\">    function setScore(uint s) public &#123;</span><br><span class=\"line\">        score = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getScore() returns ( uint)&#123;</span><br><span class=\"line\">        return score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CallTest&#123;</span><br><span class=\"line\">    function deposit() payable &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    event logSendEvent(address to, uint value);</span><br><span class=\"line\">    function transferEther(address towho) payable &#123;</span><br><span class=\"line\">        towho.transfer(10);</span><br><span class=\"line\">        logSendEvent(towho, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function callNoFunc(address addr) returns (bool)&#123;</span><br><span class=\"line\">        return addr.call(&quot;tinyxiong&quot;, 1234);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function callfunc(address addr) returns (bool)&#123;</span><br><span class=\"line\">        bytes4 methodId = bytes4(keccak256(&quot;setScore(uint256)&quot;));</span><br><span class=\"line\">        return addr.call(methodId, 100);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getBalance() returns (uint) &#123;</span><br><span class=\"line\">        return this.balance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码运行及讲解\"><a href=\"#代码运行及讲解\" class=\"headerlink\" title=\"代码运行及讲解\"></a>代码运行及讲解</h3><p>代码运行及讲解，请订阅<a href=\"https://xiaozhuanlan.com/blockchaincore\">区块链技术</a>查看</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html\">Solidity官方文档-类型</a></p>\n<p>s</p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}