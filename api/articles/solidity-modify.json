{"title":"智能合约语言 Solidity 教程系列10 - 完全理解函数修改器","slug":"solidity-modify","date":"2018-04-08T16:00:00.000Z","updated":"2022-10-19T14:40:00.266Z","comments":true,"path":"api/articles/solidity-modify.json","realPath":"/2018/solidity-modify/index/","excerpt":null,"covers":null,"cover":null,"content":"<p>智能合约语言 Solidity 教程系列10 - 完全理解函数修改器<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"函数修改器-Function-Modifiers\"><a href=\"#函数修改器-Function-Modifiers\" class=\"headerlink\" title=\"函数修改器(Function Modifiers)\"></a>函数修改器(Function Modifiers)</h2><p>函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。</p>\n<blockquote>\n<p>如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。</p>\n</blockquote>\n<p>修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。下面我们来看一段示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\">contract owned &#123;</span><br><span class=\"line\">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class=\"line\">    address owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定义了一个函数修改器，可被继承</span><br><span class=\"line\">    //  修饰时，函数体被插入到 “_;” 处</span><br><span class=\"line\">    // 不符合条件时，将抛出异常</span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract mortal is owned &#123;</span><br><span class=\"line\">    //  使用继承的`onlyOwner`</span><br><span class=\"line\">    function close() public onlyOwner &#123;</span><br><span class=\"line\">        selfdestruct(owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract priced &#123;</span><br><span class=\"line\">    // 函数修改器可接收参数</span><br><span class=\"line\">    modifier costs(uint price) &#123;</span><br><span class=\"line\">        if (msg.value &gt;= price) &#123;</span><br><span class=\"line\">            _;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Register is priced, owned &#123;</span><br><span class=\"line\">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class=\"line\">    uint price;</span><br><span class=\"line\"></span><br><span class=\"line\">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 需要提供payable 以接受以太</span><br><span class=\"line\">    function register() public payable costs(price) &#123;</span><br><span class=\"line\">        registeredAddresses[msg.sender] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class=\"line\">        price = _price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面onlyOwner就是定义的一个函数修改器，当用这个修改器区修饰一个函数时，则函数必须满足onlyOwner的条件才能运行，这里的条件是：必须是合约的创建这才能调用函数，否则抛出异常。<br>我们在<a href=\"/2018/03/10/create-token2/\">实现一个可管理、增发、兑换、冻结等高级功能的代币</a>文章中就使用了这个函数修改器。</p>\n<h3 id=\"多个修改器\"><a href=\"#多个修改器\" class=\"headerlink\" title=\"多个修改器\"></a>多个修改器</h3><p>如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。</p>\n<p>在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的”_”后继续执行， 如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Mutex &#123;</span><br><span class=\"line\">    bool locked;</span><br><span class=\"line\">    modifier noReentrancy() &#123;</span><br><span class=\"line\">        require(!locked);</span><br><span class=\"line\">        locked = true;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        locked = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止递归调用</span><br><span class=\"line\">    // return 7 之后，locked = false 依然会执行</span><br><span class=\"line\">    function f() public noReentrancy returns (uint) &#123;</span><br><span class=\"line\">        require(msg.sender.call());</span><br><span class=\"line\">        return 7;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。</p>\n<h3 id=\"深入理解修改器的执行次序\"><a href=\"#深入理解修改器的执行次序\" class=\"headerlink\" title=\"深入理解修改器的执行次序\"></a>深入理解修改器的执行次序</h3><p>再来看一个复杂一点的例子，来深入理解修改器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">contract modifysample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint a = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier mf1 (uint b) &#123;</span><br><span class=\"line\">        uint c = b;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        c = a;</span><br><span class=\"line\">        a = 11;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     modifier mf2 () &#123;</span><br><span class=\"line\">        uint c = a;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier mf3() &#123;</span><br><span class=\"line\">        a = 12;</span><br><span class=\"line\">        return ;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        a = 13;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function test1() mf1(a) mf2 mf3 public   &#123;</span><br><span class=\"line\">        a = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     function test2() public constant returns (uint)   &#123;</span><br><span class=\"line\">        return a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的智能合约运行test1()之后，状态变量a的值是多少， 是1， 11， 12，还是13呢？<br>答案是 11, 大家可以运行下test2获取下a值。</p>\n<p>我们来分析一下 test1， 它扩展之后是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint c = b;</span><br><span class=\"line\">        uint c = a;</span><br><span class=\"line\">            a = 12;</span><br><span class=\"line\">            return ;</span><br><span class=\"line\">            _;</span><br><span class=\"line\">            a = 13;</span><br><span class=\"line\">c = a;</span><br><span class=\"line\">a = 11;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候就一目了然了，最后a 为11， 注意第5及第6行是不是执行的。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers\">官方文档-Function Modifiers</a></p>\n","more":"<p>智能合约语言 Solidity 教程系列10 - 完全理解函数修改器<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"函数修改器-Function-Modifiers\"><a href=\"#函数修改器-Function-Modifiers\" class=\"headerlink\" title=\"函数修改器(Function Modifiers)\"></a>函数修改器(Function Modifiers)</h2><p>函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。</p>\n<blockquote>\n<p>如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。</p>\n</blockquote>\n<p>修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。下面我们来看一段示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\">contract owned &#123;</span><br><span class=\"line\">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class=\"line\">    address owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定义了一个函数修改器，可被继承</span><br><span class=\"line\">    //  修饰时，函数体被插入到 “_;” 处</span><br><span class=\"line\">    // 不符合条件时，将抛出异常</span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract mortal is owned &#123;</span><br><span class=\"line\">    //  使用继承的`onlyOwner`</span><br><span class=\"line\">    function close() public onlyOwner &#123;</span><br><span class=\"line\">        selfdestruct(owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract priced &#123;</span><br><span class=\"line\">    // 函数修改器可接收参数</span><br><span class=\"line\">    modifier costs(uint price) &#123;</span><br><span class=\"line\">        if (msg.value &gt;= price) &#123;</span><br><span class=\"line\">            _;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Register is priced, owned &#123;</span><br><span class=\"line\">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class=\"line\">    uint price;</span><br><span class=\"line\"></span><br><span class=\"line\">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 需要提供payable 以接受以太</span><br><span class=\"line\">    function register() public payable costs(price) &#123;</span><br><span class=\"line\">        registeredAddresses[msg.sender] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class=\"line\">        price = _price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面onlyOwner就是定义的一个函数修改器，当用这个修改器区修饰一个函数时，则函数必须满足onlyOwner的条件才能运行，这里的条件是：必须是合约的创建这才能调用函数，否则抛出异常。<br>我们在<a href=\"/2018/03/10/create-token2/\">实现一个可管理、增发、兑换、冻结等高级功能的代币</a>文章中就使用了这个函数修改器。</p>\n<h3 id=\"多个修改器\"><a href=\"#多个修改器\" class=\"headerlink\" title=\"多个修改器\"></a>多个修改器</h3><p>如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。</p>\n<p>在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的”_”后继续执行， 如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Mutex &#123;</span><br><span class=\"line\">    bool locked;</span><br><span class=\"line\">    modifier noReentrancy() &#123;</span><br><span class=\"line\">        require(!locked);</span><br><span class=\"line\">        locked = true;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        locked = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止递归调用</span><br><span class=\"line\">    // return 7 之后，locked = false 依然会执行</span><br><span class=\"line\">    function f() public noReentrancy returns (uint) &#123;</span><br><span class=\"line\">        require(msg.sender.call());</span><br><span class=\"line\">        return 7;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。</p>\n<h3 id=\"深入理解修改器的执行次序\"><a href=\"#深入理解修改器的执行次序\" class=\"headerlink\" title=\"深入理解修改器的执行次序\"></a>深入理解修改器的执行次序</h3><p>再来看一个复杂一点的例子，来深入理解修改器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">contract modifysample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint a = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier mf1 (uint b) &#123;</span><br><span class=\"line\">        uint c = b;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        c = a;</span><br><span class=\"line\">        a = 11;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     modifier mf2 () &#123;</span><br><span class=\"line\">        uint c = a;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier mf3() &#123;</span><br><span class=\"line\">        a = 12;</span><br><span class=\"line\">        return ;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        a = 13;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function test1() mf1(a) mf2 mf3 public   &#123;</span><br><span class=\"line\">        a = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     function test2() public constant returns (uint)   &#123;</span><br><span class=\"line\">        return a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的智能合约运行test1()之后，状态变量a的值是多少， 是1， 11， 12，还是13呢？<br>答案是 11, 大家可以运行下test2获取下a值。</p>\n<p>我们来分析一下 test1， 它扩展之后是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint c = b;</span><br><span class=\"line\">        uint c = a;</span><br><span class=\"line\">            a = 12;</span><br><span class=\"line\">            return ;</span><br><span class=\"line\">            _;</span><br><span class=\"line\">            a = 13;</span><br><span class=\"line\">c = a;</span><br><span class=\"line\">a = 11;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候就一目了然了，最后a 为11， 注意第5及第6行是不是执行的。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers\">官方文档-Function Modifiers</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}