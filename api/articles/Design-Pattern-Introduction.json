{"title":"23种设计模式总览","slug":"Design-Pattern-Introduction","date":"2018-04-22T04:22:22.000Z","updated":"2022-10-19T14:40:00.237Z","comments":true,"path":"api/articles/Design-Pattern-Introduction.json","realPath":"/2018/Design-Pattern-Introduction/index/","excerpt":null,"covers":["/img/java/2h6UCe.jpg"],"cover":"/img/java/2h6UCe.jpg","content":"<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了更好的代码<code>可重用性</code>、<code>可读性</code>、<code>可靠性</code>和<code>可维护性</code>。</p>\n<h2 id=\"设计模式3大分类\"><a href=\"#设计模式3大分类\" class=\"headerlink\" title=\"设计模式3大分类\"></a>设计模式3大分类</h2><h3 id=\"创建型模式（5种）\"><a href=\"#创建型模式（5种）\" class=\"headerlink\" title=\"创建型模式（5种）\"></a>创建型模式（5种）</h3><ul>\n<li>单例模式（Singleton Pattern）</li>\n<li>工厂方法模式（Factory Method Pattern）</li>\n<li>抽象工厂模式（Abstract Factory Pattern）</li>\n<li>建造者模式（Builder Pattern）</li>\n<li>原型模式（Prototype Pattern）</li>\n</ul>\n<h3 id=\"结构型模式（7种）\"><a href=\"#结构型模式（7种）\" class=\"headerlink\" title=\"结构型模式（7种）\"></a>结构型模式（7种）</h3><ul>\n<li>适配器模式（Adapter Pattern）</li>\n<li>装饰者模式（Decorator Pattern）</li>\n<li>代理模式（Proxy Pattern）</li>\n<li>外观模式（Facade Pattern）</li>\n<li>桥接模式（Bridge Pattern）</li>\n<li>组合模式（Composite Pattern）</li>\n<li>享元模式（Flyweight Pattern）</li>\n</ul>\n<h3 id=\"行为型模式（11种）\"><a href=\"#行为型模式（11种）\" class=\"headerlink\" title=\"行为型模式（11种）\"></a>行为型模式（11种）</h3><ul>\n<li>策略模式（Strategy Pattern）</li>\n<li>模板方法模式（Template Method Pattern）</li>\n<li>观察者模式（Observer Pattern）</li>\n<li>迭代器模式（Iterator Pattern）</li>\n<li>责任链模式（Chain Of Responsibility Pattern）</li>\n<li>命令模式（Command Pattern）</li>\n<li>备忘录模式（Memento Pattern）</li>\n<li>状态模式（Status Pattern）</li>\n<li>访问者模式（Visitor Pattern）</li>\n<li>中介者模式（Mediator Pattern）</li>\n<li>解释器模式（Interpreter Pattern</li>\n</ul>\n<h2 id=\"设计模式6大原则\"><a href=\"#设计模式6大原则\" class=\"headerlink\" title=\"设计模式6大原则\"></a>设计模式6大原则</h2><h3 id=\"单一职责原则（Single-Responsibility-Principle-SRP）\"><a href=\"#单一职责原则（Single-Responsibility-Principle-SRP）\" class=\"headerlink\" title=\"单一职责原则（Single Responsibility Principle, SRP）\"></a>单一职责原则（Single Responsibility Principle, SRP）</h3><blockquote>\n<p>就一个类而言，应该只有一个引起它变化的原因。</p>\n</blockquote>\n<ul>\n<li>降低类的复杂度，一个类只负责一项职责；</li>\n<li>提高类的可读性和可维护性；</li>\n<li>降低变更引起的风险。</li>\n</ul>\n<h3 id=\"里氏替换原则（Liskov-Substitution-Principle-LSP）\"><a href=\"#里氏替换原则（Liskov-Substitution-Principle-LSP）\" class=\"headerlink\" title=\"里氏替换原则（Liskov Substitution Principle, LSP）\"></a>里氏替换原则（Liskov Substitution Principle, LSP）</h3><blockquote>\n<p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>\n</blockquote>\n<ul>\n<li>里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</li>\n<li>任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li>\n</ul>\n<h3 id=\"依赖倒转原则（Dependence-Inversion-Principle-DIP）\"><a href=\"#依赖倒转原则（Dependence-Inversion-Principle-DIP）\" class=\"headerlink\" title=\"依赖倒转原则（Dependence Inversion Principle, DIP）\"></a>依赖倒转原则（Dependence Inversion Principle, DIP）</h3><blockquote>\n<p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>\n</blockquote>\n<ul>\n<li>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入（DependencyInjection, DI）的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</li>\n<li>常用的注入方式有三种，分别是：<code>构造注入</code>，<code>设值注入（Setter注入）</code>和<code>接口注入</code>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过 Setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</li>\n</ul>\n<h3 id=\"接口隔离原则（Interface-Segregation-Principle-ISP）\"><a href=\"#接口隔离原则（Interface-Segregation-Principle-ISP）\" class=\"headerlink\" title=\"接口隔离原则（Interface Segregation Principle, ISP）\"></a>接口隔离原则（Interface Segregation Principle, ISP）</h3><blockquote>\n<p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>\n</blockquote>\n<ul>\n<li>每个接口中不存在子类用不到却必须实现的方法，若存在，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</li>\n</ul>\n<h3 id=\"迪米特法则（Demeter-Principle-DP\"><a href=\"#迪米特法则（Demeter-Principle-DP\" class=\"headerlink\" title=\"迪米特法则（Demeter Principle, DP)\"></a>迪米特法则（Demeter Principle, DP)</h3><blockquote>\n<p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p>\n</blockquote>\n<ul>\n<li>迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP）。一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</li>\n</ul>\n<h3 id=\"开闭原则（Composite-Reuse-Principle-CRP）\"><a href=\"#开闭原则（Composite-Reuse-Principle-CRP）\" class=\"headerlink\" title=\"开闭原则（Composite Reuse Principle, CRP）\"></a>开闭原则（Composite Reuse Principle, CRP）</h3><blockquote>\n<p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>\n</blockquote>\n<ul>\n<li>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</li>\n</ul>\n<h2 id=\"设计模式之间的关系图\"><a href=\"#设计模式之间的关系图\" class=\"headerlink\" title=\"设计模式之间的关系图\"></a>设计模式之间的关系图</h2><p><img src=\"/img/java/2h6UCe.jpg\" alt=\"设计模式之间的关系\"></p>\n<p>【转载】原文出处：【[Mauger&#96;s Blog](<a href=\"https://wumaozheng.com/2018/Design-Pattern-Introduction.html)%E3%80%91\">https://wumaozheng.com/2018/Design-Pattern-Introduction.html)】</a></p>\n","more":"<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了更好的代码<code>可重用性</code>、<code>可读性</code>、<code>可靠性</code>和<code>可维护性</code>。</p>\n<h2 id=\"设计模式3大分类\"><a href=\"#设计模式3大分类\" class=\"headerlink\" title=\"设计模式3大分类\"></a>设计模式3大分类</h2><h3 id=\"创建型模式（5种）\"><a href=\"#创建型模式（5种）\" class=\"headerlink\" title=\"创建型模式（5种）\"></a>创建型模式（5种）</h3><ul>\n<li>单例模式（Singleton Pattern）</li>\n<li>工厂方法模式（Factory Method Pattern）</li>\n<li>抽象工厂模式（Abstract Factory Pattern）</li>\n<li>建造者模式（Builder Pattern）</li>\n<li>原型模式（Prototype Pattern）</li>\n</ul>\n<h3 id=\"结构型模式（7种）\"><a href=\"#结构型模式（7种）\" class=\"headerlink\" title=\"结构型模式（7种）\"></a>结构型模式（7种）</h3><ul>\n<li>适配器模式（Adapter Pattern）</li>\n<li>装饰者模式（Decorator Pattern）</li>\n<li>代理模式（Proxy Pattern）</li>\n<li>外观模式（Facade Pattern）</li>\n<li>桥接模式（Bridge Pattern）</li>\n<li>组合模式（Composite Pattern）</li>\n<li>享元模式（Flyweight Pattern）</li>\n</ul>\n<h3 id=\"行为型模式（11种）\"><a href=\"#行为型模式（11种）\" class=\"headerlink\" title=\"行为型模式（11种）\"></a>行为型模式（11种）</h3><ul>\n<li>策略模式（Strategy Pattern）</li>\n<li>模板方法模式（Template Method Pattern）</li>\n<li>观察者模式（Observer Pattern）</li>\n<li>迭代器模式（Iterator Pattern）</li>\n<li>责任链模式（Chain Of Responsibility Pattern）</li>\n<li>命令模式（Command Pattern）</li>\n<li>备忘录模式（Memento Pattern）</li>\n<li>状态模式（Status Pattern）</li>\n<li>访问者模式（Visitor Pattern）</li>\n<li>中介者模式（Mediator Pattern）</li>\n<li>解释器模式（Interpreter Pattern</li>\n</ul>\n<h2 id=\"设计模式6大原则\"><a href=\"#设计模式6大原则\" class=\"headerlink\" title=\"设计模式6大原则\"></a>设计模式6大原则</h2><h3 id=\"单一职责原则（Single-Responsibility-Principle-SRP）\"><a href=\"#单一职责原则（Single-Responsibility-Principle-SRP）\" class=\"headerlink\" title=\"单一职责原则（Single Responsibility Principle, SRP）\"></a>单一职责原则（Single Responsibility Principle, SRP）</h3><blockquote>\n<p>就一个类而言，应该只有一个引起它变化的原因。</p>\n</blockquote>\n<ul>\n<li>降低类的复杂度，一个类只负责一项职责；</li>\n<li>提高类的可读性和可维护性；</li>\n<li>降低变更引起的风险。</li>\n</ul>\n<h3 id=\"里氏替换原则（Liskov-Substitution-Principle-LSP）\"><a href=\"#里氏替换原则（Liskov-Substitution-Principle-LSP）\" class=\"headerlink\" title=\"里氏替换原则（Liskov Substitution Principle, LSP）\"></a>里氏替换原则（Liskov Substitution Principle, LSP）</h3><blockquote>\n<p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>\n</blockquote>\n<ul>\n<li>里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</li>\n<li>任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li>\n</ul>\n<h3 id=\"依赖倒转原则（Dependence-Inversion-Principle-DIP）\"><a href=\"#依赖倒转原则（Dependence-Inversion-Principle-DIP）\" class=\"headerlink\" title=\"依赖倒转原则（Dependence Inversion Principle, DIP）\"></a>依赖倒转原则（Dependence Inversion Principle, DIP）</h3><blockquote>\n<p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>\n</blockquote>\n<ul>\n<li>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入（DependencyInjection, DI）的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</li>\n<li>常用的注入方式有三种，分别是：<code>构造注入</code>，<code>设值注入（Setter注入）</code>和<code>接口注入</code>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过 Setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</li>\n</ul>\n<h3 id=\"接口隔离原则（Interface-Segregation-Principle-ISP）\"><a href=\"#接口隔离原则（Interface-Segregation-Principle-ISP）\" class=\"headerlink\" title=\"接口隔离原则（Interface Segregation Principle, ISP）\"></a>接口隔离原则（Interface Segregation Principle, ISP）</h3><blockquote>\n<p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>\n</blockquote>\n<ul>\n<li>每个接口中不存在子类用不到却必须实现的方法，若存在，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</li>\n</ul>\n<h3 id=\"迪米特法则（Demeter-Principle-DP\"><a href=\"#迪米特法则（Demeter-Principle-DP\" class=\"headerlink\" title=\"迪米特法则（Demeter Principle, DP)\"></a>迪米特法则（Demeter Principle, DP)</h3><blockquote>\n<p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p>\n</blockquote>\n<ul>\n<li>迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP）。一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</li>\n</ul>\n<h3 id=\"开闭原则（Composite-Reuse-Principle-CRP）\"><a href=\"#开闭原则（Composite-Reuse-Principle-CRP）\" class=\"headerlink\" title=\"开闭原则（Composite Reuse Principle, CRP）\"></a>开闭原则（Composite Reuse Principle, CRP）</h3><blockquote>\n<p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>\n</blockquote>\n<ul>\n<li>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</li>\n</ul>\n<h2 id=\"设计模式之间的关系图\"><a href=\"#设计模式之间的关系图\" class=\"headerlink\" title=\"设计模式之间的关系图\"></a>设计模式之间的关系图</h2><p><img src=\"/img/java/2h6UCe.jpg\" alt=\"设计模式之间的关系\"></p>\n<p>【转载】原文出处：【[Mauger&#96;s Blog](<a href=\"https://wumaozheng.com/2018/Design-Pattern-Introduction.html)%E3%80%91\">https://wumaozheng.com/2018/Design-Pattern-Introduction.html)】</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"设计模式","path":"api/categories/设计模式.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}