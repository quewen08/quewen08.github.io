{"title":"智能合约语言 Solidity 教程系列5 - 数组介绍","slug":"solidity-arrays","date":"2018-03-12T16:00:00.000Z","updated":"2022-10-19T14:40:00.265Z","comments":true,"path":"api/articles/solidity-arrays.json","realPath":"/2018/solidity-arrays/solidity-arrays/","excerpt":null,"covers":null,"cover":null,"content":"<p>Solidity 教程系列第5篇 - Solidity 数组介绍。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"数组（Arrays）\"><a href=\"#数组（Arrays）\" class=\"headerlink\" title=\"数组（Arrays）\"></a>数组（Arrays）</h2><p>数组可以声明时指定长度，也可以是动态变长。对storage存储的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，结构体等。但对于memory的数组来说。如果作为public函数的参数，它不能是映射类型的数组，只能是支持<a href=\"https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#types\">ABI的类型</a>。</p>\n<p>一个元素类型为__T__ ，固定长度为__k__ 的数组，可以声明为__T[k]__ ，而一个动态大小（变长）的数组则声明为__T[]__ 。<br>还可以声明一个多维数组，如声明一个类型为uint的数组长度为5的变长数组（5个元素都是变长数组），可以声明为uint[][5]。（注意，相比非区块链语言，多维数组的长度声明是反的。）</p>\n<p>要访问第三个动态数组的第二个元素，使用x[2][1]。数组的序号是从0开始的，序号顺序与定义相反。</p>\n<p><strong>bytes</strong> 和__string__ 是一种特殊的数组。<strong>bytes</strong> 类似__byte[]__ ，但在外部函数作为参数调用中，<strong>bytes</strong> 会进行压缩打包。<strong>string</strong> 类似__bytes__ ，但不提供长度和按序号的访问方式（目前）。<br>所以应该尽量使用__bytes__ 而不是__byte[]__ 。</p>\n<blockquote>\n<p>可以将字符串s通过bytes(s)转为一个bytes，可以通过bytes(s).length获取长度，bytes(s)[n]获取对应的UTF-8编码。通过下标访问获取到的不是对应字符，而是UTF-8编码，比如中文编码是多字节，变长的，所以下标访问到的只是其中的一个编码。<br>类型为数组的状态变量，可以标记为public，从而让Solidity创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。（稍后代码示例）</p>\n</blockquote>\n<h2 id=\"创建内存数组\"><a href=\"#创建内存数组\" class=\"headerlink\" title=\"创建内存数组\"></a>创建内存数组</h2><p>可使用new关键字创建一个memory的数组。与stroage数组不同的是，你不能通过.length的长度来修改数组大小属性。我们来看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    function f(uint len) public pure &#123;</span><br><span class=\"line\">        uint[] memory a = new uint[](7);</span><br><span class=\"line\"></span><br><span class=\"line\">        //a.length = 100;  // 错误</span><br><span class=\"line\">        bytes memory b = new bytes(len);</span><br><span class=\"line\">        // Here we have a.length == 7 and b.length == len</span><br><span class=\"line\">        a[6] = 8;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"数组常量以及内联数组\"><a href=\"#数组常量以及内联数组\" class=\"headerlink\" title=\"数组常量以及内联数组\"></a>数组常量以及内联数组</h2><p>数组常量，是一个数组表达式（还没有赋值到变量）。下面是一个简单的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    function f() public pure &#123;</span><br><span class=\"line\">        g([uint(1), 2, 3]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function g(uint[3] _data) public pure &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过数组常量，创建的数组是memory的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如[1, 2, 3]，只需要uint8即可存储，它的类型是__uint8[3] memory__ 。</p>\n<p>由于g()方法的参数需要的是uint（默认的uint表示的其实是uint256），所以需要对第一个元素进行类型转换，使用uint(1)来进行这个转换。</p>\n<p>还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  无法编译</span><br><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    function f() public &#123;</span><br><span class=\"line\">        // The next line creates a type error because uint[3] memory</span><br><span class=\"line\">        // cannot be converted to uint[] memory.</span><br><span class=\"line\">        uint[] x = [uint(1), 3, 4];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>已经计划在未来移除这样的限制。当前因为ABI传递数组还有些问题。</p>\n<h2 id=\"成员\"><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h2><h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。<br>不能通过访问超出当前数组的长度的方式，来自动实现改变数组长度。memory数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整。</p>\n<h3 id=\"push方法\"><a href=\"#push方法\" class=\"headerlink\" title=\"push方法\"></a>push方法</h3><p>storage的变长数组和bytes都有一个push方法（string没有），用于附加新元素到数据末端，返回值为新的长度。</p>\n<h2 id=\"限制情况\"><a href=\"#限制情况\" class=\"headerlink\" title=\"限制情况\"></a>限制情况</h2><p>当前在external函数中，不能使用多维数组。</p>\n<p>另外，基于EVM的限制，不能通过外部函数返回动态的内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract C &#123;</span><br><span class=\"line\">     function f() returns (uint[]) &#123; ... &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个的例子中，如果通过web.js调用能返回数据，但从Solidity中调用不能返回数据。一种绕过这个问题的办法是使用一个非常大的静态数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ArrayContract &#123;</span><br><span class=\"line\">    uint[2**20] m_aLotOfIntegers;</span><br><span class=\"line\">    // 这里不是两个动态数组的数组，而是一个动态数组里，每个元素是长度为二的数组。</span><br><span class=\"line\">    bool[2][] m_pairsOfFlags;</span><br><span class=\"line\">    // newPairs 存在 memory里，因为是函数参数</span><br><span class=\"line\">    function setAllFlagPairs(bool[2][] newPairs) public &#123;</span><br><span class=\"line\">        m_pairsOfFlags = newPairs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setFlagPair(uint index, bool flagA, bool flagB) public &#123;</span><br><span class=\"line\">        // 访问不存在的index会抛出异常</span><br><span class=\"line\">        m_pairsOfFlags[index][0] = flagA;</span><br><span class=\"line\">        m_pairsOfFlags[index][1] = flagB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function changeFlagArraySize(uint newSize) public &#123;</span><br><span class=\"line\">        // 如果新size更小, 移除的元素会被销毁</span><br><span class=\"line\">        m_pairsOfFlags.length = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function clear() public &#123;</span><br><span class=\"line\">        // 销毁</span><br><span class=\"line\">        delete m_pairsOfFlags;</span><br><span class=\"line\">        delete m_aLotOfIntegers;</span><br><span class=\"line\">        // 同销毁一样的效果</span><br><span class=\"line\">        m_pairsOfFlags.length = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bytes m_byteData;</span><br><span class=\"line\"></span><br><span class=\"line\">    function byteArrays(bytes data) public &#123;</span><br><span class=\"line\">        // byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br><span class=\"line\">        // but can be treated identical to &quot;uint8[]&quot;</span><br><span class=\"line\">        m_byteData = data;</span><br><span class=\"line\">        m_byteData.length += 7;</span><br><span class=\"line\">        m_byteData[3] = byte(8);</span><br><span class=\"line\">        delete m_byteData[2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function addFlag(bool[2] flag) public returns (uint) &#123;</span><br><span class=\"line\">        return m_pairsOfFlags.push(flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function createMemoryArray(uint size) public pure returns (bytes) &#123;</span><br><span class=\"line\">        // Dynamic memory arrays are created using `new`:</span><br><span class=\"line\">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class=\"line\">        // Create a dynamic byte array:</span><br><span class=\"line\">        bytes memory b = new bytes(200);</span><br><span class=\"line\">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class=\"line\">            b[i] = byte(i);</span><br><span class=\"line\">        return b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html#arrays\">Solidity官方文档-数组</a></p>\n","more":"<p>Solidity 教程系列第5篇 - Solidity 数组介绍。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"数组（Arrays）\"><a href=\"#数组（Arrays）\" class=\"headerlink\" title=\"数组（Arrays）\"></a>数组（Arrays）</h2><p>数组可以声明时指定长度，也可以是动态变长。对storage存储的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，结构体等。但对于memory的数组来说。如果作为public函数的参数，它不能是映射类型的数组，只能是支持<a href=\"https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#types\">ABI的类型</a>。</p>\n<p>一个元素类型为__T__ ，固定长度为__k__ 的数组，可以声明为__T[k]__ ，而一个动态大小（变长）的数组则声明为__T[]__ 。<br>还可以声明一个多维数组，如声明一个类型为uint的数组长度为5的变长数组（5个元素都是变长数组），可以声明为uint[][5]。（注意，相比非区块链语言，多维数组的长度声明是反的。）</p>\n<p>要访问第三个动态数组的第二个元素，使用x[2][1]。数组的序号是从0开始的，序号顺序与定义相反。</p>\n<p><strong>bytes</strong> 和__string__ 是一种特殊的数组。<strong>bytes</strong> 类似__byte[]__ ，但在外部函数作为参数调用中，<strong>bytes</strong> 会进行压缩打包。<strong>string</strong> 类似__bytes__ ，但不提供长度和按序号的访问方式（目前）。<br>所以应该尽量使用__bytes__ 而不是__byte[]__ 。</p>\n<blockquote>\n<p>可以将字符串s通过bytes(s)转为一个bytes，可以通过bytes(s).length获取长度，bytes(s)[n]获取对应的UTF-8编码。通过下标访问获取到的不是对应字符，而是UTF-8编码，比如中文编码是多字节，变长的，所以下标访问到的只是其中的一个编码。<br>类型为数组的状态变量，可以标记为public，从而让Solidity创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。（稍后代码示例）</p>\n</blockquote>\n<h2 id=\"创建内存数组\"><a href=\"#创建内存数组\" class=\"headerlink\" title=\"创建内存数组\"></a>创建内存数组</h2><p>可使用new关键字创建一个memory的数组。与stroage数组不同的是，你不能通过.length的长度来修改数组大小属性。我们来看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    function f(uint len) public pure &#123;</span><br><span class=\"line\">        uint[] memory a = new uint[](7);</span><br><span class=\"line\"></span><br><span class=\"line\">        //a.length = 100;  // 错误</span><br><span class=\"line\">        bytes memory b = new bytes(len);</span><br><span class=\"line\">        // Here we have a.length == 7 and b.length == len</span><br><span class=\"line\">        a[6] = 8;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"数组常量以及内联数组\"><a href=\"#数组常量以及内联数组\" class=\"headerlink\" title=\"数组常量以及内联数组\"></a>数组常量以及内联数组</h2><p>数组常量，是一个数组表达式（还没有赋值到变量）。下面是一个简单的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    function f() public pure &#123;</span><br><span class=\"line\">        g([uint(1), 2, 3]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function g(uint[3] _data) public pure &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过数组常量，创建的数组是memory的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如[1, 2, 3]，只需要uint8即可存储，它的类型是__uint8[3] memory__ 。</p>\n<p>由于g()方法的参数需要的是uint（默认的uint表示的其实是uint256），所以需要对第一个元素进行类型转换，使用uint(1)来进行这个转换。</p>\n<p>还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  无法编译</span><br><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    function f() public &#123;</span><br><span class=\"line\">        // The next line creates a type error because uint[3] memory</span><br><span class=\"line\">        // cannot be converted to uint[] memory.</span><br><span class=\"line\">        uint[] x = [uint(1), 3, 4];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>已经计划在未来移除这样的限制。当前因为ABI传递数组还有些问题。</p>\n<h2 id=\"成员\"><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h2><h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。<br>不能通过访问超出当前数组的长度的方式，来自动实现改变数组长度。memory数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整。</p>\n<h3 id=\"push方法\"><a href=\"#push方法\" class=\"headerlink\" title=\"push方法\"></a>push方法</h3><p>storage的变长数组和bytes都有一个push方法（string没有），用于附加新元素到数据末端，返回值为新的长度。</p>\n<h2 id=\"限制情况\"><a href=\"#限制情况\" class=\"headerlink\" title=\"限制情况\"></a>限制情况</h2><p>当前在external函数中，不能使用多维数组。</p>\n<p>另外，基于EVM的限制，不能通过外部函数返回动态的内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract C &#123;</span><br><span class=\"line\">     function f() returns (uint[]) &#123; ... &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个的例子中，如果通过web.js调用能返回数据，但从Solidity中调用不能返回数据。一种绕过这个问题的办法是使用一个非常大的静态数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ArrayContract &#123;</span><br><span class=\"line\">    uint[2**20] m_aLotOfIntegers;</span><br><span class=\"line\">    // 这里不是两个动态数组的数组，而是一个动态数组里，每个元素是长度为二的数组。</span><br><span class=\"line\">    bool[2][] m_pairsOfFlags;</span><br><span class=\"line\">    // newPairs 存在 memory里，因为是函数参数</span><br><span class=\"line\">    function setAllFlagPairs(bool[2][] newPairs) public &#123;</span><br><span class=\"line\">        m_pairsOfFlags = newPairs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setFlagPair(uint index, bool flagA, bool flagB) public &#123;</span><br><span class=\"line\">        // 访问不存在的index会抛出异常</span><br><span class=\"line\">        m_pairsOfFlags[index][0] = flagA;</span><br><span class=\"line\">        m_pairsOfFlags[index][1] = flagB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function changeFlagArraySize(uint newSize) public &#123;</span><br><span class=\"line\">        // 如果新size更小, 移除的元素会被销毁</span><br><span class=\"line\">        m_pairsOfFlags.length = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function clear() public &#123;</span><br><span class=\"line\">        // 销毁</span><br><span class=\"line\">        delete m_pairsOfFlags;</span><br><span class=\"line\">        delete m_aLotOfIntegers;</span><br><span class=\"line\">        // 同销毁一样的效果</span><br><span class=\"line\">        m_pairsOfFlags.length = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bytes m_byteData;</span><br><span class=\"line\"></span><br><span class=\"line\">    function byteArrays(bytes data) public &#123;</span><br><span class=\"line\">        // byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br><span class=\"line\">        // but can be treated identical to &quot;uint8[]&quot;</span><br><span class=\"line\">        m_byteData = data;</span><br><span class=\"line\">        m_byteData.length += 7;</span><br><span class=\"line\">        m_byteData[3] = byte(8);</span><br><span class=\"line\">        delete m_byteData[2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function addFlag(bool[2] flag) public returns (uint) &#123;</span><br><span class=\"line\">        return m_pairsOfFlags.push(flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function createMemoryArray(uint size) public pure returns (bytes) &#123;</span><br><span class=\"line\">        // Dynamic memory arrays are created using `new`:</span><br><span class=\"line\">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class=\"line\">        // Create a dynamic byte array:</span><br><span class=\"line\">        bytes memory b = new bytes(200);</span><br><span class=\"line\">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class=\"line\">            b[i] = byte(i);</span><br><span class=\"line\">        return b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html#arrays\">Solidity官方文档-数组</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}