{"title":"智能合约语言 Solidity 教程系列1 - 类型介绍","slug":"solidity1","date":"2018-02-28T16:00:00.000Z","updated":"2022-10-19T14:40:00.268Z","comments":true,"path":"api/articles/solidity1.json","realPath":"/2018/solidity1/index/","excerpt":null,"covers":null,"cover":null,"content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a><br>Solidity教程会是一系列文章，本文是第一篇：介绍Solidity的变量类型。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>Solidity是一种静态类型语言，意味着每个变量（本地或状态变量）需要在编译时指定变量的类型（或至少可以推倒出类型）。Solidity提供了一些基本类型可以用来组合成复杂类型。</p>\n<p>Solidity类型分为两类：</p>\n<ul>\n<li>值类型(Value Type) - 变量在赋值或传参时，总是进行值拷贝。</li>\n<li>引用类型(Reference Types)</li>\n</ul>\n<h3 id=\"值类型-Value-Type\"><a href=\"#值类型-Value-Type\" class=\"headerlink\" title=\"值类型(Value Type)\"></a>值类型(Value Type)</h3><p>值类型包含:</p>\n<ul>\n<li>布尔类型(Booleans)</li>\n<li>整型(Integers)</li>\n<li>定长浮点型(Fixed Point Numbers)</li>\n<li>定长字节数组(Fixed-size byte arrays)</li>\n<li>有理数和整型常量(Rational and Integer Literals)</li>\n<li>字符串常量（String literals）</li>\n<li>十六进制常量（Hexadecimal literals）</li>\n<li>枚举(Enums)</li>\n<li><a href=\"\">函数类型(Function Types)</a></li>\n<li><a href=\"\">地址类型(Address)</a></li>\n<li>地址常量(Address Literals)<blockquote>\n<p><a href=\"\">函数类型</a>及<a href=\"\">地址类型(Address)</a>有单独的博文，请点击查看。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"布尔类型-Boolean\"><a href=\"#布尔类型-Boolean\" class=\"headerlink\" title=\"布尔类型(Boolean)\"></a>布尔类型(Boolean)</h2><p>布尔(bool):可能的取值为常量值true和false。</p>\n<p>布尔类型支持的运算符有：</p>\n<ul>\n<li>！逻辑非</li>\n<li>&amp;&amp; 逻辑与</li>\n<li>|| 逻辑或</li>\n<li>&#x3D;&#x3D; 等于</li>\n<li>!&#x3D; 不等于</li>\n</ul>\n<p>注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。</p>\n<h2 id=\"整型-Integers\"><a href=\"#整型-Integers\" class=\"headerlink\" title=\"整型(Integers)\"></a>整型(Integers)</h2><p>int&#x2F;uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)，<br>uint 和 int 默认对应的是 uint256 和 int256。</p>\n<p>支持的运算符：</p>\n<ul>\n<li>比较运算符： &lt;&#x3D;, &lt; , &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回布尔值：true 或 false)</li>\n<li>位操作符： &amp;，|，^(异或)，~（位取反）</li>\n<li>算术操作符：+，-，一元运算-，一元运算+，，&#x2F;, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li>\n</ul>\n<p>说明：</p>\n<ol>\n<li>整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。</li>\n<li>整数除0会抛异常。</li>\n<li>移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x  2**y 是相等， x &gt;&gt; y 和 x &#x2F; 2**y 是相等的。</li>\n<li>不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。</li>\n</ol>\n<p>注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。</p>\n<h2 id=\"定长浮点型（Fixed-Point-Numbers）\"><a href=\"#定长浮点型（Fixed-Point-Numbers）\" class=\"headerlink\" title=\"定长浮点型（Fixed Point Numbers）\"></a>定长浮点型（Fixed Point Numbers）</h2><p>fixed&#x2F;ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。<br>M表示这个类型要占用的位数，以8步进，可为8到256位。<br>N表示小数点的个数，可为0到80之前</p>\n<p>支持的运算符：</p>\n<ul>\n<li>比较运算符： &lt;&#x3D;, &lt; , &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回布尔值：true 或 false)</li>\n<li>算术操作符：+，-，一元运算-，一元运算+，，&#x2F;, %(取余数)<br>注意：它和大多数语言的float和double不一样，*M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。</li>\n</ul>\n<h2 id=\"定长字节数组-Fixed-size-byte-arrays\"><a href=\"#定长字节数组-Fixed-size-byte-arrays\" class=\"headerlink\" title=\"定长字节数组(Fixed-size byte arrays)\"></a>定长字节数组(Fixed-size byte arrays)</h2><p>关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增）<br>byte代表bytes1。</p>\n<p>支持的运算符：</p>\n<ul>\n<li>比较符: &lt;&#x3D;, &lt;, &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回bool）</li>\n<li>位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li>\n<li>索引（下标）访问: 如果x是bytesI，当0 &lt;&#x3D; k &lt; I ，则x[k]返回第k个字节（只读）。</li>\n</ul>\n<p>移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。<br>如可以-5&lt;&lt;1, 不可以5&lt;&lt;-1</p>\n<p>成员变量：<br>.length：表示这个字节数组的长度（只读）。</p>\n<h2 id=\"变长（动态分配大小）字节数组（Dynamically-sized-byte-array）\"><a href=\"#变长（动态分配大小）字节数组（Dynamically-sized-byte-array）\" class=\"headerlink\" title=\"变长（动态分配大小）字节数组（Dynamically-sized byte array）\"></a>变长（动态分配大小）字节数组（Dynamically-sized byte array）</h2><ul>\n<li>bytes:动态分配大小字节数组, 参见Arrays,不是值类型!</li>\n<li>string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型!</li>\n</ul>\n<p>根据经验：<br>bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。<br>如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。</p>\n<h2 id=\"有理数和整型常量-Rational-and-Integer-Literals\"><a href=\"#有理数和整型常量-Rational-and-Integer-Literals\" class=\"headerlink\" title=\"有理数和整型常量(Rational and Integer Literals)\"></a>有理数和整型常量(Rational and Integer Literals)</h2><blockquote>\n<p>也有人把Literals翻译为字面量</p>\n</blockquote>\n<p>整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。</p>\n<p>10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3.</p>\n<p>科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。</p>\n<p>数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。<br>如：(2<em>800 + 1) - 2</em>800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。</p>\n<p>只要操作数是整形，整型支持的运算符都适用于整型常量表达式。<br>如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。</p>\n<p>注意：<br>Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3</p>\n<p>警告：<br>整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5&#x2F;2的值为 2.5</p>\n<p>注意：<br>数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint128 a = 1;</span><br><span class=\"line\">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码编译不能通过，因为b会被编译器认为是小数型。</p>\n<h2 id=\"字符串常量\"><a href=\"#字符串常量\" class=\"headerlink\" title=\"字符串常量\"></a>字符串常量</h2><p>字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。</p>\n<p>字符串常量支持转义字符，比如\\n，\\xNN，\\uNNNN。其中\\xNN表示16进制值，最终转换合适的字节。而\\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。</p>\n<h2 id=\"十六进制常量（Hexadecimal-literals）\"><a href=\"#十六进制常量（Hexadecimal-literals）\" class=\"headerlink\" title=\"十六进制常量（Hexadecimal literals）\"></a>十六进制常量（Hexadecimal literals）</h2><p>十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。<br>它的值会用二进制来表示。</p>\n<p>十六进制常量和字符串常量类似，也可以转换为字节数组。</p>\n<h2 id=\"枚举（Enums）\"><a href=\"#枚举（Enums）\" class=\"headerlink\" title=\"枚举（Enums）\"></a>枚举（Enums）</h2><p>在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract test &#123;</span><br><span class=\"line\">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class=\"line\">    ActionChoices choice;</span><br><span class=\"line\">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setGoStraight() &#123;</span><br><span class=\"line\">        choice = ActionChoices.GoStraight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class=\"line\">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class=\"line\">    // for all matters external to Solidity. The integer type used is just</span><br><span class=\"line\">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class=\"line\">    // `uint16` will be used and so on.</span><br><span class=\"line\">    function getChoice() returns (ActionChoices) &#123;</span><br><span class=\"line\">        return choice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getDefaultChoice() returns (uint) &#123;</span><br><span class=\"line\">        return uint(defaultChoice);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代码实例\"><a href=\"#代码实例\" class=\"headerlink\" title=\"代码实例\"></a>代码实例</h2><p>通过合约代码实例说明类型的使用，请订阅<a href=\"https://xiaozhuanlan.com/blockchaincore\">区块链技术</a>查看。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html\">Solidity官方文档-类型</a></p>\n","more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a><br>Solidity教程会是一系列文章，本文是第一篇：介绍Solidity的变量类型。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>Solidity是一种静态类型语言，意味着每个变量（本地或状态变量）需要在编译时指定变量的类型（或至少可以推倒出类型）。Solidity提供了一些基本类型可以用来组合成复杂类型。</p>\n<p>Solidity类型分为两类：</p>\n<ul>\n<li>值类型(Value Type) - 变量在赋值或传参时，总是进行值拷贝。</li>\n<li>引用类型(Reference Types)</li>\n</ul>\n<h3 id=\"值类型-Value-Type\"><a href=\"#值类型-Value-Type\" class=\"headerlink\" title=\"值类型(Value Type)\"></a>值类型(Value Type)</h3><p>值类型包含:</p>\n<ul>\n<li>布尔类型(Booleans)</li>\n<li>整型(Integers)</li>\n<li>定长浮点型(Fixed Point Numbers)</li>\n<li>定长字节数组(Fixed-size byte arrays)</li>\n<li>有理数和整型常量(Rational and Integer Literals)</li>\n<li>字符串常量（String literals）</li>\n<li>十六进制常量（Hexadecimal literals）</li>\n<li>枚举(Enums)</li>\n<li><a href=\"\">函数类型(Function Types)</a></li>\n<li><a href=\"\">地址类型(Address)</a></li>\n<li>地址常量(Address Literals)<blockquote>\n<p><a href=\"\">函数类型</a>及<a href=\"\">地址类型(Address)</a>有单独的博文，请点击查看。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"布尔类型-Boolean\"><a href=\"#布尔类型-Boolean\" class=\"headerlink\" title=\"布尔类型(Boolean)\"></a>布尔类型(Boolean)</h2><p>布尔(bool):可能的取值为常量值true和false。</p>\n<p>布尔类型支持的运算符有：</p>\n<ul>\n<li>！逻辑非</li>\n<li>&amp;&amp; 逻辑与</li>\n<li>|| 逻辑或</li>\n<li>&#x3D;&#x3D; 等于</li>\n<li>!&#x3D; 不等于</li>\n</ul>\n<p>注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。</p>\n<h2 id=\"整型-Integers\"><a href=\"#整型-Integers\" class=\"headerlink\" title=\"整型(Integers)\"></a>整型(Integers)</h2><p>int&#x2F;uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)，<br>uint 和 int 默认对应的是 uint256 和 int256。</p>\n<p>支持的运算符：</p>\n<ul>\n<li>比较运算符： &lt;&#x3D;, &lt; , &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回布尔值：true 或 false)</li>\n<li>位操作符： &amp;，|，^(异或)，~（位取反）</li>\n<li>算术操作符：+，-，一元运算-，一元运算+，，&#x2F;, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li>\n</ul>\n<p>说明：</p>\n<ol>\n<li>整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。</li>\n<li>整数除0会抛异常。</li>\n<li>移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x  2**y 是相等， x &gt;&gt; y 和 x &#x2F; 2**y 是相等的。</li>\n<li>不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。</li>\n</ol>\n<p>注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。</p>\n<h2 id=\"定长浮点型（Fixed-Point-Numbers）\"><a href=\"#定长浮点型（Fixed-Point-Numbers）\" class=\"headerlink\" title=\"定长浮点型（Fixed Point Numbers）\"></a>定长浮点型（Fixed Point Numbers）</h2><p>fixed&#x2F;ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。<br>M表示这个类型要占用的位数，以8步进，可为8到256位。<br>N表示小数点的个数，可为0到80之前</p>\n<p>支持的运算符：</p>\n<ul>\n<li>比较运算符： &lt;&#x3D;, &lt; , &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回布尔值：true 或 false)</li>\n<li>算术操作符：+，-，一元运算-，一元运算+，，&#x2F;, %(取余数)<br>注意：它和大多数语言的float和double不一样，*M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。</li>\n</ul>\n<h2 id=\"定长字节数组-Fixed-size-byte-arrays\"><a href=\"#定长字节数组-Fixed-size-byte-arrays\" class=\"headerlink\" title=\"定长字节数组(Fixed-size byte arrays)\"></a>定长字节数组(Fixed-size byte arrays)</h2><p>关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增）<br>byte代表bytes1。</p>\n<p>支持的运算符：</p>\n<ul>\n<li>比较符: &lt;&#x3D;, &lt;, &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回bool）</li>\n<li>位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li>\n<li>索引（下标）访问: 如果x是bytesI，当0 &lt;&#x3D; k &lt; I ，则x[k]返回第k个字节（只读）。</li>\n</ul>\n<p>移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。<br>如可以-5&lt;&lt;1, 不可以5&lt;&lt;-1</p>\n<p>成员变量：<br>.length：表示这个字节数组的长度（只读）。</p>\n<h2 id=\"变长（动态分配大小）字节数组（Dynamically-sized-byte-array）\"><a href=\"#变长（动态分配大小）字节数组（Dynamically-sized-byte-array）\" class=\"headerlink\" title=\"变长（动态分配大小）字节数组（Dynamically-sized byte array）\"></a>变长（动态分配大小）字节数组（Dynamically-sized byte array）</h2><ul>\n<li>bytes:动态分配大小字节数组, 参见Arrays,不是值类型!</li>\n<li>string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型!</li>\n</ul>\n<p>根据经验：<br>bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。<br>如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。</p>\n<h2 id=\"有理数和整型常量-Rational-and-Integer-Literals\"><a href=\"#有理数和整型常量-Rational-and-Integer-Literals\" class=\"headerlink\" title=\"有理数和整型常量(Rational and Integer Literals)\"></a>有理数和整型常量(Rational and Integer Literals)</h2><blockquote>\n<p>也有人把Literals翻译为字面量</p>\n</blockquote>\n<p>整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。</p>\n<p>10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3.</p>\n<p>科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。</p>\n<p>数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。<br>如：(2<em>800 + 1) - 2</em>800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。</p>\n<p>只要操作数是整形，整型支持的运算符都适用于整型常量表达式。<br>如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。</p>\n<p>注意：<br>Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3</p>\n<p>警告：<br>整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5&#x2F;2的值为 2.5</p>\n<p>注意：<br>数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint128 a = 1;</span><br><span class=\"line\">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码编译不能通过，因为b会被编译器认为是小数型。</p>\n<h2 id=\"字符串常量\"><a href=\"#字符串常量\" class=\"headerlink\" title=\"字符串常量\"></a>字符串常量</h2><p>字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。</p>\n<p>字符串常量支持转义字符，比如\\n，\\xNN，\\uNNNN。其中\\xNN表示16进制值，最终转换合适的字节。而\\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。</p>\n<h2 id=\"十六进制常量（Hexadecimal-literals）\"><a href=\"#十六进制常量（Hexadecimal-literals）\" class=\"headerlink\" title=\"十六进制常量（Hexadecimal literals）\"></a>十六进制常量（Hexadecimal literals）</h2><p>十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。<br>它的值会用二进制来表示。</p>\n<p>十六进制常量和字符串常量类似，也可以转换为字节数组。</p>\n<h2 id=\"枚举（Enums）\"><a href=\"#枚举（Enums）\" class=\"headerlink\" title=\"枚举（Enums）\"></a>枚举（Enums）</h2><p>在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract test &#123;</span><br><span class=\"line\">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class=\"line\">    ActionChoices choice;</span><br><span class=\"line\">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setGoStraight() &#123;</span><br><span class=\"line\">        choice = ActionChoices.GoStraight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class=\"line\">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class=\"line\">    // for all matters external to Solidity. The integer type used is just</span><br><span class=\"line\">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class=\"line\">    // `uint16` will be used and so on.</span><br><span class=\"line\">    function getChoice() returns (ActionChoices) &#123;</span><br><span class=\"line\">        return choice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getDefaultChoice() returns (uint) &#123;</span><br><span class=\"line\">        return uint(defaultChoice);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代码实例\"><a href=\"#代码实例\" class=\"headerlink\" title=\"代码实例\"></a>代码实例</h2><p>通过合约代码实例说明类型的使用，请订阅<a href=\"https://xiaozhuanlan.com/blockchaincore\">区块链技术</a>查看。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html\">Solidity官方文档-类型</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}