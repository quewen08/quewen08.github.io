{"title":"智能合约语言 Solidity 教程系列6 - 结构体与映射","slug":"solidity-structs","date":"2018-03-13T05:50:23.000Z","updated":"2022-10-19T14:40:00.267Z","comments":true,"path":"api/articles/solidity-structs.json","realPath":"/2018/solidity-structs/solidity-structs/","excerpt":null,"covers":null,"cover":null,"content":"<p>Solidity 教程系列第6篇 - Solidity 结构体与映射。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"结构体-Structs\"><a href=\"#结构体-Structs\" class=\"headerlink\" title=\"结构体(Structs)\"></a>结构体(Structs)</h2><p>Solidity提供__struct__ 来定义自定义类型，自定义的类型是引用类型。<br>我们看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CrowdFunding &#123;</span><br><span class=\"line\">    // 定义一个包含两个成员的新类型</span><br><span class=\"line\">    struct Funder &#123;</span><br><span class=\"line\">        address addr;</span><br><span class=\"line\">        uint amount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct Campaign &#123;</span><br><span class=\"line\">        address beneficiary;</span><br><span class=\"line\">        uint fundingGoal;</span><br><span class=\"line\">        uint numFunders;</span><br><span class=\"line\">        uint amount;</span><br><span class=\"line\">        mapping (uint =&gt; Funder) funders;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint numCampaigns;</span><br><span class=\"line\">    mapping (uint =&gt; Campaign) campaigns;</span><br><span class=\"line\"></span><br><span class=\"line\">    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) &#123;</span><br><span class=\"line\">        campaignID = numCampaigns++; // campaignID 作为一个变量返回</span><br><span class=\"line\">        // 创建一个结构体实例，存储在storage ，放入mapping里</span><br><span class=\"line\">        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function contribute(uint campaignID) public payable &#123;</span><br><span class=\"line\">        Campaign storage c = campaigns[campaignID];</span><br><span class=\"line\">        // 用mapping对应项创建一个结构体引用</span><br><span class=\"line\">        // 也可以用 Funder(msg.sender, msg.value) 来初始化.</span><br><span class=\"line\">        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</span><br><span class=\"line\">        c.amount += msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function checkGoalReached(uint campaignID) public returns (bool reached) &#123;</span><br><span class=\"line\">        Campaign storage c = campaigns[campaignID];</span><br><span class=\"line\">        if (c.amount &lt; c.fundingGoal)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        uint amount = c.amount;</span><br><span class=\"line\">        c.amount = 0;</span><br><span class=\"line\">        c.beneficiary.transfer(amount);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>上面是一个简化版的众筹合约，但它可以让我们理解__structs__ 的基础概念，<strong>struct</strong> 可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。</p>\n<p>不能声明一个__struct__ 同时将自身__struct__ 作为成员，这个限制是基于结构体的大小必须是有限的。<br>但__struct__ 可以作为__mapping__ 的值类型成员。</p>\n<p>注意在函数中，将一个__struct__ 赋值给一个局部变量（默认是__storage__ 类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。</p>\n<p>当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如__campaigns[campaignID].amount &#x3D; 0__</p>\n<h2 id=\"映射-Mappings\"><a href=\"#映射-Mappings\" class=\"headerlink\" title=\"映射(Mappings)\"></a>映射(Mappings)</h2><p>映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType &#x3D;&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。</p>\n<p><strong>映射</strong> 可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。<br>正因为此，<strong>映射</strong> 是没有长度的，也没有键集合或值集合的概念。</p>\n<p><strong>映射类型</strong> ，仅能用来作为状态变量，或在内部函数中作为__storage__ 类型的引用。</p>\n<p>可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。<br>映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。<br>来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MappingExample &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\"></span><br><span class=\"line\">    function update(uint newBalance) public &#123;</span><br><span class=\"line\">        balances[msg.sender] = newBalance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MappingUser &#123;</span><br><span class=\"line\">    function f() public returns (uint) &#123;</span><br><span class=\"line\">        MappingExample m = new MappingExample();</span><br><span class=\"line\">        m.update(100);</span><br><span class=\"line\">        return m.balances(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：<br>映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考<a href=\"https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol\">iterable mapping</a></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html#mappings\">Solidity官方文档</a></p>\n","more":"<p>Solidity 教程系列第6篇 - Solidity 结构体与映射。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"结构体-Structs\"><a href=\"#结构体-Structs\" class=\"headerlink\" title=\"结构体(Structs)\"></a>结构体(Structs)</h2><p>Solidity提供__struct__ 来定义自定义类型，自定义的类型是引用类型。<br>我们看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CrowdFunding &#123;</span><br><span class=\"line\">    // 定义一个包含两个成员的新类型</span><br><span class=\"line\">    struct Funder &#123;</span><br><span class=\"line\">        address addr;</span><br><span class=\"line\">        uint amount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct Campaign &#123;</span><br><span class=\"line\">        address beneficiary;</span><br><span class=\"line\">        uint fundingGoal;</span><br><span class=\"line\">        uint numFunders;</span><br><span class=\"line\">        uint amount;</span><br><span class=\"line\">        mapping (uint =&gt; Funder) funders;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint numCampaigns;</span><br><span class=\"line\">    mapping (uint =&gt; Campaign) campaigns;</span><br><span class=\"line\"></span><br><span class=\"line\">    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) &#123;</span><br><span class=\"line\">        campaignID = numCampaigns++; // campaignID 作为一个变量返回</span><br><span class=\"line\">        // 创建一个结构体实例，存储在storage ，放入mapping里</span><br><span class=\"line\">        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function contribute(uint campaignID) public payable &#123;</span><br><span class=\"line\">        Campaign storage c = campaigns[campaignID];</span><br><span class=\"line\">        // 用mapping对应项创建一个结构体引用</span><br><span class=\"line\">        // 也可以用 Funder(msg.sender, msg.value) 来初始化.</span><br><span class=\"line\">        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</span><br><span class=\"line\">        c.amount += msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function checkGoalReached(uint campaignID) public returns (bool reached) &#123;</span><br><span class=\"line\">        Campaign storage c = campaigns[campaignID];</span><br><span class=\"line\">        if (c.amount &lt; c.fundingGoal)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        uint amount = c.amount;</span><br><span class=\"line\">        c.amount = 0;</span><br><span class=\"line\">        c.beneficiary.transfer(amount);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>上面是一个简化版的众筹合约，但它可以让我们理解__structs__ 的基础概念，<strong>struct</strong> 可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。</p>\n<p>不能声明一个__struct__ 同时将自身__struct__ 作为成员，这个限制是基于结构体的大小必须是有限的。<br>但__struct__ 可以作为__mapping__ 的值类型成员。</p>\n<p>注意在函数中，将一个__struct__ 赋值给一个局部变量（默认是__storage__ 类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。</p>\n<p>当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如__campaigns[campaignID].amount &#x3D; 0__</p>\n<h2 id=\"映射-Mappings\"><a href=\"#映射-Mappings\" class=\"headerlink\" title=\"映射(Mappings)\"></a>映射(Mappings)</h2><p>映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType &#x3D;&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。</p>\n<p><strong>映射</strong> 可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。<br>正因为此，<strong>映射</strong> 是没有长度的，也没有键集合或值集合的概念。</p>\n<p><strong>映射类型</strong> ，仅能用来作为状态变量，或在内部函数中作为__storage__ 类型的引用。</p>\n<p>可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。<br>映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。<br>来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MappingExample &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\"></span><br><span class=\"line\">    function update(uint newBalance) public &#123;</span><br><span class=\"line\">        balances[msg.sender] = newBalance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MappingUser &#123;</span><br><span class=\"line\">    function f() public returns (uint) &#123;</span><br><span class=\"line\">        MappingExample m = new MappingExample();</span><br><span class=\"line\">        m.update(100);</span><br><span class=\"line\">        return m.balances(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：<br>映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考<a href=\"https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol\">iterable mapping</a></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html#mappings\">Solidity官方文档</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}