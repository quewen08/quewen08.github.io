{"title":"ArrayList与LinkedList遍历性能比较","slug":"arratlist-linkedlist-performance","date":"2018-12-06T03:21:00.000Z","updated":"2022-10-19T14:40:00.241Z","comments":true,"path":"api/articles/arratlist-linkedlist-performance.json","realPath":"/2018/arratlist-linkedlist-performance/index/","excerpt":null,"covers":null,"cover":null,"content":"<blockquote>\n<p>因为前段时间去了一个同学给介绍的企业去面试，然后面试官问了我这个问题，我之前有看过相关的博客，不过当时一时没有想起来，回来就自己试试咯。<br>以下是正文</p>\n</blockquote>\n<p>用实例测试ArrayList与LinkedList遍历性能。</p>\n<h2 id=\"结构差别\"><a href=\"#结构差别\" class=\"headerlink\" title=\"结构差别:\"></a>结构差别:</h2><p>我们常用的List有两种，ArrayList和LinkedList，虽然两者都是LIst，但由于内部存储结构的不同，使用不同的遍历方法性能却是千差万别的。</p>\n<table>\n<thead>\n<tr>\n<th>List</th>\n<th>存储结构</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>数组结构</td>\n<td>可以根据下标直接取值。</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>链表结构</td>\n<td>如果需要寻找某一个下标的数值必须从头遍历。</td>\n</tr>\n</tbody></table>\n<h2 id=\"常见做法\"><a href=\"#常见做法\" class=\"headerlink\" title=\"常见做法:\"></a>常见做法:</h2><p>我们在遍历List的时候可能会这样做(从C语言上带来的习惯):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loopList</span><span class=\"params\">(List&lt;Integer&gt; lists)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt; lists.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">integer</span> <span class=\"operator\">=</span> lists.get(i);</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种做法很直观，乍一看并没有什么问题，但是仔细分析一下就能知道，在这种情况下使用ArrayList与LinkedList性能是完全不同的。</p>\n<table>\n<thead>\n<tr>\n<th>List</th>\n<th align=\"center\">循环时间复杂度</th>\n<th align=\"center\">get(i)时间复杂度</th>\n<th align=\"center\">总时间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">O(n)</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n</tr>\n</tbody></table>\n<p>从时间复杂度上两者就直接差了一个数量级，可能这样说不明显，为了直观的表示，下面用代码测试处理10000条数据效率:</p>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试:\"></a>性能测试:</h3><p>创建数据:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">LinkedList&lt;Integer&gt; linkedList = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++)&#123;</span><br><span class=\"line\">    arrayList.add(i);</span><br><span class=\"line\">    linkedList.add(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试For循环用时:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> startTime1=System.currentTimeMillis();   <span class=\"comment\">//获取开始时间</span></span><br><span class=\"line\">loopList(arrayList);</span><br><span class=\"line\">iteratorList(arrayList);</span><br><span class=\"line\"><span class=\"type\">long</span> endTime1=System.currentTimeMillis(); <span class=\"comment\">//获取结束时间</span></span><br><span class=\"line\">Log.i(<span class=\"string\">&quot;Time&quot;</span>, <span class=\"string\">&quot;For-ArrayList： &quot;</span>+(endTime1-startTime1)+<span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> startTime2=System.currentTimeMillis();   <span class=\"comment\">//获取开始时间</span></span><br><span class=\"line\">loopList(linkedList);</span><br><span class=\"line\"><span class=\"type\">long</span> endTime2=System.currentTimeMillis(); <span class=\"comment\">//获取结束时间</span></span><br><span class=\"line\">Log.i(<span class=\"string\">&quot;Time&quot;</span>, <span class=\"string\">&quot;For-LinkedList：&quot;</span>+(endTime2-startTime2)+<span class=\"string\">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.gcssloop.alltest I/Time: For-ArrayList： 20ms</span><br><span class=\"line\">com.gcssloop.alltest I/Time: For-LinkedList：648ms</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，仅仅处理10000条数据两者所需时间简直不能比较，当数据量越来越大的时候，LinkedList必然会耗费更多时间。</p>\n<h2 id=\"处理办法\"><a href=\"#处理办法\" class=\"headerlink\" title=\"处理办法:\"></a>处理办法:</h2><p>我们在Java中有 迭代器(Iterator) 以及 ForEach 循环，可以用它们来替代掉这个原始的 for 循环。</p>\n<h3 id=\"迭代器-Iterator\"><a href=\"#迭代器-Iterator\" class=\"headerlink\" title=\"迭代器(Iterator):\"></a>迭代器(Iterator):</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">iteratorList</span><span class=\"params\">(List&lt;Integer&gt; lists)</span>&#123;</span><br><span class=\"line\">    Iterator&lt;Integer&gt; it = lists.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext())&#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">integer</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码与上面类似，就省略了。</p>\n<p>结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.gcssloop.alltest I/Time: Iterator-ArrayList： 4ms</span><br><span class=\"line\">com.gcssloop.alltest I/Time: Iterator-LinkedList：6ms</span><br></pre></td></tr></table></figure>\n\n<p><strong>可以看到，两者最终耗费时间差不多而且均有大幅度提升。</strong></p>\n<h3 id=\"ForEach循环\"><a href=\"#ForEach循环\" class=\"headerlink\" title=\"ForEach循环:\"></a>ForEach循环:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">foreachList</span><span class=\"params\">(List&lt;Integer&gt; lists)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer i : lists) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>性能:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.gcssloop.alltest I/Time: ForEach-ArrayList： 5ms</span><br><span class=\"line\">com.gcssloop.alltest I/Time: ForEach-LinkedList：5ms</span><br></pre></td></tr></table></figure>\n\n<p>由于 ForEach 循环底层使用的也是迭代器，所以和迭代器性能类似。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h2><p><strong>推荐使用 迭代器(Iterator) 和 ForEach 遍历 List，不要使用传统的 For 循环。</strong></p>\n<p>以下是测试处理10000条数据性能:</p>\n<blockquote>\n<p>数值仅供参考，与运行环境相关，每次测试结果都可能稍有差别。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">迭代方式</th>\n<th align=\"center\">ArrayList</th>\n<th align=\"center\">LinkedList</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">For循环</td>\n<td align=\"center\">20ms</td>\n<td align=\"center\">648ms</td>\n</tr>\n<tr>\n<td align=\"center\">Iterator</td>\n<td align=\"center\">4ms</td>\n<td align=\"center\">6ms</td>\n</tr>\n<tr>\n<td align=\"center\">for-each循环</td>\n<td align=\"center\">5ms</td>\n<td align=\"center\">5ms</td>\n</tr>\n</tbody></table>\n","more":"<blockquote>\n<p>因为前段时间去了一个同学给介绍的企业去面试，然后面试官问了我这个问题，我之前有看过相关的博客，不过当时一时没有想起来，回来就自己试试咯。<br>以下是正文</p>\n</blockquote>\n<p>用实例测试ArrayList与LinkedList遍历性能。</p>\n<h2 id=\"结构差别\"><a href=\"#结构差别\" class=\"headerlink\" title=\"结构差别:\"></a>结构差别:</h2><p>我们常用的List有两种，ArrayList和LinkedList，虽然两者都是LIst，但由于内部存储结构的不同，使用不同的遍历方法性能却是千差万别的。</p>\n<table>\n<thead>\n<tr>\n<th>List</th>\n<th>存储结构</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>数组结构</td>\n<td>可以根据下标直接取值。</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>链表结构</td>\n<td>如果需要寻找某一个下标的数值必须从头遍历。</td>\n</tr>\n</tbody></table>\n<h2 id=\"常见做法\"><a href=\"#常见做法\" class=\"headerlink\" title=\"常见做法:\"></a>常见做法:</h2><p>我们在遍历List的时候可能会这样做(从C语言上带来的习惯):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loopList</span><span class=\"params\">(List&lt;Integer&gt; lists)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt; lists.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">integer</span> <span class=\"operator\">=</span> lists.get(i);</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种做法很直观，乍一看并没有什么问题，但是仔细分析一下就能知道，在这种情况下使用ArrayList与LinkedList性能是完全不同的。</p>\n<table>\n<thead>\n<tr>\n<th>List</th>\n<th align=\"center\">循环时间复杂度</th>\n<th align=\"center\">get(i)时间复杂度</th>\n<th align=\"center\">总时间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">O(n)</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n</tr>\n</tbody></table>\n<p>从时间复杂度上两者就直接差了一个数量级，可能这样说不明显，为了直观的表示，下面用代码测试处理10000条数据效率:</p>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试:\"></a>性能测试:</h3><p>创建数据:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">LinkedList&lt;Integer&gt; linkedList = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++)&#123;</span><br><span class=\"line\">    arrayList.add(i);</span><br><span class=\"line\">    linkedList.add(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试For循环用时:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> startTime1=System.currentTimeMillis();   <span class=\"comment\">//获取开始时间</span></span><br><span class=\"line\">loopList(arrayList);</span><br><span class=\"line\">iteratorList(arrayList);</span><br><span class=\"line\"><span class=\"type\">long</span> endTime1=System.currentTimeMillis(); <span class=\"comment\">//获取结束时间</span></span><br><span class=\"line\">Log.i(<span class=\"string\">&quot;Time&quot;</span>, <span class=\"string\">&quot;For-ArrayList： &quot;</span>+(endTime1-startTime1)+<span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> startTime2=System.currentTimeMillis();   <span class=\"comment\">//获取开始时间</span></span><br><span class=\"line\">loopList(linkedList);</span><br><span class=\"line\"><span class=\"type\">long</span> endTime2=System.currentTimeMillis(); <span class=\"comment\">//获取结束时间</span></span><br><span class=\"line\">Log.i(<span class=\"string\">&quot;Time&quot;</span>, <span class=\"string\">&quot;For-LinkedList：&quot;</span>+(endTime2-startTime2)+<span class=\"string\">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.gcssloop.alltest I/Time: For-ArrayList： 20ms</span><br><span class=\"line\">com.gcssloop.alltest I/Time: For-LinkedList：648ms</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，仅仅处理10000条数据两者所需时间简直不能比较，当数据量越来越大的时候，LinkedList必然会耗费更多时间。</p>\n<h2 id=\"处理办法\"><a href=\"#处理办法\" class=\"headerlink\" title=\"处理办法:\"></a>处理办法:</h2><p>我们在Java中有 迭代器(Iterator) 以及 ForEach 循环，可以用它们来替代掉这个原始的 for 循环。</p>\n<h3 id=\"迭代器-Iterator\"><a href=\"#迭代器-Iterator\" class=\"headerlink\" title=\"迭代器(Iterator):\"></a>迭代器(Iterator):</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">iteratorList</span><span class=\"params\">(List&lt;Integer&gt; lists)</span>&#123;</span><br><span class=\"line\">    Iterator&lt;Integer&gt; it = lists.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext())&#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">integer</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码与上面类似，就省略了。</p>\n<p>结果:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.gcssloop.alltest I/Time: Iterator-ArrayList： 4ms</span><br><span class=\"line\">com.gcssloop.alltest I/Time: Iterator-LinkedList：6ms</span><br></pre></td></tr></table></figure>\n\n<p><strong>可以看到，两者最终耗费时间差不多而且均有大幅度提升。</strong></p>\n<h3 id=\"ForEach循环\"><a href=\"#ForEach循环\" class=\"headerlink\" title=\"ForEach循环:\"></a>ForEach循环:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">foreachList</span><span class=\"params\">(List&lt;Integer&gt; lists)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer i : lists) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 处理数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>性能:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.gcssloop.alltest I/Time: ForEach-ArrayList： 5ms</span><br><span class=\"line\">com.gcssloop.alltest I/Time: ForEach-LinkedList：5ms</span><br></pre></td></tr></table></figure>\n\n<p>由于 ForEach 循环底层使用的也是迭代器，所以和迭代器性能类似。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h2><p><strong>推荐使用 迭代器(Iterator) 和 ForEach 遍历 List，不要使用传统的 For 循环。</strong></p>\n<p>以下是测试处理10000条数据性能:</p>\n<blockquote>\n<p>数值仅供参考，与运行环境相关，每次测试结果都可能稍有差别。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">迭代方式</th>\n<th align=\"center\">ArrayList</th>\n<th align=\"center\">LinkedList</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">For循环</td>\n<td align=\"center\">20ms</td>\n<td align=\"center\">648ms</td>\n</tr>\n<tr>\n<td align=\"center\">Iterator</td>\n<td align=\"center\">4ms</td>\n<td align=\"center\">6ms</td>\n</tr>\n<tr>\n<td align=\"center\">for-each循环</td>\n<td align=\"center\">5ms</td>\n<td align=\"center\">5ms</td>\n</tr>\n</tbody></table>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"Java","path":"api/categories/Java.json"},{"name":"List","path":"api/categories/List.json"}],"tags":[{"name":"学习记录","path":"api/tags/学习记录.json"},{"name":"List","path":"api/tags/List.json"}]}