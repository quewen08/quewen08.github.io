{"title":"非对称加密技术- RSA算法数学原理分析","slug":"asy-encryption","date":"2018-02-14T06:22:22.000Z","updated":"2022-10-19T14:40:00.241Z","comments":true,"path":"api/articles/asy-encryption.json","realPath":"/2018/asy-encryption/asy-encryption/","excerpt":null,"covers":null,"cover":null,"content":"<p>非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。</p>\n<p>所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。<br>但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。<br>通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。</p>\n<p>题外话:<br>本博客一直有打算写一系列文章通俗的密码学，昨天给站点上https, 因其中使用了RSA算法，就查了一下，发现现在网上介绍RSA算法的文章都写的太难理解了，反正也准备写密码学，就先写RSA算法吧，下面开始正文。</p>\n<h2 id=\"RSA算法原理\"><a href=\"#RSA算法原理\" class=\"headerlink\" title=\"RSA算法原理\"></a>RSA算法原理</h2><p>RSA算法的基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。<br>如：有很大质数p跟q，很容易算出N，使得 N &#x3D; p * q，<br>但给出N, 比较难找p q（没有很好的方式， 只有不停的尝试）</p>\n<blockquote>\n<p>这其实也是单向函数的概念</p>\n</blockquote>\n<p>下面来看看数学演算过程：</p>\n<pre><code>1. 选取两个大质数p，q，计算N = p q 及 φ ( N ) = φ (p) φ (q) = (p-1) * (q-1)\n\n&gt; 三个数学概念：\n&gt; 质数(prime numbe)：又称素数，为在大于1的自然数中，除了1和它本身以外不再有其他因数。\n&gt; 互质关系：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。\n&gt; φ(N)：叫做欧拉函数，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。\n\n&gt; 如果n是质数，则 φ(n)=n-1。\n&gt; 如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。\n\n2. 选择一个大于1 小于φ(N)的数e，使得 e 和 φ(N)互质\n\n&gt; e其实是1和φ(N)之前的一个质数\n\n3. 计算d，使得de=1 mod φ(N) 等价于方程式 ed-1 = k φ(N) 求一组解。\n\n&gt; d 称为e的模反元素，e 和 φ(N)互质就肯定存在d。\n\n&gt; 模反元素是指如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，则b称为a的模反元素。\n&gt; 可根据欧拉定理证明模反元素存在，欧拉定理是指若n,a互质，则：\n&gt; ![](https://fastly.jsdelivr.net/gh/quewen08/CDN-for-Blog/img/aes_mod.png)\n\n4. (N, e)封装成公钥，(N, d)封装成私钥。\n假设m为明文，加密就是算出密文c:\nm^e mod N = c (明文m用公钥e加密并和随机数N取余得到密文c)\n解密则是：\nc^d mod N = m　(密文c用密钥解密并和随机数N取余得到明文m)\n\n&gt; 私钥解密这个是可以证明的，这里不展开了。\n</code></pre>\n<h2 id=\"加解密步骤\"><a href=\"#加解密步骤\" class=\"headerlink\" title=\"加解密步骤\"></a>加解密步骤</h2><p>具体还是来看看步骤，举个例子，假设Alice和Bob又要相互通信。</p>\n<ol>\n<li>Alice 随机取大质数P1&#x3D;53，P2&#x3D;59，那N&#x3D;53*59&#x3D;3127，φ(N)&#x3D;3016</li>\n<li>取一个e&#x3D;3，计算出d&#x3D;2011。</li>\n<li>只将N&#x3D;3127，e&#x3D;3 作为公钥传给Bob（公钥公开）</li>\n<li>假设Bob需要加密的明文m&#x3D;89，c &#x3D; 89^3 mod 3127&#x3D;1394，于是Bob传回c&#x3D;1394。 （公钥加密过程）</li>\n<li>Alice使用c^d mod N &#x3D; 1394^2011 mod 3127，就能得到明文m&#x3D;89。 （私钥解密过程）</li>\n</ol>\n<p>假如攻击者能截取到公钥n&#x3D;3127，e&#x3D;3及密文c&#x3D;1394，是仍然无法不通过d来进行密文解密的。</p>\n<h2 id=\"安全性分析\"><a href=\"#安全性分析\" class=\"headerlink\" title=\"安全性分析\"></a>安全性分析</h2><p>那么，有无可能在已知n和e的情况下，推导出d？</p>\n<ol>\n<li>ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</li>\n<li>φ(n)&#x3D;(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</li>\n<li>n&#x3D;pq。只有将n因数分解，才能算出p和q。</li>\n</ol>\n<p>如果n可以被因数分解，d就可以算出，因此RSA安全性建立在N的因式分解上。大整数的因数分解，是一件非常困难的事情。<br>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。</p>\n<h2 id=\"补充模运算规则\"><a href=\"#补充模运算规则\" class=\"headerlink\" title=\"补充模运算规则\"></a>补充模运算规则</h2><ol>\n<li>模运算加减法:<br>(a + b) mod p &#x3D; (a mod p + b mod p) mod p<br>(a - b) mod p &#x3D; (a mod p - b mod p) mod p</li>\n<li>模运算乘法：<br>(a b) mod p &#x3D; (a mod p b mod p) mod p</li>\n<li>模运算幂<br>a ^ b mod p &#x3D; ((a mod p)^b) mod p</li>\n</ol>\n","more":"<p>非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。</p>\n<p>所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。<br>但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。<br>通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。</p>\n<p>题外话:<br>本博客一直有打算写一系列文章通俗的密码学，昨天给站点上https, 因其中使用了RSA算法，就查了一下，发现现在网上介绍RSA算法的文章都写的太难理解了，反正也准备写密码学，就先写RSA算法吧，下面开始正文。</p>\n<h2 id=\"RSA算法原理\"><a href=\"#RSA算法原理\" class=\"headerlink\" title=\"RSA算法原理\"></a>RSA算法原理</h2><p>RSA算法的基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。<br>如：有很大质数p跟q，很容易算出N，使得 N &#x3D; p * q，<br>但给出N, 比较难找p q（没有很好的方式， 只有不停的尝试）</p>\n<blockquote>\n<p>这其实也是单向函数的概念</p>\n</blockquote>\n<p>下面来看看数学演算过程：</p>\n<pre><code>1. 选取两个大质数p，q，计算N = p q 及 φ ( N ) = φ (p) φ (q) = (p-1) * (q-1)\n\n&gt; 三个数学概念：\n&gt; 质数(prime numbe)：又称素数，为在大于1的自然数中，除了1和它本身以外不再有其他因数。\n&gt; 互质关系：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。\n&gt; φ(N)：叫做欧拉函数，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。\n\n&gt; 如果n是质数，则 φ(n)=n-1。\n&gt; 如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。\n\n2. 选择一个大于1 小于φ(N)的数e，使得 e 和 φ(N)互质\n\n&gt; e其实是1和φ(N)之前的一个质数\n\n3. 计算d，使得de=1 mod φ(N) 等价于方程式 ed-1 = k φ(N) 求一组解。\n\n&gt; d 称为e的模反元素，e 和 φ(N)互质就肯定存在d。\n\n&gt; 模反元素是指如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，则b称为a的模反元素。\n&gt; 可根据欧拉定理证明模反元素存在，欧拉定理是指若n,a互质，则：\n&gt; ![](https://fastly.jsdelivr.net/gh/quewen08/CDN-for-Blog/img/aes_mod.png)\n\n4. (N, e)封装成公钥，(N, d)封装成私钥。\n假设m为明文，加密就是算出密文c:\nm^e mod N = c (明文m用公钥e加密并和随机数N取余得到密文c)\n解密则是：\nc^d mod N = m　(密文c用密钥解密并和随机数N取余得到明文m)\n\n&gt; 私钥解密这个是可以证明的，这里不展开了。\n</code></pre>\n<h2 id=\"加解密步骤\"><a href=\"#加解密步骤\" class=\"headerlink\" title=\"加解密步骤\"></a>加解密步骤</h2><p>具体还是来看看步骤，举个例子，假设Alice和Bob又要相互通信。</p>\n<ol>\n<li>Alice 随机取大质数P1&#x3D;53，P2&#x3D;59，那N&#x3D;53*59&#x3D;3127，φ(N)&#x3D;3016</li>\n<li>取一个e&#x3D;3，计算出d&#x3D;2011。</li>\n<li>只将N&#x3D;3127，e&#x3D;3 作为公钥传给Bob（公钥公开）</li>\n<li>假设Bob需要加密的明文m&#x3D;89，c &#x3D; 89^3 mod 3127&#x3D;1394，于是Bob传回c&#x3D;1394。 （公钥加密过程）</li>\n<li>Alice使用c^d mod N &#x3D; 1394^2011 mod 3127，就能得到明文m&#x3D;89。 （私钥解密过程）</li>\n</ol>\n<p>假如攻击者能截取到公钥n&#x3D;3127，e&#x3D;3及密文c&#x3D;1394，是仍然无法不通过d来进行密文解密的。</p>\n<h2 id=\"安全性分析\"><a href=\"#安全性分析\" class=\"headerlink\" title=\"安全性分析\"></a>安全性分析</h2><p>那么，有无可能在已知n和e的情况下，推导出d？</p>\n<ol>\n<li>ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</li>\n<li>φ(n)&#x3D;(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</li>\n<li>n&#x3D;pq。只有将n因数分解，才能算出p和q。</li>\n</ol>\n<p>如果n可以被因数分解，d就可以算出，因此RSA安全性建立在N的因式分解上。大整数的因数分解，是一件非常困难的事情。<br>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。</p>\n<h2 id=\"补充模运算规则\"><a href=\"#补充模运算规则\" class=\"headerlink\" title=\"补充模运算规则\"></a>补充模运算规则</h2><ol>\n<li>模运算加减法:<br>(a + b) mod p &#x3D; (a mod p + b mod p) mod p<br>(a - b) mod p &#x3D; (a mod p - b mod p) mod p</li>\n<li>模运算乘法：<br>(a b) mod p &#x3D; (a mod p b mod p) mod p</li>\n<li>模运算幂<br>a ^ b mod p &#x3D; ((a mod p)^b) mod p</li>\n</ol>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"}],"tags":[{"name":"学习记录","path":"api/tags/学习记录.json"},{"name":"RSA算法","path":"api/tags/RSA算法.json"}]}