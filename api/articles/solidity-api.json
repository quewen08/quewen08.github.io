{"title":"智能合约语言 Solidity 教程系列8 - Solidity API","slug":"solidity-api","date":"2018-03-15T07:40:22.000Z","updated":"2022-10-19T14:40:00.265Z","comments":true,"path":"api/articles/solidity-api.json","realPath":"/2018/solidity-api/solidity-api/","excerpt":null,"covers":null,"cover":null,"content":"<p>智能合约语言 Solidity 教程系列8 - Solidity API<br>这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<p>Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类：</p>\n<ol>\n<li>有关区块和交易的属性</li>\n<li>有关错误处理</li>\n<li>有关数学及加密功能</li>\n<li>地址相关</li>\n<li>合约相关</li>\n</ol>\n<p>下面详细讲解下</p>\n<h2 id=\"区块和交易的属性（Block-And-Transaction-Properties）\"><a href=\"#区块和交易的属性（Block-And-Transaction-Properties）\" class=\"headerlink\" title=\"区块和交易的属性（Block And Transaction Properties）\"></a>区块和交易的属性（Block And Transaction Properties）</h2><p>用来提供一些区块链当前的信息。</p>\n<ul>\n<li>block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。</li>\n<li>block.coinbase (address): 当前块矿工的地址。</li>\n<li>block.difficulty (uint):当前块的难度。</li>\n<li>block.gaslimit (uint):当前块的gaslimit。</li>\n<li>block.number (uint):当前区块的块号。</li>\n<li>block.timestamp (uint): 当前块的Unix时间戳（从1970&#x2F;1&#x2F;1 00:00:00 UTC开始所经过的秒数）</li>\n<li>msg.data (bytes): 完整的调用数据（calldata）。</li>\n<li>msg.gas (uint): 当前还剩的gas。</li>\n<li>msg.sender (address): 当前调用发起人的地址。</li>\n<li>msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。</li>\n<li>msg.value (uint): 这个消息所附带的以太币，单位为wei。</li>\n<li>now (uint): 当前块的时间戳(block.timestamp的别名)</li>\n<li>tx.gasprice (uint) : 交易的gas价格。</li>\n<li>tx.origin (address): 交易的发送者（全调用链）</li>\n</ul>\n<p>注意：</p>\n<p>msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。</p>\n<p>不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。</p>\n<p>对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。</p>\n<p>为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0.</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><ul>\n<li>assert(bool condition)<br>用于判断内部错误，条件不满足时抛出异常</li>\n<li>require(bool condition):<br>用于判断输入或外部组件错误，条件不满足时抛出异常</li>\n<li>revert():<br>终止执行并还原改变的状态</li>\n</ul>\n<h2 id=\"数学及加密功能\"><a href=\"#数学及加密功能\" class=\"headerlink\" title=\"数学及加密功能\"></a>数学及加密功能</h2><ul>\n<li><p>addmod(uint x, uint y, uint k) returns (uint):<br>计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k !&#x3D; 0。</p>\n</li>\n<li><p>mulmod(uint x, uint y, uint k) returns (uint):<br>计算 (x y) % k， 乘法支持任意的精度且不会在2*256处溢出， 从0.5.0版本开始断言k !&#x3D; 0。</p>\n</li>\n<li><p>keccak256(…) returns (bytes32):<br>使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。</p>\n</li>\n<li><p>sha256(…) returns (bytes32):<br>使用SHA-256计算hash值，紧密打包参数。</p>\n</li>\n<li><p>sha3(…) returns (bytes32):<br>keccak256的别名</p>\n</li>\n<li><p>ripemd160(…) returns (bytes20):<br>使用RIPEMD-160计算HASH值。紧密打包参数。</p>\n</li>\n<li><p>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。</p>\n<blockquote>\n<p>ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。<br>r &#x3D; signature[0:64]<br>s &#x3D; signature[64:128]<br>v &#x3D; signature[128:130]<br>其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。</p>\n</blockquote>\n</li>\n</ul>\n<p>用javascript表达如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"string\">&#x27;0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hash = web3.<span class=\"title function_\">sha3</span>(msg)</span><br><span class=\"line\"><span class=\"keyword\">var</span> sig = web3.<span class=\"property\">eth</span>.<span class=\"title function_\">sign</span>(address, h).<span class=\"title function_\">slice</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> r = <span class=\"string\">`0x<span class=\"subst\">$&#123;sig.slice(<span class=\"number\">0</span>, <span class=\"number\">64</span>)&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">`0x<span class=\"subst\">$&#123;sig.slice(<span class=\"number\">64</span>, <span class=\"number\">128</span>)&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v = web3.<span class=\"title function_\">toDecimal</span>(sig.<span class=\"title function_\">slice</span>(<span class=\"number\">128</span>, <span class=\"number\">130</span>)) + <span class=\"number\">27</span></span><br></pre></td></tr></table></figure>\n\n<p>紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class=\"line\">keccak256(&quot;abc&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">keccak256(0x616263)  // hex</span><br><span class=\"line\">keccak256(6382179)</span><br><span class=\"line\">keccak256(97, 98, 99)   //ascii</span><br></pre></td></tr></table></figure>\n\n<p>如果需要填充，可以使用显式类型转换：keccak256(“\\x00\\x12”) 与keccak256(uint16(0x12))相同。</p>\n<p>注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) &#x3D;&#x3D; keccak256(uint8(0))和keccak256(0x12345678) &#x3D;&#x3D; keccak256(uint32(0x12345678))</p>\n<p>在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。</p>\n<h2 id=\"地址相关\"><a href=\"#地址相关\" class=\"headerlink\" title=\"地址相关\"></a>地址相关</h2><ul>\n<li>.balance (uint256):<br>  Address的余额，以wei为单位。</li>\n<li>.transfer(uint256 amount):<br>  发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。</li>\n<li>.send(uint256 amount) returns (bool):<br>  发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。</li>\n<li>.call(…) returns (bool):<br>  发起底层的call调用。失败时返回false。</li>\n<li>.callcode(…) returns (bool):<br>  发起底层的callcode调用，失败时返回false。<br>  不鼓励使用，未来可能会移除。</li>\n<li>.delegatecall(…) returns (bool):<br>  发起底层的delegatecall调用，失败时返回false</li>\n</ul>\n<p>警告：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p>\n<h2 id=\"合约相关\"><a href=\"#合约相关\" class=\"headerlink\" title=\"合约相关\"></a>合约相关</h2><ul>\n<li>this（当前合约的类型）:<br>表示当前合约，可以显式的转换为Address</li>\n<li>selfdestruct(address recipient):<br>销毁当前合约，并把它所有资金发送到给定的地址。</li>\n<li>suicide(address recipient):<br>selfdestruct的别名</li>\n</ul>\n<p>另外，当前合约里的所有函数均可支持调用，包括当前函数本身。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables\">Special Variables and Functions</a></p>\n","more":"<p>智能合约语言 Solidity 教程系列8 - Solidity API<br>这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<p>Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类：</p>\n<ol>\n<li>有关区块和交易的属性</li>\n<li>有关错误处理</li>\n<li>有关数学及加密功能</li>\n<li>地址相关</li>\n<li>合约相关</li>\n</ol>\n<p>下面详细讲解下</p>\n<h2 id=\"区块和交易的属性（Block-And-Transaction-Properties）\"><a href=\"#区块和交易的属性（Block-And-Transaction-Properties）\" class=\"headerlink\" title=\"区块和交易的属性（Block And Transaction Properties）\"></a>区块和交易的属性（Block And Transaction Properties）</h2><p>用来提供一些区块链当前的信息。</p>\n<ul>\n<li>block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。</li>\n<li>block.coinbase (address): 当前块矿工的地址。</li>\n<li>block.difficulty (uint):当前块的难度。</li>\n<li>block.gaslimit (uint):当前块的gaslimit。</li>\n<li>block.number (uint):当前区块的块号。</li>\n<li>block.timestamp (uint): 当前块的Unix时间戳（从1970&#x2F;1&#x2F;1 00:00:00 UTC开始所经过的秒数）</li>\n<li>msg.data (bytes): 完整的调用数据（calldata）。</li>\n<li>msg.gas (uint): 当前还剩的gas。</li>\n<li>msg.sender (address): 当前调用发起人的地址。</li>\n<li>msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。</li>\n<li>msg.value (uint): 这个消息所附带的以太币，单位为wei。</li>\n<li>now (uint): 当前块的时间戳(block.timestamp的别名)</li>\n<li>tx.gasprice (uint) : 交易的gas价格。</li>\n<li>tx.origin (address): 交易的发送者（全调用链）</li>\n</ul>\n<p>注意：</p>\n<p>msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。</p>\n<p>不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。</p>\n<p>对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。</p>\n<p>为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0.</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><ul>\n<li>assert(bool condition)<br>用于判断内部错误，条件不满足时抛出异常</li>\n<li>require(bool condition):<br>用于判断输入或外部组件错误，条件不满足时抛出异常</li>\n<li>revert():<br>终止执行并还原改变的状态</li>\n</ul>\n<h2 id=\"数学及加密功能\"><a href=\"#数学及加密功能\" class=\"headerlink\" title=\"数学及加密功能\"></a>数学及加密功能</h2><ul>\n<li><p>addmod(uint x, uint y, uint k) returns (uint):<br>计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k !&#x3D; 0。</p>\n</li>\n<li><p>mulmod(uint x, uint y, uint k) returns (uint):<br>计算 (x y) % k， 乘法支持任意的精度且不会在2*256处溢出， 从0.5.0版本开始断言k !&#x3D; 0。</p>\n</li>\n<li><p>keccak256(…) returns (bytes32):<br>使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。</p>\n</li>\n<li><p>sha256(…) returns (bytes32):<br>使用SHA-256计算hash值，紧密打包参数。</p>\n</li>\n<li><p>sha3(…) returns (bytes32):<br>keccak256的别名</p>\n</li>\n<li><p>ripemd160(…) returns (bytes20):<br>使用RIPEMD-160计算HASH值。紧密打包参数。</p>\n</li>\n<li><p>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。</p>\n<blockquote>\n<p>ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。<br>r &#x3D; signature[0:64]<br>s &#x3D; signature[64:128]<br>v &#x3D; signature[128:130]<br>其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。</p>\n</blockquote>\n</li>\n</ul>\n<p>用javascript表达如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"string\">&#x27;0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hash = web3.<span class=\"title function_\">sha3</span>(msg)</span><br><span class=\"line\"><span class=\"keyword\">var</span> sig = web3.<span class=\"property\">eth</span>.<span class=\"title function_\">sign</span>(address, h).<span class=\"title function_\">slice</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> r = <span class=\"string\">`0x<span class=\"subst\">$&#123;sig.slice(<span class=\"number\">0</span>, <span class=\"number\">64</span>)&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">`0x<span class=\"subst\">$&#123;sig.slice(<span class=\"number\">64</span>, <span class=\"number\">128</span>)&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v = web3.<span class=\"title function_\">toDecimal</span>(sig.<span class=\"title function_\">slice</span>(<span class=\"number\">128</span>, <span class=\"number\">130</span>)) + <span class=\"number\">27</span></span><br></pre></td></tr></table></figure>\n\n<p>紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class=\"line\">keccak256(&quot;abc&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">keccak256(0x616263)  // hex</span><br><span class=\"line\">keccak256(6382179)</span><br><span class=\"line\">keccak256(97, 98, 99)   //ascii</span><br></pre></td></tr></table></figure>\n\n<p>如果需要填充，可以使用显式类型转换：keccak256(“\\x00\\x12”) 与keccak256(uint16(0x12))相同。</p>\n<p>注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) &#x3D;&#x3D; keccak256(uint8(0))和keccak256(0x12345678) &#x3D;&#x3D; keccak256(uint32(0x12345678))</p>\n<p>在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。</p>\n<h2 id=\"地址相关\"><a href=\"#地址相关\" class=\"headerlink\" title=\"地址相关\"></a>地址相关</h2><ul>\n<li>.balance (uint256):<br>  Address的余额，以wei为单位。</li>\n<li>.transfer(uint256 amount):<br>  发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。</li>\n<li>.send(uint256 amount) returns (bool):<br>  发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。</li>\n<li>.call(…) returns (bool):<br>  发起底层的call调用。失败时返回false。</li>\n<li>.callcode(…) returns (bool):<br>  发起底层的callcode调用，失败时返回false。<br>  不鼓励使用，未来可能会移除。</li>\n<li>.delegatecall(…) returns (bool):<br>  发起底层的delegatecall调用，失败时返回false</li>\n</ul>\n<p>警告：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p>\n<h2 id=\"合约相关\"><a href=\"#合约相关\" class=\"headerlink\" title=\"合约相关\"></a>合约相关</h2><ul>\n<li>this（当前合约的类型）:<br>表示当前合约，可以显式的转换为Address</li>\n<li>selfdestruct(address recipient):<br>销毁当前合约，并把它所有资金发送到给定的地址。</li>\n<li>suicide(address recipient):<br>selfdestruct的别名</li>\n</ul>\n<p>另外，当前合约里的所有函数均可支持调用，包括当前函数本身。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables\">Special Variables and Functions</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}