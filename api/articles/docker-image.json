{"title":"镜像制作","slug":"docker-image","date":"2022-08-20T13:29:39.000Z","updated":"2022-10-20T13:28:49.301Z","comments":true,"path":"api/articles/docker-image.json","realPath":"/2022/docker-image/index/","excerpt":null,"covers":["/img/2022/docker-image/979767-20220615225133950-1185740767.png"],"cover":"/img/2022/docker-image/979767-20220615225133950-1185740767.png","content":"<h4 id=\"利用-Commit-制作镜像\"><a href=\"#利用-Commit-制作镜像\" class=\"headerlink\" title=\"利用 Commit 制作镜像\"></a>利用 Commit 制作镜像</h4><p>在容器管理章节有提到使用现有的容器制作镜像，但是这在真正的工作中明显是不合适的。使用<code>docker commit</code>意味着所有对镜像的操作都是黑箱操作，生成的镜像被称为<code>黑箱镜像</code>。</p>\n<p>换句话说，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。即使是制作人，过段时间后也无法记清具体的操作。这种镜像维护起来非常痛苦。</p>\n<p>而且，由于镜像分层存储的特点，除当前层外，之前的每一层都是不会发生改变的，这意味着任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。即使是删除，上一层的东西也并不会丢失。镜像会越来越臃肿。</p>\n<p>同时还有另外一个问题，容器中某些进程可能是动态的，过段时间会退出。如果使用 commit 制作镜像，这些进程可能不会保存到镜像中。</p>\n<h4 id=\"利用-Dockerfile-制作镜像\"><a href=\"#利用-Dockerfile-制作镜像\" class=\"headerlink\" title=\"利用 Dockerfile 制作镜像\"></a>利用 Dockerfile 制作镜像</h4><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果能把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那之前 Commit 的无法重复、镜像构建透明性、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code>。</p>\n<p>Dockerfile 是一个文本文件，其内包含了一条条的<code>指令（Instruction）</code>，每一条指令构建一层。</p>\n<p>以定制一个 <code>nginx</code> 镜像为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建目录专门用于存放相关的 Dockerfile</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p nginx/v1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 Dockerfile</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nginx/v1.0/</span><br><span class=\"line\">vim Dockerfile</span><br></pre></td></tr></table></figure>\n\n<p>Dockerfile 内容如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> nginx:latest</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;h1&gt;Hello Docker&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个最简单的 Dockerfile，以 nginx 镜像为基础镜像，然后修改镜像中的 html 文件，形成新的镜像。</p>\n<p>上面提到了基础镜像，我们可以以任何镜像为基础镜像，在它的上面进行操作形成新的镜像，Docker 官方也提供了很多精简的基础镜像，可以拿来直接使用。</p>\n<p>在编辑好 Dockerfile 之后，就进入镜像制作的步骤：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t trover/nginx:v1.0 .</span><br></pre></td></tr></table></figure>\n\n<p>注意最后那个<code>.</code>不能掉。</p>\n<p><img src=\"/img/2022/docker-image/979767-20220615225133950-1185740767.png\"></p>\n<p>可以发现，镜像构建的时候有两层，一层是<code>FROM</code>，一层是<code>RUN</code>。这也印证了上面说的每一个关键字就是一层。</p>\n<h4 id=\"镜像构建上下文\"><a href=\"#镜像构建上下文\" class=\"headerlink\" title=\"镜像构建上下文\"></a>镜像构建上下文</h4><p>关于 build 命令最后那个<code>.</code>，其实不是指 Dockerfile 的路径，而是指定<code>上下文路径</code>。</p>\n<p>想要理解上下文，首先要理解<code>docker build</code>的工作原理：</p>\n<p>Docker 的运行分为服务端 Docker 引擎（守护进程）和客户端工具。服务端 Docker 引擎提供了一组 REST API，称为<code>Docker Remote API</code>。docker 命令这样的客户端工具就是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p>\n<p>虽然表面上是在本机执行的各种 docker 功能，但实际上一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让操作远程服务器的 Docker 引擎变得轻而易举。</p>\n<p>在进行镜像构建时，并非所有定制都会通过<code>RUN</code>指令完成，经常会需要将一些本地文件复制进镜像，比如通过<code>COPY</code>指令、<code>ADD</code>指令等。而 build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>\n<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>\n<p>以 Dockerfile 为例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./package.json /app/</span></span><br></pre></td></tr></table></figure>\n\n<p>该指定并不是复制当前目录的 package.json 文件，也不是 Dockerfile 所在目录的 package.json 文件，而是上下文目录中的 package.json。</p>\n<p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是为何<code>COPY ../package.json /app</code>或者<code>COPY /opt/xxxx /app</code>无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>\n<p>通过 build 命令输出的第一行也可以看到发送上下文的过程：</p>\n<blockquote>\n<p>Sending build context to Docker daemon 2.048 kB</p>\n</blockquote>\n<p>所以，制作 Dockerfile 的目录尽量满足以下需求：</p>\n<ul>\n<li>一个空目录。</li>\n<li>将所有需要的文件都复制一份到当前目录。</li>\n<li>如果目录下有文件不需要被发送到 Docker 引擎，可以创建一个类似<code>.gitignore</code>一样语法的文件<code>.dockerignore</code>。<br>默认情况下，如果不特殊指定 Dockerfile 路径，默认会将上下文路径中的名为 Dockerfile 的文件作为 Dockerfile。</li>\n</ul>\n<p>Dockerfile 也并非文件就要叫 Dockerfile，可以通过 -f 指定其它文件，但是一般不这样做。</p>\n<h4 id=\"Dockerfile（FROM）\"><a href=\"#Dockerfile（FROM）\" class=\"headerlink\" title=\"Dockerfile（FROM）\"></a>Dockerfile（FROM）</h4><p>FROM 指令是 Dockerfile 最基础的关键字，用于指定基础镜像。格式为：<code>FROM &lt;基础镜像&gt;</code></p>\n<p>如果你自己想做一个基础镜像，则可以使用<code>FROM scratch</code>，scratch 镜像是 Docker 官方提供的一个虚拟空白镜像。</p>\n<p>基础镜像意味着不以任何系统为基础，直接将可执行文件复制到镜像中，该文件包含了运行所需的所有库。这样镜像会更小，非常适合 Go 语言开发的程序。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本使用</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基础镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> scratch</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（LABEL）\"><a href=\"#Dockerfile（LABEL）\" class=\"headerlink\" title=\"Dockerfile（LABEL）\"></a>Dockerfile（LABEL）</h4><p>LABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata），在旧版本中叫 MATAINER。格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p>\n<p>通过 LABEL 标签能够让别人更清楚你这镜像。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> name=<span class=\"string\">&quot;Trover&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\temail=<span class=\"string\">&quot;admin@buerya.cn&quot;</span></span></span><br><span class=\"line\">\tdesc=<span class=\"string\">&quot;Dockerfile demo&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（RUN）\"><a href=\"#Dockerfile（RUN）\" class=\"headerlink\" title=\"Dockerfile（RUN）\"></a>Dockerfile（RUN）</h4><p>RUN 指令用来执行命令行命令。由于命令行的强大能力，<code>RUN</code>指令在定制镜像时是最常用的指令之一。其格式有两种：</p>\n<ul>\n<li>shell 格式：<code>RUN 命令</code></li>\n<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code><br>由于 Dockerfile 中每个关键字就是一层，Union FS 会有最大层数限制，以 AUFS 为例，最大支持 127 层。为了减少镜像的层数，一般使用<code>&amp;&amp;</code>连接多个命令，<code>\\</code>进行换行，提高阅读性。</li>\n</ul>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> / &amp;&amp; yum -y install nginx \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\t&amp;&amp; <span class=\"built_in\">cd</span> /etc/nginx \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\t&amp;&amp; <span class=\"built_in\">rm</span> -f nginx.conf</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（WORKDIR）\"><a href=\"#Dockerfile（WORKDIR）\" class=\"headerlink\" title=\"Dockerfile（WORKDIR）\"></a>Dockerfile（WORKDIR）</h4><p>WORKDIR 指令用于指定工作目录（或称当前目录），以后各层的当前目录就被改为指定的目录，如果该目录不存在，WORKDIR 会自动创建。格式为：WORKDIR &lt;工作目录路径&gt;</p>\n<blockquote>\n<p>WORKDIR 目录 不等于 RUN cd 目录，前者会对后面的所有镜像层产生影响，后者只对当前层，对于下一层并不会 cd 进目录。</p>\n</blockquote>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /a</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> b</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> c</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\"><span class=\"comment\"># 最后输出目录为 /a/b/c</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（COPY）\"><a href=\"#Dockerfile（COPY）\" class=\"headerlink\" title=\"Dockerfile（COPY）\"></a>Dockerfile（COPY）</h4><p>COPY 指令用于将构建上下文目录中的源文件或目录拷贝到镜像中的指定目录，支持两种格式。</p>\n<ul>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code><br>源路径可以是多个，甚至使用通配符。目标路径可以是容器中绝对路径，也可以是 WORKDIR 的相对路径。目标路径不存在会自动创建。</li>\n</ul>\n<p>COPY 指令能保留文件的各种元数据，比如创建时间，读写权限等。如果源文件为目录，其实质是将目录中的文件拷贝到镜像中的新目录中。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package.json /usr/src/app/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package* /usr/src/app/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝并修改权限</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"built_in\">chown</span>=myuser:mygroup package* /usr/src/app/</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ADD）\"><a href=\"#Dockerfile（ADD）\" class=\"headerlink\" title=\"Dockerfile（ADD）\"></a>Dockerfile（ADD）</h4><p>ADD 指令和 COPY 类似，但不推荐使用，因为没有 COPY 定义明确。格式为：<code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></p>\n<p>ADD 源路径支持 URL，Docker 会去指定的 URL 下载文件，并保存成 600 权限，如果 URL 是压缩也文件不会解压。所以这种需求使用 RUN 指令更好。</p>\n<p>如果本地源文件是 tar，gzip，bzip2，xz 等格式的压缩文件，ADD 会自动解压。但如果只想复制一个压缩文件进去，则不能使用 ADD 指令。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> ubuntu.tar.gz /app/</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ENV）\"><a href=\"#Dockerfile（ENV）\" class=\"headerlink\" title=\"Dockerfile（ENV）\"></a>Dockerfile（ENV）</h4><p>ENV 指令用于设置环境变量，在后面的指令中可以直接使用<code>$&#123;变量名&#125;</code>的方式引用，容器中也可以看到。支持两种格式。</p>\n<ul>\n<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>\n<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code><br>通过环境变量的定义能够使 Dockerfile 更加灵活。</li>\n</ul>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> VERSION=<span class=\"string\">&quot;1.0&quot;</span> \\</span><br><span class=\"line\">\tNAME=<span class=\"string\">&quot;Dy1an&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$VERSION</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ARG）\"><a href=\"#Dockerfile（ARG）\" class=\"headerlink\" title=\"Dockerfile（ARG）\"></a>Dockerfile（ARG）</h4><p>ARG 指令功能和 ENV 类似，用于定义构建参数。不同在于 ARG 设置的是构建环境的环境变量，在容器运行时这些变量不会存在。格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>\n<p>该默认值可以在<code>docker build</code>中使用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖，起到传参构建的目的。</p>\n<p>ARG 指令有作用范围，如果是在 FROM 之前使用，则只能 FROM 指令中使用该变量。想要继续使用就得重新定义。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> DOCKER_USERNAME=library</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（USER）\"><a href=\"#Dockerfile（USER）\" class=\"headerlink\" title=\"Dockerfile（USER）\"></a>Dockerfile（USER）</h4><p>USER 指令指定当前用户和用户组，影响范围和 WORKDIR 类似。格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>\n<p>USER 指令只是切换用户，所以这个用户必须先创建好。</p>\n<p>如果脚本是 root 运行，但是容器中启动服务需要使用其他用户，建议下载<code>gosu</code>代替原本的 su 或者 sudo，可以避免很多问题。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> useradd -r -g nginx</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 gosu</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -O /usr/local/bin/gosu <span class=\"string\">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; <span class=\"built_in\">chmod</span> +x /usr/local/bin/gosu \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; gosu nginx <span class=\"literal\">true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 CMD，并以另外的用户执行</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;exec&quot;</span>, <span class=\"string\">&quot;gosu&quot;</span>, <span class=\"string\">&quot;nginx&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（EXPOSE）\"><a href=\"#Dockerfile（EXPOSE）\" class=\"headerlink\" title=\"Dockerfile（EXPOSE）\"></a>Dockerfile（EXPOSE）</h4><p>EXPOSE 指令用于声明容器运行时提供服务的端口，只是声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>\n<p>在 Dockerfile 中写入这样的声明有两个好处：</p>\n<p>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口。<br>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（CMD）\"><a href=\"#Dockerfile（CMD）\" class=\"headerlink\" title=\"Dockerfile（CMD）\"></a>Dockerfile（CMD）</h4><p><code>CMD</code> 指令用于指定容器默认的主进程启动命令。和 RUN 类似，支持两种格式：</p>\n<ul>\n<li>shell 格式：<code>CMD &lt;命令&gt;</code></li>\n<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code><br>推荐使用 exec 格式，因为 shell 格式也会被 docker 转换成 exec 格式，比如：</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\"># 会被转换成</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;echo &#x27;Hello&#x27;&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>exec 格式在解析时会被解析为 JSON 数组，因此一定要使用双引号<code>&quot;</code>，而不要使用单引号。</p>\n</blockquote>\n<p>在容器运行时，可以指定新的命令来替代镜像中设置的 CMD 默认命令。</p>\n<p>比如：ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，run -it 启动会直接进入容器的 bash。可以在运行时指定其它命令，如<code>docker run -it ubuntu cat /etc/os-release</code>的方式替换掉默认的<code>/bin/bash</code>命令。</p>\n<p>注意：</p>\n<blockquote>\n<p>docker 不是虚拟机，容器中的应用都应该以前台执行，不能用 systemd 去启动后台服务，容器内没有后台服务的概念。</p>\n</blockquote>\n<p>如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> service nginx start</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的容器启动后立即退出，即使是进入容器内使用<code>systemctl</code>也一样。</p>\n<p>对于容器而言，启动命令就是容器的应用进程，容器为主进程而存在，主进程退出，容器就失去了存在的意义，从而跟着退出，其它进程它不关心。</p>\n<p>所以，使用<code>service nginx start</code>命令希望以后台守护进程形式启动 nginx。而 CMD 会被转换成<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>。此时主进程实际上是<code>sh</code>。那么当 service nginx start 命令结束后，sh 主进程也就结束了，容器自然就会跟着退出。</p>\n<p>正确的做法是以前台的方式直接启动：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;nginx&quot;</span>, <span class=\"string\">&quot;-g&quot;</span>, <span class=\"string\">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ENTRYPOINT）\"><a href=\"#Dockerfile（ENTRYPOINT）\" class=\"headerlink\" title=\"Dockerfile（ENTRYPOINT）\"></a>Dockerfile（ENTRYPOINT）</h4><p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。它的启动命令也是可以被替换的，不过比 CMD 繁琐，需要通过 docker run 的参数 –entrypoint 来指定。和 RUN 一样，也是支持两种格式。</p>\n<p>相较于 CMD，ENTRYPOINT 常用于解决以下问题：</p>\n<h5 id=\"1-能够实现灵活的传参功能\"><a href=\"#1-能够实现灵活的传参功能\" class=\"headerlink\" title=\"1. 能够实现灵活的传参功能\"></a>1. 能够实现灵活的传参功能</h5><p>一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该镜像用于输出当前公网 IP</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> busybox</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-s&quot;</span>, <span class=\"string\">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>docker build -t myip</code>. 生成 myip 镜像，然后使用 <code>docker run myip</code> 运行。这个 docker 就能变成一个类似于查询公网 IP 的命令。</p>\n<p>但是如果此时需求变得复杂，需要在镜像的 curl 中加入<code>-i</code>参数输出请求头信息。</p>\n<p>直接使用<code>docker run myip -i</code>会报错：executable file not found。原因在于镜像后面的参数会被当成命令替换掉 CMD 中的内容，而 CMD 第一个参数是可执行文件，-i 显然不是可执行文件，所以报错。</p>\n<p>如果将 CMD 换成 ENTRYPOINT：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该镜像用于输出当前公网 IP</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> busybox</span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-s&quot;</span>, <span class=\"string\">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<p>此时再次执行 <code>docker run myip -i</code> 就能正常使用。原因在于，-i 参数会替换 CMD 中的内容，但是在定义了 ENTRYPOINT 的 Dockerfile 中，CMD 中的所有内容会成为参数传递给 ENTRYPOINT，这就实现了灵活参数的功能。</p>\n<h5 id=\"2-通过判断不同的传参干不同的事情\"><a href=\"#2-通过判断不同的传参干不同的事情\" class=\"headerlink\" title=\"2. 通过判断不同的传参干不同的事情\"></a>2. 通过判断不同的传参干不同的事情</h5><p>生产中有这样一类场景，某些镜像的运行方案可能不一定，用户可以传递相关的参数修改容器的运行方式。由于在 ENTRYPOINT 加入了逻辑判断等操作，再写命令或者 exec 格式显然不适合，所以需要使用脚本的格式。 然后将 CMD 的内容作为参数传给它。</p>\n<p>一个简单的 Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> busybox</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝脚本到镜像中</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> docker-entrypoint.sh /usr/local/bin/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行脚本</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>docker-entrypoint.sh：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> = <span class=\"string\">&#x27;hello&#x27;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（VOLUME）\"><a href=\"#Dockerfile（VOLUME）\" class=\"headerlink\" title=\"Dockerfile（VOLUME）\"></a>Dockerfile（VOLUME）</h4><p>VOLUME 指令用于挂在一个或多个存储卷，格式如下：</p>\n<ul>\n<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME &lt;路径&gt;</code><br>容器运行时应尽量保持容器存储层不发生写操作，但数据写入往往又是不可避免的。</li>\n</ul>\n<p>为了防止运行时用户忘记将动态文件所保存的目录挂载为卷，可以在<code>Dockerfile</code>中事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /data</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>/data</code>目录就会在容器运行时自动挂载为匿名卷，任何向<code>/data</code>中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以通过<code>-v</code>参数覆盖这个挂载设置。</p>\n<p>后面会对存储卷进行详细的说明。</p>\n<h4 id=\"Dockerfile（HEALTHCHECK）\"><a href=\"#Dockerfile（HEALTHCHECK）\" class=\"headerlink\" title=\"Dockerfile（HEALTHCHECK）\"></a>Dockerfile（HEALTHCHECK）</h4><p>HEALTHCHECK 指令用于告诉 Docker 应该如何进行判断容器的状态是否正常，在 Docker 1.12 引入。支持以下格式：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>\n<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br>在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁或死循环状态，应用进程并不会退出，容器已经无法提供服务，却并不会被重新调度。HEALTHCHECK 指令的价值就在于能够比较真实的反应容器实际状态。</li>\n</ul>\n<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 后，用其启动容器，初始状态会为<code>starting</code>，在 <code>HEALTHCHECK</code> 检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。</p>\n<p>HEALTHCHECK 支持下列选项：</p>\n<ul>\n<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒</li>\n<li><code>--timeout=&lt;时长&gt;</code>：健康检查运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒</li>\n<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为<code>unhealthy</code>，默认 3 次<br>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</li>\n</ul>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"language-bash\"> --interval=5s --<span class=\"built_in\">timeout</span>=3s CMD curl -fs http://localhost/ || <span class=\"built_in\">exit</span> 1</span></span><br></pre></td></tr></table></figure>\n\n<p>容器运行后，使用 docker container ls 就可以看到健康状态。使用 docker container inspect xxx 可以看到检测信息。</p>\n<h4 id=\"Dockerfile（SHELL）\"><a href=\"#Dockerfile（SHELL）\" class=\"headerlink\" title=\"Dockerfile（SHELL）\"></a>Dockerfile（SHELL）</h4><p>SHELL 指令用于指定 RUN，ENTRYPOINT，CMD 指令的 shell，Linux 中默认为<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>。格式为：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-cex&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<pre><code># 命令最终会被解析为：/bin/sh -cex &quot;nginx&quot;\nENTRYPOINT nginx\n</code></pre>\n<h4 id=\"Dockerfile（ONBUILD）\"><a href=\"#Dockerfile（ONBUILD）\" class=\"headerlink\" title=\"Dockerfile（ONBUILD）\"></a>Dockerfile（ONBUILD）</h4><p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等。这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:slim</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span> /app</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./package.json /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">RUN</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;install&quot;</span> ]</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">COPY</span><span class=\"language-bash\"> . /app/</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile-建议\"><a href=\"#Dockerfile-建议\" class=\"headerlink\" title=\"Dockerfile 建议\"></a>Dockerfile 建议</h4><p>在制作 Dockerfile 的时候，应该尽可能的遵守一些约定俗称的方法和建议：</p>\n<ul>\n<li>容器应该是短暂的<ul>\n<li>通过 Dockerfile 构建的镜像生命周期不宜过长，容器从销毁到创建都应该将工作量将到最小。</li>\n</ul>\n</li>\n<li>增加 .dockerigonre 文件<ul>\n<li>每一个单独的项目都应该有一个单独的目录并创建一个 .dockerignore 文件用于忽略不需要的文件或目录，构建镜像所需的文件都应该存放到该目录下。</li>\n</ul>\n</li>\n<li>避免不必要的文件，使用多阶段构建<ul>\n<li>在 Dockerfile 的每一层定义中，在进入下一层之前，都需要删除掉其它不需要的文件，以此尽可能的减小镜像的体积。</li>\n<li>比如通过 Dockerfile 直接完成打包，运行，打包这一步除了打出来的包其它的文件其实都是没用的，此时就是和多阶段构建。</li>\n<li>示例：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一阶段，打包。使用 as 对阶段进行命名，每一个 FROM 就是一个阶段</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:<span class=\"number\">1.7</span>.<span class=\"number\">3</span> as build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> go get -d -v golang.org/x/net/html  </span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app.go    .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二阶段，运行。</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine:latest  </span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apk --no-cache add ca-certificates</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /root/</span></span><br><span class=\"line\"><span class=\"comment\"># 从第一阶段中拷贝打好的包</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;./app&quot;</span>] </span></span><br></pre></td></tr></table></figure>\n<pre><code>此时 build 镜像的话，镜像中就不会包含第一节点的内容，包也尽可能的减小了。\n</code></pre>\n<ul>\n<li>一个容器只运行一个进程<ul>\n<li>应该保证每个容器只有一个进程，多个进程解耦到不同容器中，便于后续的扩展。</li>\n</ul>\n</li>\n<li>将多行参数排序<ul>\n<li>某些参数太多太长需要换行的，尽可能按照字母顺序排序，这样可以避免重复。</li>\n</ul>\n</li>\n<li>使用构建缓存<ul>\n<li>在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 –no-cache&#x3D;true 选项。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"完整的-Dockerfile-示例\"><a href=\"#完整的-Dockerfile-示例\" class=\"headerlink\" title=\"完整的 Dockerfile 示例\"></a>完整的 Dockerfile 示例</h4><p>以下是一些常见的 Dockerfile 示例：</p>\n<ol>\n<li>TOMCAT部署镜像：</li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础就像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> centos</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义元数据</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> auhtor=<span class=\"string\">&quot;Dy1an&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\temail=<span class=\"string\">&quot;1214966109@qq.com&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\tdesc=<span class=\"string\">&quot;TOMCAT demo Dockerfile&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> WORK_PATH=/ops \\</span><br><span class=\"line\">\tENV_PATH=$&#123;WORK_PATH&#125;/<span class=\"keyword\">env</span> \\</span><br><span class=\"line\">\tSERVICE_PATH=$&#123;WORK_PATH&#125;/service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 JDK</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> jdk-8u11-linux-x64.tar.gz <span class=\"variable\">$&#123;ENV_PATH&#125;</span>/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 TOMCAT</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> apache-tomcat-9.0.22.tar.gz <span class=\"variable\">$&#123;SERVICE_PATH&#125;</span>/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ROOT.war <span class=\"variable\">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压安装包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> unzip ROOT.war -d ROOT &amp;&amp; <span class=\"built_in\">rm</span> -f ROOT.war</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_HOME=$&#123;ENV_PATH&#125;/jdk1.<span class=\"number\">8.0</span>_11 \\</span><br><span class=\"line\">\tCLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar \\</span><br><span class=\"line\">\tCATALINA_HOME=$&#123;SERVICE_PATH&#125;/apache-tomcat-<span class=\"number\">9.0</span>.<span class=\"number\">22</span> \\</span><br><span class=\"line\">\tPATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动项目</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;CATALINA_HOME&#125;</span>/bin/startup.sh &amp;&amp; <span class=\"built_in\">tail</span> -f <span class=\"variable\">$&#123;CATALINA_HOME&#125;</span>/logs/catalina.out</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>我参与的一个github项目 <a href=\"https://github.com/BaoXuebin/beancount-gs/issues/23#issuecomment-1194917665\">beancount-gs</a></li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> BEANCOUNT_VERSION=<span class=\"number\">2.3</span>.<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GOLANG_VERSION=<span class=\"number\">1.17</span>.<span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:$&#123;GOLANG_VERSION&#125; AS go_build_env</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GO111MODULE=on \\</span><br><span class=\"line\">    GOPROXY=https://goproxy.cn,direct \\</span><br><span class=\"line\">    GIN_MODE=release \\</span><br><span class=\"line\">    CGO_ENABLED=<span class=\"number\">0</span> \\</span><br><span class=\"line\">    PORT=<span class=\"number\">80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> https://github.com/BaoXuebin/beancount-gs.git</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build/beancount-gs</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span> -p public/default_icons &amp;&amp; <span class=\"built_in\">cp</span> -rn public/icons/* public/default_icons</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> go build .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:latest as build_env</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> BEANCOUNT_VERSION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH <span class=\"string\">&quot;/app/bin:$PATH&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> python3 -mvenv /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> https://github.com/beancount/beancount</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build/beancount</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git checkout <span class=\"variable\">$&#123;BEANCOUNT_VERSION&#125;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> CFLAGS=-s pip3 install -U /tmp/build/beancount</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip3 uninstall -y pip</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> find /app -name __pycache__ -<span class=\"built_in\">exec</span> <span class=\"built_in\">rm</span> -rf -v &#123;&#125; +</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.10</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build_env /app /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=go_build_env /tmp/build/beancount-gs /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">cp</span> -rn /app/public/default_icons/* /app/public/icons</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH <span class=\"string\">&quot;/app/bin:$PATH&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/beancount-gs&quot;</span>, <span class=\"string\">&quot;-p&quot;</span>, <span class=\"string\">&quot;80&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n","more":"<h4 id=\"利用-Commit-制作镜像\"><a href=\"#利用-Commit-制作镜像\" class=\"headerlink\" title=\"利用 Commit 制作镜像\"></a>利用 Commit 制作镜像</h4><p>在容器管理章节有提到使用现有的容器制作镜像，但是这在真正的工作中明显是不合适的。使用<code>docker commit</code>意味着所有对镜像的操作都是黑箱操作，生成的镜像被称为<code>黑箱镜像</code>。</p>\n<p>换句话说，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。即使是制作人，过段时间后也无法记清具体的操作。这种镜像维护起来非常痛苦。</p>\n<p>而且，由于镜像分层存储的特点，除当前层外，之前的每一层都是不会发生改变的，这意味着任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。即使是删除，上一层的东西也并不会丢失。镜像会越来越臃肿。</p>\n<p>同时还有另外一个问题，容器中某些进程可能是动态的，过段时间会退出。如果使用 commit 制作镜像，这些进程可能不会保存到镜像中。</p>\n<h4 id=\"利用-Dockerfile-制作镜像\"><a href=\"#利用-Dockerfile-制作镜像\" class=\"headerlink\" title=\"利用 Dockerfile 制作镜像\"></a>利用 Dockerfile 制作镜像</h4><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果能把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那之前 Commit 的无法重复、镜像构建透明性、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code>。</p>\n<p>Dockerfile 是一个文本文件，其内包含了一条条的<code>指令（Instruction）</code>，每一条指令构建一层。</p>\n<p>以定制一个 <code>nginx</code> 镜像为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建目录专门用于存放相关的 Dockerfile</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p nginx/v1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 Dockerfile</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nginx/v1.0/</span><br><span class=\"line\">vim Dockerfile</span><br></pre></td></tr></table></figure>\n\n<p>Dockerfile 内容如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> nginx:latest</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;h1&gt;Hello Docker&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个最简单的 Dockerfile，以 nginx 镜像为基础镜像，然后修改镜像中的 html 文件，形成新的镜像。</p>\n<p>上面提到了基础镜像，我们可以以任何镜像为基础镜像，在它的上面进行操作形成新的镜像，Docker 官方也提供了很多精简的基础镜像，可以拿来直接使用。</p>\n<p>在编辑好 Dockerfile 之后，就进入镜像制作的步骤：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t trover/nginx:v1.0 .</span><br></pre></td></tr></table></figure>\n\n<p>注意最后那个<code>.</code>不能掉。</p>\n<p><img src=\"/img/2022/docker-image/979767-20220615225133950-1185740767.png\"></p>\n<p>可以发现，镜像构建的时候有两层，一层是<code>FROM</code>，一层是<code>RUN</code>。这也印证了上面说的每一个关键字就是一层。</p>\n<h4 id=\"镜像构建上下文\"><a href=\"#镜像构建上下文\" class=\"headerlink\" title=\"镜像构建上下文\"></a>镜像构建上下文</h4><p>关于 build 命令最后那个<code>.</code>，其实不是指 Dockerfile 的路径，而是指定<code>上下文路径</code>。</p>\n<p>想要理解上下文，首先要理解<code>docker build</code>的工作原理：</p>\n<p>Docker 的运行分为服务端 Docker 引擎（守护进程）和客户端工具。服务端 Docker 引擎提供了一组 REST API，称为<code>Docker Remote API</code>。docker 命令这样的客户端工具就是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p>\n<p>虽然表面上是在本机执行的各种 docker 功能，但实际上一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让操作远程服务器的 Docker 引擎变得轻而易举。</p>\n<p>在进行镜像构建时，并非所有定制都会通过<code>RUN</code>指令完成，经常会需要将一些本地文件复制进镜像，比如通过<code>COPY</code>指令、<code>ADD</code>指令等。而 build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>\n<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>\n<p>以 Dockerfile 为例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./package.json /app/</span></span><br></pre></td></tr></table></figure>\n\n<p>该指定并不是复制当前目录的 package.json 文件，也不是 Dockerfile 所在目录的 package.json 文件，而是上下文目录中的 package.json。</p>\n<p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是为何<code>COPY ../package.json /app</code>或者<code>COPY /opt/xxxx /app</code>无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>\n<p>通过 build 命令输出的第一行也可以看到发送上下文的过程：</p>\n<blockquote>\n<p>Sending build context to Docker daemon 2.048 kB</p>\n</blockquote>\n<p>所以，制作 Dockerfile 的目录尽量满足以下需求：</p>\n<ul>\n<li>一个空目录。</li>\n<li>将所有需要的文件都复制一份到当前目录。</li>\n<li>如果目录下有文件不需要被发送到 Docker 引擎，可以创建一个类似<code>.gitignore</code>一样语法的文件<code>.dockerignore</code>。<br>默认情况下，如果不特殊指定 Dockerfile 路径，默认会将上下文路径中的名为 Dockerfile 的文件作为 Dockerfile。</li>\n</ul>\n<p>Dockerfile 也并非文件就要叫 Dockerfile，可以通过 -f 指定其它文件，但是一般不这样做。</p>\n<h4 id=\"Dockerfile（FROM）\"><a href=\"#Dockerfile（FROM）\" class=\"headerlink\" title=\"Dockerfile（FROM）\"></a>Dockerfile（FROM）</h4><p>FROM 指令是 Dockerfile 最基础的关键字，用于指定基础镜像。格式为：<code>FROM &lt;基础镜像&gt;</code></p>\n<p>如果你自己想做一个基础镜像，则可以使用<code>FROM scratch</code>，scratch 镜像是 Docker 官方提供的一个虚拟空白镜像。</p>\n<p>基础镜像意味着不以任何系统为基础，直接将可执行文件复制到镜像中，该文件包含了运行所需的所有库。这样镜像会更小，非常适合 Go 语言开发的程序。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本使用</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基础镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> scratch</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（LABEL）\"><a href=\"#Dockerfile（LABEL）\" class=\"headerlink\" title=\"Dockerfile（LABEL）\"></a>Dockerfile（LABEL）</h4><p>LABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata），在旧版本中叫 MATAINER。格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p>\n<p>通过 LABEL 标签能够让别人更清楚你这镜像。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> name=<span class=\"string\">&quot;Trover&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\temail=<span class=\"string\">&quot;admin@buerya.cn&quot;</span></span></span><br><span class=\"line\">\tdesc=<span class=\"string\">&quot;Dockerfile demo&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（RUN）\"><a href=\"#Dockerfile（RUN）\" class=\"headerlink\" title=\"Dockerfile（RUN）\"></a>Dockerfile（RUN）</h4><p>RUN 指令用来执行命令行命令。由于命令行的强大能力，<code>RUN</code>指令在定制镜像时是最常用的指令之一。其格式有两种：</p>\n<ul>\n<li>shell 格式：<code>RUN 命令</code></li>\n<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code><br>由于 Dockerfile 中每个关键字就是一层，Union FS 会有最大层数限制，以 AUFS 为例，最大支持 127 层。为了减少镜像的层数，一般使用<code>&amp;&amp;</code>连接多个命令，<code>\\</code>进行换行，提高阅读性。</li>\n</ul>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> / &amp;&amp; yum -y install nginx \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\t&amp;&amp; <span class=\"built_in\">cd</span> /etc/nginx \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\t&amp;&amp; <span class=\"built_in\">rm</span> -f nginx.conf</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（WORKDIR）\"><a href=\"#Dockerfile（WORKDIR）\" class=\"headerlink\" title=\"Dockerfile（WORKDIR）\"></a>Dockerfile（WORKDIR）</h4><p>WORKDIR 指令用于指定工作目录（或称当前目录），以后各层的当前目录就被改为指定的目录，如果该目录不存在，WORKDIR 会自动创建。格式为：WORKDIR &lt;工作目录路径&gt;</p>\n<blockquote>\n<p>WORKDIR 目录 不等于 RUN cd 目录，前者会对后面的所有镜像层产生影响，后者只对当前层，对于下一层并不会 cd 进目录。</p>\n</blockquote>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /a</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> b</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> c</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\"><span class=\"comment\"># 最后输出目录为 /a/b/c</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（COPY）\"><a href=\"#Dockerfile（COPY）\" class=\"headerlink\" title=\"Dockerfile（COPY）\"></a>Dockerfile（COPY）</h4><p>COPY 指令用于将构建上下文目录中的源文件或目录拷贝到镜像中的指定目录，支持两种格式。</p>\n<ul>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code><br>源路径可以是多个，甚至使用通配符。目标路径可以是容器中绝对路径，也可以是 WORKDIR 的相对路径。目标路径不存在会自动创建。</li>\n</ul>\n<p>COPY 指令能保留文件的各种元数据，比如创建时间，读写权限等。如果源文件为目录，其实质是将目录中的文件拷贝到镜像中的新目录中。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package.json /usr/src/app/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package* /usr/src/app/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝并修改权限</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"built_in\">chown</span>=myuser:mygroup package* /usr/src/app/</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ADD）\"><a href=\"#Dockerfile（ADD）\" class=\"headerlink\" title=\"Dockerfile（ADD）\"></a>Dockerfile（ADD）</h4><p>ADD 指令和 COPY 类似，但不推荐使用，因为没有 COPY 定义明确。格式为：<code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></p>\n<p>ADD 源路径支持 URL，Docker 会去指定的 URL 下载文件，并保存成 600 权限，如果 URL 是压缩也文件不会解压。所以这种需求使用 RUN 指令更好。</p>\n<p>如果本地源文件是 tar，gzip，bzip2，xz 等格式的压缩文件，ADD 会自动解压。但如果只想复制一个压缩文件进去，则不能使用 ADD 指令。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> ubuntu.tar.gz /app/</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ENV）\"><a href=\"#Dockerfile（ENV）\" class=\"headerlink\" title=\"Dockerfile（ENV）\"></a>Dockerfile（ENV）</h4><p>ENV 指令用于设置环境变量，在后面的指令中可以直接使用<code>$&#123;变量名&#125;</code>的方式引用，容器中也可以看到。支持两种格式。</p>\n<ul>\n<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>\n<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code><br>通过环境变量的定义能够使 Dockerfile 更加灵活。</li>\n</ul>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> VERSION=<span class=\"string\">&quot;1.0&quot;</span> \\</span><br><span class=\"line\">\tNAME=<span class=\"string\">&quot;Dy1an&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$VERSION</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ARG）\"><a href=\"#Dockerfile（ARG）\" class=\"headerlink\" title=\"Dockerfile（ARG）\"></a>Dockerfile（ARG）</h4><p>ARG 指令功能和 ENV 类似，用于定义构建参数。不同在于 ARG 设置的是构建环境的环境变量，在容器运行时这些变量不会存在。格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>\n<p>该默认值可以在<code>docker build</code>中使用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖，起到传参构建的目的。</p>\n<p>ARG 指令有作用范围，如果是在 FROM 之前使用，则只能 FROM 指令中使用该变量。想要继续使用就得重新定义。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> DOCKER_USERNAME=library</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（USER）\"><a href=\"#Dockerfile（USER）\" class=\"headerlink\" title=\"Dockerfile（USER）\"></a>Dockerfile（USER）</h4><p>USER 指令指定当前用户和用户组，影响范围和 WORKDIR 类似。格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>\n<p>USER 指令只是切换用户，所以这个用户必须先创建好。</p>\n<p>如果脚本是 root 运行，但是容器中启动服务需要使用其他用户，建议下载<code>gosu</code>代替原本的 su 或者 sudo，可以避免很多问题。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> useradd -r -g nginx</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 gosu</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -O /usr/local/bin/gosu <span class=\"string\">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; <span class=\"built_in\">chmod</span> +x /usr/local/bin/gosu \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; gosu nginx <span class=\"literal\">true</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 CMD，并以另外的用户执行</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;exec&quot;</span>, <span class=\"string\">&quot;gosu&quot;</span>, <span class=\"string\">&quot;nginx&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（EXPOSE）\"><a href=\"#Dockerfile（EXPOSE）\" class=\"headerlink\" title=\"Dockerfile（EXPOSE）\"></a>Dockerfile（EXPOSE）</h4><p>EXPOSE 指令用于声明容器运行时提供服务的端口，只是声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>\n<p>在 Dockerfile 中写入这样的声明有两个好处：</p>\n<p>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口。<br>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（CMD）\"><a href=\"#Dockerfile（CMD）\" class=\"headerlink\" title=\"Dockerfile（CMD）\"></a>Dockerfile（CMD）</h4><p><code>CMD</code> 指令用于指定容器默认的主进程启动命令。和 RUN 类似，支持两种格式：</p>\n<ul>\n<li>shell 格式：<code>CMD &lt;命令&gt;</code></li>\n<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code><br>推荐使用 exec 格式，因为 shell 格式也会被 docker 转换成 exec 格式，比如：</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\"># 会被转换成</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;echo &#x27;Hello&#x27;&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>exec 格式在解析时会被解析为 JSON 数组，因此一定要使用双引号<code>&quot;</code>，而不要使用单引号。</p>\n</blockquote>\n<p>在容器运行时，可以指定新的命令来替代镜像中设置的 CMD 默认命令。</p>\n<p>比如：ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，run -it 启动会直接进入容器的 bash。可以在运行时指定其它命令，如<code>docker run -it ubuntu cat /etc/os-release</code>的方式替换掉默认的<code>/bin/bash</code>命令。</p>\n<p>注意：</p>\n<blockquote>\n<p>docker 不是虚拟机，容器中的应用都应该以前台执行，不能用 systemd 去启动后台服务，容器内没有后台服务的概念。</p>\n</blockquote>\n<p>如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> service nginx start</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的容器启动后立即退出，即使是进入容器内使用<code>systemctl</code>也一样。</p>\n<p>对于容器而言，启动命令就是容器的应用进程，容器为主进程而存在，主进程退出，容器就失去了存在的意义，从而跟着退出，其它进程它不关心。</p>\n<p>所以，使用<code>service nginx start</code>命令希望以后台守护进程形式启动 nginx。而 CMD 会被转换成<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>。此时主进程实际上是<code>sh</code>。那么当 service nginx start 命令结束后，sh 主进程也就结束了，容器自然就会跟着退出。</p>\n<p>正确的做法是以前台的方式直接启动：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;nginx&quot;</span>, <span class=\"string\">&quot;-g&quot;</span>, <span class=\"string\">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（ENTRYPOINT）\"><a href=\"#Dockerfile（ENTRYPOINT）\" class=\"headerlink\" title=\"Dockerfile（ENTRYPOINT）\"></a>Dockerfile（ENTRYPOINT）</h4><p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。它的启动命令也是可以被替换的，不过比 CMD 繁琐，需要通过 docker run 的参数 –entrypoint 来指定。和 RUN 一样，也是支持两种格式。</p>\n<p>相较于 CMD，ENTRYPOINT 常用于解决以下问题：</p>\n<h5 id=\"1-能够实现灵活的传参功能\"><a href=\"#1-能够实现灵活的传参功能\" class=\"headerlink\" title=\"1. 能够实现灵活的传参功能\"></a>1. 能够实现灵活的传参功能</h5><p>一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该镜像用于输出当前公网 IP</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> busybox</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-s&quot;</span>, <span class=\"string\">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>docker build -t myip</code>. 生成 myip 镜像，然后使用 <code>docker run myip</code> 运行。这个 docker 就能变成一个类似于查询公网 IP 的命令。</p>\n<p>但是如果此时需求变得复杂，需要在镜像的 curl 中加入<code>-i</code>参数输出请求头信息。</p>\n<p>直接使用<code>docker run myip -i</code>会报错：executable file not found。原因在于镜像后面的参数会被当成命令替换掉 CMD 中的内容，而 CMD 第一个参数是可执行文件，-i 显然不是可执行文件，所以报错。</p>\n<p>如果将 CMD 换成 ENTRYPOINT：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该镜像用于输出当前公网 IP</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> busybox</span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-s&quot;</span>, <span class=\"string\">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<p>此时再次执行 <code>docker run myip -i</code> 就能正常使用。原因在于，-i 参数会替换 CMD 中的内容，但是在定义了 ENTRYPOINT 的 Dockerfile 中，CMD 中的所有内容会成为参数传递给 ENTRYPOINT，这就实现了灵活参数的功能。</p>\n<h5 id=\"2-通过判断不同的传参干不同的事情\"><a href=\"#2-通过判断不同的传参干不同的事情\" class=\"headerlink\" title=\"2. 通过判断不同的传参干不同的事情\"></a>2. 通过判断不同的传参干不同的事情</h5><p>生产中有这样一类场景，某些镜像的运行方案可能不一定，用户可以传递相关的参数修改容器的运行方式。由于在 ENTRYPOINT 加入了逻辑判断等操作，再写命令或者 exec 格式显然不适合，所以需要使用脚本的格式。 然后将 CMD 的内容作为参数传给它。</p>\n<p>一个简单的 Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> busybox</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝脚本到镜像中</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> docker-entrypoint.sh /usr/local/bin/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行脚本</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>docker-entrypoint.sh：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> = <span class=\"string\">&#x27;hello&#x27;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile（VOLUME）\"><a href=\"#Dockerfile（VOLUME）\" class=\"headerlink\" title=\"Dockerfile（VOLUME）\"></a>Dockerfile（VOLUME）</h4><p>VOLUME 指令用于挂在一个或多个存储卷，格式如下：</p>\n<ul>\n<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME &lt;路径&gt;</code><br>容器运行时应尽量保持容器存储层不发生写操作，但数据写入往往又是不可避免的。</li>\n</ul>\n<p>为了防止运行时用户忘记将动态文件所保存的目录挂载为卷，可以在<code>Dockerfile</code>中事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /data</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>/data</code>目录就会在容器运行时自动挂载为匿名卷，任何向<code>/data</code>中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以通过<code>-v</code>参数覆盖这个挂载设置。</p>\n<p>后面会对存储卷进行详细的说明。</p>\n<h4 id=\"Dockerfile（HEALTHCHECK）\"><a href=\"#Dockerfile（HEALTHCHECK）\" class=\"headerlink\" title=\"Dockerfile（HEALTHCHECK）\"></a>Dockerfile（HEALTHCHECK）</h4><p>HEALTHCHECK 指令用于告诉 Docker 应该如何进行判断容器的状态是否正常，在 Docker 1.12 引入。支持以下格式：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>\n<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br>在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁或死循环状态，应用进程并不会退出，容器已经无法提供服务，却并不会被重新调度。HEALTHCHECK 指令的价值就在于能够比较真实的反应容器实际状态。</li>\n</ul>\n<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 后，用其启动容器，初始状态会为<code>starting</code>，在 <code>HEALTHCHECK</code> 检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。</p>\n<p>HEALTHCHECK 支持下列选项：</p>\n<ul>\n<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒</li>\n<li><code>--timeout=&lt;时长&gt;</code>：健康检查运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒</li>\n<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为<code>unhealthy</code>，默认 3 次<br>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</li>\n</ul>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"language-bash\"> --interval=5s --<span class=\"built_in\">timeout</span>=3s CMD curl -fs http://localhost/ || <span class=\"built_in\">exit</span> 1</span></span><br></pre></td></tr></table></figure>\n\n<p>容器运行后，使用 docker container ls 就可以看到健康状态。使用 docker container inspect xxx 可以看到检测信息。</p>\n<h4 id=\"Dockerfile（SHELL）\"><a href=\"#Dockerfile（SHELL）\" class=\"headerlink\" title=\"Dockerfile（SHELL）\"></a>Dockerfile（SHELL）</h4><p>SHELL 指令用于指定 RUN，ENTRYPOINT，CMD 指令的 shell，Linux 中默认为<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>。格式为：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-cex&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<pre><code># 命令最终会被解析为：/bin/sh -cex &quot;nginx&quot;\nENTRYPOINT nginx\n</code></pre>\n<h4 id=\"Dockerfile（ONBUILD）\"><a href=\"#Dockerfile（ONBUILD）\" class=\"headerlink\" title=\"Dockerfile（ONBUILD）\"></a>Dockerfile（ONBUILD）</h4><p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等。这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>\n<p>Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:slim</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span> /app</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./package.json /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">RUN</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;install&quot;</span> ]</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">COPY</span><span class=\"language-bash\"> . /app/</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [ <span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dockerfile-建议\"><a href=\"#Dockerfile-建议\" class=\"headerlink\" title=\"Dockerfile 建议\"></a>Dockerfile 建议</h4><p>在制作 Dockerfile 的时候，应该尽可能的遵守一些约定俗称的方法和建议：</p>\n<ul>\n<li>容器应该是短暂的<ul>\n<li>通过 Dockerfile 构建的镜像生命周期不宜过长，容器从销毁到创建都应该将工作量将到最小。</li>\n</ul>\n</li>\n<li>增加 .dockerigonre 文件<ul>\n<li>每一个单独的项目都应该有一个单独的目录并创建一个 .dockerignore 文件用于忽略不需要的文件或目录，构建镜像所需的文件都应该存放到该目录下。</li>\n</ul>\n</li>\n<li>避免不必要的文件，使用多阶段构建<ul>\n<li>在 Dockerfile 的每一层定义中，在进入下一层之前，都需要删除掉其它不需要的文件，以此尽可能的减小镜像的体积。</li>\n<li>比如通过 Dockerfile 直接完成打包，运行，打包这一步除了打出来的包其它的文件其实都是没用的，此时就是和多阶段构建。</li>\n<li>示例：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一阶段，打包。使用 as 对阶段进行命名，每一个 FROM 就是一个阶段</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:<span class=\"number\">1.7</span>.<span class=\"number\">3</span> as build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> go get -d -v golang.org/x/net/html  </span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app.go    .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二阶段，运行。</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine:latest  </span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apk --no-cache add ca-certificates</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /root/</span></span><br><span class=\"line\"><span class=\"comment\"># 从第一阶段中拷贝打好的包</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;./app&quot;</span>] </span></span><br></pre></td></tr></table></figure>\n<pre><code>此时 build 镜像的话，镜像中就不会包含第一节点的内容，包也尽可能的减小了。\n</code></pre>\n<ul>\n<li>一个容器只运行一个进程<ul>\n<li>应该保证每个容器只有一个进程，多个进程解耦到不同容器中，便于后续的扩展。</li>\n</ul>\n</li>\n<li>将多行参数排序<ul>\n<li>某些参数太多太长需要换行的，尽可能按照字母顺序排序，这样可以避免重复。</li>\n</ul>\n</li>\n<li>使用构建缓存<ul>\n<li>在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 –no-cache&#x3D;true 选项。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"完整的-Dockerfile-示例\"><a href=\"#完整的-Dockerfile-示例\" class=\"headerlink\" title=\"完整的 Dockerfile 示例\"></a>完整的 Dockerfile 示例</h4><p>以下是一些常见的 Dockerfile 示例：</p>\n<ol>\n<li>TOMCAT部署镜像：</li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础就像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> centos</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义元数据</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> auhtor=<span class=\"string\">&quot;Dy1an&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\temail=<span class=\"string\">&quot;1214966109@qq.com&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">\tdesc=<span class=\"string\">&quot;TOMCAT demo Dockerfile&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> WORK_PATH=/ops \\</span><br><span class=\"line\">\tENV_PATH=$&#123;WORK_PATH&#125;/<span class=\"keyword\">env</span> \\</span><br><span class=\"line\">\tSERVICE_PATH=$&#123;WORK_PATH&#125;/service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 JDK</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> jdk-8u11-linux-x64.tar.gz <span class=\"variable\">$&#123;ENV_PATH&#125;</span>/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 TOMCAT</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> apache-tomcat-9.0.22.tar.gz <span class=\"variable\">$&#123;SERVICE_PATH&#125;</span>/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ROOT.war <span class=\"variable\">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压安装包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> unzip ROOT.war -d ROOT &amp;&amp; <span class=\"built_in\">rm</span> -f ROOT.war</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_HOME=$&#123;ENV_PATH&#125;/jdk1.<span class=\"number\">8.0</span>_11 \\</span><br><span class=\"line\">\tCLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar \\</span><br><span class=\"line\">\tCATALINA_HOME=$&#123;SERVICE_PATH&#125;/apache-tomcat-<span class=\"number\">9.0</span>.<span class=\"number\">22</span> \\</span><br><span class=\"line\">\tPATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动项目</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;CATALINA_HOME&#125;</span>/bin/startup.sh &amp;&amp; <span class=\"built_in\">tail</span> -f <span class=\"variable\">$&#123;CATALINA_HOME&#125;</span>/logs/catalina.out</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>我参与的一个github项目 <a href=\"https://github.com/BaoXuebin/beancount-gs/issues/23#issuecomment-1194917665\">beancount-gs</a></li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> BEANCOUNT_VERSION=<span class=\"number\">2.3</span>.<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GOLANG_VERSION=<span class=\"number\">1.17</span>.<span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:$&#123;GOLANG_VERSION&#125; AS go_build_env</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GO111MODULE=on \\</span><br><span class=\"line\">    GOPROXY=https://goproxy.cn,direct \\</span><br><span class=\"line\">    GIN_MODE=release \\</span><br><span class=\"line\">    CGO_ENABLED=<span class=\"number\">0</span> \\</span><br><span class=\"line\">    PORT=<span class=\"number\">80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> https://github.com/BaoXuebin/beancount-gs.git</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build/beancount-gs</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span> -p public/default_icons &amp;&amp; <span class=\"built_in\">cp</span> -rn public/icons/* public/default_icons</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> go build .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:latest as build_env</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> BEANCOUNT_VERSION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH <span class=\"string\">&quot;/app/bin:$PATH&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> python3 -mvenv /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> https://github.com/beancount/beancount</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /tmp/build/beancount</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git checkout <span class=\"variable\">$&#123;BEANCOUNT_VERSION&#125;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> CFLAGS=-s pip3 install -U /tmp/build/beancount</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip3 uninstall -y pip</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> find /app -name __pycache__ -<span class=\"built_in\">exec</span> <span class=\"built_in\">rm</span> -rf -v &#123;&#125; +</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.10</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build_env /app /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=go_build_env /tmp/build/beancount-gs /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">cp</span> -rn /app/public/default_icons/* /app/public/icons</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH <span class=\"string\">&quot;/app/bin:$PATH&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/beancount-gs&quot;</span>, <span class=\"string\">&quot;-p&quot;</span>, <span class=\"string\">&quot;80&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"Docker","path":"api/categories/Docker.json"}],"tags":[{"name":"docker","path":"api/tags/docker.json"},{"name":"k8s","path":"api/tags/k8s.json"},{"name":"kubernetes","path":"api/tags/kubernetes.json"},{"name":"容器","path":"api/tags/容器.json"},{"name":"云原生","path":"api/tags/云原生.json"}]}