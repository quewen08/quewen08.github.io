{"title":"2018年Android面试题整理","slug":"questioninterview2018","date":"2018-09-04T16:00:00.000Z","updated":"2022-10-19T14:40:00.262Z","comments":true,"path":"api/articles/questioninterview2018.json","realPath":"/2018/questioninterview2018/index/","excerpt":null,"covers":["/img/img/questioninterview2018/161bb552a99f8490_tplv-t2oaga2asx-watermark.awebp","/img/img/questioninterview2018/fff72bb7eec021cd437e03e0f655152d.jfif"],"cover":"/img/img/questioninterview2018/161bb552a99f8490_tplv-t2oaga2asx-watermark.awebp","content":"<p>这是我近段时间收集的面试题，献给打算年后找工作的同学们。文中涉及的知识比较广也可能比较零散，并且一些较为基础的知识我都略去了（比如Android四大组件是什么这类问题），有些我附上了自己的理解，有些附上了详细的相关文章链接。大家挑自己感兴趣的内容查看即可，后期我也会继续不断补充。</p>\n<h2 id=\"基础组件篇\"><a href=\"#基础组件篇\" class=\"headerlink\" title=\"基础组件篇\"></a>基础组件篇</h2><h3 id=\"横竖屏切换时Activity的生命周期变化\"><a href=\"#横竖屏切换时Activity的生命周期变化\" class=\"headerlink\" title=\"横竖屏切换时Activity的生命周期变化\"></a>横竖屏切换时Activity的生命周期变化</h3><ul>\n<li>如果自己没有配置<code>android:ConfigChanges</code>，这时默认让系统处理，就会重建Activity，此时Activity的生命周期会走一遍。</li>\n</ul>\n<p><img src=\"/img/img/questioninterview2018/161bb552a99f8490_tplv-t2oaga2asx-watermark.awebp\"></p>\n<blockquote>\n<h2 id=\"onSaveInstanceState-与-onRestoreIntanceState\"><a href=\"#onSaveInstanceState-与-onRestoreIntanceState\" class=\"headerlink\" title=\"onSaveInstanceState() 与 onRestoreIntanceState()\"></a><code>onSaveInstanceState() 与 onRestoreIntanceState()</code></h2><p>资源相关的系统配置发生改变或者资源不足：例如屏幕旋转，当前Activity会销毁，并且在onStop之前回调onSaveInstanceState保存数据，在重新创建Activity的时候在onStart之后回调onRestoreInstanceState。其中Bundle数据会传到onCreate（不一定有数据）和onRestoreInstanceState（一定有数据）。<br>用户或者程序员主动去销毁一个Activity的时候不会回调，其他情况都会调用，来保存界面信息。如代码中finish（）或用户按下back，不会回调。</p>\n</blockquote>\n<ul>\n<li>如果设置<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</code>，此时Activity的生命周期不会重走一遍，Activity不会重建，只会回调onConfigurationChanged方法。</li>\n</ul>\n<h3 id=\"activity的startActivity和context的startActivity的区别\"><a href=\"#activity的startActivity和context的startActivity的区别\" class=\"headerlink\" title=\"activity的startActivity和context的startActivity的区别\"></a>activity的startActivity和context的startActivity的区别</h3><ol>\n<li>从Activity中启动新的Activity时可直接mContext.startActivity(intent)就好；</li>\n<li>如果从其他Context中启动Activity则必须给intent设置Flag:</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">mContext.startActivity(intent);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"介绍下Android应用程序启动过程\"><a href=\"#介绍下Android应用程序启动过程\" class=\"headerlink\" title=\"介绍下Android应用程序启动过程\"></a>介绍下Android应用程序启动过程</h3><p>整个应用程序的启动过程要执行很多步骤，但是整体来看，主要分为以下五个阶段：</p>\n<blockquote>\n<ol>\n<li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</li>\n<li>ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</li>\n<li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</li>\n<li>ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</li>\n<li>ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</li>\n</ol>\n</blockquote>\n<h3 id=\"如何保证Service不被杀死？\"><a href=\"#如何保证Service不被杀死？\" class=\"headerlink\" title=\"如何保证Service不被杀死？\"></a>如何保证Service不被杀死？</h3><ul>\n<li><p>提供进程优先级，降低进程被杀死的概率<br>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。<br>方法二：启动前台service。<br>方法三：提升service优先级：<br>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority &#x3D; “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>\n</li>\n<li><p>在进程被杀死后，进行拉活<br>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等<br>方法二：双进程相互唤起。<br>方法三：依靠系统唤起。<br>方法四：onDestroy方法里重启service：service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>\n</li>\n<li><p>依靠第三方 根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A&#x2F;B Test。</p>\n</li>\n</ul>\n<h3 id=\"简述下Activity任务栈和使用方法\"><a href=\"#简述下Activity任务栈和使用方法\" class=\"headerlink\" title=\"简述下Activity任务栈和使用方法\"></a>简述下Activity任务栈和使用方法</h3><p>任务栈是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名.</p>\n<ol>\n<li><code>standard</code> <strong>默认模式</strong> 每次启动都会创建一个新的Activity对象，放到目标任务栈中。</li>\n<li><code>singleTop</code> 判断当前的任务栈顶是否存在相同的activity对象，如果存在，则直接使用，如果不存在，那么创建新的activity对象放入栈中</li>\n<li><code>singleTask</code> 在任务栈中会判断是否存在相同的activity，如果存在，那么会清除该activity之上的其他activity对象显示，如果不存在，则会创建一个新的activity放入栈顶</li>\n<li><code>singleIntance</code> 会在一个新的任务栈中创建activity，并且该任务栈种只允许存在一个activity实例，其他调用该activity的组件会直接使用该任务栈种的activity对象</li>\n</ol>\n<p>方法一： 使用android:launchMode&#x3D;”standard|singleInstance|single Task|singleTop”来控制Acivity任务栈。<br>方法二： Intent Flags：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Intent intent=<span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setClass(MainActivity.<span class=\"built_in\">this</span>, MainActivity2.class);</span><br><span class=\"line\">intent.addFlags(Intent. FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Flags有很多，比如：<br>Intent.FLAG_ACTIVITY_NEW_TASK 相当于singleTask<br>Intent. FLAG_ACTIVITY_CLEAR_TOP 相当于singleTop</p>\n<h3 id=\"Context相关问题\"><a href=\"#Context相关问题\" class=\"headerlink\" title=\"Context相关问题\"></a>Context相关问题</h3><p>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper.<br>每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象<br>getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法.getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。</p>\n<p>Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application.<br>那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。</p>\n<h3 id=\"怎么在Service中创建Dialog对话框\"><a href=\"#怎么在Service中创建Dialog对话框\" class=\"headerlink\" title=\"怎么在Service中创建Dialog对话框\"></a>怎么在Service中创建Dialog对话框</h3><ol>\n<li>在我们取得Dialog对象后，需给它设置类型，即：<br><code>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)</code></li>\n<li>在Manifest中加上权限:<br><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code></li>\n</ol>\n<h2 id=\"View篇\"><a href=\"#View篇\" class=\"headerlink\" title=\"View篇\"></a>View篇</h2><h3 id=\"非UI线程可以更新UI吗？\"><a href=\"#非UI线程可以更新UI吗？\" class=\"headerlink\" title=\"非UI线程可以更新UI吗？\"></a>非UI线程可以更新UI吗？</h3><p>可以<br>当访问UI时，<code>ViewRootImpl</code>会调用<code>checkThread()</code>方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常<br>执行<code>onCreate</code>方法的那个时候<code>ViewRootImpl</code>还没创建，无法去检查当前线程<code>ViewRootImpl</code>的创建在<code>onResume()</code>方法回调之后.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">checkThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CalledFromWrongThreadException</span>(</span><br><span class=\"line\">                <span class=\"string\">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非UI线程是可以刷新UI的，前提是它要拥有自己的<code>ViewRoot</code>,即更新UI的线程和创建<code>ViewRoot</code>是同一个,或者在执行<code>checkThread()</code>前更新UI.</p>\n<h3 id=\"解决ScrollView嵌套ListView和GridView冲突的方法\"><a href=\"#解决ScrollView嵌套ListView和GridView冲突的方法\" class=\"headerlink\" title=\"解决ScrollView嵌套ListView和GridView冲突的方法\"></a>解决ScrollView嵌套ListView和GridView冲突的方法</h3><p>重写ListView的onMeasure方法，来自定义高度：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMeasure</span><span class=\"params\">(<span class=\"type\">int</span> widthMeasureSpec, <span class=\"type\">int</span> heightMeasureSpec)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">expandSpec</span> <span class=\"operator\">=</span> MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; <span class=\"number\">2</span>, MeasureSpec.AT_MOST);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要考察对MeasureSpec的三种模式的理解,<a href=\"http://blog.csdn.net/btt2013/article/details/53447649\">相关文章</a>.</p>\n<h3 id=\"自定义View优化策略\"><a href=\"#自定义View优化策略\" class=\"headerlink\" title=\"自定义View优化策略\"></a>自定义View优化策略</h3><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>\n<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>\n<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>\n<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>\n<h2 id=\"线程篇\"><a href=\"#线程篇\" class=\"headerlink\" title=\"线程篇\"></a>线程篇</h2><h3 id=\"Handler、Message、Looper、MessageQueue\"><a href=\"#Handler、Message、Looper、MessageQueue\" class=\"headerlink\" title=\"Handler、Message、Looper、MessageQueue\"></a>Handler、Message、Looper、MessageQueue</h3><h4 id=\"相关概念的解释\"><a href=\"#相关概念的解释\" class=\"headerlink\" title=\"相关概念的解释\"></a>相关概念的解释</h4><ul>\n<li>主线程（UI线程）<br>定义：当程序第一次启动时，Android会同时启动一条主线程（Main Thread）<br>作用：主线程主要负责处理与UI相关的事件</li>\n<li>Message（消息）<br>定义：Handler接收和处理的消息对象（Bean对象）<br>作用：通信时相关信息的存放和传递</li>\n<li>ThreadLocal<br>定义：ThreadLocal是线程内部的存储类，通过它可以实现在每个线程中存储自己的私有数据。即数据存储以后，只能在指定的线程中获取这个存储的对象，而其它线程则不能获取到当前线程存储的这个对象。<br>作用：负责存储和获取本线程的Looper</li>\n<li>MessageQueue（消息队列）<br>定义：采用单链表的数据结构来存储消息列表<br>作用：用来存放通过Handler发过来的Message，按照先进先出执行</li>\n<li>Handler（处理者）<br>定义：Message的主要处理者<br>作用：负责发送Message到消息队列&amp;处理Looper分派过来的Message</li>\n<li>Looper（循环器）<br>定义：扮演Message Queue和Handler之间桥梁的角色<br>作用：<br>消息循环：循环取出Message Queue的Message<br>消息派发：将取出的Message交付给相应的Handler</li>\n</ul>\n<h4 id=\"自己画下图解\"><a href=\"#自己画下图解\" class=\"headerlink\" title=\"自己画下图解\"></a>自己画下图解</h4><p><img src=\"/img/img/questioninterview2018/fff72bb7eec021cd437e03e0f655152d.jfif\"></p>\n<h4 id=\"Handler发送消息有哪几种方式？\"><a href=\"#Handler发送消息有哪几种方式？\" class=\"headerlink\" title=\"Handler发送消息有哪几种方式？\"></a>Handler发送消息有哪几种方式？</h4><ul>\n<li>sendMessage(Message msg)</li>\n<li>post(Runnable r)</li>\n</ul>\n<h4 id=\"Handler处理消息有哪几种方式\"><a href=\"#Handler处理消息有哪几种方式\" class=\"headerlink\" title=\"Handler处理消息有哪几种方式\"></a>Handler处理消息有哪几种方式</h4><p>直接看源码<code>dispatchMessage()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dispatchMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. post()方法的处理方法</span></span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//2. sendMessage()方法的处理方法</span></span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//1. post()方法的最终处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleCallback</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">    message.callback.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2. sendMessage()方法的最终处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Message、Handler、MessageQueue、Looper的之间的关系？\"><a href=\"#Message、Handler、MessageQueue、Looper的之间的关系？\" class=\"headerlink\" title=\"Message、Handler、MessageQueue、Looper的之间的关系？\"></a>Message、Handler、MessageQueue、Looper的之间的关系？</h4><p>首先，是这个MessagQueue，MessageQueue是一个消息队列，它可以存储Handler发送过来的消息，其内部提供了进队和出队的方法来管理这个消息队列，其出队和进队的原理是采用单链表的数据结构进行插入和删除的，即enqueueMessage()方法和next()方法。这里提到的Message，其实就是一个Bean对象，里面的属性用来记录Message的各种信息。</p>\n<p>然后，是这个Looper，Looper是一个循环器，它可以循环的取出MessageQueue中的Message，其内部提供了Looper的初始化和循环出去Message的方法，即prepare()方法和loop()方法。在prepare()方法中，Looper会关联一个MessageQueue，而且将Looper存进一个ThreadLocal中，在loop()方法中，通过ThreadLocal取出Looper，使用MessageQueue的next()方法取出Message后，判断Message是否为空，如果是则Looper阻塞，如果不是，则通过dispatchMessage()方法分发该Message到Handler中，而Handler执行handlerMessage()方法，由于handlerMessage()方法是个空方法，这也是为什么需要在Handler中重写handlerMessage()方法的原因。这里要注意的是Looper只能在一个线程中只能存在一个。这里提到的ThreadLocal，其实就是一个对象，用来在不同线程中存放对应线程的Looper。</p>\n<p>最后，是这个Handler，Handler是Looper和MessageQueue的桥梁，Handler内部提供了发送Message的一系列方法，最终会通过MessageQueue的enqueueMessage()方法将Message存进MessageQueue中。我们平时可以直接在主线程中使用Handler，那是因为在应用程序启动时，在入口的main方法中已经默认为我们创建好了Looper。</p>\n<h4 id=\"为什么在子线程中创建Handler会抛异常？\"><a href=\"#为什么在子线程中创建Handler会抛异常？\" class=\"headerlink\" title=\"为什么在子线程中创建Handler会抛异常？\"></a>为什么在子线程中创建Handler会抛异常？</h4><p>Handler的工作是依赖于Looper的，而Looper（与消息队列）又是属于某一个线程（ThreadLocal是线程内部的数据存储类，通过它可以在指定线程中存储数据，其他线程则无法获取到），其他线程不能访问。因此Handler就是间接跟线程是绑定在一起了。因此要使用Handler必须要保证Handler所创建的线程中有Looper对象并且启动循环。因为子线程中默认是没有Looper的，所以会报错。<br>正确的使用方法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WorkThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">public</span> Handler <span class=\"title function_\">getHandler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> mHandler;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          mHandler.getLooper().quit();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">          <span class=\"comment\">//创建该线程对应的Looper,</span></span><br><span class=\"line\">          <span class=\"comment\">// 内部实现</span></span><br><span class=\"line\">          <span class=\"comment\">// 1。new Looper（）</span></span><br><span class=\"line\">          <span class=\"comment\">// 2。将1步中的lopper 放在ThreadLocal里，ThreadLocal是保存数据的，主要应用场景是：线程间数据互不影响的情况</span></span><br><span class=\"line\">          <span class=\"comment\">// 3。在1步中的Looper的构造函数中new MessageQueue();</span></span><br><span class=\"line\">          <span class=\"comment\">//其实就是创建了该线程对用的Looper，Looper里创建MessageQueue来实现消息机制</span></span><br><span class=\"line\">          <span class=\"comment\">//对消息机制不懂得同学可以查阅资料，网上很多也讲的很不错。</span></span><br><span class=\"line\">          Looper.prepare();</span><br><span class=\"line\">          mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>() &#123;</span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">                  Log.d(<span class=\"string\">&quot;WorkThread&quot;</span>, (Looper.getMainLooper() == Looper.myLooper()) + <span class=\"string\">&quot;,&quot;</span> + msg.what);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">          <span class=\"comment\">//开启消息的死循环处理即：dispatchMessage</span></span><br><span class=\"line\">          Looper.loop();</span><br><span class=\"line\">          <span class=\"comment\">//注意这3个的顺序不能颠倒</span></span><br><span class=\"line\">          Log.d(<span class=\"string\">&quot;WorkThread&quot;</span>, <span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HandlerThread\"><a href=\"#HandlerThread\" class=\"headerlink\" title=\"HandlerThread\"></a>HandlerThread</h3><ol>\n<li><p>HandlerThread作用<br>当系统有多个耗时任务需要执行时，每个任务都会开启一个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题，Google提供了HandlerThread，HandlerThread是在线程中创建一个Looper循环器，让Looper轮询消息队列，当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞。</p>\n</li>\n<li><p>HanlderThread的优缺点</p>\n</li>\n</ol>\n<ul>\n<li>HandlerThread本质上是一个线程类，它继承了Thread；</li>\n<li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li>\n<li>通过获取HandlerThread的looper对象传递给Handler对象，可以在<code>handleMessage()</code>方法中执行异步任务。</li>\n<li>创建HandlerThread后必须先调用<code>HandlerThread.start()</code>方法，Thread会先调用run方法，创建Looper对象。</li>\n<li>HandlerThread优点是异步不会堵塞，减少对性能的消耗</li>\n<li>HandlerThread缺点是不能同时继续进行多任务处理，需要等待进行处理，处理效率较低</li>\n<li>HandlerThread与线程池不同，HandlerThread是一个串行队列，背后只有一个线程。</li>\n</ul>\n<h3 id=\"IntentService\"><a href=\"#IntentService\" class=\"headerlink\" title=\"IntentService\"></a>IntentService</h3><ul>\n<li><p>它本质是一种特殊的Service,继承自Service并且本身就是一个抽象类</p>\n</li>\n<li><p>它可以用于在后台执行耗时的异步任务，当任务完成后会自动停止</p>\n</li>\n<li><p>它拥有较高的优先级，不易被系统杀死（继承自Service的缘故），因此比较适合执行一些高优先级的异步任务<br>它内部通过HandlerThread和Handler实现异步操作</p>\n</li>\n<li><p>创建IntentService时，只需实现onHandleIntent和构造方法，onHandleIntent为异步方法，可以执行耗时操作</p>\n</li>\n<li><p>即使我们多次启动IntentService，但IntentService的实例只有一个，这跟传统的Service是一样的，最终IntentService会去调用onHandleIntent执行异步任务。</p>\n</li>\n<li><p>当任务完成后，IntentService会自动停止，而不需要手动调用<code>stopSelf()</code>。另外，可以多次启动IntentService，每个耗时操作都会以工作队列的方式在<code>IntentService</code>中<code>onHandlerIntent()</code>回调方法中执行，并且每次只会执行一个工作线程。</p>\n</li>\n</ul>\n<h3 id=\"AsyncTask\"><a href=\"#AsyncTask\" class=\"headerlink\" title=\"AsyncTask\"></a>AsyncTask</h3><p>1、AsyncTask是什么</p>\n<p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并主线程中更新UI，通过AsyncTask可以更加方便执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的后台任务，对于特别耗时的任务来说，建议使用线程池。</p>\n<p>2、AsyncTask使用方法</p>\n<p>三个参数<br><code>Params</code>：表示后台任务执行时的参数类型，该参数会传给AysncTask的<code>doInBackground()</code>方法<br><code>Progress</code>：表示后台任务的执行进度的参数类型，该参数会作为<code>onProgressUpdate()</code>方法的参数<br><code>Result</code>：表示后台任务的返回结果的参数类型，该参数会作为<code>onPostExecute()</code>方法的参数<br>五个方法<br><code>onPreExecute()</code>：异步任务开启之前回调，在主线程中执行<br><code>doInBackground()</code>：执行异步任务，在线程池中执行<br><code>onProgressUpdate()</code>：当doInBackground中调用publishProgress时回调，在主线程中执行<br><code>onPostExecute()</code>：在异步任务执行之后回调，在主线程中执行<br><code>onCancelled()</code>：在异步任务被取消时回调</p>\n<p>3、AsyncTask引起的内存泄漏<br>原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放<br>解决：<br>AsyncTask内部持有外部Activity的弱引用<br>AsyncTask改为静态内部类<br>Activity的<code>onDestory()</code>中调用<code>AsyncTask.cancel()</code></p>\n<p>4.结果丢失<br>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用<code>onPostExecute()</code>再去更新界面将不再生效。</p>\n<p>5、AsyncTask并行or串行<br>AsyncTask在Android 2.3之前默认采用并行执行任务，AsyncTask在Android 2.3之后默认采用串行执行任务<br>如果需要在Android 2.3之后采用并行执行任务，可以调用AsyncTask的<code>executeOnExecutor()</code>;</p>\n<p>6.AsyncTask内部的线程池<br><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</code><br><code>sDefaultExecutor</code>是<code>SerialExecutor</code>的一个实例，而且它是个静态变量。也就是说，一个进程里面所有AsyncTask对象都共享同一个<code>SerialExecutor</code>对象。</p>\n<h2 id=\"一些面试心经\"><a href=\"#一些面试心经\" class=\"headerlink\" title=\"一些面试心经\"></a>一些面试心经</h2><p>一般情况下第一轮都是基础面试，需要扎实的基础</p>\n<p>最常用的Android 基础知识<br>Java 基础知识<br>了解一些 常用东西的原理，例如：handler， thread 等<br>项目中的技术点</p>\n<p>第二轮的时候需要了解更深层次的东西</p>\n<p>Android 事件分发机制原理<br>Android 绘图机制原理<br>WindowManager 的相关知识<br>进程间传输方式<br>Java 内存管理机制<br>一些常用的 list,map 原理，以及子类之间的差别</p>\n<p>能进入第三轮基本没什么问题，但是要注意以下问题</p>\n<p>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度<br>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</p>\n<p>我们的面试原则就是拿到合理薪资，得到 offer<br>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。<br>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</p>\n","more":"<p>这是我近段时间收集的面试题，献给打算年后找工作的同学们。文中涉及的知识比较广也可能比较零散，并且一些较为基础的知识我都略去了（比如Android四大组件是什么这类问题），有些我附上了自己的理解，有些附上了详细的相关文章链接。大家挑自己感兴趣的内容查看即可，后期我也会继续不断补充。</p>\n<h2 id=\"基础组件篇\"><a href=\"#基础组件篇\" class=\"headerlink\" title=\"基础组件篇\"></a>基础组件篇</h2><h3 id=\"横竖屏切换时Activity的生命周期变化\"><a href=\"#横竖屏切换时Activity的生命周期变化\" class=\"headerlink\" title=\"横竖屏切换时Activity的生命周期变化\"></a>横竖屏切换时Activity的生命周期变化</h3><ul>\n<li>如果自己没有配置<code>android:ConfigChanges</code>，这时默认让系统处理，就会重建Activity，此时Activity的生命周期会走一遍。</li>\n</ul>\n<p><img src=\"/img/img/questioninterview2018/161bb552a99f8490_tplv-t2oaga2asx-watermark.awebp\"></p>\n<blockquote>\n<h2 id=\"onSaveInstanceState-与-onRestoreIntanceState\"><a href=\"#onSaveInstanceState-与-onRestoreIntanceState\" class=\"headerlink\" title=\"onSaveInstanceState() 与 onRestoreIntanceState()\"></a><code>onSaveInstanceState() 与 onRestoreIntanceState()</code></h2><p>资源相关的系统配置发生改变或者资源不足：例如屏幕旋转，当前Activity会销毁，并且在onStop之前回调onSaveInstanceState保存数据，在重新创建Activity的时候在onStart之后回调onRestoreInstanceState。其中Bundle数据会传到onCreate（不一定有数据）和onRestoreInstanceState（一定有数据）。<br>用户或者程序员主动去销毁一个Activity的时候不会回调，其他情况都会调用，来保存界面信息。如代码中finish（）或用户按下back，不会回调。</p>\n</blockquote>\n<ul>\n<li>如果设置<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</code>，此时Activity的生命周期不会重走一遍，Activity不会重建，只会回调onConfigurationChanged方法。</li>\n</ul>\n<h3 id=\"activity的startActivity和context的startActivity的区别\"><a href=\"#activity的startActivity和context的startActivity的区别\" class=\"headerlink\" title=\"activity的startActivity和context的startActivity的区别\"></a>activity的startActivity和context的startActivity的区别</h3><ol>\n<li>从Activity中启动新的Activity时可直接mContext.startActivity(intent)就好；</li>\n<li>如果从其他Context中启动Activity则必须给intent设置Flag:</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">mContext.startActivity(intent);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"介绍下Android应用程序启动过程\"><a href=\"#介绍下Android应用程序启动过程\" class=\"headerlink\" title=\"介绍下Android应用程序启动过程\"></a>介绍下Android应用程序启动过程</h3><p>整个应用程序的启动过程要执行很多步骤，但是整体来看，主要分为以下五个阶段：</p>\n<blockquote>\n<ol>\n<li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</li>\n<li>ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</li>\n<li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</li>\n<li>ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</li>\n<li>ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</li>\n</ol>\n</blockquote>\n<h3 id=\"如何保证Service不被杀死？\"><a href=\"#如何保证Service不被杀死？\" class=\"headerlink\" title=\"如何保证Service不被杀死？\"></a>如何保证Service不被杀死？</h3><ul>\n<li><p>提供进程优先级，降低进程被杀死的概率<br>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。<br>方法二：启动前台service。<br>方法三：提升service优先级：<br>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority &#x3D; “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>\n</li>\n<li><p>在进程被杀死后，进行拉活<br>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等<br>方法二：双进程相互唤起。<br>方法三：依靠系统唤起。<br>方法四：onDestroy方法里重启service：service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>\n</li>\n<li><p>依靠第三方 根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A&#x2F;B Test。</p>\n</li>\n</ul>\n<h3 id=\"简述下Activity任务栈和使用方法\"><a href=\"#简述下Activity任务栈和使用方法\" class=\"headerlink\" title=\"简述下Activity任务栈和使用方法\"></a>简述下Activity任务栈和使用方法</h3><p>任务栈是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名.</p>\n<ol>\n<li><code>standard</code> <strong>默认模式</strong> 每次启动都会创建一个新的Activity对象，放到目标任务栈中。</li>\n<li><code>singleTop</code> 判断当前的任务栈顶是否存在相同的activity对象，如果存在，则直接使用，如果不存在，那么创建新的activity对象放入栈中</li>\n<li><code>singleTask</code> 在任务栈中会判断是否存在相同的activity，如果存在，那么会清除该activity之上的其他activity对象显示，如果不存在，则会创建一个新的activity放入栈顶</li>\n<li><code>singleIntance</code> 会在一个新的任务栈中创建activity，并且该任务栈种只允许存在一个activity实例，其他调用该activity的组件会直接使用该任务栈种的activity对象</li>\n</ol>\n<p>方法一： 使用android:launchMode&#x3D;”standard|singleInstance|single Task|singleTop”来控制Acivity任务栈。<br>方法二： Intent Flags：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Intent intent=<span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setClass(MainActivity.<span class=\"built_in\">this</span>, MainActivity2.class);</span><br><span class=\"line\">intent.addFlags(Intent. FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Flags有很多，比如：<br>Intent.FLAG_ACTIVITY_NEW_TASK 相当于singleTask<br>Intent. FLAG_ACTIVITY_CLEAR_TOP 相当于singleTop</p>\n<h3 id=\"Context相关问题\"><a href=\"#Context相关问题\" class=\"headerlink\" title=\"Context相关问题\"></a>Context相关问题</h3><p>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper.<br>每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象<br>getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法.getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。</p>\n<p>Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application.<br>那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。</p>\n<h3 id=\"怎么在Service中创建Dialog对话框\"><a href=\"#怎么在Service中创建Dialog对话框\" class=\"headerlink\" title=\"怎么在Service中创建Dialog对话框\"></a>怎么在Service中创建Dialog对话框</h3><ol>\n<li>在我们取得Dialog对象后，需给它设置类型，即：<br><code>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)</code></li>\n<li>在Manifest中加上权限:<br><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code></li>\n</ol>\n<h2 id=\"View篇\"><a href=\"#View篇\" class=\"headerlink\" title=\"View篇\"></a>View篇</h2><h3 id=\"非UI线程可以更新UI吗？\"><a href=\"#非UI线程可以更新UI吗？\" class=\"headerlink\" title=\"非UI线程可以更新UI吗？\"></a>非UI线程可以更新UI吗？</h3><p>可以<br>当访问UI时，<code>ViewRootImpl</code>会调用<code>checkThread()</code>方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常<br>执行<code>onCreate</code>方法的那个时候<code>ViewRootImpl</code>还没创建，无法去检查当前线程<code>ViewRootImpl</code>的创建在<code>onResume()</code>方法回调之后.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">checkThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CalledFromWrongThreadException</span>(</span><br><span class=\"line\">                <span class=\"string\">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非UI线程是可以刷新UI的，前提是它要拥有自己的<code>ViewRoot</code>,即更新UI的线程和创建<code>ViewRoot</code>是同一个,或者在执行<code>checkThread()</code>前更新UI.</p>\n<h3 id=\"解决ScrollView嵌套ListView和GridView冲突的方法\"><a href=\"#解决ScrollView嵌套ListView和GridView冲突的方法\" class=\"headerlink\" title=\"解决ScrollView嵌套ListView和GridView冲突的方法\"></a>解决ScrollView嵌套ListView和GridView冲突的方法</h3><p>重写ListView的onMeasure方法，来自定义高度：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMeasure</span><span class=\"params\">(<span class=\"type\">int</span> widthMeasureSpec, <span class=\"type\">int</span> heightMeasureSpec)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">expandSpec</span> <span class=\"operator\">=</span> MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; <span class=\"number\">2</span>, MeasureSpec.AT_MOST);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要考察对MeasureSpec的三种模式的理解,<a href=\"http://blog.csdn.net/btt2013/article/details/53447649\">相关文章</a>.</p>\n<h3 id=\"自定义View优化策略\"><a href=\"#自定义View优化策略\" class=\"headerlink\" title=\"自定义View优化策略\"></a>自定义View优化策略</h3><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>\n<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>\n<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>\n<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>\n<h2 id=\"线程篇\"><a href=\"#线程篇\" class=\"headerlink\" title=\"线程篇\"></a>线程篇</h2><h3 id=\"Handler、Message、Looper、MessageQueue\"><a href=\"#Handler、Message、Looper、MessageQueue\" class=\"headerlink\" title=\"Handler、Message、Looper、MessageQueue\"></a>Handler、Message、Looper、MessageQueue</h3><h4 id=\"相关概念的解释\"><a href=\"#相关概念的解释\" class=\"headerlink\" title=\"相关概念的解释\"></a>相关概念的解释</h4><ul>\n<li>主线程（UI线程）<br>定义：当程序第一次启动时，Android会同时启动一条主线程（Main Thread）<br>作用：主线程主要负责处理与UI相关的事件</li>\n<li>Message（消息）<br>定义：Handler接收和处理的消息对象（Bean对象）<br>作用：通信时相关信息的存放和传递</li>\n<li>ThreadLocal<br>定义：ThreadLocal是线程内部的存储类，通过它可以实现在每个线程中存储自己的私有数据。即数据存储以后，只能在指定的线程中获取这个存储的对象，而其它线程则不能获取到当前线程存储的这个对象。<br>作用：负责存储和获取本线程的Looper</li>\n<li>MessageQueue（消息队列）<br>定义：采用单链表的数据结构来存储消息列表<br>作用：用来存放通过Handler发过来的Message，按照先进先出执行</li>\n<li>Handler（处理者）<br>定义：Message的主要处理者<br>作用：负责发送Message到消息队列&amp;处理Looper分派过来的Message</li>\n<li>Looper（循环器）<br>定义：扮演Message Queue和Handler之间桥梁的角色<br>作用：<br>消息循环：循环取出Message Queue的Message<br>消息派发：将取出的Message交付给相应的Handler</li>\n</ul>\n<h4 id=\"自己画下图解\"><a href=\"#自己画下图解\" class=\"headerlink\" title=\"自己画下图解\"></a>自己画下图解</h4><p><img src=\"/img/img/questioninterview2018/fff72bb7eec021cd437e03e0f655152d.jfif\"></p>\n<h4 id=\"Handler发送消息有哪几种方式？\"><a href=\"#Handler发送消息有哪几种方式？\" class=\"headerlink\" title=\"Handler发送消息有哪几种方式？\"></a>Handler发送消息有哪几种方式？</h4><ul>\n<li>sendMessage(Message msg)</li>\n<li>post(Runnable r)</li>\n</ul>\n<h4 id=\"Handler处理消息有哪几种方式\"><a href=\"#Handler处理消息有哪几种方式\" class=\"headerlink\" title=\"Handler处理消息有哪几种方式\"></a>Handler处理消息有哪几种方式</h4><p>直接看源码<code>dispatchMessage()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dispatchMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. post()方法的处理方法</span></span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//2. sendMessage()方法的处理方法</span></span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//1. post()方法的最终处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleCallback</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">    message.callback.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2. sendMessage()方法的最终处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Message、Handler、MessageQueue、Looper的之间的关系？\"><a href=\"#Message、Handler、MessageQueue、Looper的之间的关系？\" class=\"headerlink\" title=\"Message、Handler、MessageQueue、Looper的之间的关系？\"></a>Message、Handler、MessageQueue、Looper的之间的关系？</h4><p>首先，是这个MessagQueue，MessageQueue是一个消息队列，它可以存储Handler发送过来的消息，其内部提供了进队和出队的方法来管理这个消息队列，其出队和进队的原理是采用单链表的数据结构进行插入和删除的，即enqueueMessage()方法和next()方法。这里提到的Message，其实就是一个Bean对象，里面的属性用来记录Message的各种信息。</p>\n<p>然后，是这个Looper，Looper是一个循环器，它可以循环的取出MessageQueue中的Message，其内部提供了Looper的初始化和循环出去Message的方法，即prepare()方法和loop()方法。在prepare()方法中，Looper会关联一个MessageQueue，而且将Looper存进一个ThreadLocal中，在loop()方法中，通过ThreadLocal取出Looper，使用MessageQueue的next()方法取出Message后，判断Message是否为空，如果是则Looper阻塞，如果不是，则通过dispatchMessage()方法分发该Message到Handler中，而Handler执行handlerMessage()方法，由于handlerMessage()方法是个空方法，这也是为什么需要在Handler中重写handlerMessage()方法的原因。这里要注意的是Looper只能在一个线程中只能存在一个。这里提到的ThreadLocal，其实就是一个对象，用来在不同线程中存放对应线程的Looper。</p>\n<p>最后，是这个Handler，Handler是Looper和MessageQueue的桥梁，Handler内部提供了发送Message的一系列方法，最终会通过MessageQueue的enqueueMessage()方法将Message存进MessageQueue中。我们平时可以直接在主线程中使用Handler，那是因为在应用程序启动时，在入口的main方法中已经默认为我们创建好了Looper。</p>\n<h4 id=\"为什么在子线程中创建Handler会抛异常？\"><a href=\"#为什么在子线程中创建Handler会抛异常？\" class=\"headerlink\" title=\"为什么在子线程中创建Handler会抛异常？\"></a>为什么在子线程中创建Handler会抛异常？</h4><p>Handler的工作是依赖于Looper的，而Looper（与消息队列）又是属于某一个线程（ThreadLocal是线程内部的数据存储类，通过它可以在指定线程中存储数据，其他线程则无法获取到），其他线程不能访问。因此Handler就是间接跟线程是绑定在一起了。因此要使用Handler必须要保证Handler所创建的线程中有Looper对象并且启动循环。因为子线程中默认是没有Looper的，所以会报错。<br>正确的使用方法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WorkThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">public</span> Handler <span class=\"title function_\">getHandler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> mHandler;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          mHandler.getLooper().quit();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">          <span class=\"comment\">//创建该线程对应的Looper,</span></span><br><span class=\"line\">          <span class=\"comment\">// 内部实现</span></span><br><span class=\"line\">          <span class=\"comment\">// 1。new Looper（）</span></span><br><span class=\"line\">          <span class=\"comment\">// 2。将1步中的lopper 放在ThreadLocal里，ThreadLocal是保存数据的，主要应用场景是：线程间数据互不影响的情况</span></span><br><span class=\"line\">          <span class=\"comment\">// 3。在1步中的Looper的构造函数中new MessageQueue();</span></span><br><span class=\"line\">          <span class=\"comment\">//其实就是创建了该线程对用的Looper，Looper里创建MessageQueue来实现消息机制</span></span><br><span class=\"line\">          <span class=\"comment\">//对消息机制不懂得同学可以查阅资料，网上很多也讲的很不错。</span></span><br><span class=\"line\">          Looper.prepare();</span><br><span class=\"line\">          mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>() &#123;</span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">                  Log.d(<span class=\"string\">&quot;WorkThread&quot;</span>, (Looper.getMainLooper() == Looper.myLooper()) + <span class=\"string\">&quot;,&quot;</span> + msg.what);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">          <span class=\"comment\">//开启消息的死循环处理即：dispatchMessage</span></span><br><span class=\"line\">          Looper.loop();</span><br><span class=\"line\">          <span class=\"comment\">//注意这3个的顺序不能颠倒</span></span><br><span class=\"line\">          Log.d(<span class=\"string\">&quot;WorkThread&quot;</span>, <span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HandlerThread\"><a href=\"#HandlerThread\" class=\"headerlink\" title=\"HandlerThread\"></a>HandlerThread</h3><ol>\n<li><p>HandlerThread作用<br>当系统有多个耗时任务需要执行时，每个任务都会开启一个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题，Google提供了HandlerThread，HandlerThread是在线程中创建一个Looper循环器，让Looper轮询消息队列，当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞。</p>\n</li>\n<li><p>HanlderThread的优缺点</p>\n</li>\n</ol>\n<ul>\n<li>HandlerThread本质上是一个线程类，它继承了Thread；</li>\n<li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li>\n<li>通过获取HandlerThread的looper对象传递给Handler对象，可以在<code>handleMessage()</code>方法中执行异步任务。</li>\n<li>创建HandlerThread后必须先调用<code>HandlerThread.start()</code>方法，Thread会先调用run方法，创建Looper对象。</li>\n<li>HandlerThread优点是异步不会堵塞，减少对性能的消耗</li>\n<li>HandlerThread缺点是不能同时继续进行多任务处理，需要等待进行处理，处理效率较低</li>\n<li>HandlerThread与线程池不同，HandlerThread是一个串行队列，背后只有一个线程。</li>\n</ul>\n<h3 id=\"IntentService\"><a href=\"#IntentService\" class=\"headerlink\" title=\"IntentService\"></a>IntentService</h3><ul>\n<li><p>它本质是一种特殊的Service,继承自Service并且本身就是一个抽象类</p>\n</li>\n<li><p>它可以用于在后台执行耗时的异步任务，当任务完成后会自动停止</p>\n</li>\n<li><p>它拥有较高的优先级，不易被系统杀死（继承自Service的缘故），因此比较适合执行一些高优先级的异步任务<br>它内部通过HandlerThread和Handler实现异步操作</p>\n</li>\n<li><p>创建IntentService时，只需实现onHandleIntent和构造方法，onHandleIntent为异步方法，可以执行耗时操作</p>\n</li>\n<li><p>即使我们多次启动IntentService，但IntentService的实例只有一个，这跟传统的Service是一样的，最终IntentService会去调用onHandleIntent执行异步任务。</p>\n</li>\n<li><p>当任务完成后，IntentService会自动停止，而不需要手动调用<code>stopSelf()</code>。另外，可以多次启动IntentService，每个耗时操作都会以工作队列的方式在<code>IntentService</code>中<code>onHandlerIntent()</code>回调方法中执行，并且每次只会执行一个工作线程。</p>\n</li>\n</ul>\n<h3 id=\"AsyncTask\"><a href=\"#AsyncTask\" class=\"headerlink\" title=\"AsyncTask\"></a>AsyncTask</h3><p>1、AsyncTask是什么</p>\n<p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并主线程中更新UI，通过AsyncTask可以更加方便执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的后台任务，对于特别耗时的任务来说，建议使用线程池。</p>\n<p>2、AsyncTask使用方法</p>\n<p>三个参数<br><code>Params</code>：表示后台任务执行时的参数类型，该参数会传给AysncTask的<code>doInBackground()</code>方法<br><code>Progress</code>：表示后台任务的执行进度的参数类型，该参数会作为<code>onProgressUpdate()</code>方法的参数<br><code>Result</code>：表示后台任务的返回结果的参数类型，该参数会作为<code>onPostExecute()</code>方法的参数<br>五个方法<br><code>onPreExecute()</code>：异步任务开启之前回调，在主线程中执行<br><code>doInBackground()</code>：执行异步任务，在线程池中执行<br><code>onProgressUpdate()</code>：当doInBackground中调用publishProgress时回调，在主线程中执行<br><code>onPostExecute()</code>：在异步任务执行之后回调，在主线程中执行<br><code>onCancelled()</code>：在异步任务被取消时回调</p>\n<p>3、AsyncTask引起的内存泄漏<br>原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放<br>解决：<br>AsyncTask内部持有外部Activity的弱引用<br>AsyncTask改为静态内部类<br>Activity的<code>onDestory()</code>中调用<code>AsyncTask.cancel()</code></p>\n<p>4.结果丢失<br>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用<code>onPostExecute()</code>再去更新界面将不再生效。</p>\n<p>5、AsyncTask并行or串行<br>AsyncTask在Android 2.3之前默认采用并行执行任务，AsyncTask在Android 2.3之后默认采用串行执行任务<br>如果需要在Android 2.3之后采用并行执行任务，可以调用AsyncTask的<code>executeOnExecutor()</code>;</p>\n<p>6.AsyncTask内部的线程池<br><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</code><br><code>sDefaultExecutor</code>是<code>SerialExecutor</code>的一个实例，而且它是个静态变量。也就是说，一个进程里面所有AsyncTask对象都共享同一个<code>SerialExecutor</code>对象。</p>\n<h2 id=\"一些面试心经\"><a href=\"#一些面试心经\" class=\"headerlink\" title=\"一些面试心经\"></a>一些面试心经</h2><p>一般情况下第一轮都是基础面试，需要扎实的基础</p>\n<p>最常用的Android 基础知识<br>Java 基础知识<br>了解一些 常用东西的原理，例如：handler， thread 等<br>项目中的技术点</p>\n<p>第二轮的时候需要了解更深层次的东西</p>\n<p>Android 事件分发机制原理<br>Android 绘图机制原理<br>WindowManager 的相关知识<br>进程间传输方式<br>Java 内存管理机制<br>一些常用的 list,map 原理，以及子类之间的差别</p>\n<p>能进入第三轮基本没什么问题，但是要注意以下问题</p>\n<p>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度<br>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</p>\n<p>我们的面试原则就是拿到合理薪资，得到 offer<br>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。<br>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</p>\n","categories":[{"name":"教程分享","path":"api/categories/教程分享.json"},{"name":"Android","path":"api/categories/Android.json"}],"tags":[{"name":"面试题","path":"api/tags/面试题.json"}]}