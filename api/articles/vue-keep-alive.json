{"title":"【vue】3.0 keep-alive实现动态缓存以及缓存销毁","slug":"vue-keep-alive","date":"2020-01-19T16:00:00.000Z","updated":"2022-10-19T14:40:00.272Z","comments":true,"path":"api/articles/vue-keep-alive.json","realPath":"/2020/vue-keep-alive/index/","excerpt":null,"covers":["/img/2020/01/vue/15794851288763.png"],"cover":"/img/2020/01/vue/15794851288763.png","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li><code>keep-alive</code><ul>\n<li><code>keep-alive</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和<code>transition</code>相似，<code>keep-alive</code>是一个抽象组件：它自身不会渲染一个<code>DOM</code>元素，也不会出现在父组件链中。</li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#keep-alive\">keep-alive: vue文档</a></li>\n</ul>\n</li>\n<li>组件内的守卫-<code>beforeRouteLeave</code><ul>\n<li>导航离开该组件的对应路由时调用</li>\n<li>可以访问组件实例<code>this</code></li>\n<li><a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB\">组件内的守卫:<code>vue-router</code>文档</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>后台管理系统中，左侧为功能菜单栏，点击菜单列表，右侧显示该菜单的功能页面，本来是一个非常简单的后台管理系统布局，现在增加了tabs菜单按钮；<br>点击左侧菜单栏时，右侧页面头部header显示当前的页面标题，形成一个tabs列表，点击可切换页面内容和关闭tab；<br>现在的需求：<br>  打开之后需要保留的页面在tab不关闭的情况下，保留上一次的状态，而在tab关闭之后，则下次打开会重新请求数据，不会保留上次状态。</p>\n<p>  <img src=\"/img/2020/01/vue/15794851288763.png\"></p>\n<h2 id=\"初步解决\"><a href=\"#初步解决\" class=\"headerlink\" title=\"初步解决\"></a>初步解决</h2><p>第一想到的就是利用vue的功能组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">    &lt;router-view /&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n<p>但是这种情况只能实现缓存所有页面，就是不能根据需求实现动态缓存，所有状态都存着呢，愁啊。</p>\n<h2 id=\"解决方案构想：\"><a href=\"#解决方案构想：\" class=\"headerlink\" title=\"解决方案构想：\"></a>解决方案构想：</h2><blockquote>\n<p>路由元信息内添加特定字段如：<code>keepAlive</code></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/foo&#x27;,</span><br><span class=\"line\">      component: Foo,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#x27;bar&#x27;,</span><br><span class=\"line\">          component: Bar,</span><br><span class=\"line\">          // a meta field</span><br><span class=\"line\">          meta: &#123;</span><br><span class=\"line\">            keepAlive: true</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>父组件内根据路由中的<code>keepAlive</code>字段动态使用<code>keep-alive</code>标签</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Vue</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    get keepAlive () &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取当前路由的元信息中的keepAlive字段</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">$route</span>.<span class=\"property\">meta</span>.<span class=\"property\">keepAlive</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">            !this.keepAlive &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">router-view</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">              this.keepAlive &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">router-view</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Home</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由于现在组件的<code>keep-alive</code>是动态根据路由元信息中的<code>keepAlive</code>字段进行动态使用的，所以只要动态改变对应路由元信息的<code>keepAlive</code>字段就可以实现动态缓存。</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>利用<code>beforeRouteLeave</code>改变<code>from</code>的<code>keepAlive</code>实现（原思路，网络解决方案之一，有bug）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteLeave (to: any, from: any, next: any) &#123;</span><br><span class=\"line\">  // 导航离开该组件的对应路由时调用</span><br><span class=\"line\">  // 判断是否是去往页面 C</span><br><span class=\"line\">  if (to.name !== &#x27;C&#x27;) &#123;</span><br><span class=\"line\">    // 不是去 C 页面，不缓存</span><br><span class=\"line\">    from.meta.keepAlive = false</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 是去 C 页面，缓存</span><br><span class=\"line\">    from.meta.keepAlive = true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bug：首次去C页面，再返回B页面，B并没有缓存，第二次再进入C页面，B页面缓存，且进A页面并不能清除B页面的缓存</p>\n</blockquote>\n<h3 id=\"方案二（网络方案）\"><a href=\"#方案二（网络方案）\" class=\"headerlink\" title=\"方案二（网络方案）\"></a>方案二（网络方案）</h3><p><code>$destroy()</code>销毁</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteLeave (to: any, from: any, next: any) &#123;</span><br><span class=\"line\">  // 导航离开该组件的对应路由时调用</span><br><span class=\"line\">  // 判断是否是去往页面 C</span><br><span class=\"line\">  if (to.name !== &#x27;C&#x27;) &#123;</span><br><span class=\"line\">    // 不是去 C 页面，不缓存</span><br><span class=\"line\">    this.$destroy()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bug：销毁之后永远不会被缓存</p>\n</blockquote>\n<h3 id=\"方案三（网络方案）\"><a href=\"#方案三（网络方案）\" class=\"headerlink\" title=\"方案三（网络方案）\"></a>方案三（网络方案）</h3><ul>\n<li>根据源码看来缓存的组件都会设置一个cache属性，可以通过代码强行移除掉。缺点就是没有彻底销毁依旧占内存</li>\n<li><a href=\"https://segmentfault.com/a/1190000015845117\">具体实现参考</a></li>\n</ul>\n<h3 id=\"方案四（最优解）\"><a href=\"#方案四（最优解）\" class=\"headerlink\" title=\"方案四（最优解）\"></a>方案四（最优解）</h3><p>利用<code>keep-alive</code>的<code>include</code>属性，利用<code>vuex</code>动态控制<code>include</code>达到动态管理缓存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive :include=&quot;keepAliveList&quot;&gt;</span><br><span class=\"line\">    &lt;router-view :key=&quot;$route.fullPath&quot;/&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n\n<p>利用计算属性和vuex获取缓存列表</p>\n<blockquote>\n<p>这里可以使用你自己的规则，原因请继续往下看</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--vuex--&gt;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">    keepAliveList:&#x27;&#x27;,//保存缓存的列表</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    setKeepAliveLists(state,arrListString)&#123;</span><br><span class=\"line\">        state.keepAliveList = arrListString;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--视图组件中--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    keepAliveList()&#123;</span><br><span class=\"line\">        // 获取缓存的路由列表</span><br><span class=\"line\">        return this.$store.state.keepAliveList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成缓存列表，列表的值为各组件中name的值集合拼接的字符串</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&#x27;setKeepAliveLists&#x27;,routerComponentNameList.join())</span><br></pre></td></tr></table></figure>\n\n<p>点击左侧菜单栏时，更新缓存列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 点击左侧菜单的事件函数 --&gt;</span><br><span class=\"line\">handleSelect(name) &#123;</span><br><span class=\"line\">    if(this.routerNameMap.has(name))&#123;//如果当前点击的路由已经在缓存列表中，则先清除缓存列表，再添加；</span><br><span class=\"line\">        this.resetKeepAive(name,this.keepAliveList);//删除缓存路由</span><br><span class=\"line\">        this.tabChangeRoute(name);//切换路由</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.routerNameMap.add(name)</span><br><span class=\"line\">        this.tabChangeRoute(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 更新要缓存的路由列表</span><br><span class=\"line\">resetKeepAive(name,cacheList) &#123;</span><br><span class=\"line\">    const conf = this.keepAliveList;</span><br><span class=\"line\">    let arr = cacheList.split(&#x27;,&#x27;);</span><br><span class=\"line\">    if (name &amp;&amp; typeof name === &#x27;string&#x27;) &#123;</span><br><span class=\"line\">        let i = arr.indexOf(name);</span><br><span class=\"line\">        if (i &gt; -1) &#123;</span><br><span class=\"line\">            arr.splice(i, 1);</span><br><span class=\"line\">            this.$store.commit(&#x27;setKeepAliveLists&#x27;,arr.join());</span><br><span class=\"line\">            this.$nextTick(() =&gt; &#123;//添加缓存路由</span><br><span class=\"line\">                this.$store.commit(&#x27;setKeepAliveLists&#x27;,conf);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点击右侧tabs关闭标签删除缓存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">removeTab(name)&#123;</span><br><span class=\"line\">    // 点击tab上的关闭按钮，清除当前路由的缓存</span><br><span class=\"line\">    this.routerNameMap.delete(name);</span><br><span class=\"line\">    this.resetKeepAive(name,this.keepAliveList);//删除缓存路由</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面为主要代码，监听当前路由是否被移除缓存，如果移除缓存则需要销毁该组件，否则内容中的缓存组件会越来越来，影响使用性能；<br>创建一个<code>mixin.js</code>文件，然后引入到需要被动态缓存的路由组件中即可；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 路由缓存管理</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    computed: &#123;</span><br><span class=\"line\">        keepAliveConf()&#123;</span><br><span class=\"line\">            return this.$store.state.keepAliveList;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    watch:&#123;</span><br><span class=\"line\">        keepAliveConf(e)&#123;</span><br><span class=\"line\">            // 监听缓存列表的变化，如果缓存列表中没有当前的路由或组件则在缓存中销毁该实例</span><br><span class=\"line\">            let name = this.$options.name;</span><br><span class=\"line\">            if(!e.split(&#x27;,&#x27;).includes(name)) &#123;</span><br><span class=\"line\">                this.$destroy()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于在<code>$store</code>中保存和删除的过程，各人有各人的方法，我这边只是一种参考，不过多讨论。</p>\n<p>不过关于<code>keep-alive</code>的<code>include</code>原理，这里简单介绍下，官方(截止到2020年1月)给的方案是正则白名单，也就是说在<code>include</code>中包含的字段，只要路由的<code>name</code>满足正则要求，则会缓存，<code>exclude</code>的规则同样满足，所以这就造成匿名路由的童鞋无法使用<code>keep-alive</code>。不过也有解决方案，使用<code>beforeRouteLeave</code>监听，自己做缓存，不过目前我还没试过，后续我试完会新写的。</p>\n<p>以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作具有一定的参考学习价值，如果有疑问大家可以留言交流，谢谢大家对我的支持。😘✔</p>\n","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li><code>keep-alive</code><ul>\n<li><code>keep-alive</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和<code>transition</code>相似，<code>keep-alive</code>是一个抽象组件：它自身不会渲染一个<code>DOM</code>元素，也不会出现在父组件链中。</li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#keep-alive\">keep-alive: vue文档</a></li>\n</ul>\n</li>\n<li>组件内的守卫-<code>beforeRouteLeave</code><ul>\n<li>导航离开该组件的对应路由时调用</li>\n<li>可以访问组件实例<code>this</code></li>\n<li><a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB\">组件内的守卫:<code>vue-router</code>文档</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>后台管理系统中，左侧为功能菜单栏，点击菜单列表，右侧显示该菜单的功能页面，本来是一个非常简单的后台管理系统布局，现在增加了tabs菜单按钮；<br>点击左侧菜单栏时，右侧页面头部header显示当前的页面标题，形成一个tabs列表，点击可切换页面内容和关闭tab；<br>现在的需求：<br>  打开之后需要保留的页面在tab不关闭的情况下，保留上一次的状态，而在tab关闭之后，则下次打开会重新请求数据，不会保留上次状态。</p>\n<p>  <img src=\"/img/2020/01/vue/15794851288763.png\"></p>\n<h2 id=\"初步解决\"><a href=\"#初步解决\" class=\"headerlink\" title=\"初步解决\"></a>初步解决</h2><p>第一想到的就是利用vue的功能组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">    &lt;router-view /&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n<p>但是这种情况只能实现缓存所有页面，就是不能根据需求实现动态缓存，所有状态都存着呢，愁啊。</p>\n<h2 id=\"解决方案构想：\"><a href=\"#解决方案构想：\" class=\"headerlink\" title=\"解决方案构想：\"></a>解决方案构想：</h2><blockquote>\n<p>路由元信息内添加特定字段如：<code>keepAlive</code></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/foo&#x27;,</span><br><span class=\"line\">      component: Foo,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#x27;bar&#x27;,</span><br><span class=\"line\">          component: Bar,</span><br><span class=\"line\">          // a meta field</span><br><span class=\"line\">          meta: &#123;</span><br><span class=\"line\">            keepAlive: true</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>父组件内根据路由中的<code>keepAlive</code>字段动态使用<code>keep-alive</code>标签</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Vue</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    get keepAlive () &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取当前路由的元信息中的keepAlive字段</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">$route</span>.<span class=\"property\">meta</span>.<span class=\"property\">keepAlive</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">            !this.keepAlive &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">router-view</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">              this.keepAlive &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">router-view</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Home</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由于现在组件的<code>keep-alive</code>是动态根据路由元信息中的<code>keepAlive</code>字段进行动态使用的，所以只要动态改变对应路由元信息的<code>keepAlive</code>字段就可以实现动态缓存。</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>利用<code>beforeRouteLeave</code>改变<code>from</code>的<code>keepAlive</code>实现（原思路，网络解决方案之一，有bug）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteLeave (to: any, from: any, next: any) &#123;</span><br><span class=\"line\">  // 导航离开该组件的对应路由时调用</span><br><span class=\"line\">  // 判断是否是去往页面 C</span><br><span class=\"line\">  if (to.name !== &#x27;C&#x27;) &#123;</span><br><span class=\"line\">    // 不是去 C 页面，不缓存</span><br><span class=\"line\">    from.meta.keepAlive = false</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 是去 C 页面，缓存</span><br><span class=\"line\">    from.meta.keepAlive = true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bug：首次去C页面，再返回B页面，B并没有缓存，第二次再进入C页面，B页面缓存，且进A页面并不能清除B页面的缓存</p>\n</blockquote>\n<h3 id=\"方案二（网络方案）\"><a href=\"#方案二（网络方案）\" class=\"headerlink\" title=\"方案二（网络方案）\"></a>方案二（网络方案）</h3><p><code>$destroy()</code>销毁</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteLeave (to: any, from: any, next: any) &#123;</span><br><span class=\"line\">  // 导航离开该组件的对应路由时调用</span><br><span class=\"line\">  // 判断是否是去往页面 C</span><br><span class=\"line\">  if (to.name !== &#x27;C&#x27;) &#123;</span><br><span class=\"line\">    // 不是去 C 页面，不缓存</span><br><span class=\"line\">    this.$destroy()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bug：销毁之后永远不会被缓存</p>\n</blockquote>\n<h3 id=\"方案三（网络方案）\"><a href=\"#方案三（网络方案）\" class=\"headerlink\" title=\"方案三（网络方案）\"></a>方案三（网络方案）</h3><ul>\n<li>根据源码看来缓存的组件都会设置一个cache属性，可以通过代码强行移除掉。缺点就是没有彻底销毁依旧占内存</li>\n<li><a href=\"https://segmentfault.com/a/1190000015845117\">具体实现参考</a></li>\n</ul>\n<h3 id=\"方案四（最优解）\"><a href=\"#方案四（最优解）\" class=\"headerlink\" title=\"方案四（最优解）\"></a>方案四（最优解）</h3><p>利用<code>keep-alive</code>的<code>include</code>属性，利用<code>vuex</code>动态控制<code>include</code>达到动态管理缓存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive :include=&quot;keepAliveList&quot;&gt;</span><br><span class=\"line\">    &lt;router-view :key=&quot;$route.fullPath&quot;/&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n\n<p>利用计算属性和vuex获取缓存列表</p>\n<blockquote>\n<p>这里可以使用你自己的规则，原因请继续往下看</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--vuex--&gt;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">    keepAliveList:&#x27;&#x27;,//保存缓存的列表</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    setKeepAliveLists(state,arrListString)&#123;</span><br><span class=\"line\">        state.keepAliveList = arrListString;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--视图组件中--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    keepAliveList()&#123;</span><br><span class=\"line\">        // 获取缓存的路由列表</span><br><span class=\"line\">        return this.$store.state.keepAliveList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成缓存列表，列表的值为各组件中name的值集合拼接的字符串</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&#x27;setKeepAliveLists&#x27;,routerComponentNameList.join())</span><br></pre></td></tr></table></figure>\n\n<p>点击左侧菜单栏时，更新缓存列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 点击左侧菜单的事件函数 --&gt;</span><br><span class=\"line\">handleSelect(name) &#123;</span><br><span class=\"line\">    if(this.routerNameMap.has(name))&#123;//如果当前点击的路由已经在缓存列表中，则先清除缓存列表，再添加；</span><br><span class=\"line\">        this.resetKeepAive(name,this.keepAliveList);//删除缓存路由</span><br><span class=\"line\">        this.tabChangeRoute(name);//切换路由</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.routerNameMap.add(name)</span><br><span class=\"line\">        this.tabChangeRoute(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 更新要缓存的路由列表</span><br><span class=\"line\">resetKeepAive(name,cacheList) &#123;</span><br><span class=\"line\">    const conf = this.keepAliveList;</span><br><span class=\"line\">    let arr = cacheList.split(&#x27;,&#x27;);</span><br><span class=\"line\">    if (name &amp;&amp; typeof name === &#x27;string&#x27;) &#123;</span><br><span class=\"line\">        let i = arr.indexOf(name);</span><br><span class=\"line\">        if (i &gt; -1) &#123;</span><br><span class=\"line\">            arr.splice(i, 1);</span><br><span class=\"line\">            this.$store.commit(&#x27;setKeepAliveLists&#x27;,arr.join());</span><br><span class=\"line\">            this.$nextTick(() =&gt; &#123;//添加缓存路由</span><br><span class=\"line\">                this.$store.commit(&#x27;setKeepAliveLists&#x27;,conf);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点击右侧tabs关闭标签删除缓存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">removeTab(name)&#123;</span><br><span class=\"line\">    // 点击tab上的关闭按钮，清除当前路由的缓存</span><br><span class=\"line\">    this.routerNameMap.delete(name);</span><br><span class=\"line\">    this.resetKeepAive(name,this.keepAliveList);//删除缓存路由</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面为主要代码，监听当前路由是否被移除缓存，如果移除缓存则需要销毁该组件，否则内容中的缓存组件会越来越来，影响使用性能；<br>创建一个<code>mixin.js</code>文件，然后引入到需要被动态缓存的路由组件中即可；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 路由缓存管理</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    computed: &#123;</span><br><span class=\"line\">        keepAliveConf()&#123;</span><br><span class=\"line\">            return this.$store.state.keepAliveList;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    watch:&#123;</span><br><span class=\"line\">        keepAliveConf(e)&#123;</span><br><span class=\"line\">            // 监听缓存列表的变化，如果缓存列表中没有当前的路由或组件则在缓存中销毁该实例</span><br><span class=\"line\">            let name = this.$options.name;</span><br><span class=\"line\">            if(!e.split(&#x27;,&#x27;).includes(name)) &#123;</span><br><span class=\"line\">                this.$destroy()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于在<code>$store</code>中保存和删除的过程，各人有各人的方法，我这边只是一种参考，不过多讨论。</p>\n<p>不过关于<code>keep-alive</code>的<code>include</code>原理，这里简单介绍下，官方(截止到2020年1月)给的方案是正则白名单，也就是说在<code>include</code>中包含的字段，只要路由的<code>name</code>满足正则要求，则会缓存，<code>exclude</code>的规则同样满足，所以这就造成匿名路由的童鞋无法使用<code>keep-alive</code>。不过也有解决方案，使用<code>beforeRouteLeave</code>监听，自己做缓存，不过目前我还没试过，后续我试完会新写的。</p>\n<p>以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作具有一定的参考学习价值，如果有疑问大家可以留言交流，谢谢大家对我的支持。😘✔</p>\n","categories":[{"name":"教程分享","path":"api/categories/教程分享.json"},{"name":"Vue","path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","path":"api/tags/Vue.json"}]}