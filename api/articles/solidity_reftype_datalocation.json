{"title":"智能合约语言 Solidity 教程系列4 - 数据存储位置分析","slug":"solidity_reftype_datalocation","date":"2018-03-11T16:00:00.000Z","updated":"2022-10-19T14:40:00.269Z","comments":true,"path":"api/articles/solidity_reftype_datalocation.json","realPath":"/2018/solidity_reftype_datalocation/index/","excerpt":null,"covers":null,"cover":null,"content":"<p>Solidity教程系列第4篇 - Solidity数据位置分析。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"数据位置-Data-location\"><a href=\"#数据位置-Data-location\" class=\"headerlink\" title=\"数据位置(Data location)\"></a>数据位置(Data location)</h2><p>在系列第一篇，我们提到 Solidity 类型分为两类：<br>值类型(Value Type) 及 引用类型(Reference Types)，<br>前面我们已经介绍完了值类型，接下来会介绍引用类型。</p>\n<p>引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存储在区块链中）<br>所有的复杂类型如数组(arrays)和结构体(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。</p>\n<p>根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。</p>\n<p>函数参数（包含返回的参数）默认是memory。<br>局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。</p>\n<blockquote>\n<p>局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。<br>状态变量：合约内声明的公有变量</p>\n</blockquote>\n<p>还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。</p>\n<p>数据位置指定非常重要，因为他们影响着赋值行为。<br>在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。<br>而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。<br>另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。</p>\n<blockquote>\n<ol>\n<li>注意：不能将memory赋值给局部变量。</li>\n<li>对于值类型，总是会进行拷贝。</li>\n</ol>\n</blockquote>\n<p>下面看一段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    uint[] x; //  x的存储位置是storage</span><br><span class=\"line\"></span><br><span class=\"line\">    // memoryArray的存储位置是 memory</span><br><span class=\"line\">    function f(uint[] memoryArray) public &#123;</span><br><span class=\"line\">        x = memoryArray;    // 从 memory 复制到 storage</span><br><span class=\"line\">        var y = x;          // storage 引用传递局部变量y（y 是一个 storage 引用）</span><br><span class=\"line\">        y[7];               // 返回第8个元素</span><br><span class=\"line\">        y.length = 2;       // x同样会被修改</span><br><span class=\"line\">        delete x;           // y同样会被修改</span><br><span class=\"line\"></span><br><span class=\"line\">        // 错误， 不能将memory赋值给局部变量</span><br><span class=\"line\">        // y = memoryArray;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 错误，不能通过引用销毁storage</span><br><span class=\"line\">        // delete y;</span><br><span class=\"line\"></span><br><span class=\"line\">        g(x);               // 引用传递， g可以改变x的内容</span><br><span class=\"line\">        h(x);               // 拷贝到memory， h无法改变x的内容</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class=\"line\">    function h(uint[] memoryArray) public &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"强制的数据位置-Forced-data-location\"><a href=\"#强制的数据位置-Forced-data-location\" class=\"headerlink\" title=\"强制的数据位置(Forced data location)\"></a>强制的数据位置(Forced data location)</h4><ul>\n<li>外部函数(External function)的参数(不包括返回参数)强制为：calldata</li>\n<li>状态变量(State variables)强制为: storage</li>\n</ul>\n<h4 id=\"默认数据位置（Default-data-location）\"><a href=\"#默认数据位置（Default-data-location）\" class=\"headerlink\" title=\"默认数据位置（Default data location）\"></a>默认数据位置（Default data location）</h4><ul>\n<li>函数参数及返回参数：memory</li>\n<li>复杂类型的局部变量：storage</li>\n</ul>\n<h2 id=\"深入分析\"><a href=\"#深入分析\" class=\"headerlink\" title=\"深入分析\"></a>深入分析</h2><p>storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。</p>\n<blockquote>\n<p>Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。</p>\n</blockquote>\n<p>memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。</p>\n<blockquote>\n<p>storage 在区块链中是用key&#x2F;value的形式存储，而memory则表现为字节数组</p>\n</blockquote>\n<h3 id=\"关于栈\"><a href=\"#关于栈\" class=\"headerlink\" title=\"关于栈\"></a>关于栈</h3><p>EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。<br>值类型的局部变量是存储在栈上。</p>\n<h3 id=\"不同存储的消耗（gas消耗）\"><a href=\"#不同存储的消耗（gas消耗）\" class=\"headerlink\" title=\"不同存储的消耗（gas消耗）\"></a>不同存储的消耗（gas消耗）</h3><ul>\n<li>storage 会永久保存合约状态变量，开销最大</li>\n<li>memory 仅保存临时变量，函数调用之后释放，开销很小</li>\n<li>stack 保存很小的局部变量，几乎免费使用，但有数量限制。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html#data-location\">Solidity官方文档-类型</a></p>\n","more":"<p>Solidity教程系列第4篇 - Solidity数据位置分析。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"数据位置-Data-location\"><a href=\"#数据位置-Data-location\" class=\"headerlink\" title=\"数据位置(Data location)\"></a>数据位置(Data location)</h2><p>在系列第一篇，我们提到 Solidity 类型分为两类：<br>值类型(Value Type) 及 引用类型(Reference Types)，<br>前面我们已经介绍完了值类型，接下来会介绍引用类型。</p>\n<p>引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存储在区块链中）<br>所有的复杂类型如数组(arrays)和结构体(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。</p>\n<p>根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。</p>\n<p>函数参数（包含返回的参数）默认是memory。<br>局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。</p>\n<blockquote>\n<p>局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。<br>状态变量：合约内声明的公有变量</p>\n</blockquote>\n<p>还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。</p>\n<p>数据位置指定非常重要，因为他们影响着赋值行为。<br>在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。<br>而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。<br>另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。</p>\n<blockquote>\n<ol>\n<li>注意：不能将memory赋值给局部变量。</li>\n<li>对于值类型，总是会进行拷贝。</li>\n</ol>\n</blockquote>\n<p>下面看一段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract C &#123;</span><br><span class=\"line\">    uint[] x; //  x的存储位置是storage</span><br><span class=\"line\"></span><br><span class=\"line\">    // memoryArray的存储位置是 memory</span><br><span class=\"line\">    function f(uint[] memoryArray) public &#123;</span><br><span class=\"line\">        x = memoryArray;    // 从 memory 复制到 storage</span><br><span class=\"line\">        var y = x;          // storage 引用传递局部变量y（y 是一个 storage 引用）</span><br><span class=\"line\">        y[7];               // 返回第8个元素</span><br><span class=\"line\">        y.length = 2;       // x同样会被修改</span><br><span class=\"line\">        delete x;           // y同样会被修改</span><br><span class=\"line\"></span><br><span class=\"line\">        // 错误， 不能将memory赋值给局部变量</span><br><span class=\"line\">        // y = memoryArray;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 错误，不能通过引用销毁storage</span><br><span class=\"line\">        // delete y;</span><br><span class=\"line\"></span><br><span class=\"line\">        g(x);               // 引用传递， g可以改变x的内容</span><br><span class=\"line\">        h(x);               // 拷贝到memory， h无法改变x的内容</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class=\"line\">    function h(uint[] memoryArray) public &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"强制的数据位置-Forced-data-location\"><a href=\"#强制的数据位置-Forced-data-location\" class=\"headerlink\" title=\"强制的数据位置(Forced data location)\"></a>强制的数据位置(Forced data location)</h4><ul>\n<li>外部函数(External function)的参数(不包括返回参数)强制为：calldata</li>\n<li>状态变量(State variables)强制为: storage</li>\n</ul>\n<h4 id=\"默认数据位置（Default-data-location）\"><a href=\"#默认数据位置（Default-data-location）\" class=\"headerlink\" title=\"默认数据位置（Default data location）\"></a>默认数据位置（Default data location）</h4><ul>\n<li>函数参数及返回参数：memory</li>\n<li>复杂类型的局部变量：storage</li>\n</ul>\n<h2 id=\"深入分析\"><a href=\"#深入分析\" class=\"headerlink\" title=\"深入分析\"></a>深入分析</h2><p>storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。</p>\n<blockquote>\n<p>Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。</p>\n</blockquote>\n<p>memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。</p>\n<blockquote>\n<p>storage 在区块链中是用key&#x2F;value的形式存储，而memory则表现为字节数组</p>\n</blockquote>\n<h3 id=\"关于栈\"><a href=\"#关于栈\" class=\"headerlink\" title=\"关于栈\"></a>关于栈</h3><p>EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。<br>值类型的局部变量是存储在栈上。</p>\n<h3 id=\"不同存储的消耗（gas消耗）\"><a href=\"#不同存储的消耗（gas消耗）\" class=\"headerlink\" title=\"不同存储的消耗（gas消耗）\"></a>不同存储的消耗（gas消耗）</h3><ul>\n<li>storage 会永久保存合约状态变量，开销最大</li>\n<li>memory 仅保存临时变量，函数调用之后释放，开销很小</li>\n<li>stack 保存很小的局部变量，几乎免费使用，但有数量限制。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html#data-location\">Solidity官方文档-类型</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}