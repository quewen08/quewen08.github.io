{"title":"容器管理","slug":"docker-container","date":"2022-07-19T13:29:39.000Z","updated":"2022-10-20T13:28:49.301Z","comments":true,"path":"api/articles/docker-container.json","realPath":"/2022/docker-container/index/","excerpt":null,"covers":["/img/2022/docker-container/979767-20220613230044356-1739155940.png","/img/2022/docker-container/979767-20220613230101520-12884147.png","/img/2022/docker-container/979767-20220613230115647-335897184.png","/img/2022/docker-container/979767-20220613230139284-2045625911.png","/img/2022/docker-container/979767-20220613230148765-1700841146.png","/img/2022/docker-container/979767-20220613230204245-595295977.png","/img/2022/docker-container/979767-20220613230217469-498760333.png","/img/2022/docker-container/979767-20220613230241715-1635978379.png","/img/2022/docker-container/979767-20220613230301553-222894916.png","/img/2022/docker-container/979767-20220613230318144-1256119776.png","/img/2022/docker-container/979767-20220613230341164-1246990897.png","/img/2022/docker-container/979767-20220613230358617-1596296745.png","/img/2022/docker-container/979767-20220613230414251-864497271.png","/img/2022/docker-container/979767-20220613230425653-1546012181.png","/img/2022/docker-container/979767-20220613230443140-850543444.png","/img/2022/docker-container/979767-20220613230456764-365638708.png","/img/2022/docker-container/979767-20220613230514143-33194940.png","/img/2022/docker-container/979767-20220613230526915-1148740640.png","/img/2022/docker-container/979767-20220613230542052-1112346775.png","/img/2022/docker-container/979767-20220613230553943-1837768949.png","/img/2022/docker-container/979767-20220613230607064-1784552793.png","/img/2022/docker-container/979767-20220613230619331-869669860.png","/img/2022/docker-container/979767-20220613230641212-907588129.png","/img/2022/docker-container/979767-20220613230700355-227583119.png"],"cover":"/img/2022/docker-container/979767-20220613230044356-1739155940.png","content":"<h4 id=\"查看容器-ps\"><a href=\"#查看容器-ps\" class=\"headerlink\" title=\"查看容器(ps)\"></a>查看容器(ps)</h4><p>在运行容器之前，我们需要知道如何查看运行中的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Management Commands（推荐）</span></span><br><span class=\"line\">docker container ps</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">docker container <span class=\"built_in\">ls</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Commands</span></span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n\n<p>使用此方法只能看到运行中的容器，对于以及停止的容器，还需要使用<code>-a</code>参数，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container ps -a</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"容器运行-run-无参数\"><a href=\"#容器运行-run-无参数\" class=\"headerlink\" title=\"容器运行(run, 无参数)\"></a>容器运行(run, 无参数)</h4><p>前面有说过，容器是镜像的实例。学习 docker 最终目的就是就是运行它。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>\n\n<p>运行第一个测试容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Management Commands（推荐）</span></span><br><span class=\"line\">docker container run hello-world</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Commands</span></span><br><span class=\"line\">docker run hello-world</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230044356-1739155940.png\"></p>\n<p>hello-world 容器是一个测试容器，在输出一些文字之后就会退出，通过这个过程，我们可以发现：</p>\n<ol>\n<li>对于运行容器，如果镜像不存在，则会去 registry 中自动下载。</li>\n<li>使用 ps 查看容器的时候，如果不使用 -a 参数是看不到状态属于 Exited 的容器的。</li>\n<li>使用 ps 可以简单的看到容器的 ID，使用的镜像，执行的命令，创建时间，运行状态，端口，容器的名字等信息。</li>\n</ol>\n<h4 id=\"容器运行（run-d，守护态）\"><a href=\"#容器运行（run-d，守护态）\" class=\"headerlink\" title=\"容器运行（run -d，守护态）\"></a>容器运行（run -d，守护态）</h4><p>在运行容器时，需要确定这个容器是运行在前台模式还是后台模式。</p>\n<p><code>-d，--detach</code>，守护态运行。能够将容器运行在后台模式。这样所有的 IO 都只能通过网络资源或存储卷来进行交互。容器不再监听执行 docker run 这个命令行的窗口。有点类似于 Linux 启动程序时候的<code>nohup</code>或者<code> &amp;</code>组合。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d hello-world</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230101520-12884147.png\"></p>\n<p>可以发现，hello-world 容器加了 -d 参数后不在输出它的信息，只是返回了一长串字符，其实就是完整的 Container ID，用法类似 Image ID。</p>\n<p>同时由于 hello-world 容器本身的特性，程序在后台执行完成之后就直接退出了，容器也跟着退出了。</p>\n<p>再次运行以 nginx 容器为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run nginx</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230115647-335897184.png\"></p>\n<p>可以发现以下信息：</p>\n<ol>\n<li>由于没有跟 TAG，默认会以 latest 版本执行。在 docker 中，如果是运行 latest 版本，docker 都会去仓库试着拉取，而不是直接使用本地的镜像，因为本地的 latest 不一定是真正的 latest。</li>\n<li>容器在运行之后会以前台模式运行，所有它 hung 在了命令行。</li>\n<li>此时如果我们新开一个窗口来查看，可以发现容器处于 Up 状态，如下图所示：</li>\n</ol>\n<p><img src=\"/img/2022/docker-container/979767-20220613230139284-2045625911.png\"></p>\n<ol start=\"4\">\n<li>如果我们去 docker run 的窗口使用 Ctrl + c 中断，然后再次查看容器运行状态，可以发现容器已经退出，这就是前台运行的问题，如图所示：</li>\n</ol>\n<p><img src=\"/img/2022/docker-container/979767-20220613230148765-1700841146.png\"></p>\n<p>如果使用后台运行模式运行该容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d nginx</span><br></pre></td></tr></table></figure>\n\n<p>运行效果如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230204245-595295977.png\"></p>\n<p>容器被放在了后台运行，不会 hung 在命令行。当然所有的输出信息也不能直接看到了。</p>\n<h4 id=\"容器运行（run-it，交互式运行）\"><a href=\"#容器运行（run-it，交互式运行）\" class=\"headerlink\" title=\"容器运行（run -it，交互式运行）\"></a>容器运行（run -it，交互式运行）</h4><p>在使用 -d 参数之后，容器就不会 hung 在命令行窗口，而是以后台方式运行。但是这同时也有一个问题，某些时候我们是需要进入容器查看相关启动等信息的。此时就需要另外的参数配合使用：</p>\n<ul>\n<li><code>-i，--interactive</code>：打开一个交互式界面。</li>\n<li><code>-t，--tty</code>：打开一个 TTY 终端。<br>将这个两个参数结合就是打开一个交互式的 TTY 终端。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -it nginx /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230217469-498760333.png\"></p>\n<p>通过该方法在创建容器的时候指定运行命令，然后以 bash 进入容器内部的命令行。可以发现：</p>\n<ol>\n<li>容器内部就是 linux 的目录结构，但是是一个很简化的 linux，很多基础命令都没有。</li>\n<li>当退出容器命令行，容器也跟着退出。原因是我们重写容器内部的命令为 bash 之后，nginx 就没有启动了，当退出 bash 之后，容器内部就没有进程了，所有容器就退出了。</li>\n<li>这种方式用的比较少，一般都是容器运行之后，使用专门的命令进入容器。</li>\n</ol>\n<h4 id=\"容器运行（run-–name，容器命名）\"><a href=\"#容器运行（run-–name，容器命名）\" class=\"headerlink\" title=\"容器运行（run –name，容器命名）\"></a>容器运行（run –name，容器命名）</h4><p>在创建容器的时候，如果不给容器指定一个名字，容器会生成一个随机的名字，一般都是以 xxx_xxx 的格式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --name demo01 nginx</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230241715-1635978379.png\"></p>\n<p>针对容器的名字，我们可以根据自己的需求指定相关的命名规范，以此来实现统一管理的目的。</p>\n<h4 id=\"容器运行（run-–rm，退出删除）\"><a href=\"#容器运行（run-–rm，退出删除）\" class=\"headerlink\" title=\"容器运行（run –rm，退出删除）\"></a>容器运行（run –rm，退出删除）</h4><p>某些容器可能是一次性容器，在运行之后，容器退出。同时不保留在 ps 中，此时就需要使用到 <code>--rm</code> 参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> --name rm_test hello-world</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230301553-222894916.png\"></p>\n<h4 id=\"容器运行（run-–restart，重启规则）\"><a href=\"#容器运行（run-–restart，重启规则）\" class=\"headerlink\" title=\"容器运行（run –restart，重启规则）\"></a>容器运行（run –restart，重启规则）</h4><p>为了保障在以外的停止之后能够自动恢复，就需要对它配置相关<code>--restart</code>规则：</p>\n<ul>\n<li><code>on-failure</code>：容器停止时，容器出现报错，则容器会被重启。但是如果 docker 服务被重启了该配置就不会生效。</li>\n<li><code>unless-stopped</code>：容器停止，如果没有报错，则容器会被重启。即使重启了 docker 服务，该配置也生效。</li>\n<li><code>always</code>：不管如何，容器只要停止就重启。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --restart always --name busybox_test busybox /bin/sh -c <span class=\"string\">&quot;sleep 60&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>busybox</code> 镜像是一个精简的 Linux，非常小，适合用来做测试。结果如下：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230318144-1256119776.png\"></p>\n<p>通过过一段时间查看，发现在容器内部 sleep 60 之后退出，然后被重启拉起一个新的。</p>\n<p>以上就是容器运行的基本参数，至于容器的存储卷，网络等内容，后面会单独分节介绍。</p>\n<h4 id=\"查看详情（inspect）\"><a href=\"#查看详情（inspect）\" class=\"headerlink\" title=\"查看详情（inspect）\"></a>查看详情（inspect）</h4><p>通过该命令可以查看容器的详细信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container inspect busybox_test</span><br></pre></td></tr></table></figure>\n\n<p>详细信息中需要关注的点包括：</p>\n<ul>\n<li><code>Image</code>：使用的镜像。</li>\n<li><code>Volumes</code>：数据存储卷。</li>\n<li><code>IPAddress</code>：容器的 IP 地址。</li>\n<li><code>Ports</code>：端口信息。</li>\n</ul>\n<h4 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><p>通过该命令可以查看容器的运行时状态，如 Up，Exited 等：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建容器但不运行</span></span><br><span class=\"line\">docker container create --name demo02 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">docker container start demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\">docker container pause demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 继续运行容器</span></span><br><span class=\"line\">docker container unpause demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止容器</span></span><br><span class=\"line\">docker container stop demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启容器</span></span><br><span class=\"line\">docker container restart demo02</span><br></pre></td></tr></table></figure>\n\n<p>结果如图所示</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230341164-1246990897.png\"></p>\n<h4 id=\"进入容器（attach）\"><a href=\"#进入容器（attach）\" class=\"headerlink\" title=\"进入容器（attach）\"></a>进入容器（attach）</h4><p>通过该命令可以连接到一个运行中的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container attach --sig-proxy=<span class=\"literal\">false</span> demo02</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>--sig-proxy=false</code>的目的是为了避免<code>Ctrl + C</code>或者<code>Ctrl + D</code>使容器退出。</p>\n<p>该命令会对容器进行监听，命令行处于交互式界面，此时从新窗口请求该容器的 nginx：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230358617-1596296745.png\"></p>\n<p>可以看到日志直接输出到屏幕，<code>Ctrl + C</code>就可以退出该界面且保持容器继续运行。</p>\n<h4 id=\"进入容器（exec）\"><a href=\"#进入容器（exec）\" class=\"headerlink\" title=\"进入容器（exec）\"></a>进入容器（exec）</h4><p>上面的方法是将输出直接输出到屏幕上，无法操作，如果想将容器当虚拟机一样使用，则需要 exec：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it demo02 /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>注意，exec 后面需要跟执行命令，由于是命令行，则需要使用 &#x2F;bin&#x2F;bash 或者 &#x2F;bin&#x2F;sh。</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230414251-864497271.png\"></p>\n<h4 id=\"查看日志（logs）\"><a href=\"#查看日志（logs）\" class=\"headerlink\" title=\"查看日志（logs）\"></a>查看日志（logs）</h4><p>通过该命令可以实时查看容器运行的日志：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container logs -f demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230425653-1546012181.png\"></p>\n<p>使用<code>-f</code>的参数可以让它像linux中的<code>tail</code>命令一样。否则就是一次性查看，跟<code>cat</code>一样。</p>\n<h4 id=\"文件拷贝（cp）\"><a href=\"#文件拷贝（cp）\" class=\"headerlink\" title=\"文件拷贝（cp）\"></a>文件拷贝（cp）</h4><p>通过该命令可以实现容器和宿主机之间文件传输：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝文件到容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> anaconda-ks.cfg demo02:/tmp/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝文件到容器并改名</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> anaconda-ks.cfg demo02:/tmp/1.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝目录到容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> demo demo02:/tmp/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝文件到本地</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> demo02:/tmp/1.txt .</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230443140-850543444.png\"></p>\n<h4 id=\"查看端口-port\"><a href=\"#查看端口-port\" class=\"headerlink\" title=\"查看端口(port)\"></a>查看端口(port)</h4><p>通过该命令可以查看容器和宿主机的端口映射关系：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container port demo02</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看状态-stats\"><a href=\"#查看状态-stats\" class=\"headerlink\" title=\"查看状态(stats)\"></a>查看状态(stats)</h4><p>通过该命令可以查看容器内部系统资源使用情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container stats demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230456764-365638708.png\"></p>\n<h4 id=\"查看进程（top）\"><a href=\"#查看进程（top）\" class=\"headerlink\" title=\"查看进程（top）\"></a>查看进程（top）</h4><p>通过该命令可以查看到容器内部运行的进程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container top demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230514143-33194940.png\"></p>\n<h4 id=\"提交镜像（commit）\"><a href=\"#提交镜像（commit）\" class=\"headerlink\" title=\"提交镜像（commit）\"></a>提交镜像（commit）</h4><p>该命令可以将现有的容器提交成镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container commit -a <span class=\"string\">&quot;Trover &lt;admin@buerya.cn&gt;&quot;</span> -m <span class=\"string\">&quot;Copy file&quot;</span> -p demo02 trover/nginx-copy-file:v1.0</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li><code>-a</code>：作者信息。</li>\n<li><code>-m</code>：提交信息，有点像 <code>git commit -m</code>。</li>\n<li><code>-p</code>：生成镜像时容器暂停。<br>如图所示：</li>\n</ul>\n<p><img src=\"/img/2022/docker-container/979767-20220613230526915-1148740640.png\"></p>\n<h4 id=\"停止容器（kill）\"><a href=\"#停止容器（kill）\" class=\"headerlink\" title=\"停止容器（kill）\"></a>停止容器（kill）</h4><p>该命令相较于 stop 更暴力杀死一个或多个容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container <span class=\"built_in\">kill</span> demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230542052-1112346775.png\"></p>\n<h4 id=\"重命名容器（rename）\"><a href=\"#重命名容器（rename）\" class=\"headerlink\" title=\"重命名容器（rename）\"></a>重命名容器（rename）</h4><p>该命令可以对容器重命名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container rename demo02 demo03</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230553943-1837768949.png\"></p>\n<h4 id=\"导出容器（export）\"><a href=\"#导出容器（export）\" class=\"headerlink\" title=\"导出容器（export）\"></a>导出容器（export）</h4><p>该命令可以将容器当前的状态导出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container <span class=\"built_in\">export</span> -o /tmp/demo03.tar demo03</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230607064-1784552793.png\"></p>\n<h4 id=\"查看系统变化（diff）\"><a href=\"#查看系统变化（diff）\" class=\"headerlink\" title=\"查看系统变化（diff）\"></a>查看系统变化（diff）</h4><p>该命令可以查看容器目前的文件和文件系统本身的差异：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container diff demo03</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230619331-869669860.png\"></p>\n<h4 id=\"删除容器（rm）\"><a href=\"#删除容器（rm）\" class=\"headerlink\" title=\"删除容器（rm）\"></a>删除容器（rm）</h4><p>该命令可以删除指定的一个或多个容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除停止的容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">rm</span> a7851616b54c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除运行中的容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">rm</span> -f 338a3419e42e</span><br></pre></td></tr></table></figure>\n\n<p>如果容器在运行，需要使用<code>-f</code>强制删除：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230641212-907588129.png\"></p>\n<h4 id=\"批量删除（rm）\"><a href=\"#批量删除（rm）\" class=\"headerlink\" title=\"批量删除（rm）\"></a>批量删除（rm）</h4><p>对于容器或者镜像，都可以使用条件筛选的方式对它进行批量删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">rm</span> $(docker container <span class=\"built_in\">ls</span> -aq)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除所有 redis 镜像</span></span><br><span class=\"line\">docker image <span class=\"built_in\">rm</span> $(docker image <span class=\"built_in\">ls</span> -aq redis)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除所有在 mongo:3.2 之前的镜像</span></span><br><span class=\"line\">docker image <span class=\"built_in\">rm</span> $(docker image <span class=\"built_in\">ls</span> -aq -f before=mongo:3.2)</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>-q</code>参数能够增加筛选条件。</p>\n<h4 id=\"删除容器（prune）\"><a href=\"#删除容器（prune）\" class=\"headerlink\" title=\"删除容器（prune）\"></a>删除容器（prune）</h4><p>该命令可以删除没有使用的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>可以通过<code>-f</code>参数直接删除，不用确认。</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230700355-227583119.png\"></p>\n<p>到此，容器的大部分操作都已经体验完毕。接下来将讲解如何制作镜像！</p>\n","more":"<h4 id=\"查看容器-ps\"><a href=\"#查看容器-ps\" class=\"headerlink\" title=\"查看容器(ps)\"></a>查看容器(ps)</h4><p>在运行容器之前，我们需要知道如何查看运行中的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Management Commands（推荐）</span></span><br><span class=\"line\">docker container ps</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">docker container <span class=\"built_in\">ls</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Commands</span></span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n\n<p>使用此方法只能看到运行中的容器，对于以及停止的容器，还需要使用<code>-a</code>参数，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container ps -a</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"容器运行-run-无参数\"><a href=\"#容器运行-run-无参数\" class=\"headerlink\" title=\"容器运行(run, 无参数)\"></a>容器运行(run, 无参数)</h4><p>前面有说过，容器是镜像的实例。学习 docker 最终目的就是就是运行它。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>\n\n<p>运行第一个测试容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Management Commands（推荐）</span></span><br><span class=\"line\">docker container run hello-world</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Commands</span></span><br><span class=\"line\">docker run hello-world</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230044356-1739155940.png\"></p>\n<p>hello-world 容器是一个测试容器，在输出一些文字之后就会退出，通过这个过程，我们可以发现：</p>\n<ol>\n<li>对于运行容器，如果镜像不存在，则会去 registry 中自动下载。</li>\n<li>使用 ps 查看容器的时候，如果不使用 -a 参数是看不到状态属于 Exited 的容器的。</li>\n<li>使用 ps 可以简单的看到容器的 ID，使用的镜像，执行的命令，创建时间，运行状态，端口，容器的名字等信息。</li>\n</ol>\n<h4 id=\"容器运行（run-d，守护态）\"><a href=\"#容器运行（run-d，守护态）\" class=\"headerlink\" title=\"容器运行（run -d，守护态）\"></a>容器运行（run -d，守护态）</h4><p>在运行容器时，需要确定这个容器是运行在前台模式还是后台模式。</p>\n<p><code>-d，--detach</code>，守护态运行。能够将容器运行在后台模式。这样所有的 IO 都只能通过网络资源或存储卷来进行交互。容器不再监听执行 docker run 这个命令行的窗口。有点类似于 Linux 启动程序时候的<code>nohup</code>或者<code> &amp;</code>组合。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d hello-world</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230101520-12884147.png\"></p>\n<p>可以发现，hello-world 容器加了 -d 参数后不在输出它的信息，只是返回了一长串字符，其实就是完整的 Container ID，用法类似 Image ID。</p>\n<p>同时由于 hello-world 容器本身的特性，程序在后台执行完成之后就直接退出了，容器也跟着退出了。</p>\n<p>再次运行以 nginx 容器为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run nginx</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230115647-335897184.png\"></p>\n<p>可以发现以下信息：</p>\n<ol>\n<li>由于没有跟 TAG，默认会以 latest 版本执行。在 docker 中，如果是运行 latest 版本，docker 都会去仓库试着拉取，而不是直接使用本地的镜像，因为本地的 latest 不一定是真正的 latest。</li>\n<li>容器在运行之后会以前台模式运行，所有它 hung 在了命令行。</li>\n<li>此时如果我们新开一个窗口来查看，可以发现容器处于 Up 状态，如下图所示：</li>\n</ol>\n<p><img src=\"/img/2022/docker-container/979767-20220613230139284-2045625911.png\"></p>\n<ol start=\"4\">\n<li>如果我们去 docker run 的窗口使用 Ctrl + c 中断，然后再次查看容器运行状态，可以发现容器已经退出，这就是前台运行的问题，如图所示：</li>\n</ol>\n<p><img src=\"/img/2022/docker-container/979767-20220613230148765-1700841146.png\"></p>\n<p>如果使用后台运行模式运行该容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d nginx</span><br></pre></td></tr></table></figure>\n\n<p>运行效果如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230204245-595295977.png\"></p>\n<p>容器被放在了后台运行，不会 hung 在命令行。当然所有的输出信息也不能直接看到了。</p>\n<h4 id=\"容器运行（run-it，交互式运行）\"><a href=\"#容器运行（run-it，交互式运行）\" class=\"headerlink\" title=\"容器运行（run -it，交互式运行）\"></a>容器运行（run -it，交互式运行）</h4><p>在使用 -d 参数之后，容器就不会 hung 在命令行窗口，而是以后台方式运行。但是这同时也有一个问题，某些时候我们是需要进入容器查看相关启动等信息的。此时就需要另外的参数配合使用：</p>\n<ul>\n<li><code>-i，--interactive</code>：打开一个交互式界面。</li>\n<li><code>-t，--tty</code>：打开一个 TTY 终端。<br>将这个两个参数结合就是打开一个交互式的 TTY 终端。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -it nginx /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230217469-498760333.png\"></p>\n<p>通过该方法在创建容器的时候指定运行命令，然后以 bash 进入容器内部的命令行。可以发现：</p>\n<ol>\n<li>容器内部就是 linux 的目录结构，但是是一个很简化的 linux，很多基础命令都没有。</li>\n<li>当退出容器命令行，容器也跟着退出。原因是我们重写容器内部的命令为 bash 之后，nginx 就没有启动了，当退出 bash 之后，容器内部就没有进程了，所有容器就退出了。</li>\n<li>这种方式用的比较少，一般都是容器运行之后，使用专门的命令进入容器。</li>\n</ol>\n<h4 id=\"容器运行（run-–name，容器命名）\"><a href=\"#容器运行（run-–name，容器命名）\" class=\"headerlink\" title=\"容器运行（run –name，容器命名）\"></a>容器运行（run –name，容器命名）</h4><p>在创建容器的时候，如果不给容器指定一个名字，容器会生成一个随机的名字，一般都是以 xxx_xxx 的格式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --name demo01 nginx</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230241715-1635978379.png\"></p>\n<p>针对容器的名字，我们可以根据自己的需求指定相关的命名规范，以此来实现统一管理的目的。</p>\n<h4 id=\"容器运行（run-–rm，退出删除）\"><a href=\"#容器运行（run-–rm，退出删除）\" class=\"headerlink\" title=\"容器运行（run –rm，退出删除）\"></a>容器运行（run –rm，退出删除）</h4><p>某些容器可能是一次性容器，在运行之后，容器退出。同时不保留在 ps 中，此时就需要使用到 <code>--rm</code> 参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run --<span class=\"built_in\">rm</span> --name rm_test hello-world</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230301553-222894916.png\"></p>\n<h4 id=\"容器运行（run-–restart，重启规则）\"><a href=\"#容器运行（run-–restart，重启规则）\" class=\"headerlink\" title=\"容器运行（run –restart，重启规则）\"></a>容器运行（run –restart，重启规则）</h4><p>为了保障在以外的停止之后能够自动恢复，就需要对它配置相关<code>--restart</code>规则：</p>\n<ul>\n<li><code>on-failure</code>：容器停止时，容器出现报错，则容器会被重启。但是如果 docker 服务被重启了该配置就不会生效。</li>\n<li><code>unless-stopped</code>：容器停止，如果没有报错，则容器会被重启。即使重启了 docker 服务，该配置也生效。</li>\n<li><code>always</code>：不管如何，容器只要停止就重启。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d --restart always --name busybox_test busybox /bin/sh -c <span class=\"string\">&quot;sleep 60&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>busybox</code> 镜像是一个精简的 Linux，非常小，适合用来做测试。结果如下：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230318144-1256119776.png\"></p>\n<p>通过过一段时间查看，发现在容器内部 sleep 60 之后退出，然后被重启拉起一个新的。</p>\n<p>以上就是容器运行的基本参数，至于容器的存储卷，网络等内容，后面会单独分节介绍。</p>\n<h4 id=\"查看详情（inspect）\"><a href=\"#查看详情（inspect）\" class=\"headerlink\" title=\"查看详情（inspect）\"></a>查看详情（inspect）</h4><p>通过该命令可以查看容器的详细信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container inspect busybox_test</span><br></pre></td></tr></table></figure>\n\n<p>详细信息中需要关注的点包括：</p>\n<ul>\n<li><code>Image</code>：使用的镜像。</li>\n<li><code>Volumes</code>：数据存储卷。</li>\n<li><code>IPAddress</code>：容器的 IP 地址。</li>\n<li><code>Ports</code>：端口信息。</li>\n</ul>\n<h4 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><p>通过该命令可以查看容器的运行时状态，如 Up，Exited 等：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建容器但不运行</span></span><br><span class=\"line\">docker container create --name demo02 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">docker container start demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\">docker container pause demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 继续运行容器</span></span><br><span class=\"line\">docker container unpause demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止容器</span></span><br><span class=\"line\">docker container stop demo02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启容器</span></span><br><span class=\"line\">docker container restart demo02</span><br></pre></td></tr></table></figure>\n\n<p>结果如图所示</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230341164-1246990897.png\"></p>\n<h4 id=\"进入容器（attach）\"><a href=\"#进入容器（attach）\" class=\"headerlink\" title=\"进入容器（attach）\"></a>进入容器（attach）</h4><p>通过该命令可以连接到一个运行中的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container attach --sig-proxy=<span class=\"literal\">false</span> demo02</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>--sig-proxy=false</code>的目的是为了避免<code>Ctrl + C</code>或者<code>Ctrl + D</code>使容器退出。</p>\n<p>该命令会对容器进行监听，命令行处于交互式界面，此时从新窗口请求该容器的 nginx：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230358617-1596296745.png\"></p>\n<p>可以看到日志直接输出到屏幕，<code>Ctrl + C</code>就可以退出该界面且保持容器继续运行。</p>\n<h4 id=\"进入容器（exec）\"><a href=\"#进入容器（exec）\" class=\"headerlink\" title=\"进入容器（exec）\"></a>进入容器（exec）</h4><p>上面的方法是将输出直接输出到屏幕上，无法操作，如果想将容器当虚拟机一样使用，则需要 exec：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it demo02 /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>注意，exec 后面需要跟执行命令，由于是命令行，则需要使用 &#x2F;bin&#x2F;bash 或者 &#x2F;bin&#x2F;sh。</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230414251-864497271.png\"></p>\n<h4 id=\"查看日志（logs）\"><a href=\"#查看日志（logs）\" class=\"headerlink\" title=\"查看日志（logs）\"></a>查看日志（logs）</h4><p>通过该命令可以实时查看容器运行的日志：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container logs -f demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230425653-1546012181.png\"></p>\n<p>使用<code>-f</code>的参数可以让它像linux中的<code>tail</code>命令一样。否则就是一次性查看，跟<code>cat</code>一样。</p>\n<h4 id=\"文件拷贝（cp）\"><a href=\"#文件拷贝（cp）\" class=\"headerlink\" title=\"文件拷贝（cp）\"></a>文件拷贝（cp）</h4><p>通过该命令可以实现容器和宿主机之间文件传输：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝文件到容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> anaconda-ks.cfg demo02:/tmp/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝文件到容器并改名</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> anaconda-ks.cfg demo02:/tmp/1.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝目录到容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> demo demo02:/tmp/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝文件到本地</span></span><br><span class=\"line\">docker container <span class=\"built_in\">cp</span> demo02:/tmp/1.txt .</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230443140-850543444.png\"></p>\n<h4 id=\"查看端口-port\"><a href=\"#查看端口-port\" class=\"headerlink\" title=\"查看端口(port)\"></a>查看端口(port)</h4><p>通过该命令可以查看容器和宿主机的端口映射关系：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container port demo02</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看状态-stats\"><a href=\"#查看状态-stats\" class=\"headerlink\" title=\"查看状态(stats)\"></a>查看状态(stats)</h4><p>通过该命令可以查看容器内部系统资源使用情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container stats demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230456764-365638708.png\"></p>\n<h4 id=\"查看进程（top）\"><a href=\"#查看进程（top）\" class=\"headerlink\" title=\"查看进程（top）\"></a>查看进程（top）</h4><p>通过该命令可以查看到容器内部运行的进程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container top demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230514143-33194940.png\"></p>\n<h4 id=\"提交镜像（commit）\"><a href=\"#提交镜像（commit）\" class=\"headerlink\" title=\"提交镜像（commit）\"></a>提交镜像（commit）</h4><p>该命令可以将现有的容器提交成镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container commit -a <span class=\"string\">&quot;Trover &lt;admin@buerya.cn&gt;&quot;</span> -m <span class=\"string\">&quot;Copy file&quot;</span> -p demo02 trover/nginx-copy-file:v1.0</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li><code>-a</code>：作者信息。</li>\n<li><code>-m</code>：提交信息，有点像 <code>git commit -m</code>。</li>\n<li><code>-p</code>：生成镜像时容器暂停。<br>如图所示：</li>\n</ul>\n<p><img src=\"/img/2022/docker-container/979767-20220613230526915-1148740640.png\"></p>\n<h4 id=\"停止容器（kill）\"><a href=\"#停止容器（kill）\" class=\"headerlink\" title=\"停止容器（kill）\"></a>停止容器（kill）</h4><p>该命令相较于 stop 更暴力杀死一个或多个容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container <span class=\"built_in\">kill</span> demo02</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230542052-1112346775.png\"></p>\n<h4 id=\"重命名容器（rename）\"><a href=\"#重命名容器（rename）\" class=\"headerlink\" title=\"重命名容器（rename）\"></a>重命名容器（rename）</h4><p>该命令可以对容器重命名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container rename demo02 demo03</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230553943-1837768949.png\"></p>\n<h4 id=\"导出容器（export）\"><a href=\"#导出容器（export）\" class=\"headerlink\" title=\"导出容器（export）\"></a>导出容器（export）</h4><p>该命令可以将容器当前的状态导出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container <span class=\"built_in\">export</span> -o /tmp/demo03.tar demo03</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230607064-1784552793.png\"></p>\n<h4 id=\"查看系统变化（diff）\"><a href=\"#查看系统变化（diff）\" class=\"headerlink\" title=\"查看系统变化（diff）\"></a>查看系统变化（diff）</h4><p>该命令可以查看容器目前的文件和文件系统本身的差异：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container diff demo03</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230619331-869669860.png\"></p>\n<h4 id=\"删除容器（rm）\"><a href=\"#删除容器（rm）\" class=\"headerlink\" title=\"删除容器（rm）\"></a>删除容器（rm）</h4><p>该命令可以删除指定的一个或多个容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除停止的容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">rm</span> a7851616b54c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除运行中的容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">rm</span> -f 338a3419e42e</span><br></pre></td></tr></table></figure>\n\n<p>如果容器在运行，需要使用<code>-f</code>强制删除：</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230641212-907588129.png\"></p>\n<h4 id=\"批量删除（rm）\"><a href=\"#批量删除（rm）\" class=\"headerlink\" title=\"批量删除（rm）\"></a>批量删除（rm）</h4><p>对于容器或者镜像，都可以使用条件筛选的方式对它进行批量删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有容器</span></span><br><span class=\"line\">docker container <span class=\"built_in\">rm</span> $(docker container <span class=\"built_in\">ls</span> -aq)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除所有 redis 镜像</span></span><br><span class=\"line\">docker image <span class=\"built_in\">rm</span> $(docker image <span class=\"built_in\">ls</span> -aq redis)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除所有在 mongo:3.2 之前的镜像</span></span><br><span class=\"line\">docker image <span class=\"built_in\">rm</span> $(docker image <span class=\"built_in\">ls</span> -aq -f before=mongo:3.2)</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>-q</code>参数能够增加筛选条件。</p>\n<h4 id=\"删除容器（prune）\"><a href=\"#删除容器（prune）\" class=\"headerlink\" title=\"删除容器（prune）\"></a>删除容器（prune）</h4><p>该命令可以删除没有使用的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>可以通过<code>-f</code>参数直接删除，不用确认。</p>\n<p><img src=\"/img/2022/docker-container/979767-20220613230700355-227583119.png\"></p>\n<p>到此，容器的大部分操作都已经体验完毕。接下来将讲解如何制作镜像！</p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"Docker","path":"api/categories/Docker.json"}],"tags":[{"name":"docker","path":"api/tags/docker.json"},{"name":"k8s","path":"api/tags/k8s.json"},{"name":"kubernetes","path":"api/tags/kubernetes.json"},{"name":"容器","path":"api/tags/容器.json"},{"name":"云原生","path":"api/tags/云原生.json"}]}