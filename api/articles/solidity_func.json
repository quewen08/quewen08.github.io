{"title":"智能合约语言 Solidity 教程系列3 - 类型介绍","slug":"solidity_func","date":"2018-03-08T16:00:00.000Z","updated":"2022-10-19T14:40:00.268Z","comments":true,"path":"api/articles/solidity_func.json","realPath":"/2018/solidity_func/index/","excerpt":null,"covers":null,"cover":null,"content":"<p>Solidity 教程系列第三篇 - Solidity 函数类型介绍。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"函数类型-Function-Types\"><a href=\"#函数类型-Function-Types\" class=\"headerlink\" title=\"函数类型(Function Types)\"></a>函数类型(Function Types)</h2><p>函数也是一种类型，且属于值类型。<br>可以将一个函数赋值给一个函数类型的变量。还可以将一个函数作为参数进行传递。也可以在函数调用中返回一个函数。<br>函数类型有两类:内部(internal)和外部(external)函数</p>\n<p><strong>内部(internal)</strong> 函数只能在当前合约内被调用（在当前的代码块内，包括内部库函数，和继承的函数中）。<br><strong>外部(external)</strong> 函数由地址和函数方法签名两部分组成，可作为外部函数调用的参数，或返回值。</p>\n<p>函数类型定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure>\n\n<p>如果函数不需要返回，则省去returns ()<br>函数类型默认是internal， 因此internal可以省去。但以此相反，合约中函数本身默认是public的， 仅仅是当作类型名使用时默认是internal的。</p>\n<p>有两个方式访问函数，一种是直接用函数名f, 一种是this.f， 前者用于内部函数，后者用于外部函数。</p>\n<p>如果一个函数变量没有初始化，直接调用它将会产生异常。如果delete了一个函数后调用，也会发生同样的异常。</p>\n<p>如果外部函数类型在Solidity的上下文环境以外的地方使用，他们会被视为function类型。它会编码为20字节的函数所在地址，和在它之前的4字节的函数方法签名一起作为bytes24类型。<br>合约中的public的函数，可以使用internal和external两种方式来调用。<br>internal访问形式为f, external访问形式为this.f</p>\n<h3 id=\"成员：属性-selector\"><a href=\"#成员：属性-selector\" class=\"headerlink\" title=\"成员：属性 selector\"></a>成员：属性 selector</h3><p>public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Selector &#123;</span><br><span class=\"line\">  function f() public view returns (bytes4) &#123;</span><br><span class=\"line\">      return this.f.selector;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的代码显示内部（internal）函数类型的使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">library ArrayUtils &#123;</span><br><span class=\"line\">  // internal functions can be used in internal library functions because</span><br><span class=\"line\">  // they will be part of the same code context</span><br><span class=\"line\">  function map(uint[] memory self, function (uint) pure returns (uint) f)</span><br><span class=\"line\">    internal</span><br><span class=\"line\">    pure</span><br><span class=\"line\">    returns (uint[] memory r)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    r = new uint[](self.length);</span><br><span class=\"line\">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class=\"line\">      r[i] = f(self[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function reduce(</span><br><span class=\"line\">    uint[] memory self,</span><br><span class=\"line\">    function (uint, uint) pure returns (uint) f</span><br><span class=\"line\">  )</span><br><span class=\"line\">    internal</span><br><span class=\"line\">    pure</span><br><span class=\"line\">    returns (uint r)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    r = self[0];</span><br><span class=\"line\">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class=\"line\">      r = f(r, self[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function range(uint length) internal pure returns (uint[] memory r) &#123;</span><br><span class=\"line\">    r = new uint[](length);</span><br><span class=\"line\">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">      r[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Pyramid &#123;</span><br><span class=\"line\">  using ArrayUtils for *;</span><br><span class=\"line\">  function pyramid(uint l) public pure returns (uint) &#123;</span><br><span class=\"line\">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function square(uint x) internal pure returns (uint) &#123;</span><br><span class=\"line\">    return x * x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function sum(uint x, uint y) internal pure returns (uint) &#123;</span><br><span class=\"line\">    return x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的代码显示外部（external）函数类型的使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Oracle &#123;</span><br><span class=\"line\">  struct Request &#123;</span><br><span class=\"line\">    bytes data;</span><br><span class=\"line\">    function(bytes memory) external callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Request[] requests;</span><br><span class=\"line\">  event NewRequest(uint);</span><br><span class=\"line\">  function query(bytes data, function(bytes memory) external callback) public &#123;</span><br><span class=\"line\">    requests.push(Request(data, callback));</span><br><span class=\"line\">    NewRequest(requests.length - 1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function reply(uint requestID, bytes response) public &#123;</span><br><span class=\"line\">    // Here goes the check that the reply comes from a trusted source</span><br><span class=\"line\">    requests[requestID].callback(response);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract OracleUser &#123;</span><br><span class=\"line\">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class=\"line\">  function buySomething() &#123;</span><br><span class=\"line\">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function oracleResponse(bytes response) public &#123;</span><br><span class=\"line\">    require(msg.sender == address(oracle));</span><br><span class=\"line\">    // Use the data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数可见性分析\"><a href=\"#函数可见性分析\" class=\"headerlink\" title=\"函数可见性分析\"></a>函数可见性分析</h2><ul>\n<li>public - 任意访问</li>\n<li>private - 仅当前合约内</li>\n<li>internal - 仅当前合约及所继承的合约</li>\n<li>external - 仅外部访问（在内部也只能用外部访问方式访问）</li>\n</ul>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html\">Solidity官方文档-类型</a></p>\n","more":"<p>Solidity 教程系列第三篇 - Solidity 函数类型介绍。<br>Solidity 系列完整的文章列表请查看<a href=\"/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/\">分类-Solidity</a>。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href=\"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html\">以太坊是什么</a></p>\n<p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p>\n<h2 id=\"函数类型-Function-Types\"><a href=\"#函数类型-Function-Types\" class=\"headerlink\" title=\"函数类型(Function Types)\"></a>函数类型(Function Types)</h2><p>函数也是一种类型，且属于值类型。<br>可以将一个函数赋值给一个函数类型的变量。还可以将一个函数作为参数进行传递。也可以在函数调用中返回一个函数。<br>函数类型有两类:内部(internal)和外部(external)函数</p>\n<p><strong>内部(internal)</strong> 函数只能在当前合约内被调用（在当前的代码块内，包括内部库函数，和继承的函数中）。<br><strong>外部(external)</strong> 函数由地址和函数方法签名两部分组成，可作为外部函数调用的参数，或返回值。</p>\n<p>函数类型定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure>\n\n<p>如果函数不需要返回，则省去returns ()<br>函数类型默认是internal， 因此internal可以省去。但以此相反，合约中函数本身默认是public的， 仅仅是当作类型名使用时默认是internal的。</p>\n<p>有两个方式访问函数，一种是直接用函数名f, 一种是this.f， 前者用于内部函数，后者用于外部函数。</p>\n<p>如果一个函数变量没有初始化，直接调用它将会产生异常。如果delete了一个函数后调用，也会发生同样的异常。</p>\n<p>如果外部函数类型在Solidity的上下文环境以外的地方使用，他们会被视为function类型。它会编码为20字节的函数所在地址，和在它之前的4字节的函数方法签名一起作为bytes24类型。<br>合约中的public的函数，可以使用internal和external两种方式来调用。<br>internal访问形式为f, external访问形式为this.f</p>\n<h3 id=\"成员：属性-selector\"><a href=\"#成员：属性-selector\" class=\"headerlink\" title=\"成员：属性 selector\"></a>成员：属性 selector</h3><p>public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Selector &#123;</span><br><span class=\"line\">  function f() public view returns (bytes4) &#123;</span><br><span class=\"line\">      return this.f.selector;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的代码显示内部（internal）函数类型的使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.16;</span><br><span class=\"line\"></span><br><span class=\"line\">library ArrayUtils &#123;</span><br><span class=\"line\">  // internal functions can be used in internal library functions because</span><br><span class=\"line\">  // they will be part of the same code context</span><br><span class=\"line\">  function map(uint[] memory self, function (uint) pure returns (uint) f)</span><br><span class=\"line\">    internal</span><br><span class=\"line\">    pure</span><br><span class=\"line\">    returns (uint[] memory r)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    r = new uint[](self.length);</span><br><span class=\"line\">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class=\"line\">      r[i] = f(self[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function reduce(</span><br><span class=\"line\">    uint[] memory self,</span><br><span class=\"line\">    function (uint, uint) pure returns (uint) f</span><br><span class=\"line\">  )</span><br><span class=\"line\">    internal</span><br><span class=\"line\">    pure</span><br><span class=\"line\">    returns (uint r)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    r = self[0];</span><br><span class=\"line\">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class=\"line\">      r = f(r, self[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function range(uint length) internal pure returns (uint[] memory r) &#123;</span><br><span class=\"line\">    r = new uint[](length);</span><br><span class=\"line\">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">      r[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Pyramid &#123;</span><br><span class=\"line\">  using ArrayUtils for *;</span><br><span class=\"line\">  function pyramid(uint l) public pure returns (uint) &#123;</span><br><span class=\"line\">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function square(uint x) internal pure returns (uint) &#123;</span><br><span class=\"line\">    return x * x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function sum(uint x, uint y) internal pure returns (uint) &#123;</span><br><span class=\"line\">    return x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的代码显示外部（external）函数类型的使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.11;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Oracle &#123;</span><br><span class=\"line\">  struct Request &#123;</span><br><span class=\"line\">    bytes data;</span><br><span class=\"line\">    function(bytes memory) external callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Request[] requests;</span><br><span class=\"line\">  event NewRequest(uint);</span><br><span class=\"line\">  function query(bytes data, function(bytes memory) external callback) public &#123;</span><br><span class=\"line\">    requests.push(Request(data, callback));</span><br><span class=\"line\">    NewRequest(requests.length - 1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function reply(uint requestID, bytes response) public &#123;</span><br><span class=\"line\">    // Here goes the check that the reply comes from a trusted source</span><br><span class=\"line\">    requests[requestID].callback(response);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract OracleUser &#123;</span><br><span class=\"line\">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class=\"line\">  function buySomething() &#123;</span><br><span class=\"line\">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function oracleResponse(bytes response) public &#123;</span><br><span class=\"line\">    require(msg.sender == address(oracle));</span><br><span class=\"line\">    // Use the data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数可见性分析\"><a href=\"#函数可见性分析\" class=\"headerlink\" title=\"函数可见性分析\"></a>函数可见性分析</h2><ul>\n<li>public - 任意访问</li>\n<li>private - 仅当前合约内</li>\n<li>internal - 仅当前合约及所继承的合约</li>\n<li>external - 仅外部访问（在内部也只能用外部访问方式访问）</li>\n</ul>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://solidity.readthedocs.io/en/develop/types.html\">Solidity官方文档-类型</a></p>\n","categories":[{"name":"学习记录","path":"api/categories/学习记录.json"},{"name":"区块链","path":"api/categories/区块链.json"},{"name":"以太坊","path":"api/categories/以太坊.json"}],"tags":[{"name":"Solidity手册","path":"api/tags/Solidity手册.json"}]}