<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络管理</title>
      <link href="/2022/docker-network/index/"/>
      <url>/2022/docker-network/index/</url>
      
        <content type="html"><![CDATA[<h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><p>容器的网络通信可以分为两大方面：单主机上的容器之间相互通信和跨主机的容器相互通信。</p><p>docker 的单主机通信基于 Network Namespace 实现，它可以为容器创建隔离的网络环境。docker 官方本身提供了 5 种网络模式，可以基本满足日常开发中的需求：</p><table><thead><tr><th>网络模式</th><th>说明</th></tr></thead><tbody><tr><td>bridge</td><td>默认，为每个容器分配一个 IP，该 IP 会连接到 docker 宿主机的 docker0 虚拟网卡</td></tr><tr><td>host</td><td>容器不会拥有自己的虚拟网卡和 IP，而是直接使用宿主机的 IP 和端口</td></tr><tr><td>none</td><td>为容器创建独立网络名称空间，但不做任何网络配置，容器中只有 lo，用户可以就此对容器网络做任意定制</td></tr><tr><td>container</td><td>类似 host，容器不会拥有自己的网卡和 IP，而是和一个指定的容器共享 IP，端口等</td></tr><tr><td>用户自定义</td><td>在 docker 1.9 以后新增的特性，允许容器使用第三方的网络实现或者创建单独的 bridge 网络，提供网络隔离能力</td></tr></tbody></table><p>在安装完成 docker 之后，会默认创建三种网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-network/979767-20220704091535994-104412335.png"></p><p>在运行容器时，可以使用 <code>--network</code> 或者 <code>--net</code> 指定容器使用的网络模式，如：<code>--net bridge</code></p><p>同时也可以使用命令查看网络模式下有哪些容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>bridge 模式是 docker 默认的网络模式，也是开发者最常使用的网络模式。</p><p>在这种模式下，docker 为容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，实现容器与容器之间、容器与宿主机之间的网络栈隔离。</p><p>同时，通过宿主机上的 docker0 网桥，容器可以与宿主机乃至外界进行网络通信。其网络模型可以参考下图：</p><p><img src="/img/2022/docker-network/979767-20220704091606017-359286512.png"></p><p>大致流程如下：</p><ol><li><p>docker 先创建一对虚拟网卡 <code>veth pair</code> 设备（其特征为：成对出现，数据从一个设备进入，就会从另一个设备出来，常用于实现数据通道）。</p></li><li><p>docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0。</p></li><li><p>docker 将 veth pair 设备的另一端放在宿主机中，以 vethxxx 格式命名，并将它加入到 docker0 网桥中（可通过 brctl show 命令查看到）。</p></li><li><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 为容器的默认网关。</p></li></ol><h4 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h4><h5 id="查看本机网络情况："><a href="#查看本机网络情况：" class="headerlink" title="查看本机网络情况："></a>查看本机网络情况：</h5><p><img src="/img/2022/docker-network/979767-20220704091633136-860769745.png"></p><p>docker 安装完后会在宿主机创建一个 <code>docker0</code> 虚拟网卡。其作用类似于网络交换设备，用于实现容器之间，容器与宿主机之间甚至容器与外部主机之间的通信</p><p>docker0 网桥的 IP 一般会是 docker 配置网段的第一个 IP，且这个 IP 会作为 bridge 网络模式的容器的网关使用。</p><p>本文由于我们在配置 docker 时有另外指定了 IP 网段，所以这里看到的网段为：<code>172.16.0.0/16</code> 而不是 docker 默认的网段 <code>172.17.0.0/16</code>。</p><h5 id="新建两个容器并查看其网络情况："><a href="#新建两个容器并查看其网络情况：" class="headerlink" title="新建两个容器并查看其网络情况："></a>新建两个容器并查看其网络情况：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端 1</span></span><br><span class="line">docker container run --<span class="built_in">rm</span> -it --name demo01 busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端 2</span></span><br><span class="line">docker container run --<span class="built_in">rm</span> -it --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>终端 1：</p><p><img src="/img/2022/docker-network/979767-20220704091656783-1241667431.png"></p><p>终端 2:</p><p><img src="/img/2022/docker-network/979767-20220704091704333-641634607.png"></p><h5 id="查看此时宿主机网络情况："><a href="#查看此时宿主机网络情况：" class="headerlink" title="查看此时宿主机网络情况："></a>查看此时宿主机网络情况：</h5><p><img src="/img/2022/docker-network/979767-20220704091721008-803339553.png"></p><p>宿主机多了两个 veth 网卡，这两个网卡就是和容器内部的 eth0 成对出现的，通过 <code>bridge-utils</code> 提供的命令也可以看到它们和 docker0 的连接关系。</p><h5 id="查看任意容器的详细信息："><a href="#查看任意容器的详细信息：" class="headerlink" title="查看任意容器的详细信息："></a>查看任意容器的详细信息：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect demo01</span><br></pre></td></tr></table></figure><p>找到网络配置部分，如下图所示：</p><p><img src="/img/2022/docker-network/979767-20220704091744085-427117787.png"></p><p>docker0 网卡的 IP 地址被作为容器的网关。</p><h5 id="测试容器和外部连通性："><a href="#测试容器和外部连通性：" class="headerlink" title="测试容器和外部连通性："></a>测试容器和外部连通性：</h5><p><img src="/img/2022/docker-network/979767-20220704091754258-1370297203.png"></p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host 网络模式的容器可直接使用宿主机的 IP 与外界通信，同时容器内的端口也直接使用宿主机的端口，无需额外 NAT 转换。创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定。</p><p><img src="/img/2022/docker-network/979767-20220704091804590-1310706088.png"></p><h4 id="测试示例"><a href="#测试示例" class="headerlink" title="测试示例"></a>测试示例</h4><h5 id="创建一个-Nginx-容器："><a href="#创建一个-Nginx-容器：" class="headerlink" title="创建一个 Nginx 容器："></a>创建一个 Nginx 容器：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --net host --<span class="built_in">rm</span> --name demo01 nginx</span><br></pre></td></tr></table></figure><p>查看端口使用情况：</p><p><img src="/img/2022/docker-network/979767-20220704091823317-1908177264.png"></p><p>可以发现 80 端口已经在宿主机启动。</p><h5 id="查看容器的网络信息："><a href="#查看容器的网络信息：" class="headerlink" title="查看容器的网络信息："></a>查看容器的网络信息：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect demo01</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-network/979767-20220704091834984-308810944.png"></p><p>网络模式已经成为 host，且本身没有 IP 信息。</p><h5 id="测试端口占用信息："><a href="#测试端口占用信息：" class="headerlink" title="测试端口占用信息："></a>测试端口占用信息：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --net host --<span class="built_in">rm</span> --name demo02 nginx</span><br></pre></td></tr></table></figure><p>容器无法运行，查看日志提示端口被占用。</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>none 网络模式是指禁用网络功能，只有 lo 本地环回接口。在创建容器时通过参数 <code>--net none</code> 或 <code>--network none</code> 指定。</p><p>创建一个测试容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it --<span class="built_in">rm</span> none --name demo01 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>查看网络信息：</p><p><img src="/img/2022/docker-network/979767-20220704091946328-1290620573.png"></p><p>该容器无法和宿主机通信。</p><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>Container 网络模式是 docker 中一种较为特别的网络的模式。在创建容器时通过参数 –net container:已运行的容器名称|ID 或者 –network container:已运行的容器名称|ID 指定。</p><p>处于这个模式下的容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。</p><p>Container 网络模式下，新创建的容器不会创建自己的网卡，而是和一个指定的容器共享 IP、端口范围等。除了网络方面相同之外，其它都是隔离的。</p><p>其原理大致如下：</p><p><img src="/img/2022/docker-network/979767-20220704091956538-381437287.png"></p><h4 id="测试示例-1"><a href="#测试示例-1" class="headerlink" title="测试示例"></a>测试示例</h4><h5 id="创建一个-bridge-网络模式的容器："><a href="#创建一个-bridge-网络模式的容器：" class="headerlink" title="创建一个 bridge 网络模式的容器："></a>创建一个 bridge 网络模式的容器：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --name demo01 nginx</span><br><span class="line">docker container inspect demo01</span><br></pre></td></tr></table></figure><p>网络配置如下所示：</p><p><img src="/img/2022/docker-network/979767-20220704092014851-2142729234.png"></p><h5 id="创建一个-container-网络模式的容器："><a href="#创建一个-container-网络模式的容器：" class="headerlink" title="创建一个 container 网络模式的容器："></a>创建一个 container 网络模式的容器：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --<span class="built_in">rm</span> -it --net container:demo01 --name demo02 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>网络信息如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092044531-1942375962.png"></p><h5 id="此时删除-demo01-容器再查看-demo02-的网络："><a href="#此时删除-demo01-容器再查看-demo02-的网络：" class="headerlink" title="此时删除 demo01 容器再查看 demo02 的网络："></a>此时删除 demo01 容器再查看 demo02 的网络：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">rm</span> -f demo01</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-network/979767-20220704092105202-406328144.png"></p><p>网卡只剩下 lo 回环网卡。</p><p><code>docker container run --link</code></p><p>可以用来连接两个容器，能够实现被链接的容器（源容器）和主动去链接的容器（接收容器）之间互相通信，并且接收容器可以获取源容器的一些数据，如环境变量。不过该方法将来可能被 docker 废弃。</p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>docker 提供的默认网络模式使用起来比较简单，但是在实际应用中，为了保证应用的安全性，还是更推荐自定义网络来进行容器管理。并启用容器名称到容器 IP 的自动 DNS 解析。</p><blockquote><p>从 docker 1.10 版本开始，docker daemon 实现了一个内嵌 DNS Server，但只能在用户自定义的网络模式使用，它可以实现直接使用容器的名称进行通信。</p></blockquote><h4 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h4><p>使用命令直接创建一个自定义的 bridge 网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge hello_bridge</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092119145-1396915150.png"></p><p><code>-d，--driver</code> 参数可以指定网络模式，默认不指定就是 bridge 模式。</p><h4 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h4><p>再次创建一个自定义网络协助测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge world_bridge</span><br></pre></td></tr></table></figure><p>创建相关的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认网络</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --name demo01 busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># hello_bridge 网络</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --net hello_bridge --name demo02 busybox sh</span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --net hello_bridge --name demo03 busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># world_bridge 网络</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --net world_bridge --name demo04 busybox sh</span><br></pre></td></tr></table></figure><p>查看此时的网络情况</p><p><img src="/img/2022/docker-network/979767-20220704092152957-641815307.png"></p><p>可以发现 IP 多了一些的新的网段，同一网络模式的容器处于同一网段。</p><p>此时查看本机的网络情况：</p><p><img src="/img/2022/docker-network/979767-20220704092220944-1730385068.png"></p><p>可以发现多了两个类似于 docker0 网桥的网卡，都分配了新的网段。由此可以知道，每新建一个 bridge 网络，就会在宿主机新建一个 bridge 网桥，并分配一个新的网段。</p><p>测试网络连通性：</p><p>demo01 测试：</p><p><img src="/img/2022/docker-network/979767-20220704092233837-1409078039.png" alt="demo01 测试"></p><p>demo02 测试：</p><p><img src="/img/2022/docker-network/979767-20220704092243092-165781342.png" alt="demo02 测试"></p><p>剩下的就不做测试了，但是大致能得出以下结论：</p><ol><li>不同的网络之间是隔离的，无法互相通信。</li><li>在自定义网络中，容器可以使用容器名称直接通信。</li></ol><h4 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h4><p>可以将现有的容器连接到其它网络中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect bridge demo04</span><br></pre></td></tr></table></figure><p>此时查看网络情况：</p><p><img src="/img/2022/docker-network/979767-20220704092255464-1585960726.png"></p><p>可以发现限制 demo04 容器既属于默认 bridge 网络，也属于 world_bridge 网络了，这也就能和默认网络的 demo01 进行通信。</p><h4 id="断开网络"><a href="#断开网络" class="headerlink" title="断开网络"></a>断开网络</h4><p>可以连接网络自然也可以断开网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect bridge demo04</span><br><span class="line">docker network disconnect world_bridge demo04</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092305846-1244327742.png"></p><p>当连接的网络都断开之后，它的网络模式就像 none 网络了。</p><h4 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h4><p>对于没有使用的网络也可以进行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> world_bridge</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092318259-979745258.png"></p><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>当容器内部应用想要暴露给外部访问，就需要使用到 <code>-P</code> 或者 <code>-p</code> 参数来进行端口映射。</p><p>随机映射（-P）</p><p>使用 <code>-P</code> 参数能够随机映射一个 <code>32768</code> 以上的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --<span class="built_in">rm</span> -P --name demo01 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时查看容器详情：</p><p><img src="/img/2022/docker-network/979767-20220704092332863-390921249.png"></p><p>能够看到容器内部 nginx 的 80 端口以及被随机映射到了 49153 端口，可以使用宿主机加这个随机端口在浏览器进行访问。</p><h4 id="指定映射（-p）"><a href="#指定映射（-p）" class="headerlink" title="指定映射（-p）"></a>指定映射（-p）</h4><p>使用 <code>-p</code> 参数能够指定映射的端口，它的格式为：<code>监听IP:宿主机端口:容器端口</code>，<code>监听IP::容器端口</code>，<code>宿主机端口:容器端口</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整的监听映射</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;0.0.0.0:8080:80&quot;</span> --name demo01 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机映射</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;0.0.0.0::80&quot;</span> --name demo02 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通监听映射</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;8081:80&quot;</span> --name demo03 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口协议</span></span><br><span class="line">docker container run -d --<span class="built_in">rm</span> -p <span class="string">&quot;0.0.0.0:8080:80/udp&quot;</span> --name demo04 nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092343147-280600039.png"></p><p>如果有多个端口需要映射则指定多个 -p 即可。</p><p>也可以通过命令反查容器映射了哪些端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container port demo01</span><br><span class="line">docker container port demo01 80</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-network/979767-20220704092355495-1641775382.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源限制</title>
      <link href="/2022/docker-assets/index/"/>
      <url>/2022/docker-assets/index/</url>
      
        <content type="html"><![CDATA[<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p><code>cgroup</code>（control group，控制组） 是 Linux 内核的一个功能，可以用来限制、控制与分离一个进程组。Docker 就是通过 cgroup 来控制容器的 CPU、内存、磁盘输入输出等资源。</p><p>在默认情况下，Docker 容器是没有资源限制的，它会尽可能地使用宿主机能够分配给它的资源。如果不对容器资源进行限制，容器之间就会相互影响，一些占用硬件资源较高的容器会吞噬掉所有的硬件资源，从而导致其它容器无硬件资源可用，发生停服。</p><p>Docker 提供了限制内存，CPU 或磁盘 IO 的方法， 在 docker create 或者 docker run 的时候可以对容器所占用的硬件资源大小以及多少进行限制。</p><h3 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h3><p>默认情况下，所有容器可以平等地使用宿主机的 CPU 资源，如果想要限制 CPU 资源，可以使用以下参数进行限制。</p><h4 id="相对限制"><a href="#相对限制" class="headerlink" title="相对限制"></a>相对限制</h4><ul><li><p><code>-c</code> 或 <code>--cpu-shares</code>：用于多个容器运行时设置容器对于 CPU 的使用权重比例（共享权值）。</p><ul><li><p>Docker 默认每个容器的权值为<code>1024</code>。如果不指定或将其设置为 0，都将使用默认值。</p></li><li><p>当系统上运行了两容器，第一个权重是 1024，第二个权重是 512。第二个启动后没运行任何进程，第一个的进程很多。此时，第一个完全可以占用第二个的 CPU 空闲资源，这就是共享式 CPU 资源。如果第二个也跑了进程，那么就会把自己的 512 给要回来，按照正常权重1024:512 划分。</p></li><li><p>CPU 共享式证明了 CPU 为可压缩性资源。</p></li></ul></li><li><p><code>--cpus</code>：用于限制容器运行的核数。</p><ul><li>从 1.13 版本之后开始支持限定容器能使用的 CPU 核数，属于常用的限制手段之一。</li></ul></li><li><p><code>--cpuset-cpus</code>：用于限制容器运行的 CPU 核心。</p><ul><li>例如，主机有 4 个 CPU 核心，CPU 核心标识为 0-3，可以指定容器只在标识 0 和 3 的两个 CPU 核心上运行。</li></ul></li></ul><blockquote><p>通过 -c 设置的并不是 CPU 资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的 CPU 资源取决于它的分配的权重占所有容器总和的比例。换句话说，通过 -c 参数可以设置容器使用 CPU 的优先级。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定权重</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> -c 1024 --name demo01 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定核数，可以是 1.5 之类的小数</span></span><br><span class="line">docker container run -it --<span class="built_in">rm</span> --cpus=2 --name demo02 busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器在 CPU-1 和 CPU-3 上执行</span></span><br><span class="line">docker container run -it --cpuset-cpus=<span class="string">&quot;1,3&quot;</span> --name demo03 busybox /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器在 CPU-0、CPU-1 及 CPU-2 上执行</span></span><br><span class="line">docker container run -it --cpuset-cpus=<span class="string">&quot;0-2&quot;</span> --name demo04 busybox /bin/sh</span><br></pre></td></tr></table></figure><h4 id="绝对限制"><a href="#绝对限制" class="headerlink" title="绝对限制"></a>绝对限制</h4><p>Linux 通过 <code>CFS</code>（Completely Fair Scheduler，完全公平调度器）来调度各个进程对 CPU 的使用。CFS 默认的调度周期是 <code>100ms</code>。</p><p>我们可以通过设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少 CPU 时间来达到限制 CPU 的目的。具体参数如下：</p><ul><li><p><code>--cpu-period</code>：设置每个容器进程的调度周期，单位 us。</p></li><li><p><code>--cpu-quota</code>：设置在每个周期内容器能使用的 CPU 时间，单位 us。</p></li></ul><p>示例 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 CFS 调度周期设为 50000，将每个周期内的 CPU 配额设置为 25000</span></span><br><span class="line">docker run -it --cpu-period=50000 --cpu-quota=25000 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>该配置表示该容器每 50ms 可以得到 50% 的 CPU 运行时间。</p><p>示例 2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器的 CPU 配额设置为 CFS 周期的两倍</span></span><br><span class="line">docker run -it --cpu-period=10000 --cpu-quota=20000 busybox /bin/sh</span><br></pre></td></tr></table></figure><p>CPU 使用时间是周期的两倍，意味着给容器分配了两个 CPU。容器可以在每个周期内使用两个 CPU 的 100% 时间。</p><p>CFS 周期的有效范围是 1ms<del>1s，对应的 –cpu-period 的数值范围是 1000</del>1000000。</p><p>容器的 CPU 配额必须不小于 1ms，即 –cpu-quota 的值必须 &gt;&#x3D; 1000。</p><p>–cpu-quota 设置容器在一个调度周期内能使用的 CPU 时间实际上是一个上限时间，并不是说容器一定会使用这么长的 CPU 时间。</p><h3 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h3><p>在默认的情况下，容器的内存是没有限制的。也是就说，如果不限制，容器将能使用宿主机能够调用的最大内存。</p><p>这在生产环境是非常危险的行为，很容易造成宿主机 OOM（内存溢出），然后为了释放内存空间而杀掉一些其它进程，这其中可能包含 docker daemon 进程（docker 对优先级做了调整，一般杀不到它）。但这在生产中是绝对不允许的。</p><p>可以通过两个参数限制内存：</p><ul><li><code>-m，--memory</code>：设置内存使用限额，例如：100MB，1GB。</li><li><code>--memory-swap</code>：设置内存 + Swap 的是使用限额。<br>默认情况下，两个参数的值都是<code>-1</code>。但是如果在启动是指定了<code>-m</code>，那么<code>--memory-swap</code>会是<code>-m</code>的两倍。</li></ul><p>限制内存使用的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许容器使用 100M 内存和 100M Swap</span></span><br><span class="line">docker container run -d -m 100m --name demo01 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许容器使用 100M 内存和 200M Swap</span></span><br><span class="line">docker container run -d -m 100m --memory-swap 300m --name demo02 nginx</span><br></pre></td></tr></table></figure><p>如果发生内存溢出错误，内核将 kill 掉容器中的进程。可以使用 <code>--oom-kill-disable</code> 参数控制。</p><h3 id="磁盘-IO-限制"><a href="#磁盘-IO-限制" class="headerlink" title="磁盘 IO 限制"></a>磁盘 IO 限制</h3><p>Block IO 是另一种可以限制容器使用的资源。Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽。</p><ul><li><code>bps</code>： byte per second，表示每秒读写的数据量。</li><li><code>iops</code>：io per second，表示每秒的输入输出量（或读写次数）。<br>目前 Block IO 限额只对 direct IO（不使用文件缓存）有效。</li></ul><p>支持如下参数：</p><ul><li><code>--blkio-weight</code>：用于改变容器的权重，类似于 CPU 限制的 -c 参数，默认值为 500。</li><li><code>--device-read-bps</code>：限制读某个设备的 bps。</li><li><code>--device-write-bps</code>：限制写某个设备的 bps。</li><li><code>--device-read-iops</code>：限制读某个设备的 iops。</li><li><code>--device-write-iops</code>：限制写某个设备的 iops。</li></ul><p>使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制读写权重</span></span><br><span class="line">docker container run -d --blkio-weight 500 --name demo01 nginx</span><br><span class="line">docker container run -d --blkio-weight 250 --name demo02 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制磁盘 /dev/sda 写带宽为 30M</span></span><br><span class="line">docker container run -d --device-write-bps /dev/sda:30MB --name demo03 nginx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据持久化</title>
      <link href="/2022/docker-volume/index/"/>
      <url>/2022/docker-volume/index/</url>
      
        <content type="html"><![CDATA[<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>默认情况下，容器被删除，容器中数据也会随着一起删除。这对于某些重要的数据是绝对不允许的。此时就需要对数据进行持久化。<br><code>数据卷</code>是一个可以提供给一个或者多个容器使用的特殊目录，它绕过 UFS，能提供以下特性：</p><ul><li>多个容器可以共享和重用。</li><li>对数据卷的修改会马上生效。</li><li>对数据卷的更新不会影响镜像。</li><li>数据卷会一直存在，即使删除容器。</li></ul><p>常用的数据卷操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个数据卷</span></span><br><span class="line">docker volume create demo_volume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据卷详情</span></span><br><span class="line">docker volume inspect demo_volume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> demo_volume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除没用的数据卷</span></span><br><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-volume/979767-20220616225959742-922397250.png"></p><p>启动一个挂载了数据卷的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --mount <span class="built_in">source</span>=demo02_volume,target=/usr/share/nginx/html --name demo02 nginx</span><br></pre></td></tr></table></figure><p>如图所示 ：</p><p><img src="/img/2022/docker-volume/979767-20220616230012670-157780076.png"></p><p>配置说明：</p><ul><li><code>--mount</code>：用于标记挂载数据卷到容器中，可以有多个。</li><li><code>source</code>：指定数据卷，如果数据卷不存在，则会自动创建。</li><li><code>target</code>：指定容器内挂载的目录。</li></ul><p>查看容器相关信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect demo02</span><br></pre></td></tr></table></figure><p>其中挂载部分内容如下</p><p><img src="/img/2022/docker-volume/979767-20220616230025341-858480054.png"></p><blockquote><p>数据卷是用来持久化容器数据的，它的生命周期独立于容器之外。</p></blockquote><p>如果在删除容器的时候想要一并删除存储卷的话，只需要<code>docker container rm -v</code>即可。</p><h3 id="挂载主机目录和文件"><a href="#挂载主机目录和文件" class="headerlink" title="挂载主机目录和文件"></a>挂载主机目录和文件</h3><p>使用<code>--mount</code>参数除了能够挂载数据卷，还能挂载本机的目录到容器中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp,target=/usr/share/nginx/html,<span class="built_in">readonly</span> --name demo03 nginx</span><br></pre></td></tr></table></figure><p>需要注意：</p><ul><li>默认情况下，<code>--mount</code>挂载的数据卷<code>volume</code>，如果需要挂载目录，需要指定<code>type=bind</code>。</li><li>source 在 bind 挂载中必须事先存在。</li><li>在挂载最后可以加上<code>readonly</code>，标识容器对该目录只读。</li></ul><p>此时进入容器测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">exec</span> -it demo03 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-volume/979767-20220616230042565-21286420.png"></p><p>可以发现，文件是宿主机的 &#x2F;tmp 下面的文件，并且只读无法创建文件。</p><p>当然，也可以单独只挂载某个文件，但是前提是这个文件事先得存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp/1.txt,target=/root/.bash_history --name demo04 nginx</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-volume/979767-20220616230056286-1861018710.png"></p><p>历史命令就能被记录到本地。</p><h3 id="其它挂载方式"><a href="#其它挂载方式" class="headerlink" title="其它挂载方式"></a>其它挂载方式</h3><p>除了<code>--mount</code>以外，还有<code>-v</code>，<code>--volume</code>的方式挂载数据卷，使用方法类似。示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载目录并只读</span></span><br><span class="line">docker container run -d -v /tmp:/usr/share/nginx/html:ro --name demo05 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载文件</span></span><br><span class="line">docker container run -d -v /tmp/1.txt:/root/.bash_history --name demo08 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载一个随机生成的数据卷到指定目录</span></span><br><span class="line">docker container run -d -v /usr/share/nginx/html --name demo06 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载一个已经存在的数据卷到指定目录</span></span><br><span class="line">docker container run -d -v demo02_volume:/usr/share/nginx/html --name demo07 nginx</span><br></pre></td></tr></table></figure><p>使用方法类似，而且在<code>Dockerfile</code>中的<code>VOLUME</code>指令就能定义。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>镜像制作</title>
      <link href="/2022/docker-image/index/"/>
      <url>/2022/docker-image/index/</url>
      
        <content type="html"><![CDATA[<h4 id="利用-Commit-制作镜像"><a href="#利用-Commit-制作镜像" class="headerlink" title="利用 Commit 制作镜像"></a>利用 Commit 制作镜像</h4><p>在容器管理章节有提到使用现有的容器制作镜像，但是这在真正的工作中明显是不合适的。使用<code>docker commit</code>意味着所有对镜像的操作都是黑箱操作，生成的镜像被称为<code>黑箱镜像</code>。</p><p>换句话说，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。即使是制作人，过段时间后也无法记清具体的操作。这种镜像维护起来非常痛苦。</p><p>而且，由于镜像分层存储的特点，除当前层外，之前的每一层都是不会发生改变的，这意味着任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。即使是删除，上一层的东西也并不会丢失。镜像会越来越臃肿。</p><p>同时还有另外一个问题，容器中某些进程可能是动态的，过段时间会退出。如果使用 commit 制作镜像，这些进程可能不会保存到镜像中。</p><h4 id="利用-Dockerfile-制作镜像"><a href="#利用-Dockerfile-制作镜像" class="headerlink" title="利用 Dockerfile 制作镜像"></a>利用 Dockerfile 制作镜像</h4><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果能把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那之前 Commit 的无法重复、镜像构建透明性、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code>。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<code>指令（Instruction）</code>，每一条指令构建一层。</p><p>以定制一个 <code>nginx</code> 镜像为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录专门用于存放相关的 Dockerfile</span></span><br><span class="line"><span class="built_in">mkdir</span> -p nginx/v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Dockerfile</span></span><br><span class="line"><span class="built_in">cd</span> nginx/v1.0/</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;Hello Docker&lt;/h1&gt;&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>这就是一个最简单的 Dockerfile，以 nginx 镜像为基础镜像，然后修改镜像中的 html 文件，形成新的镜像。</p><p>上面提到了基础镜像，我们可以以任何镜像为基础镜像，在它的上面进行操作形成新的镜像，Docker 官方也提供了很多精简的基础镜像，可以拿来直接使用。</p><p>在编辑好 Dockerfile 之后，就进入镜像制作的步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t trover/nginx:v1.0 .</span><br></pre></td></tr></table></figure><p>注意最后那个<code>.</code>不能掉。</p><p><img src="/img/2022/docker-image/979767-20220615225133950-1185740767.png"></p><p>可以发现，镜像构建的时候有两层，一层是<code>FROM</code>，一层是<code>RUN</code>。这也印证了上面说的每一个关键字就是一层。</p><h4 id="镜像构建上下文"><a href="#镜像构建上下文" class="headerlink" title="镜像构建上下文"></a>镜像构建上下文</h4><p>关于 build 命令最后那个<code>.</code>，其实不是指 Dockerfile 的路径，而是指定<code>上下文路径</code>。</p><p>想要理解上下文，首先要理解<code>docker build</code>的工作原理：</p><p>Docker 的运行分为服务端 Docker 引擎（守护进程）和客户端工具。服务端 Docker 引擎提供了一组 REST API，称为<code>Docker Remote API</code>。docker 命令这样的客户端工具就是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p><p>虽然表面上是在本机执行的各种 docker 功能，但实际上一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让操作远程服务器的 Docker 引擎变得轻而易举。</p><p>在进行镜像构建时，并非所有定制都会通过<code>RUN</code>指令完成，经常会需要将一些本地文件复制进镜像，比如通过<code>COPY</code>指令、<code>ADD</code>指令等。而 build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>以 Dockerfile 为例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure><p>该指定并不是复制当前目录的 package.json 文件，也不是 Dockerfile 所在目录的 package.json 文件，而是上下文目录中的 package.json。</p><p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是为何<code>COPY ../package.json /app</code>或者<code>COPY /opt/xxxx /app</code>无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>通过 build 命令输出的第一行也可以看到发送上下文的过程：</p><blockquote><p>Sending build context to Docker daemon 2.048 kB</p></blockquote><p>所以，制作 Dockerfile 的目录尽量满足以下需求：</p><ul><li>一个空目录。</li><li>将所有需要的文件都复制一份到当前目录。</li><li>如果目录下有文件不需要被发送到 Docker 引擎，可以创建一个类似<code>.gitignore</code>一样语法的文件<code>.dockerignore</code>。<br>默认情况下，如果不特殊指定 Dockerfile 路径，默认会将上下文路径中的名为 Dockerfile 的文件作为 Dockerfile。</li></ul><p>Dockerfile 也并非文件就要叫 Dockerfile，可以通过 -f 指定其它文件，但是一般不这样做。</p><h4 id="Dockerfile（FROM）"><a href="#Dockerfile（FROM）" class="headerlink" title="Dockerfile（FROM）"></a>Dockerfile（FROM）</h4><p>FROM 指令是 Dockerfile 最基础的关键字，用于指定基础镜像。格式为：<code>FROM &lt;基础镜像&gt;</code></p><p>如果你自己想做一个基础镜像，则可以使用<code>FROM scratch</code>，scratch 镜像是 Docker 官方提供的一个虚拟空白镜像。</p><p>基础镜像意味着不以任何系统为基础，直接将可执行文件复制到镜像中，该文件包含了运行所需的所有库。这样镜像会更小，非常适合 Go 语言开发的程序。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br></pre></td></tr></table></figure><h4 id="Dockerfile（LABEL）"><a href="#Dockerfile（LABEL）" class="headerlink" title="Dockerfile（LABEL）"></a>Dockerfile（LABEL）</h4><p>LABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata），在旧版本中叫 MATAINER。格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p><p>通过 LABEL 标签能够让别人更清楚你这镜像。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> name=<span class="string">&quot;Trover&quot;</span> \</span></span><br><span class="line"><span class="language-bash">email=<span class="string">&quot;admin@buerya.cn&quot;</span></span></span><br><span class="line">desc=<span class="string">&quot;Dockerfile demo&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（RUN）"><a href="#Dockerfile（RUN）" class="headerlink" title="Dockerfile（RUN）"></a>Dockerfile（RUN）</h4><p>RUN 指令用来执行命令行命令。由于命令行的强大能力，<code>RUN</code>指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li>shell 格式：<code>RUN 命令</code></li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code><br>由于 Dockerfile 中每个关键字就是一层，Union FS 会有最大层数限制，以 AUFS 为例，最大支持 127 层。为了减少镜像的层数，一般使用<code>&amp;&amp;</code>连接多个命令，<code>\</code>进行换行，提高阅读性。</li></ul><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> / &amp;&amp; yum -y install nginx \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">cd</span> /etc/nginx \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">rm</span> -f nginx.conf</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（WORKDIR）"><a href="#Dockerfile（WORKDIR）" class="headerlink" title="Dockerfile（WORKDIR）"></a>Dockerfile（WORKDIR）</h4><p>WORKDIR 指令用于指定工作目录（或称当前目录），以后各层的当前目录就被改为指定的目录，如果该目录不存在，WORKDIR 会自动创建。格式为：WORKDIR &lt;工作目录路径&gt;</p><blockquote><p>WORKDIR 目录 不等于 RUN cd 目录，前者会对后面的所有镜像层产生影响，后者只对当前层，对于下一层并不会 cd 进目录。</p></blockquote><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br><span class="line"><span class="comment"># 最后输出目录为 /a/b/c</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（COPY）"><a href="#Dockerfile（COPY）" class="headerlink" title="Dockerfile（COPY）"></a>Dockerfile（COPY）</h4><p>COPY 指令用于将构建上下文目录中的源文件或目录拷贝到镜像中的指定目录，支持两种格式。</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code><br>源路径可以是多个，甚至使用通配符。目标路径可以是容器中绝对路径，也可以是 WORKDIR 的相对路径。目标路径不存在会自动创建。</li></ul><p>COPY 指令能保留文件的各种元数据，比如创建时间，读写权限等。如果源文件为目录，其实质是将目录中的文件拷贝到镜像中的新目录中。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /usr/src/app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝多个文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package* /usr/src/app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝并修改权限</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=myuser:mygroup package* /usr/src/app/</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ADD）"><a href="#Dockerfile（ADD）" class="headerlink" title="Dockerfile（ADD）"></a>Dockerfile（ADD）</h4><p>ADD 指令和 COPY 类似，但不推荐使用，因为没有 COPY 定义明确。格式为：<code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></p><p>ADD 源路径支持 URL，Docker 会去指定的 URL 下载文件，并保存成 600 权限，如果 URL 是压缩也文件不会解压。所以这种需求使用 RUN 指令更好。</p><p>如果本地源文件是 tar，gzip，bzip2，xz 等格式的压缩文件，ADD 会自动解压。但如果只想复制一个压缩文件进去，则不能使用 ADD 指令。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ubuntu.tar.gz /app/</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ENV）"><a href="#Dockerfile（ENV）" class="headerlink" title="Dockerfile（ENV）"></a>Dockerfile（ENV）</h4><p>ENV 指令用于设置环境变量，在后面的指令中可以直接使用<code>$&#123;变量名&#125;</code>的方式引用，容器中也可以看到。支持两种格式。</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code><br>通过环境变量的定义能够使 Dockerfile 更加灵活。</li></ul><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="string">&quot;1.0&quot;</span> \</span><br><span class="line">NAME=<span class="string">&quot;Dy1an&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span></span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ARG）"><a href="#Dockerfile（ARG）" class="headerlink" title="Dockerfile（ARG）"></a>Dockerfile（ARG）</h4><p>ARG 指令功能和 ENV 类似，用于定义构建参数。不同在于 ARG 设置的是构建环境的环境变量，在容器运行时这些变量不会存在。格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>该默认值可以在<code>docker build</code>中使用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖，起到传参构建的目的。</p><p>ARG 指令有作用范围，如果是在 FROM 之前使用，则只能 FROM 指令中使用该变量。想要继续使用就得重新定义。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br></pre></td></tr></table></figure><h4 id="Dockerfile（USER）"><a href="#Dockerfile（USER）" class="headerlink" title="Dockerfile（USER）"></a>Dockerfile（USER）</h4><p>USER 指令指定当前用户和用户组，影响范围和 WORKDIR 类似。格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p>USER 指令只是切换用户，所以这个用户必须先创建好。</p><p>如果脚本是 root 运行，但是容器中启动服务需要使用其他用户，建议下载<code>gosu</code>代替原本的 su 或者 sudo，可以避免很多问题。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -r -g nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nginx <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;nginx&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（EXPOSE）"><a href="#Dockerfile（EXPOSE）" class="headerlink" title="Dockerfile（EXPOSE）"></a>Dockerfile（EXPOSE）</h4><p>EXPOSE 指令用于声明容器运行时提供服务的端口，只是声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p><p>在 Dockerfile 中写入这样的声明有两个好处：</p><p>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口。<br>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（CMD）"><a href="#Dockerfile（CMD）" class="headerlink" title="Dockerfile（CMD）"></a>Dockerfile（CMD）</h4><p><code>CMD</code> 指令用于指定容器默认的主进程启动命令。和 RUN 类似，支持两种格式：</p><ul><li>shell 格式：<code>CMD &lt;命令&gt;</code></li><li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code><br>推荐使用 exec 格式，因为 shell 格式也会被 docker 转换成 exec 格式，比如：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"><span class="comment"># 会被转换成</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;Hello&#x27;&quot;</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>exec 格式在解析时会被解析为 JSON 数组，因此一定要使用双引号<code>&quot;</code>，而不要使用单引号。</p></blockquote><p>在容器运行时，可以指定新的命令来替代镜像中设置的 CMD 默认命令。</p><p>比如：ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，run -it 启动会直接进入容器的 bash。可以在运行时指定其它命令，如<code>docker run -it ubuntu cat /etc/os-release</code>的方式替换掉默认的<code>/bin/bash</code>命令。</p><p>注意：</p><blockquote><p>docker 不是虚拟机，容器中的应用都应该以前台执行，不能用 systemd 去启动后台服务，容器内没有后台服务的概念。</p></blockquote><p>如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> service nginx start</span></span><br></pre></td></tr></table></figure><p>这样的容器启动后立即退出，即使是进入容器内使用<code>systemctl</code>也一样。</p><p>对于容器而言，启动命令就是容器的应用进程，容器为主进程而存在，主进程退出，容器就失去了存在的意义，从而跟着退出，其它进程它不关心。</p><p>所以，使用<code>service nginx start</code>命令希望以后台守护进程形式启动 nginx。而 CMD 会被转换成<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>。此时主进程实际上是<code>sh</code>。那么当 service nginx start 命令结束后，sh 主进程也就结束了，容器自然就会跟着退出。</p><p>正确的做法是以前台的方式直接启动：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（ENTRYPOINT）"><a href="#Dockerfile（ENTRYPOINT）" class="headerlink" title="Dockerfile（ENTRYPOINT）"></a>Dockerfile（ENTRYPOINT）</h4><p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。它的启动命令也是可以被替换的，不过比 CMD 繁琐，需要通过 docker run 的参数 –entrypoint 来指定。和 RUN 一样，也是支持两种格式。</p><p>相较于 CMD，ENTRYPOINT 常用于解决以下问题：</p><h5 id="1-能够实现灵活的传参功能"><a href="#1-能够实现灵活的传参功能" class="headerlink" title="1. 能够实现灵活的传参功能"></a>1. 能够实现灵活的传参功能</h5><p>一个简单的 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该镜像用于输出当前公网 IP</span></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>使用<code>docker build -t myip</code>. 生成 myip 镜像，然后使用 <code>docker run myip</code> 运行。这个 docker 就能变成一个类似于查询公网 IP 的命令。</p><p>但是如果此时需求变得复杂，需要在镜像的 curl 中加入<code>-i</code>参数输出请求头信息。</p><p>直接使用<code>docker run myip -i</code>会报错：executable file not found。原因在于镜像后面的参数会被当成命令替换掉 CMD 中的内容，而 CMD 第一个参数是可执行文件，-i 显然不是可执行文件，所以报错。</p><p>如果将 CMD 换成 ENTRYPOINT：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该镜像用于输出当前公网 IP</span></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>此时再次执行 <code>docker run myip -i</code> 就能正常使用。原因在于，-i 参数会替换 CMD 中的内容，但是在定义了 ENTRYPOINT 的 Dockerfile 中，CMD 中的所有内容会成为参数传递给 ENTRYPOINT，这就实现了灵活参数的功能。</p><h5 id="2-通过判断不同的传参干不同的事情"><a href="#2-通过判断不同的传参干不同的事情" class="headerlink" title="2. 通过判断不同的传参干不同的事情"></a>2. 通过判断不同的传参干不同的事情</h5><p>生产中有这样一类场景，某些镜像的运行方案可能不一定，用户可以传递相关的参数修改容器的运行方式。由于在 ENTRYPOINT 加入了逻辑判断等操作，再写命令或者 exec 格式显然不适合，所以需要使用脚本的格式。 然后将 CMD 的内容作为参数传给它。</p><p>一个简单的 Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝脚本到镜像中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-entrypoint.sh /usr/local/bin/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>docker-entrypoint.sh：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;hello&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile（VOLUME）"><a href="#Dockerfile（VOLUME）" class="headerlink" title="Dockerfile（VOLUME）"></a>Dockerfile（VOLUME）</h4><p>VOLUME 指令用于挂在一个或多个存储卷，格式如下：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code><br>容器运行时应尽量保持容器存储层不发生写操作，但数据写入往往又是不可避免的。</li></ul><p>为了防止运行时用户忘记将动态文件所保存的目录挂载为卷，可以在<code>Dockerfile</code>中事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br></pre></td></tr></table></figure><p>这里的<code>/data</code>目录就会在容器运行时自动挂载为匿名卷，任何向<code>/data</code>中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以通过<code>-v</code>参数覆盖这个挂载设置。</p><p>后面会对存储卷进行详细的说明。</p><h4 id="Dockerfile（HEALTHCHECK）"><a href="#Dockerfile（HEALTHCHECK）" class="headerlink" title="Dockerfile（HEALTHCHECK）"></a>Dockerfile（HEALTHCHECK）</h4><p>HEALTHCHECK 指令用于告诉 Docker 应该如何进行判断容器的状态是否正常，在 Docker 1.12 引入。支持以下格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br>在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁或死循环状态，应用进程并不会退出，容器已经无法提供服务，却并不会被重新调度。HEALTHCHECK 指令的价值就在于能够比较真实的反应容器实际状态。</li></ul><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 后，用其启动容器，初始状态会为<code>starting</code>，在 <code>HEALTHCHECK</code> 检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。</p><p>HEALTHCHECK 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为<code>unhealthy</code>，默认 3 次<br>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</li></ul><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>容器运行后，使用 docker container ls 就可以看到健康状态。使用 docker container inspect xxx 可以看到检测信息。</p><h4 id="Dockerfile（SHELL）"><a href="#Dockerfile（SHELL）" class="headerlink" title="Dockerfile（SHELL）"></a>Dockerfile（SHELL）</h4><p>SHELL 指令用于指定 RUN，ENTRYPOINT，CMD 指令的 shell，Linux 中默认为<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>。格式为：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br></pre></td></tr></table></figure><pre><code># 命令最终会被解析为：/bin/sh -cex &quot;nginx&quot;ENTRYPOINT nginx</code></pre><h4 id="Dockerfile（ONBUILD）"><a href="#Dockerfile（ONBUILD）" class="headerlink" title="Dockerfile（ONBUILD）"></a>Dockerfile（ONBUILD）</h4><p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等。这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h4 id="Dockerfile-建议"><a href="#Dockerfile-建议" class="headerlink" title="Dockerfile 建议"></a>Dockerfile 建议</h4><p>在制作 Dockerfile 的时候，应该尽可能的遵守一些约定俗称的方法和建议：</p><ul><li>容器应该是短暂的<ul><li>通过 Dockerfile 构建的镜像生命周期不宜过长，容器从销毁到创建都应该将工作量将到最小。</li></ul></li><li>增加 .dockerigonre 文件<ul><li>每一个单独的项目都应该有一个单独的目录并创建一个 .dockerignore 文件用于忽略不需要的文件或目录，构建镜像所需的文件都应该存放到该目录下。</li></ul></li><li>避免不必要的文件，使用多阶段构建<ul><li>在 Dockerfile 的每一层定义中，在进入下一层之前，都需要删除掉其它不需要的文件，以此尽可能的减小镜像的体积。</li><li>比如通过 Dockerfile 直接完成打包，运行，打包这一步除了打出来的包其它的文件其实都是没用的，此时就是和多阶段构建。</li><li>示例：</li></ul></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段，打包。使用 as 对阶段进行命名，每一个 FROM 就是一个阶段</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.7</span>.<span class="number">3</span> as build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v golang.org/x/net/html  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go    .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段，运行。</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"><span class="comment"># 从第一阶段中拷贝打好的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>] </span></span><br></pre></td></tr></table></figure><pre><code>此时 build 镜像的话，镜像中就不会包含第一节点的内容，包也尽可能的减小了。</code></pre><ul><li>一个容器只运行一个进程<ul><li>应该保证每个容器只有一个进程，多个进程解耦到不同容器中，便于后续的扩展。</li></ul></li><li>将多行参数排序<ul><li>某些参数太多太长需要换行的，尽可能按照字母顺序排序，这样可以避免重复。</li></ul></li><li>使用构建缓存<ul><li>在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 –no-cache&#x3D;true 选项。</li></ul></li></ul><h4 id="完整的-Dockerfile-示例"><a href="#完整的-Dockerfile-示例" class="headerlink" title="完整的 Dockerfile 示例"></a>完整的 Dockerfile 示例</h4><p>以下是一些常见的 Dockerfile 示例：</p><ol><li>TOMCAT部署镜像：</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础就像</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义元数据</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> auhtor=<span class="string">&quot;Dy1an&quot;</span> \</span></span><br><span class="line"><span class="language-bash">email=<span class="string">&quot;1214966109@qq.com&quot;</span> \</span></span><br><span class="line"><span class="language-bash">desc=<span class="string">&quot;TOMCAT demo Dockerfile&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH=/ops \</span><br><span class="line">ENV_PATH=$&#123;WORK_PATH&#125;/<span class="keyword">env</span> \</span><br><span class="line">SERVICE_PATH=$&#123;WORK_PATH&#125;/service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 JDK</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u11-linux-x64.tar.gz <span class="variable">$&#123;ENV_PATH&#125;</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 TOMCAT</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.22.tar.gz <span class="variable">$&#123;SERVICE_PATH&#125;</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ROOT.war <span class="variable">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;SERVICE_PATH&#125;</span>/webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压安装包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> unzip ROOT.war -d ROOT &amp;&amp; <span class="built_in">rm</span> -f ROOT.war</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$&#123;ENV_PATH&#125;/jdk1.<span class="number">8.0</span>_11 \</span><br><span class="line">CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar \</span><br><span class="line">CATALINA_HOME=$&#123;SERVICE_PATH&#125;/apache-tomcat-<span class="number">9.0</span>.<span class="number">22</span> \</span><br><span class="line">PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="variable">$&#123;CATALINA_HOME&#125;</span>/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -f <span class="variable">$&#123;CATALINA_HOME&#125;</span>/logs/catalina.out</span></span><br></pre></td></tr></table></figure><ol start="2"><li>我参与的一个github项目 <a href="https://github.com/BaoXuebin/beancount-gs/issues/23#issuecomment-1194917665">beancount-gs</a></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> BEANCOUNT_VERSION=<span class="number">2.3</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">ARG</span> GOLANG_VERSION=<span class="number">1.17</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> golang:$&#123;GOLANG_VERSION&#125; AS go_build_env</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct \</span><br><span class="line">    GIN_MODE=release \</span><br><span class="line">    CGO_ENABLED=<span class="number">0</span> \</span><br><span class="line">    PORT=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> https://github.com/BaoXuebin/beancount-gs.git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build/beancount-gs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p public/default_icons &amp;&amp; <span class="built_in">cp</span> -rn public/icons/* public/default_icons</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:latest as build_env</span><br><span class="line"><span class="keyword">ARG</span> BEANCOUNT_VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH <span class="string">&quot;/app/bin:$PATH&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 -mvenv /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> https://github.com/beancount/beancount</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /tmp/build/beancount</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git checkout <span class="variable">$&#123;BEANCOUNT_VERSION&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CFLAGS=-s pip3 install -U /tmp/build/beancount</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 uninstall -y pip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> find /app -name __pycache__ -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf -v &#123;&#125; +</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build_env /app /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=go_build_env /tmp/build/beancount-gs /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -rn /app/public/default_icons/* /app/public/icons</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH <span class="string">&quot;/app/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/app/beancount-gs&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;80&quot;</span>]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器管理</title>
      <link href="/2022/docker-container/index/"/>
      <url>/2022/docker-container/index/</url>
      
        <content type="html"><![CDATA[<h4 id="查看容器-ps"><a href="#查看容器-ps" class="headerlink" title="查看容器(ps)"></a>查看容器(ps)</h4><p>在运行容器之前，我们需要知道如何查看运行中的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker container ps</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>使用此方法只能看到运行中的容器，对于以及停止的容器，还需要使用<code>-a</code>参数，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ps -a</span><br></pre></td></tr></table></figure><h4 id="容器运行-run-无参数"><a href="#容器运行-run-无参数" class="headerlink" title="容器运行(run, 无参数)"></a>容器运行(run, 无参数)</h4><p>前面有说过，容器是镜像的实例。学习 docker 最终目的就是就是运行它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>运行第一个测试容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker container run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230044356-1739155940.png"></p><p>hello-world 容器是一个测试容器，在输出一些文字之后就会退出，通过这个过程，我们可以发现：</p><ol><li>对于运行容器，如果镜像不存在，则会去 registry 中自动下载。</li><li>使用 ps 查看容器的时候，如果不使用 -a 参数是看不到状态属于 Exited 的容器的。</li><li>使用 ps 可以简单的看到容器的 ID，使用的镜像，执行的命令，创建时间，运行状态，端口，容器的名字等信息。</li></ol><h4 id="容器运行（run-d，守护态）"><a href="#容器运行（run-d，守护态）" class="headerlink" title="容器运行（run -d，守护态）"></a>容器运行（run -d，守护态）</h4><p>在运行容器时，需要确定这个容器是运行在前台模式还是后台模式。</p><p><code>-d，--detach</code>，守护态运行。能够将容器运行在后台模式。这样所有的 IO 都只能通过网络资源或存储卷来进行交互。容器不再监听执行 docker run 这个命令行的窗口。有点类似于 Linux 启动程序时候的<code>nohup</code>或者<code> &amp;</code>组合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d hello-world</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230101520-12884147.png"></p><p>可以发现，hello-world 容器加了 -d 参数后不在输出它的信息，只是返回了一长串字符，其实就是完整的 Container ID，用法类似 Image ID。</p><p>同时由于 hello-world 容器本身的特性，程序在后台执行完成之后就直接退出了，容器也跟着退出了。</p><p>再次运行以 nginx 容器为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230115647-335897184.png"></p><p>可以发现以下信息：</p><ol><li>由于没有跟 TAG，默认会以 latest 版本执行。在 docker 中，如果是运行 latest 版本，docker 都会去仓库试着拉取，而不是直接使用本地的镜像，因为本地的 latest 不一定是真正的 latest。</li><li>容器在运行之后会以前台模式运行，所有它 hung 在了命令行。</li><li>此时如果我们新开一个窗口来查看，可以发现容器处于 Up 状态，如下图所示：</li></ol><p><img src="/img/2022/docker-container/979767-20220613230139284-2045625911.png"></p><ol start="4"><li>如果我们去 docker run 的窗口使用 Ctrl + c 中断，然后再次查看容器运行状态，可以发现容器已经退出，这就是前台运行的问题，如图所示：</li></ol><p><img src="/img/2022/docker-container/979767-20220613230148765-1700841146.png"></p><p>如果使用后台运行模式运行该容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d nginx</span><br></pre></td></tr></table></figure><p>运行效果如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230204245-595295977.png"></p><p>容器被放在了后台运行，不会 hung 在命令行。当然所有的输出信息也不能直接看到了。</p><h4 id="容器运行（run-it，交互式运行）"><a href="#容器运行（run-it，交互式运行）" class="headerlink" title="容器运行（run -it，交互式运行）"></a>容器运行（run -it，交互式运行）</h4><p>在使用 -d 参数之后，容器就不会 hung 在命令行窗口，而是以后台方式运行。但是这同时也有一个问题，某些时候我们是需要进入容器查看相关启动等信息的。此时就需要另外的参数配合使用：</p><ul><li><code>-i，--interactive</code>：打开一个交互式界面。</li><li><code>-t，--tty</code>：打开一个 TTY 终端。<br>将这个两个参数结合就是打开一个交互式的 TTY 终端。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it nginx /bin/bash</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230217469-498760333.png"></p><p>通过该方法在创建容器的时候指定运行命令，然后以 bash 进入容器内部的命令行。可以发现：</p><ol><li>容器内部就是 linux 的目录结构，但是是一个很简化的 linux，很多基础命令都没有。</li><li>当退出容器命令行，容器也跟着退出。原因是我们重写容器内部的命令为 bash 之后，nginx 就没有启动了，当退出 bash 之后，容器内部就没有进程了，所有容器就退出了。</li><li>这种方式用的比较少，一般都是容器运行之后，使用专门的命令进入容器。</li></ol><h4 id="容器运行（run-–name，容器命名）"><a href="#容器运行（run-–name，容器命名）" class="headerlink" title="容器运行（run –name，容器命名）"></a>容器运行（run –name，容器命名）</h4><p>在创建容器的时候，如果不给容器指定一个名字，容器会生成一个随机的名字，一般都是以 xxx_xxx 的格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --name demo01 nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230241715-1635978379.png"></p><p>针对容器的名字，我们可以根据自己的需求指定相关的命名规范，以此来实现统一管理的目的。</p><h4 id="容器运行（run-–rm，退出删除）"><a href="#容器运行（run-–rm，退出删除）" class="headerlink" title="容器运行（run –rm，退出删除）"></a>容器运行（run –rm，退出删除）</h4><p>某些容器可能是一次性容器，在运行之后，容器退出。同时不保留在 ps 中，此时就需要使用到 <code>--rm</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --<span class="built_in">rm</span> --name rm_test hello-world</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230301553-222894916.png"></p><h4 id="容器运行（run-–restart，重启规则）"><a href="#容器运行（run-–restart，重启规则）" class="headerlink" title="容器运行（run –restart，重启规则）"></a>容器运行（run –restart，重启规则）</h4><p>为了保障在以外的停止之后能够自动恢复，就需要对它配置相关<code>--restart</code>规则：</p><ul><li><code>on-failure</code>：容器停止时，容器出现报错，则容器会被重启。但是如果 docker 服务被重启了该配置就不会生效。</li><li><code>unless-stopped</code>：容器停止，如果没有报错，则容器会被重启。即使重启了 docker 服务，该配置也生效。</li><li><code>always</code>：不管如何，容器只要停止就重启。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --restart always --name busybox_test busybox /bin/sh -c <span class="string">&quot;sleep 60&quot;</span></span><br></pre></td></tr></table></figure><p><code>busybox</code> 镜像是一个精简的 Linux，非常小，适合用来做测试。结果如下：</p><p><img src="/img/2022/docker-container/979767-20220613230318144-1256119776.png"></p><p>通过过一段时间查看，发现在容器内部 sleep 60 之后退出，然后被重启拉起一个新的。</p><p>以上就是容器运行的基本参数，至于容器的存储卷，网络等内容，后面会单独分节介绍。</p><h4 id="查看详情（inspect）"><a href="#查看详情（inspect）" class="headerlink" title="查看详情（inspect）"></a>查看详情（inspect）</h4><p>通过该命令可以查看容器的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect busybox_test</span><br></pre></td></tr></table></figure><p>详细信息中需要关注的点包括：</p><ul><li><code>Image</code>：使用的镜像。</li><li><code>Volumes</code>：数据存储卷。</li><li><code>IPAddress</code>：容器的 IP 地址。</li><li><code>Ports</code>：端口信息。</li></ul><h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h4><p>通过该命令可以查看容器的运行时状态，如 Up，Exited 等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器但不运行</span></span><br><span class="line">docker container create --name demo02 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker container start demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停容器</span></span><br><span class="line">docker container pause demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续运行容器</span></span><br><span class="line">docker container unpause demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker container stop demo02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker container restart demo02</span><br></pre></td></tr></table></figure><p>结果如图所示</p><p><img src="/img/2022/docker-container/979767-20220613230341164-1246990897.png"></p><h4 id="进入容器（attach）"><a href="#进入容器（attach）" class="headerlink" title="进入容器（attach）"></a>进入容器（attach）</h4><p>通过该命令可以连接到一个运行中的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container attach --sig-proxy=<span class="literal">false</span> demo02</span><br></pre></td></tr></table></figure><p>使用<code>--sig-proxy=false</code>的目的是为了避免<code>Ctrl + C</code>或者<code>Ctrl + D</code>使容器退出。</p><p>该命令会对容器进行监听，命令行处于交互式界面，此时从新窗口请求该容器的 nginx：</p><p><img src="/img/2022/docker-container/979767-20220613230358617-1596296745.png"></p><p>可以看到日志直接输出到屏幕，<code>Ctrl + C</code>就可以退出该界面且保持容器继续运行。</p><h4 id="进入容器（exec）"><a href="#进入容器（exec）" class="headerlink" title="进入容器（exec）"></a>进入容器（exec）</h4><p>上面的方法是将输出直接输出到屏幕上，无法操作，如果想将容器当虚拟机一样使用，则需要 exec：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it demo02 /bin/bash</span><br></pre></td></tr></table></figure><p>注意，exec 后面需要跟执行命令，由于是命令行，则需要使用 &#x2F;bin&#x2F;bash 或者 &#x2F;bin&#x2F;sh。</p><p><img src="/img/2022/docker-container/979767-20220613230414251-864497271.png"></p><h4 id="查看日志（logs）"><a href="#查看日志（logs）" class="headerlink" title="查看日志（logs）"></a>查看日志（logs）</h4><p>通过该命令可以实时查看容器运行的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs -f demo02</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230425653-1546012181.png"></p><p>使用<code>-f</code>的参数可以让它像linux中的<code>tail</code>命令一样。否则就是一次性查看，跟<code>cat</code>一样。</p><h4 id="文件拷贝（cp）"><a href="#文件拷贝（cp）" class="headerlink" title="文件拷贝（cp）"></a>文件拷贝（cp）</h4><p>通过该命令可以实现容器和宿主机之间文件传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝文件到容器</span></span><br><span class="line">docker container <span class="built_in">cp</span> anaconda-ks.cfg demo02:/tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件到容器并改名</span></span><br><span class="line">docker container <span class="built_in">cp</span> anaconda-ks.cfg demo02:/tmp/1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝目录到容器</span></span><br><span class="line">docker container <span class="built_in">cp</span> demo demo02:/tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件到本地</span></span><br><span class="line">docker container <span class="built_in">cp</span> demo02:/tmp/1.txt .</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230443140-850543444.png"></p><h4 id="查看端口-port"><a href="#查看端口-port" class="headerlink" title="查看端口(port)"></a>查看端口(port)</h4><p>通过该命令可以查看容器和宿主机的端口映射关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container port demo02</span><br></pre></td></tr></table></figure><h4 id="查看状态-stats"><a href="#查看状态-stats" class="headerlink" title="查看状态(stats)"></a>查看状态(stats)</h4><p>通过该命令可以查看容器内部系统资源使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stats demo02</span><br></pre></td></tr></table></figure><p>如图所示</p><p><img src="/img/2022/docker-container/979767-20220613230456764-365638708.png"></p><h4 id="查看进程（top）"><a href="#查看进程（top）" class="headerlink" title="查看进程（top）"></a>查看进程（top）</h4><p>通过该命令可以查看到容器内部运行的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container top demo02</span><br></pre></td></tr></table></figure><p>如图所示</p><p><img src="/img/2022/docker-container/979767-20220613230514143-33194940.png"></p><h4 id="提交镜像（commit）"><a href="#提交镜像（commit）" class="headerlink" title="提交镜像（commit）"></a>提交镜像（commit）</h4><p>该命令可以将现有的容器提交成镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container commit -a <span class="string">&quot;Trover &lt;admin@buerya.cn&gt;&quot;</span> -m <span class="string">&quot;Copy file&quot;</span> -p demo02 trover/nginx-copy-file:v1.0</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-a</code>：作者信息。</li><li><code>-m</code>：提交信息，有点像 <code>git commit -m</code>。</li><li><code>-p</code>：生成镜像时容器暂停。<br>如图所示：</li></ul><p><img src="/img/2022/docker-container/979767-20220613230526915-1148740640.png"></p><h4 id="停止容器（kill）"><a href="#停止容器（kill）" class="headerlink" title="停止容器（kill）"></a>停止容器（kill）</h4><p>该命令相较于 stop 更暴力杀死一个或多个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">kill</span> demo02</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230542052-1112346775.png"></p><h4 id="重命名容器（rename）"><a href="#重命名容器（rename）" class="headerlink" title="重命名容器（rename）"></a>重命名容器（rename）</h4><p>该命令可以对容器重命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rename demo02 demo03</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230553943-1837768949.png"></p><h4 id="导出容器（export）"><a href="#导出容器（export）" class="headerlink" title="导出容器（export）"></a>导出容器（export）</h4><p>该命令可以将容器当前的状态导出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">export</span> -o /tmp/demo03.tar demo03</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230607064-1784552793.png"></p><h4 id="查看系统变化（diff）"><a href="#查看系统变化（diff）" class="headerlink" title="查看系统变化（diff）"></a>查看系统变化（diff）</h4><p>该命令可以查看容器目前的文件和文件系统本身的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container diff demo03</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-container/979767-20220613230619331-869669860.png"></p><h4 id="删除容器（rm）"><a href="#删除容器（rm）" class="headerlink" title="删除容器（rm）"></a>删除容器（rm）</h4><p>该命令可以删除指定的一个或多个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除停止的容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> a7851616b54c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除运行中的容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> -f 338a3419e42e</span><br></pre></td></tr></table></figure><p>如果容器在运行，需要使用<code>-f</code>强制删除：</p><p><img src="/img/2022/docker-container/979767-20220613230641212-907588129.png"></p><h4 id="批量删除（rm）"><a href="#批量删除（rm）" class="headerlink" title="批量删除（rm）"></a>批量删除（rm）</h4><p>对于容器或者镜像，都可以使用条件筛选的方式对它进行批量删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> $(docker container <span class="built_in">ls</span> -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有 redis 镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -aq redis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有在 mongo:3.2 之前的镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -aq -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><p>使用<code>-q</code>参数能够增加筛选条件。</p><h4 id="删除容器（prune）"><a href="#删除容器（prune）" class="headerlink" title="删除容器（prune）"></a>删除容器（prune）</h4><p>该命令可以删除没有使用的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><p>可以通过<code>-f</code>参数直接删除，不用确认。</p><p><img src="/img/2022/docker-container/979767-20220613230700355-227583119.png"></p><p>到此，容器的大部分操作都已经体验完毕。接下来将讲解如何制作镜像！</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>镜像管理</title>
      <link href="/2022/docker-hub/index/"/>
      <url>/2022/docker-hub/index/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p><code>docker hub</code>作为默认的注册点，不管是官方还是第三方都上传了很多人们可以直接拿来使用的镜像。</p><blockquote><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p></blockquote><p>通过搜索功能可以直接搜索到相关的镜像：</p><p><img src="/img/2022/docker-hub/979767-20220612181114029-1547561283.png"></p><p>这里以 Nginx 为例：</p><p><img src="/img/2022/docker-hub/979767-20220612181125322-23214919.png"></p><p>通过在 <code>registry</code> 上面搜索可以发现：</p><ol><li>仓库前面没有用户名，一般都是官方镜像仓库。后面会有 <code>DOCKER OFFICIAL IMAGE</code> 的标识。这意味着我们大概率可以放心大胆的直接拿来使用。</li><li>仓库前面有用户名，一般都第三方的镜像仓库。后面会有 <code>VERIFIED PUBLISHER</code> 的标识（已经验证的开发者）或 <code>OPEN SOURCE PROGRAM</code> 标识（开源项目）。这两者的安全优先级相对于较低，使用需要谨慎。</li><li>右边 <code>Downloads</code> 标识该仓库被下载了多少次，下载次数越多表示用户越多，有问题被发现的概率越大。可以作为镜像是否靠谱的参考依据。</li><li>右边 <code>Stars</code> 也和 Downloads 有着类似的功能。</li><li>通过左边的筛选栏可以对仓库进行筛选。</li></ol><p>点击进入一个仓库可以看到相关详细信息：</p><p><img src="/img/2022/docker-hub/979767-20220612181143608-2120734119.png"></p><p>常见的功能包括：</p><ol><li>怎么下载镜像。</li><li>关于这个仓库的说明介绍与配置使用方法。</li><li>关于这个仓库的用户评价。</li><li>该仓库中的镜像支持的版本，我们可以通过标版编号，下载指定版本。</li></ol><p>除了在页面上查询镜像以外，docker 本身命令行也提供了查询方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181201719-136720622.png"></p><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>docker 所有支持的命令都可以使用 <code>docker --help</code> 看到。同时通过该命令，我们也可以发现，docker 的命令分为两大类：<code>Management Commands</code> 和 <code>Commands</code>。</p><p>在 docker 设置之初是没有分类这一概念，到后面因为命令多了加入了分类。所以在学习 docker 命令的时候，建议养成使用 Management Commands 的习惯。虽然命令可能更复杂一点，但是说不定单纯的 Commands 说不定哪天就被删除了。</p><p>对于镜像支持的操作，我们可以使用命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181240712-106763821.png"></p><h2 id="拉取镜像（pull）"><a href="#拉取镜像（pull）" class="headerlink" title="拉取镜像（pull）"></a>拉取镜像（pull）</h2><p>docker 安装之后本身是没有镜像的，需要从 registry 中下载镜像才能使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载指定版本</span></span><br><span class="line">docker image pull nginx:1.22.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181257167-639154413.png"></p><p>从整个镜像的下载信息可以看出：</p><ol><li>如果没有跟版本号，默认下载 <code>latest</code> 版本。</li><li>镜像是分层结构，一个完整的镜像一般都是一层一层分开 pull 的。<br>查</li></ol><h2 id="查看本地镜像（ls）"><a href="#查看本地镜像（ls）" class="headerlink" title="查看本地镜像（ls）"></a>查看本地镜像（ls）</h2><p>镜像下载完成之后就可以使用相关命令查看它在服务器上面的保存信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker images</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181314136-1294251006.png"></p><p>通过该命令可以了解镜像的相关信息：</p><ol><li>想要唯一标识一个镜像可以有两种方法：<REPOSITORY>:<TAG> 或者 <code>IMAGE ID</code>。</li><li>通过该命令看到的 IAMGE ID 并非是完整的，但是显示部分一般已经足够区分不同镜像。</li><li>可以看到镜像的大小。</li></ol><h2 id="查看镜像详情（inspect）"><a href="#查看镜像详情（inspect）" class="headerlink" title="查看镜像详情（inspect）"></a>查看镜像详情（inspect）</h2><p>ls 查看到的镜像信息只是很少的一部分，如果想了解更详细的镜像信息，需要使用其他命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要关注以下输出的信息中的以下项目：</p><ul><li>Id：完整的 IMAGE ID，ls 展示的只是这个 ID 的开始部分。</li><li>ExposedPorts：镜像中的服务运行端口。</li><li>Env：镜像中定义的环境变量。</li><li>Cmd：启动镜像中服务所使用的命令。</li><li>Volumes：镜像挂载的持久化数据卷。</li></ul><h2 id="删除指定镜像（rm）"><a href="#删除指定镜像（rm）" class="headerlink" title="删除指定镜像（rm）"></a>删除指定镜像（rm）</h2><p>如果下载错了镜像或者需要为了清理磁盘空间而删除不需要的镜像，可以执行以下命令进行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image <span class="built_in">rm</span> nginx:1.22.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker rmi nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过 ID 镜像删除</span></span><br><span class="line">docker image <span class="built_in">rm</span> 605c77e624dd</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181338631-1279399900.png"></p><p>删除和拉取镜像类似，也是一层一层的删除。</p><blockquote><p>注意，如果有通过该镜像创建的容器正在运行，则无法直接删除镜像。需要先删除容器或者加入 <code>-f</code> 参数强制删除，容器也会跟着删除。</p></blockquote><h2 id="镜像导出（save）"><a href="#镜像导出（save）" class="headerlink" title="镜像导出（save）"></a>镜像导出（save）</h2><p>在没有私有 registry 或者没有外网环境的机器之间想要运行别的机器上面的镜像，就需要将镜像导出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mamagement Commands（推荐）</span></span><br><span class="line">docker image save nginx:1.22.0 nginx:latest -o /tmp/nginx-image.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker save nginx:1.22.0 nginx:latest -o /tmp/nginx-image-2.tar</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181357799-2107861404.png"></p><h2 id="镜像导入（load）"><a href="#镜像导入（load）" class="headerlink" title="镜像导入（load）"></a>镜像导入（load）</h2><p>为了测试导入，需要先删除所有镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image load -i /tmp/nginx-image.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker load -i /tmp/nginx-image.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181409536-1292770390.png"></p><h2 id="镜像打标签（tag）"><a href="#镜像打标签（tag）" class="headerlink" title="镜像打标签（tag）"></a>镜像打标签（tag）</h2><p>镜像在下载的时候有自己的 TAG，某些时候可能需要对其进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image tag nginx:1.20.0 nginx:<span class="built_in">history</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands</span></span><br><span class="line">docker tag nginx:1.20.0 nginx:<span class="built_in">history</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="/img/2022/docker-hub/979767-20220612181435230-234859769.png"></p><p>可以发现，打 TAG 其实就是在原来的镜像基础上重新增加一个 TAG 指向该镜像 ID。</p><p>当删除某个 TAG 的时候，镜像并不会跟着全部删除。当然直接删除镜像 ID 除外。</p><h2 id="删除未使用镜像（prune）"><a href="#删除未使用镜像（prune）" class="headerlink" title="删除未使用镜像（prune）"></a>删除未使用镜像（prune）</h2><p>某些镜像在服务器中保存是没用的，如果有很多的话，可以直接使用以下命令全部清理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Management Commands（推荐）</span></span><br><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><p><img src="/img/2022/docker-hub/979767-20220612181449476-939906458.png"></p><p>关于更多镜像相关操作需要等后面容器相关知识整理了之后结合着使用。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Docker</title>
      <link href="/2022/docker-install/index/"/>
      <url>/2022/docker-install/index/</url>
      
        <content type="html"><![CDATA[<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>本次作为测试安装，我这里使用的是一台虚拟机，具体配置如下：</p><table><thead><tr><th>主机名</th><th>IP 地址</th><th>系统版本</th><th>内存（G）</th><th>CPU（核）</th><th>硬盘（G）</th></tr></thead><tbody><tr><td>node-01</td><td>192.168.200.101</td><td>CentOS Linux release 7.9.2009</td><td>4</td><td>4</td><td>20</td></tr></tbody></table><ol><li>关闭防火墙和 Selinux</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 Selinux</span></span><br><span class="line">sed -i <span class="string">&quot;s#^SELINUX=.*#SELINUX=disabled#g&quot;</span> /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 swap 分区</span></span><br><span class="line">swapoff -a &amp;&amp; sysctl -w vm.swappiness=0</span><br><span class="line">sed -ri <span class="string">&#x27;/^[^#]*swap/s@^@#@&#x27;</span> /etc/fstab</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>配置 yum 源（云服务器不需要）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份旧的 yum 源</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"><span class="built_in">mkdir</span> backup-$(<span class="built_in">date</span> +%F)</span><br><span class="line"><span class="built_in">mv</span> *repo backup-$(<span class="built_in">date</span> +%F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加阿里云 yum 源</span></span><br><span class="line">curl http://mirrors.aliyun.com/repo/Centos-7.repo -o ali.repo</span><br></pre></td></tr></table></figure><ol start="3"><li>安装基础依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 epel 源</span></span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装常用依赖</span></span><br><span class="line">yum -y install gcc glibc gcc-c++ make cmake net-tools screen vim lrzsz tree dos2unix lsof \</span><br><span class="line">    tcpdump bash-completion wget ntp setuptool openssl openssl-devel bind-utils traceroute \</span><br><span class="line">    bash-completion bash-completion-extras glib2 glib2-devel unzip bzip2 bzip2-devel libevent libevent-devel \</span><br><span class="line">    ntp expect pcre pcre-devel zlib zlib-devel jq psmisc tcping yum-utils device-mapper-persistent-data \</span><br><span class="line">    lvm2 git device-mapper-persistent-data bridge-utils container-selinux binutils-devel \</span><br><span class="line">    ncurses ncurses-devel elfutils-libelf-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级服务器</span></span><br><span class="line">yum update</span><br></pre></td></tr></table></figure><ol start="4"><li>时间同步</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# 互联网时间同步&quot;</span> &gt;&gt; /var/spool/cron/root</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*/5 * * * * /usr/sbin/ntpdate time2.aliyun.com &gt;/dev/null 2&gt;&amp;1&quot;</span> &gt;&gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><ol start="5"><li>打开文件数优化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/security/limits.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 打开文件优化配置</span></span><br><span class="line"><span class="string">* soft nofile 655360</span></span><br><span class="line"><span class="string">* hard nofile 131072</span></span><br><span class="line"><span class="string">* soft nproc 655350</span></span><br><span class="line"><span class="string">* hard nproc 655350</span></span><br><span class="line"><span class="string">* soft memlock unlimited</span></span><br><span class="line"><span class="string">* hard memlock unlimited</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ol start="6"><li>内核优化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/sysctl.d/user.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 内核调优</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">fs.may_detach_mounts = 1</span></span><br><span class="line"><span class="string">vm.overcommit_memory=1</span></span><br><span class="line"><span class="string">vm.panic_on_oom=0</span></span><br><span class="line"><span class="string">fs.inotify.max_user_watches=89100</span></span><br><span class="line"><span class="string">fs.file-max=52706963</span></span><br><span class="line"><span class="string">fs.nr_open=52706963</span></span><br><span class="line"><span class="string">net.netfilter.nf_conntrack_max=2310720</span></span><br><span class="line"><span class="string">net.ipv4.tcp_keepalive_time = 600</span></span><br><span class="line"><span class="string">net.ipv4.tcp_keepalive_probes = 3</span></span><br><span class="line"><span class="string">net.ipv4.tcp_keepalive_intvl =15</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_tw_buckets = 36000</span></span><br><span class="line"><span class="string">net.ipv4.tcp_tw_reuse = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_orphans = 327680</span></span><br><span class="line"><span class="string">net.ipv4.tcp_orphan_retries = 3</span></span><br><span class="line"><span class="string">net.ipv4.tcp_syncookies = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_syn_backlog = 16384</span></span><br><span class="line"><span class="string">net.ipv4.ip_conntrack_max = 65536</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_syn_backlog = 16384</span></span><br><span class="line"><span class="string">net.ipv4.tcp_timestamps = 0</span></span><br><span class="line"><span class="string">net.core.somaxconn = 16384</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ol start="7"><li>内核升级</li></ol><p>docker 对于 CentOS 的要求为内核版本不低于 <code>3.10</code>，尽管 7.9 已经是 3.10 版本，但还是有升级的必要。</p><p>同时作为生产环境，一般不会选择安装最新版本。但官方仓库中提供的 rpm 一般只会有一个 lt 和一个 ml 版本，所以需要从第三方下载想要的版本，统一服务器的内核版本，可以避免出现未知 BUG。</p><blockquote><p><a href="http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/">http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/</a></p></blockquote><p>本次使用的是 4 版本最后一版：<code>4.20</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载内核 rpm 包</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/</span><br><span class="line">wget http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-4.20.13-1.el7.elrepo.x86_64.rpm</span><br><span class="line">wget http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-devel-4.20.13-1.el7.elrepo.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装内核</span></span><br><span class="line">yum -y localinstall kernel-ml-*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看顺序</span></span><br><span class="line">awk -F\<span class="string">&#x27; &#x27;</span><span class="variable">$1</span>==<span class="string">&quot;menuentry &quot;</span> &#123;<span class="built_in">print</span> i++ <span class="string">&quot; : &quot;</span> <span class="variable">$2</span>&#125;<span class="string">&#x27; /etc/grub2.cfg</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置默认启动内核，上面的命令可以看到最新内核的序号是 0</span></span><br><span class="line"><span class="string">grub2-set-default 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 重启系统</span></span><br><span class="line"><span class="string">reboot</span></span><br></pre></td></tr></table></figure><p>系统启动完成之后，查看内核情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><p>到此，系统初始化完成！</p><h2 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h2><p>docker 目前有三种版本可供选择：<code>nightly（开发版）</code>，<code>test（测试版）</code>，<code>stable（稳定版）</code>。</p><p>对于生产环境，为了避免因为版本不同导致集群出现未知 BUG，建议手动下载 rpm 包安装。本次安装版本为 <code>20.10.9</code>,下载地址：</p><blockquote><p><a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></p></blockquote><p>如果觉得下载慢，可以使用国内的镜像地址：</p><blockquote><p><a href="http://mirrors.ustc.edu.cn/docker-ce/linux/centos/7/x86_64/stable/Packages/">http://mirrors.ustc.edu.cn/docker-ce/linux/centos/7/x86_64/stable/Packages/</a></p></blockquote><p>需要下载的安装包如下：</p><ol><li>docker-ce-20.10.9-3.el7.x86_64.rpm（docker 引擎）</li><li>docker-ce-cli-20.10.9-3.el7.x86_64.rpm（docker 引擎的命令行）</li><li>containerd.io-1.6.6-3.1.el7.x86_64.rpm（守护进程，独立于 docker 工作，管理容器的生命周期）</li><li>docker-ce-rootless-extras-20.10.9-3.el7.x86_64.rpm（ce 需要的依赖）</li><li>docker-scan-plugin-0.9.0-3.el7.x86_64.rpm（cli 需要的依赖）</li></ol><h2 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h2><p>事先使用 lrzsz 将下载的安装包上传到 <code>/usr/local/src/</code> 目录然后开始进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载可能存在的旧版本 docker</span></span><br><span class="line">yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装新版本</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/</span><br><span class="line">yum -y localinstall docker* containerd*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>查看 docker 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/img/2022/install-docker/979767-20220611152733982-509376277.png"></p><h2 id="服务优化"><a href="#服务优化" class="headerlink" title="服务优化"></a>服务优化</h2><p>由于 docker 默认的 registry 是 docker hub，而 docker hub 又是外网的服务，可能因为网络原因访问，下载都会非常慢。所以需要将 registry 调整为国内的。</p><p>国内常用的 registry 有以下一些：</p><ul><li>阿里云（需要注册用户）：<code>https://&lt;你的ID&gt;.mirror.aliyuncs.com</code></li><li>网易：<code>http://hub-mirror.c.163.com</code></li><li>中科大：<code>https://docker.mirrors.ustc.edu.cn</code></li></ul><p>通过增加配置来修改 docker 默认的 registry 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 docker 数据目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /ops/&#123;data,service,<span class="built_in">log</span>,backup,shell,package&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p /ops/data/docker/&#123;run,lib&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="comment"># exec-opts：调整 docker 为 systemd 管理</span></span><br><span class="line"><span class="comment"># registry-mirrors：设置注册点</span></span><br><span class="line"><span class="comment"># bip：修改 docker 的网段</span></span><br><span class="line"><span class="comment"># exec-root：重新定义 docker 的运行目录</span></span><br><span class="line"><span class="comment"># data-root：重新定义 docker 的数据目录</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;],</span></span><br><span class="line"><span class="string">    &quot;bip&quot;: &quot;172.16.0.1/16&quot;,</span></span><br><span class="line"><span class="string">    &quot;exec-root&quot;: &quot;/ops/data/docker/run&quot;,</span></span><br><span class="line"><span class="string">    &quot;data-root&quot;: &quot;/ops/data/docker/lib&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>如果不清楚网段划分，可以使用工具查看：</p><blockquote><p><a href="http://tools.jb51.net/aideddesign/ip_net_calc/">http://tools.jb51.net/aideddesign/ip_net_calc/</a></p></blockquote><p>重启完成后查看 docker 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/img/2022/install-docker/979767-20220611152714666-1498814086.png"></p><h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><p>docker 在停止的时候可能会出现提醒：</p><blockquote><p>Warning: Stopping docker.service, but it can still be activated by: docker.socket</p></blockquote><p>告警的意思为：如果你试图连接到 docker socket，而 docker 服务没有运行，系统将自动启动 docker。</p><p>该配置是在 <code>/lib/systemd/system/docker.service</code> 中配置的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>所以这个告警可以忽略掉。</p><p>重启失败，大概可能是 &#x2F;etc&#x2F;docker&#x2F;daemon.json 存在报错，可以通过错误日志查看信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -1000f /var/log/messages</span><br></pre></td></tr></table></figure><ul><li>故障问题 1</li></ul><blockquote><p>unable to configure the Docker daemon with file &#x2F;etc&#x2F;docker&#x2F;daemon.json: invalid character ‘Â’ looking for beginning of value</p></blockquote><p>查看配置文件没有问题，但是一直这个错误，所以我怀疑里面的 tab 或者空格存在问题，通过执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -A /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>发现文件中确实有很多特殊的字符，因为配置是网上复制的。通过将里面空格和 tab 替换成空格之后故障解决。</p><ul><li>故障问题 2</li></ul><blockquote><p>unable to configure the Docker daemon with file &#x2F;etc&#x2F;docker&#x2F;daemon.json: invalid character ‘}’ looking for beginning of object key string</p></blockquote><p>原因是我在 json 最后一个值后面也加了 , 符号的缘故，删除了就好了。</p><h2 id="daemon-json"><a href="#daemon-json" class="headerlink" title="daemon.json"></a>daemon.json</h2><p>配置文件 <code>daemon.json</code> 参数详解：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 在引擎 API 中设置 CORS 标头</span></span><br><span class="line">    <span class="attr">&quot;api-cors-header&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 要加载的授权插件</span></span><br><span class="line">    <span class="attr">&quot;authorization-plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 将容器附加到网桥</span></span><br><span class="line">    <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 指定网桥 IP</span></span><br><span class="line">    <span class="attr">&quot;bip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.88.0/22&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 为所有容器设置父 cgroup</span></span><br><span class="line">    <span class="attr">&quot;cgroup-parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 分布式存储后端的 URL</span></span><br><span class="line">    <span class="attr">&quot;cluster-store&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置集群存储选项（默认map []）</span></span><br><span class="line">    <span class="attr">&quot;cluster-store-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 要通告的地址或接口名称</span></span><br><span class="line">    <span class="attr">&quot;cluster-advertise&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用调试模式，启用后，可以看到很多的启动信息。默认 false</span></span><br><span class="line">    <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器默认网关 IPv4 地址</span></span><br><span class="line">    <span class="attr">&quot;default-gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器默认网关 IPv6 地址</span></span><br><span class="line">    <span class="attr">&quot;default-gateway-v6&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器的默认 OCI 运行时，默认为 runc</span></span><br><span class="line">    <span class="attr">&quot;default-runtime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;runc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器的默认 ulimit（默认[]）</span></span><br><span class="line">    <span class="attr">&quot;default-ulimits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设定容器 DNS 的地址，在容器的 /etc/resolv.conf 文件中可查看</span></span><br><span class="line">    <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.1.1&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器 /etc/resolv.conf 文件，其他设置</span></span><br><span class="line">    <span class="attr">&quot;dns-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设定容器的搜索域。</span></span><br><span class="line">    <span class="attr">&quot;dns-search&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 运行时执行选项</span></span><br><span class="line">    <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 执行状态文件的根目录，默认 /var/run/docker</span></span><br><span class="line">    <span class="attr">&quot;exec-root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 固定 IP 的 IPv4 子网</span></span><br><span class="line">    <span class="attr">&quot;fixed-cidr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 固定 IP 的 IPv6 子网</span></span><br><span class="line">    <span class="attr">&quot;fixed-cidr-v6&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// docker 运行时使用的根路径，默认 /var/lib/docker</span></span><br><span class="line">    <span class="attr">&quot;data-root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// UNIX 接字的组，默认 docker</span></span><br><span class="line">    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置容器 hosts</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用容器间通信，默认 true</span></span><br><span class="line">    <span class="attr">&quot;icc&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 绑定容器端口时的默认 IP，默认 0.0.0.0</span></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用 iptables 规则添加，默认 true</span></span><br><span class="line">    <span class="attr">&quot;iptables&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用IPv6网络</span></span><br><span class="line">    <span class="attr">&quot;ipv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 默认 true, 启用 net.ipv4.ip_forward</span></span><br><span class="line">    <span class="attr">&quot;ip-forward&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用 IP 伪装，默认 true</span></span><br><span class="line">    <span class="attr">&quot;ip-masq&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置私有仓库地址可以设为 http</span></span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;120.123.122.123:12312&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// docker 主机的标签</span></span><br><span class="line">    <span class="attr">&quot;labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;nodeName=node-101&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 在容器仍在运行时启用 docker 的实时还原</span></span><br><span class="line">    <span class="attr">&quot;live-restore&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器日志的默认驱动程序，默认 json-file</span></span><br><span class="line">    <span class="attr">&quot;log-driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置日志记录级别：&quot;调试&quot;，&quot;信息&quot;，&quot;警告&quot;，&quot;错误&quot;，&quot;致命&quot;</span></span><br><span class="line">    <span class="attr">&quot;log-level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置每个请求的最大并发下载量，默认 3</span></span><br><span class="line">    <span class="attr">&quot;max-concurrent-downloads&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置每次推送的最大同时上传数，默认 5</span></span><br><span class="line">    <span class="attr">&quot;max-concurrent-uploads&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置容器网络 MTU</span></span><br><span class="line">    <span class="attr">&quot;mtu&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置守护程序的 oom_score_adj，默认 -500</span></span><br><span class="line">    <span class="attr">&quot;oom-score-adjust&quot;</span><span class="punctuation">:</span> <span class="number">-500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Docker 守护进程的 PID 文件</span></span><br><span class="line">    <span class="attr">&quot;pidfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 全时间戳机制</span></span><br><span class="line">    <span class="attr">&quot;raw-logs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置镜像加速</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://192.498.89.232:89&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用 selinux 支持，默认 false</span></span><br><span class="line">    <span class="attr">&quot;selinux-enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 要使用的存储驱动程序</span></span><br><span class="line">    <span class="attr">&quot;storage-driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置默认地址或群集广告地址的接口</span></span><br><span class="line">    <span class="attr">&quot;swarm-default-advertise-addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启动 TLS 认证开关，默认 false</span></span><br><span class="line">    <span class="attr">&quot;tls&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 通过 CA 认证过的 certificate 文件路径，默认 ~/.docker/ca.pem</span></span><br><span class="line">    <span class="attr">&quot;tlscacert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// TLS 的 certificate 文件路径，默认 ~/.docker/cert.pem</span></span><br><span class="line">    <span class="attr">&quot;tlscert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// TLS 的 key 文件路径，默认 ~/.docker/key.pem</span></span><br><span class="line">    <span class="attr">&quot;tlskey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 使用 TLS 并做后台进程与客户端通讯的验证，默认 false</span></span><br><span class="line">    <span class="attr">&quot;tlsverify&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 使用 userland 代理进行环回流量，默认 true</span></span><br><span class="line">    <span class="attr">&quot;userland-proxy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 用户名称空间的用户/组设置</span></span><br><span class="line">    <span class="attr">&quot;userns-remap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 存储驱动程序选项</span></span><br><span class="line">    <span class="attr">&quot;storage-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;overlay2.override_kernel_check=true&quot;</span><span class="punctuation">,</span> <span class="string">&quot;overlay2.size=15G&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器默认日志驱动程序选项</span></span><br><span class="line">    <span class="attr">&quot;log-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;max-file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max-size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10m&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Docker</title>
      <link href="/2022/docker-about/index/"/>
      <url>/2022/docker-about/index/</url>
      
        <content type="html"><![CDATA[<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>2008 年，<code>Solomon Hykes</code>和他的朋友 Kamel Founadi、Sebastien Pahl 共同创立了一家名为<code>DotCloud</code>的公司，目标是利用一种叫做容器的技术来创建一种任何人都可以使用的编程工具。</p><p>2010 年，DotCloud 获得了创业孵化器 Y Combinator 的支持，并开始吸引到一些真正的投资，在接下来的 3 年中，<code>DotCloud</code>内部孵化了一款使用 Go 语言编写，C&#x2F;S 架构，名为 Docker 的产品。</p><p>2013 年 3 月，创始人<code>Solomon Hykes</code>在 PyCon 大会上首次公开介绍了 Docker 这一产品。其<code>创新式镜像格式</code>以及<code>容器运行时</code>迅速成为社区、客户和更广泛行业的实际标准和基石。可移植的形式和易于使用的工具给应用程序和基础设施之间创造了独立性。容器技术逐渐大众化并成为主流。</p><p>docker 最初是在<code>Ubuntu 12.04</code>上开发实现的，而<code>Red Hat</code>则要从<code>6.5</code>开始才对其进行支持。</p><p><img src="/img/2022/about-docker/979767-20220608220537883-1025728940.png"></p><p>2013 年 3 月 20 日，DotCloud 发布了 Docker 的首个版本，并将 Docker 源码进行了 开源。</p><p>2013 年 9 月，红帽公司成为 Docker 的主要合作伙伴，利用 Docker 来驱动他的 OpenShift 云业务。</p><p>随后，谷歌、亚马逊以及 DigitalOcean 也迅速的在其云服务平台提供了 Docker 的支持。主流云厂商的加入，加速了 Docker 的发展，Docker 技术也至此开始风靡全球。</p><p>2013 年底，Docker 公司名称也由<code>DotCloud Inc</code>更改为<code>Docker Inc</code>，并全力的主攻到 Docker 项目开发中。</p><p>2014 年 6 月，在<code>DockerCon</code>大会上 Docker 正式发布了 1.0 版本。这意味着 Docker 的稳定性和可靠性已经基本满足了生产环境的运行需求。会议上同时也发布 Docker Image 的镜像仓库 Docker Hub。</p><p>与此同时，已经有 10 年以上容器管理编排经验的谷歌终于出手了，基于自己内部内部强大的 Borg 系统使用 Go 语言重写出来目前最火的容器编排工具：<code>Kubernetes</code>。</p><p><img src="/img/2022/about-docker/979767-20220608220555533-1493806359.png"></p><p>2014 年 8 月，Docker Inc 宣布将用于 PaaS 业务服务的 DotCloud 软件出售给德国柏林的 PaaS 服务厂商 CloudControl，自以，DotCloud 正式的和 Docker 分道扬镳。</p><p>2014 年 12 月，DockerConEU 大会上，<code>Docker Swarm</code> （Docker 集群管理工具）和 <code>Docker Machine</code> （部署 Docker 主机的命令工具）同时面世。</p><p>容器技术不只有 Docker，很早之前 Google 就投资了 CoreOS 来做竞争的容器 <code>Rocket（rkt）</code>。那时三家鼎立：Docker &#x2F; Rocket &#x2F; Warden。</p><p>2015 年 6 月，为了避免惨烈的竞争，由 Docker、IBM、微软、红帽及 Google 等厂商所组成的开放容器项目 <code>OCP</code> 联盟成立，隶属 Linux 基金会。该项目旨在建立软件容器的通用标准。Docker 将捐赠其软件容器格式，运行时以及相关规范的代码。应用容器规范（<code>appc</code>）计划的领导者，包括创始成员 CoreOS，也将把他们的技术领导力和支持带到 OCP。</p><p>2015 年，Docker 发布了 <code>runC</code> ，一个轻量级的跨平台的容器运行时命令行小工具。docker 将最初实现由 <code>LXC，0.7 版本开始去除</code> 转为自行开发的 <code>libcontainer</code>。用户可以直接利用 libcontainer 运行容器，而无需通过 docker engine。这意味着 Docker 真正解决了跨平台的问题，真正做到一次构建到处运行。</p><p>2016 年 6 月，DockerCon 大会上，Docker 宣布了 <code>Open Container Initiative，OCI</code> 正式成立 。意在业界一起合作，开发一个开放的、标准的容器格式和 Runtime。</p><p>在 OCI 标准制定后，Docker 也将 <code>Containerd</code> 独立拆分，并将其捐赠给了社区。这意味着 Docker 将容器的管理功能移出自身的核心引擎，移入了一个单独的守护进程。</p><p>同时，人们也逐渐意识到，容器技术本身的价值是在于容器的编排。然而 Docker 却放弃了自己的 Swarm 项目，想着将容器的编排和集群的管理功能添加到 Docker 自身项目当中。这和 Kubernetes 推进民主化架构，通过暴露 Kubernetes API 让更多的人来不断丰富 Kubernetes 的插件的方案截然相反，当然最终的结果大家也看到了。</p><p>2017 年 2 月， 从版本 <code>1.13</code> 开始，Docker 版本号开始遵循 <code>YY.MM-xx</code> 格式，并以每月发布一个前沿版（Edge），每季度发布一个稳定版（Stable）的进度更新。</p><p>2017 年是容器成为主流技术的一年，在 Austin 举办的 DockerCon 上，开源 Docker 项目正式命名为 <code>Moby</code> 项目。GitHub 上的 docker&#x2F;docker 库也被转移到了 moby&#x2F;moby，并且拥有了项目自己的 Logo。同时，Docker Inc 公司将 Docker 本身拆分为 <code>Docker-CE</code> 开源社区免费版和 <code>Docker-EE</code> 闭源商业版。</p><p><img src="/img/2022/about-docker/979767-20220608220621806-584954900.png"></p><p>至此，容器天下三分。其中 Moby 由社区维护，Docker-CE 由 Docker 公司维护，Docker-EE 属 Docker 公司闭源商品。</p><p>2018 年 3 月，Docker 公司创始人 Solomon Hykes 在 Docker 博客上宣布已正式从 Docker 公司离职，不再担任公司的日常运作工作。未来的身份只是 Docker 的董事会成员、主要股东，以及 Docker 维护者。</p><h2 id="为何选择"><a href="#为何选择" class="headerlink" title="为何选择"></a>为何选择</h2><p>由于硬件的飞速发展，服务器的性能也随之增强。单个业务的发布无法充分利用硬件资源，导致资源利用率较低。但是如果同一套服务器运行多个业务又可能会互相的影响，产生一系列的问题。</p><p><img src="/img/2022/about-docker/979767-20220608220643777-10168043.png"></p><p>和传统的 VM 虚拟化相比，docker 存在下面的一下优势：</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于 docker 不像传统的 VM 虚拟化需要进行硬件虚拟以及运行完整操作系统，所以系统开销更低，对系统资源的利用率自然更高。无论是应用执行速度、内存损耗还是文件存储速度，都要比传统虚拟化技术更高效。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境的不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维人员来说，最希望的就是一次创建，到处运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建测试，而运维人员则可以直接在生产环境中快速部署该镜像。由于 Dockerfile 的构建透明化，不仅开发团队可以理解应用运行环境，运维团队也可以更好的理解应用运行所需条件，帮助更好的在生产环境中部署。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此可以很轻易的将应用从一个平台迁移到另一个平台上，而且无需担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>docker 主要包含了四个核心的概念，其关系如图所示：</p><p><img src="/img/2022/about-docker/979767-20220610224042637-1318914544.png"></p><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>操作系统可以分为 <code>内核</code> 和 <code>用户空间</code>。以 Linux 为例，在内核启动后，会挂载 <code>root</code> 文件系统来提供用户空间支持。</p><p>镜像其实就相当于一个 root 文件系统。比如 ubuntu 镜像，它本身就包含了一套完整的 ubuntu 最小化文件系统。</p><p>当然，镜像是一个特殊的文件系统。除了包含文件以外，还包含了一些为容器运行时准备的配置参数，如：匿名卷，环境变量，用户等。</p><blockquote><p>镜像是不包含任何动态数据的，在镜像构建之后里面的内容就不会再发生改变。</p></blockquote><p>作为一个操作系统，即使是最小化，其大小也不小。所以 docker 在设计之时，就利用 Union FS 技术，将镜像设计为分层存储。</p><p>镜像在构建时会一层一层的叠加。前一层对于后一层都是只读的。这意味着用户想要修改镜像里面的内容，只能自己再加一层，形成一个新的镜像。所以，不管你如何修改新的镜像，其底层的镜像是不会改变的。好处在于：</p><blockquote><p>多个用到相同层级镜像的新镜像可以复用同一层，这样既能节省磁盘空间，也能提升镜像的制作速度，避免每次搞一个新的镜像就得去拉一次底层镜像。毕竟一个操作系统镜像往往都是几百 M 往上。</p></blockquote><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>镜像（Image）和容器（Container）的关系就像编程语言中常说的类和实例的关系。镜像属于静态定义，容器是镜像的运行时实体。容器可以被创建，启动，暂停，停止，删除等。</p><blockquote><p>容器的实质是进程。</p></blockquote><p>但和宿主机本身运行的进程不同，容器的进程运行在独立的名称空间中。这使得容器可以拥有自己独立的文件系统，网络，进程，用户等。</p><p>由于镜像的分层特性，每个运行的容器都相当于在镜像的基础上创建了一个当前容器的存储层用于写入数据。但这个存储层会随着容器的销毁而删除。</p><p>为了保障数据的安全，同时符合 docker 的设计规范，所有的文件，数据的写入都应该直接写入到额外挂载的 数据卷（Volume） 或者 绑定的宿主机目录 中。跳过 docker 存储层，直接持久化到宿主机本地或者外部存储，也能提升性能和稳定性。</p><blockquote><p>数据卷的生命周期独立于容器，不会随着容器的销毁而删除。</p></blockquote><h3 id="注册点（Registry）和仓库（Repository）"><a href="#注册点（Registry）和仓库（Repository）" class="headerlink" title="注册点（Registry）和仓库（Repository）"></a>注册点（Registry）和仓库（Repository）</h3><p>镜像构建完成之后可以很容易在本机运行，但是如果其他服务器想要使用该镜像，就需要另外一个服务来专门负责集中存储，分发镜像。这个服务就是 <code>注册点（Registry）</code>。</p><blockquote><p>一个注册点由一个或者多个仓库组成。</p></blockquote><p>所谓的 <code>仓库（Repository）</code>，就是用于存放同一个镜像不同版本的集合。比如：centos 仓库，它可能包含 centos:7 和 centos:8 镜像。</p><blockquote><p>一般通过 &lt;仓库名称&gt;:&lt;标签&gt; 这样的格式来区分镜像，如果没有指定标签，则默认使用 latest 标签。</p></blockquote><p>仓库名称往往也是由两段组成，比如：dylan&#x2F;centos 仓库。前者用于区分在多用户的注册点中的用户名，后者一般都是软件名。也比如：dylan&#x2F;nginx。但这并非绝对，某些仓库就没有用户名，这取决于注册点的配置。</p><p>常见的注册点分为两类：<br>    - 开放注册点：<br>      + 网上开放给用户的注册点。用户可以在上面创建自己的仓库，镜像。也可以拉取使用别人的镜像。<br>      + 最常见的 registry 就是 docker 官方提供的 Docker Hub，它也是 docker 默认的 registry。上面有着大量的官方镜像供人们使用。<br>      + 此外还有阿里云，Google 等也提供了开放的 resgistry。<br>    - 私有注册点：<br>      + 出于数据的安全性考虑，公司使用的注册点一般都是自己搭建或者云厂商们提供的私有服务。其特点在于只有授权的用户才能看到并使用它的镜像。<br>      + docker 官方开源的 docker registry 镜像能够搭建私有仓库，但是该仓库只有 API 功能，没有图形化界面。<br>      + 生产中用户一般使用 Harbor 或者 Sonatype Nexus 搭建自己的私有注册点。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器技术</title>
      <link href="/2022/container-technology/index/"/>
      <url>/2022/container-technology/index/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>对于容器这个词，大部分人第一时间想到的肯定是生活中常见瓶瓶罐罐，用来装水的东西。它给人的第一感觉就是能 “装”。</p><p>而在<code>IT</code>领域，<code>Container</code>就被直译为容器，但<code>Container</code>本身是集装箱的意思，容器属于中国人的信雅达叫法。</p><p>可以想象一下，如果容器技术改为集装箱技术，档次一下就低了。但是为了帮助我们更好的理解容器，集装箱的翻译才能体现它的本质：</p><blockquote><p>规格标准化，层层堆叠，互相隔离，将各类零散的货物分门别类，形成统一的形状，提升运输效率，降低管理成本，保护了货物的完整性。</p></blockquote><p>在早期，<code>IT</code>领域就是通过借鉴这一思想，研发出了<code>hypervisor</code>虚拟化，将不同操作系统的虚拟机通过<code>hypervisor</code>（KVM、XEN 等）来衍生、运行、销毁。</p><p>但随着时间推移，用户也发现了<code>hypervisor</code>存在的问题：</p><blockquote><p>每次部署发布都得搞一个完整操作系统和附带的依赖环境，而用户其实更关注自己部署的应用，这导致了任务变重和性能低下。</p></blockquote><p>为此，有没有办法实现底层多余的操作系统和环境的复用就成了急需解决的问题，好比下面这个例子：</p><blockquote><p>将一辆兰博基尼（应用），打包放到一个集装箱里（容器），通过货轮轻而易举的将它从上海码头（CentOS 环境）运送到纽约码头（Ubuntu 环境）。在运输期间，兰博基尼（应用）没有受到任何的损坏，在纽约码头卸货后依然可以完美风骚的飙车（启动正常）。</p></blockquote><p><img src="/img/2022/container-technology/979767-20220608213320068-246351981.png"></p><h2 id="容器的原理"><a href="#容器的原理" class="headerlink" title="容器的原理"></a>容器的原理</h2><p><code>Linux Container</code>容器技术，简称<code>LXC</code>，是一种<code>内核轻量级的操作系统层虚拟化技术</code>，它的诞生（2008 年）解决了 IT 世界里的 “集装箱运输” 问题。</p><p>为了实现容器进程对外界的隔离，容器底层主要运用了 <code>名称空间（Namespaces）</code>、<code>控制组（Control groups）</code> 和 <code>切根（Change to root）</code>。</p><p><img src="/img/2022/container-technology/979767-20220608213342536-1386926153.png"></p><h3 id="名称空间（Namespaces）"><a href="#名称空间（Namespaces）" class="headerlink" title="名称空间（Namespaces）"></a>名称空间（Namespaces）</h3><p>每个运行的容器都有自己的名称空间（诞生于 2002 年），它主要用于实现资源的隔离。</p><p>Linux 操作系统默认提供了以下 6 个常用的 Namespace 的 API：</p><ul><li><code>PID Namespace</code>：提供进程隔离能力。<ul><li>在 Linux 系统中，有一个 PID 为 1 的进程（init&#x2F;systemd）是其他所有进程的父进程。在每个容器内也要有一个父进程来管理其下属的子进程。</li><li>不同容器就是通过 PID Namespace 隔离的，不同的名称空间中可以有相同的 pid。</li></ul></li><li><code>MNT Namespace</code>：提供磁盘挂载点和文件系统的隔离能力。<ul><li>每个容器都要有独立的根文件系统用户空间，以实现在容器里面启动服务并且使用容器的运行环境。</li><li>在容器里面不能访问宿主机的资源，宿主机使用了 chroot 技术把容器锁定到一个指的运行目录里面。</li><li>例如：宿主机是 ubuntu，里面启动一个 Centos 容器，并在容器里启动一个 Nginx，该 Nginx 运行时使用的运行环境就是 Centos 系统目录的运行环境。</li></ul></li><li><code>IPC Namespace</code>：提供进程间通信的隔离能力。<ul><li>允许一个容器内的不同进程的（内存，缓存等）数据访问，但是不能跨容器访问其他容器的数据 。</li><li>容器中进程交互还是采用 Linux 常见的进程交互方法（interprocess communication，IPC）。</li></ul></li><li><code>Net Namespace</code>：提供网络隔离能力。<ul><li>每一个容器都类似于虚拟机一样有自己的网络设备，IP地址，路由表，&#x2F;proc&#x2F;net 目录等。</li><li>以 docker 为例，使用 network namespace 启动一个 vethX 接口，这样你的容器将拥有它自己的桥接 IP 地址，通常是docker0。</li></ul></li><li><code>UTS Namespace</code>：提供主机名隔离能力。<ul><li>UNIX Time-sharing System 允许容器拥有独立的 hostname 和 domain name，使其在网络上能被视作一个独立节点而非主机的一个进程。</li></ul></li><li><code>User Namespace</code>：提供用户隔离能力。<ul><li>每个容器可以有不同的用户和组 id，也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</li></ul></li></ul><h3 id="控制组（Control-groups）"><a href="#控制组（Control-groups）" class="headerlink" title="控制组（Control groups）"></a>控制组（Control groups）</h3><p>简称<code>Cgroups</code>，是 Linux 内核提供的一种可以限制、记录、隔离进程组的物理资源的机制，由 Google 贡献，2007 年合并到 Linux Kernel。</p><p>因为 Namespace 只能改变进程的视觉范围，不能真实地对资源做出限制，所以就需要用到 Cgroup 技术。以防止某个容器把宿主机资源全部用完导致其它容器也宕掉。</p><p>在 Linux 的<code>/sys/fs/cgroup</code>目录中有 cpu、memory、devices、net_cls 等目录，可以按需修改相应的配置文件来设置某个进程 ID 对物理资源的最大使用率。</p><h3 id="切根（Change-to-root）"><a href="#切根（Change-to-root）" class="headerlink" title="切根（Change to root）"></a>切根（Change to root）</h3><p>简称<code>chroot</code>，用于改变一个程序运行时参考的根目录位置，让不同容器在不同的虚拟根目录下工作，从而相互不直接影响。</p><h2 id="容器的特点"><a href="#容器的特点" class="headerlink" title="容器的特点"></a>容器的特点</h2><p>想要更好的理解容器的特点，就需要拿跟它跟硬件抽象层虚拟化 hypervisor 技术做对比。</p><p><img src="/img/2022/container-technology/979767-20220608213409392-1087932555.png"></p><p>主要的区别如下：</p><ol><li>本质上来看，虚拟机是通过 Hypervisor 虚拟化硬件，然后在上安装不同的操作系统，而容器是宿主机上运行的不同进程。</li><li>用户体验上来看，虚拟机是重量级的，系统本身占用的物理资源多，启动时间长。而容器则相反。</li><li>隔离性上来看，虚拟机隔离的更彻底，容器则要差一些。</li></ol><p>比较得出容器主要包含以下几个特点：</p><ol><li>极其轻量：只打包了必要的 bin&#x2F;lib。</li><li>秒级部署：根据镜像的不同，容器的部署大概在毫秒与秒之间。</li><li>易于移植：<code>一次构建，到处运行</code>。</li></ol><h2 id="容器发展史"><a href="#容器发展史" class="headerlink" title="容器发展史"></a>容器发展史</h2><p>虽然现在提到容器，大家就想到<code>docker</code>，但事实上容器是从 1979 年的<code>Chroot</code>开始的。而 docker 是在 2013 年才开始推出第一个版本。具体历程如下：</p><ul><li>1979 年，<code>chroot</code>：一套 Unix 操作系统，为每个进程提供一个隔离化的磁盘空间。</li><li>2000 年，FreeBSD Jails：与 chroot 类似，增加了进程的沙箱，对制作资源进行隔离。</li><li>2001 年，Linux Vserver：每个分区被称为一套安全上下文，其中虚拟化系统被称为一套虚拟私有服务器。</li><li>2004 年，Solaris 容器：将系统资源控制与分区提供的边界结合，各分区在单一的操作系统实例之内。</li><li>2005 年，OpenVZ：安装有补丁的 Linux 内核实现虚拟化，隔离能力，资源管理以及检查点交付。</li><li>2006 年，Process 容器：对整套进程集合中的资源使用量进行限制，分配与隔离。</li><li>2007 年，<code>Control Groups</code>：谷歌实现的 Cgroups，后被合并到 Linux 内核中。</li><li>2008 年，LXC：通过 liblxc 库交付，提供可与 Python，Lua，Go 等语言对接的 API。</li><li>2011 年，Warden：不与 Linux 紧密耦合，以后台进程方式运行，并提供 API 以实现容器管理。</li><li>2013 年，<code>Docker</code>：目前最流行的容器引擎，具备完整的生态系统。</li><li>2014 年，<code>Rocket</code>：由 CoreOS 开发，专门用于解决 docker 中存在的缺陷。</li><li>2016 年，Windows 容器：docker 能够在 Windows 平台上运行。</li></ul><h2 id="容器标准化"><a href="#容器标准化" class="headerlink" title="容器标准化"></a>容器标准化</h2><blockquote><p>docker 是容器，但容器并不只有 docker。</p></blockquote><p>任何技术出现都需要一个标准来规范它，不然各搞各的很容易导致技术实现的碎片化，出现大量的冲突和冗余。所以，在 2015 年，由 Google，Docker、CoreOS、IBM、微软、红帽等厂商联合成立了<code>OCI（Open Container Initiative）</code>组织，并于 2016 年 4 月推出了第一个开放容器标准。其主要内容包括 <code>runtime 运行时标准</code> 和 <code>image 镜像标准</code>。</p><p>该标准的推出，保障了市场的稳定性，让企业能放心采用容器技术，用户在打包、部署应用程序后，可以自由选择不同的容器 Runtime。同时，镜像打包、建立、认证、部署、命名也都能按照统一的规范来做。</p><p>两种标准主要包含以下内容：</p><h3 id="容器运行时标准-（runtime-spec）"><a href="#容器运行时标准-（runtime-spec）" class="headerlink" title="容器运行时标准 （runtime spec）"></a>容器运行时标准 （runtime spec）</h3><p>规定了容器的基本操作规范。</p><ol><li>creating：使用 create 命令创建容器，这个过程称为创建中。</li><li>created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台。</li><li>running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务。</li><li>stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除。</li></ol><h3 id="容器镜像标准（image-spec）"><a href="#容器镜像标准（image-spec）" class="headerlink" title="容器镜像标准（image spec）"></a>容器镜像标准（image spec）</h3><p>定义镜像的基本格式。</p><ol><li>文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等。</li><li>config 文件：保存了文件系统的层级信息，以及容器运行时需要的一些信息，指定了镜像在某个特定平台和系统的配置。</li><li>manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，还保存了很多和当前平台有关的信息。</li><li>index 文件：可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习一门技术</title>
      <link href="/2022/how-to-learn-tech/how-to-learn-tech/"/>
      <url>/2022/how-to-learn-tech/how-to-learn-tech/</url>
      
        <content type="html"><![CDATA[<p>作为一个<code>终身学习</code>的实践者，我经常有学习一些新技术的需求。如何学习这些新技术不同人有不同的做法，早前我也写过一篇 <a href="/2022/06/01/leran-skill/">如何快速学习一项新技能？</a> 的文章分享我学习的理论框架，但这篇文章我会以我学习WebRTC这个技术为例分享我在学习新技术时用的一些方法。</p><p>如何学习某个知识，在我看来，主要矛盾在于解决这三个问题。</p><h3 id="要学否"><a href="#要学否" class="headerlink" title="要学否"></a>要学否</h3><p>在学习一门新技术前需要解决的第一个问题是<strong>要不要投资时间去学这门技术</strong>。就像买书最大的成本并不是买书的价格，而是看书的时间。花费大量的时间去看一本没有价值的书，无异于浪费生命。正是方向搞错了，越努力越尴尬。</p><p>怎么确定一门技术的价值，可以从以下两个方面来考虑：</p><ul><li><strong>从知识体系出发</strong>：某门技术经常不是孤立存在的，而是一个积木般搭建的大厦的一部分。要学习顶部的技术，就需要掌握一定的底部技术。如果一个技术很基础很底层，被很多高层的技术所依赖，那学习这门技术就很有价值。</li><li><strong>从应用前景出发</strong>：如果一门技术很有市场“钱景”，或者有潜在的市场需求，那学习这门技术就很有价值。毕竟我们学习目的很大的一部分在于赚钱解决自己的生活问题。</li></ul><p>不过这里的难点在于从我们已知的信息来分析，很难判断某门技术的市场前景。如果分析判断错误，很可能会导致我们学习这门技术的时间被浪费。那最佳的选择的就是尽可能让自己所学的技术都满足这两点，哪怕最后没有市场前景，但如能成为我们知识体系的基础，也值得投入时间去学习。</p><p>基于这两方面的考虑，我开始学习了分布式系统的一些底层知识：</p><p><img src="/img/2022/how-to-learn-tech/578bc683-a3ba-f6f8-7c6a-965b95181c58.webp"></p><p>之后通过搜索，间接找到了基于WebRTC技术的语音聊天网站<a href="https://speakrandom.com/">speakrandom</a>，在分析这个网站技术栈的时候找到了<a href="https://github.com/pion/webrtc">pion&#x2F;webrtc</a>这个框架，最终决定从这个框架入手开始学习WebRTC。</p><h3 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h3><p>在制定了学习目标之后，剩下的问题是怎么怎么学？学习方法千万条，重要的是找到适合自己的学习方法。</p><p>我的方法是<strong>善用搜索，找到对的资料和对的人</strong>。学习本身不应是一件复杂的事情，因为它不是做研究，不是探索未知的东西，只是站在巨人的肩膀上把已经被解决的问题学习一遍。</p><p>但这里的难点在于资料千万份，一不小心就找到错误的资料，让本来简单的学习变得复杂，这就像天龙八部鸠摩智学了段誉给的错误的六脉神剑剑诀，很容易学的走火入魔。</p><h4 id="主动搜索"><a href="#主动搜索" class="headerlink" title="主动搜索"></a>主动搜索</h4><p><code>主动获取资料</code>方式的要点在于从错误少的信息库筛选、交叉对比选择要看的资料。由于很多技术资料都是用英文写的，用Google英文搜索更容易获取高质量的资料。另外使用Google图片关键词搜索可以快速获得架构方面的资料，方便从高层次理解这个技术。</p><p>一般我会从Google、YouTube、bilibili和GitHub上搜索某个技术相关的资料、视频教程和开源库。以搜索切入，找到合适的开源项目或者技术标准，然后制定学习计划。很容易通过<code>webrtc</code>关键词在这些平台上搜索得到这些资料和教程：</p><ul><li>GitHub<ul><li><a href="https://github.com/pion/webrtc">https://github.com/pion/webrtc</a></li></ul></li><li>YouTube<ul><li>WebRTC Crash Course</li></ul></li><li>Google<ul><li>Build the backend services needed for a WebRTC app: STUN, TURN, and signaling - HTML5 Rocks</li></ul></li></ul><p>从pion&#x2F;webrtc这个库上了解到作者是<a href="https://github.com/Sean-Der"><code>@Sean DuBois</code></a>，GitHub关注一波然后去YouTube搜索下他的演讲，又收获了一波高质量的教程：</p><p><img src="/img/2022/how-to-learn-tech/e0c41270-6329-edcb-815e-a83fc2ede51e.webp"></p><h4 id="技术标准"><a href="#技术标准" class="headerlink" title="技术标准"></a>技术标准</h4><p>另外一个高质量的资料是协议标准，比如<code>IETF RFC</code>文档。搜索一番后找到WebRTC相关的标准：</p><ul><li><a href="https://www.w3.org/TR/webrtc/">https://www.w3.org/TR/webrtc/</a></li></ul><p>从这个<code>W3C</code>制定的标准里又可以看到很多<code>IETF RFC</code>的资料。了解这些技术标准有助于我从高层次理解这个技术的一些特性。当然这些标准的细节我暂时不会去看，等到需要了解细节的时候再去看。</p><p>另外还可以从标准中梳理出这个技术的一些历史背景知识。</p><h4 id="技术历史"><a href="#技术历史" class="headerlink" title="技术历史"></a>技术历史</h4><p>复杂的技术不是横空出世的，而是从简单的技术逐渐根据需求而演变来的。很多时候一个技术的复杂是因为其有很多历史性而导致的，比如Java的范型之所以使用复杂并具备很多限制性是因为其为兼容老的库而妥协设计出的产物。了解这个技术的历史背景有助于降低理解这个技术的复杂度。</p><h4 id="做好笔记"><a href="#做好笔记" class="headerlink" title="做好笔记"></a>做好笔记</h4><p>搜索而来的资料如果不做整理和记录的话，时间久了就全忘了。我把这些资料整理到了<a href="https://logseq.com/"><code>Logseq</code></a> 这个双链笔记中。</p><p><img src="/img/2022/how-to-learn-tech/0cc2b35b-e70c-547c-f0fa-26a54178da87.webp"></p><p>从下面这个笔记拓扑图中可以看出我记录的分布式知识（Distributed System）和<code>WebRTC</code>间的关联关系。众所周知，学习在大脑的体现就是神经元突触之间建立新的连接，笔记间的知识通过这种方式也能帮助我们快速建立知识间的联系。</p><p><img src="/img/2022/how-to-learn-tech/feafeb84-b5f7-3b81-3b07-3bc04fa4375d.webp"></p><h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><p>记录完笔记后，我要做的就是规划时间把整理得来的资料学习消化。在这个环节可用<code>时间管理</code>的方法制定该项技术的学习计划。</p><h4 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h4><p>学习技巧千万条，但有一条是我觉得很重要的，那就是把你所学的<strong>说给别人听</strong>，从别人的反馈中了解自己对该知识掌握薄弱的点。很多时候大脑在学习的过程中会有很多模糊不清的点，如果不说出来的话，这些不清楚的点会被忽略掉，但如果要让别人听得懂，那需要我们懂的更多才行。</p><p><img src="/img/2022/how-to-learn-tech/e62f6b6b-637f-b8bc-0210-60578ba8664c.webp"></p><p>写文章其实也是说给别人听，只不过比单纯的说要更为系统。所以我一般在学习某个技术的时候会去写文章分享。一方面让自己的知识梳理的更清晰，另外一方面可以与读者交流，掌握更多的知识，这也可以解决掉那个经典的我不知道我不知道的知识，当我写出来时，会有看到的人帮我发现我不知道的知识。</p><p>当然也可以在社交网站上分享一些学习中梳理的知识点，之后方便整合成文章：</p><p><img src="/img/2022/how-to-learn-tech/7b4629f4-e36c-2af1-4385-a6f41a0f72fb.webp"></p><h4 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h4><p>找对的人解决学习中的困惑无异于能加速整个学习过程。这方面很多开源项目都有自己的讨论区，比如我在理解WebRTC SFU的过程中就有很多困惑甚至错误的理解，在社区中与作者沟通后才得到了正确的答案：</p><p><img src="/img/2022/how-to-learn-tech/e6a7869e-5cfc-6ecc-bfa5-5ebcbc7e11df.webp"></p><p>当然我们还可以在论坛、GitHub Issue、邮件组或交流群等地方中寻求帮助。</p><h4 id="心理建设"><a href="#心理建设" class="headerlink" title="心理建设"></a>心理建设</h4><p>学习里的一大难点可能是不好意思说出自己不懂的点，尤其是工作多年后，要承认自己不懂是件困难的事情。但如果你以终身学习为目标，那么这方面就没什么障碍。不懂就去学，不懂就去问。无知并不可怕，年龄大不懂也不可怕，可怕的是不懂却隐藏这一点。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>在掌握了技术的理论后，可以通过技术的实践来提高自己的技术水平，比如做一个开源项目。对技术的应用有两种方式：</p><ul><li>从零开始，一步步实现自己的系统。这种方式的问题在于，刚开始我们对技术的应用不是很熟悉，完全自己做可能无法应用一些最佳实践，摸着石头过河的成本比较高。</li><li>从现有的应用中改造。开源项目有很多好的应用，可以直接用来学习并改造。一方面可以加速应用的开发，另外还可以学习别人成熟的经验。</li></ul><p>通过一番搜索，我找到了两个不错的学习项目：</p><ul><li><a href="https://github.com/fletcherist/webtrc-voice-chat">webtrc-voice-chat</a></li><li><a href="https://github.com/MixinNetwork/kraken">kraken</a></li></ul><p>这两个都是基于pion&#x2F;webrtc库开发的语音聊天网站。基于这两个开源项目，我可以逐渐学习并开发自己的开源项目。</p><p>这个目标有点大，我会把这个业余项目作为技术试验田，把需要学习应用的技术都应用到这里。</p><p><strong>学以致用，是学习的最终目的</strong>。只有真正去用这个技术，才能真正掌握它。否则花费时间去学习，不用的话很快就忘了。</p><p>最后，能看到这里的话，希望这篇文章里提到的一些方法能让你更快速的学习某个领域的技术。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 技术方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 技术方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速学习一项新技能？</title>
      <link href="/2022/leran-skill/leran-skill/"/>
      <url>/2022/leran-skill/leran-skill/</url>
      
        <content type="html"><![CDATA[<p>马上就要高考了，还记得当初读高中时书店里有不少《21天学会XXX》的书，到了大学后书店里还是有不少这类型的书。今天在Quora上有一个热门问题：“如何在一晚上学会写代码？”有个高票回答大意是带着笔记本去冬天刚来临的北极，这样就有一晚上约六个月时长的时间来学习写代码了。从调侃式的回答中表明了某些领域如编程就算是一个天才也需要一定的时间来学习实践。</p><hr><p>这两件事从侧面说明大众对快速学习新技能的渴望，但是很多快速学习的书或文章一般看了都没什么效果，大多都是一堆知识的罗列，没有一套系统化的理念和执行的框架根本不可行。</p><p>社会在全球化背景下的迅速发展，互联网对各个行业的不断渗透，传统经验积累式门槛的逐渐消除，多领域降维打击般的隐形竞争，都在迫使我们需要短期内快速学习很多领域知识。</p><p>在万众创新、全民创业的号召下，我也曾经历过一段创业历程。在创业的过程中经常面临着许多变化，经常需要我快速学习、快速决策、快速改变。这段经历迫使我建立了自己的一套快速学习框架，它让我在多个需要学习的领域从容应对，我给它起了个抽象的名字：<code>元学习</code>。</p><h3 id="元学习流程"><a href="#元学习流程" class="headerlink" title="元学习流程"></a>元学习流程</h3><blockquote><p>以下工具都可以在你自认为合适的情况下替换，不接受diss</p></blockquote><ol><li><p>制定目标：确定学习目标、期望效果及学习周期</p></li><li><p>信息收集：尽可能通过多种途径搜索相关信息，如搜索引擎、社区、专业人士及书</p></li><li><p>模式匹配：综合快速对比信息，确定最优学习路径</p></li><li><p>制定计划：学习理论并制定学习执行计划</p></li><li><p>执行计划：使用OmniFocus与OneNote开始执行并实践计划</p></li><li><p>回顾计划：使用OmniFocus与OneNote每周、每月定期检查计划执行情况</p></li><li><p>优化改善：使用OneNote从结果反馈中完善技能</p></li></ol><h3 id="元学习实例"><a href="#元学习实例" class="headerlink" title="元学习实例"></a>元学习实例</h3><p>理论看着很空，我依旧拿一个简单的实例来展示我是如何实践这套框架的。需要说明的一点是这套元学习框架并不是什么新奇的东西，很多执行力强的人大多也是按这套流程来学习新领域，在这其中我认为很重要的一点是你需要通过不断的解决一个个问题来快速获得该领域的知识，该领域的理论知识你不需要学习太充分，大概理解的差不多的时候就去实践，在解决问题的过程中学习。</p><p>在昨天的时候我因为学习移动端安全的目的要研究如何反编译iOS上架App。我使用Google查找相关资料，在打开十几篇文章后我把感觉不错的资料放入OneNote学习笔记本的开发技术分区中的iOS主题分页中以便日后查看，还找到一个很短的Youtube视频讲解看了下。在大致了解了所需要的工具和流程后，我在OmniFocus中建立了初步的学习计划，这样我可以按计划去学习该领域知识，OmniFocus会在计划的时间内去提醒我当日要做的任务。</p><p>上述场景是一个非常简单的实例：</p><ol><li><p>我给自己制定了一个学习目标：在一周内研究并实践iOS反编译技术。</p></li><li><p>我用Google查找了很多相关的技术资料，了解了使用的工具及流程。</p></li><li><p>利用已有的经验和论坛上相关的讨论，我很快确定了下一步要学习的计划。</p></li><li><p>我查看了在OneNote收集的资料，并制定了学习计划。</p></li><li><p>我在OmniFocus中制定了该主题的学习计划，这样就可以利用空闲时间去学习这个领域知识，而OmniFocus也会在相应的学习周期中去提醒我当日在该领域的学习任务，我会在每天的待办事项中去执行它。</p></li><li><p>一周结束后我回去回顾这个计划，查看是否执行完毕，如果未完毕则重新调整计划。</p></li><li><p>如果该领域知识已经掌握，我会在OneNote中记录所有和这个领域知识相关的资料，这样方便我日后做进一步的完善。</p></li></ol><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><p>这套学习框架看似平淡无奇，但是会有不少人遇到问题。</p><ol><li><p>找不到合适的目标。对于这个问题来说，我觉得可以先给自己找一个学习榜样。比如在社区里遇到很厉害的高手，你想学习他的技能，那么你可以去看他的作品或履历，这样你可能会建立自己的学习目标。</p></li><li><p>无法收集有效资料。首先请提高你的信息检索能力和学会翻墙（我们是局域网，学会翻墙可以让你上真正的互联网），这方面又很多教程可以供你学习。互联网有大量的有效资料，很多时候是你搜索技术有问题而不是没有这个资料。如果实在找不到，你可以去周边大学的图书馆里去查找，那里可以找到很多学术期刊资料。</p></li><li><p>无法制定学习计划。能出现这个问题，说明你对该领域知识宏观上还是缺乏了解，所做的阅读量并不够，多研究该领域学习者的经验分享可以让你制定合理的学习计划从而少走很多弯路。</p></li><li><p>领域知识无法长久保留下去。这方面你需要把该领域相关知识建立在OneNote同一个分区下，这样方便日后查找。同时尽可能学习一些长期技能，因为最大的学习成本是时间，如果你把大量的时间都投入到用一次就不用的领域里，那你就是选择了错误的方向，而错误方向的努力反而是最大的懒惰。</p></li><li><p>没有时间去执行计划。这说明你并不了解你的时间分配，很少会出现一个人忙到没有时间去完成自己的学习计划。如果你真的觉得没有时间，那是因为你自己把它浪费掉了。这方面可以看我之前写的文章： 利用GTD理念管理你的时间</p></li><li><p>计划执行总是出现偏差。这个需要你定期会回顾这个计划，我会在每周周末和每月月末去回顾我本周和本月的计划，查看是否有的项目需要我重现做调整。很多计划无法执行下去，也是和没有做定期回顾有关。人的记忆容量有限，所以很容易忘掉很多事情，如果你定期回顾你的计划，那么执行起来也会很容易的。</p></li></ol><p>我们可以通过大量的阅读和查看多领域的信息，在每天接受信息的过程中对知识体系进行微升级并建立新的知识点连接，从而产生跨领域创作经验，这样就可以建立你自己的能力圈。这其中建立好自己的信息渠道很重要，因为当你打开你的朋友圈后看到的都是做微商广告的，你的邮箱又经常收到很多垃圾邮件，你的手机每天推送给你的都是很多垃圾资讯，这样就会导致你无法接受高质量的信息，也就很难去打造自己的知识体系。我会在日后写一篇如何构建自己的信息渠道的文章。</p><h3 id="简单技能组合"><a href="#简单技能组合" class="headerlink" title="简单技能组合"></a>简单技能组合</h3><p>在<code>UNIX</code>系统设计哲学里，推崇的是用小工具组合来解决复杂的问题：小程序之间通过管道连接，前一个程序的输出可以做后一个程序的输入，通过简单的连接打造极为强大的软件系统。</p><hr><p>这是一种优秀的设计，简单而强大。我也相信我们可以通过建立简单的长期技能，然后把不同的技能组合在一起，通过简单的技能组合你就可以解决很多复杂的问题。比如我们给公众号写一篇文章，这需要我们有阅读总结技能、设计排版技能、写作技能、运营推广技能等，每个技能不需要非常专业精通，也许你只是简单了解这个领域的知识，但是你一旦你去综合的运用这些技能的时候，你就解决了很复杂的大问题。简单的技能只需要你花不长的时间就可以掌握，如果该技能失去用途，你的时间成本损失也不是很高。如果你花了很多时间去学习了一个技能后，一旦因为大环境的改变导致这个领域知识失去用途，那你的损失将会非常之高。而经过一系列组合后，简单的技能也可以爆发出很大的威力。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 技术方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的跨域Content Security Policy通行设置</title>
      <link href="/2022/nginx-content-security-policy/nginx-content-security-policy/"/>
      <url>/2022/nginx-content-security-policy/nginx-content-security-policy/</url>
      
        <content type="html"><![CDATA[<h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>A 站点 HTTPS，A 站点做为中心站，引用 B&#x2F;C&#x2F;D&#x2F;E&#x2F;F……站点的资源进行供给，确定的只有 A 站点是 HTTPS，其它站点可能是 HTTP 也可能是 HTTPS，文件类型不限定，包括但不限于：CSS,JS,IMAGE,MP4,MP3,RAR,ZIP,M3U8,FLV……。</p><p>如果你使用的是默认配置，那么它会提示以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://site.com/index.m3u8&#x27; from origin &#x27;http://site&#x27; has been blocked by CORS policy: The response is invalid.</span><br></pre></td></tr></table></figure><p>知道通常情况下，HTTPS 引用 HTTP 的资源就会出现跨域错误，但今天我们的要求是允许它跨域，并且尽量保证它是基本安全的。</p><p>在上周我测试过很多方案，最终使用的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;upgrade-insecure-requests&quot;;</span><br></pre></td></tr></table></figure><p>意思是将所有 HTTP 请求尽可能的转换成 HTTPS 请求，如果对方同时支持 HTTPS 和 HTTP 协议，那这没有任何问题，但如果对方只支持 HTTP，那这时候就会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Refused to load the image &#x27;http://site/file.png&#x27;</span><br><span class="line">because it violates the following Content Security Policy directive:</span><br></pre></td></tr></table></figure><p>看到提示后直觉告诉我要去放行<code>img-src</code>和<code>media-src</code>，但当我去放行设置后，问题依旧，甚至还多出了错误。</p><h3 id="Content-Security-Policy-内容安全策略"><a href="#Content-Security-Policy-内容安全策略" class="headerlink" title="Content-Security-Policy 内容安全策略"></a>Content-Security-Policy 内容安全策略</h3><p>内容安全策略（CSP）需要仔细调整和精确定义策略。如果启用，CSP 会对浏览器呈现页面的方式产生重大影响（例如，默认情况下禁用内联 JavaScript，并且必须在策略中明确允许）。CSP 可防止各种攻击，包括跨站点脚本和其他跨站点注入。</p><h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><table><thead><tr><th>Directive</th><th>Description</th></tr></thead><tbody><tr><td>base-uri</td><td>Define the base uri for relative uri.</td></tr><tr><td>default-src</td><td>Define loading policy for all resources type in case of a resource type dedicated directive is not defined (fallback).</td></tr><tr><td>script-src</td><td>Define which scripts the protected resource can execute.</td></tr><tr><td>object-src</td><td>Define from where the protected resource can load plugins.</td></tr><tr><td>style-src</td><td>Define which styles (CSS) the user applies to the protected resource.</td></tr><tr><td>img-src</td><td>Define from where the protected resource can load images.</td></tr><tr><td>media-src</td><td>Define from where the protected resource can load video and audio.</td></tr><tr><td>frame-src</td><td>Deprecated and replaced by child-src. Define from where the protected resource can embed frames.</td></tr><tr><td>child-src</td><td>Define from where the protected resource can embed frames.</td></tr><tr><td>frame-ancestors</td><td>Define from where the protected resource can be embedded in frames.</td></tr><tr><td>font-src</td><td>Define from where the protected resource can load fonts.</td></tr><tr><td>connect-src</td><td>Define which URIs the protected resource can load using script interfaces.</td></tr><tr><td>manifest-src</td><td>Define from where the protected resource can load manifest.</td></tr><tr><td>form-action</td><td>Define which URIs can be used as the action of HTML form elements.</td></tr><tr><td>sandbox</td><td>Specifies an HTML sandbox policy that the user agent applies to the protected resource.</td></tr><tr><td>script-nonce</td><td>Define script execution by requiring the presence of the specified nonce on script elements.</td></tr><tr><td>plugin-types</td><td>Define the set of plugins that can be invoked by the protected resource by limiting the types of resources that can be embedded.</td></tr><tr><td>reflected-xss</td><td>Instructs a user agent to activate or deactivate any heuristics used to filter or block reflected cross-site scripting attacks, equivalent to the effects of the non-standard X-XSS-Protection header.</td></tr><tr><td>block-all-mixed-content</td><td>Prevent user agent from loading mixed content.</td></tr><tr><td>upgrade-insecure-requests</td><td>Instructs user agent to download insecure resources using HTTPS.</td></tr><tr><td>referrer</td><td>Define information user agent must send in Referer header.</td></tr><tr><td>report-uri</td><td>Specifies a URI to which the user agent sends reports about policy violation.</td></tr><tr><td>report-to</td><td>Specifies a group (defined in Report-To header) to which the user agent sends reports about policy violation.</td></tr></tbody></table><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p><code>Content-Security-Policy: script-src &#39;self&#39;</code></p><h4 id="在经过反复测试后"><a href="#在经过反复测试后" class="headerlink" title="在经过反复测试后"></a>在经过反复测试后</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;upgrade-insecure-requests;connect-src *&quot;;</span><br></pre></td></tr></table></figure><p>解决了全部问题，即消除全部警告，同时兼容了各种协议资源。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></li><li><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#csp">https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#csp</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 服务器 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本管理操作规范及gitflow使用</title>
      <link href="/2022/git-flow/git-flow/"/>
      <url>/2022/git-flow/git-flow/</url>
      
        <content type="html"><![CDATA[<blockquote><p>版本&#x2F;分支管理规范，主要包括 commit 规范，版本号管理规范，mversion 的使用方法，commitizen 的使用方法，git 常用命令收集，gitflow 使用说明</p></blockquote><h3 id="有模板的项目，要以统一的模板创建项目"><a href="#有模板的项目，要以统一的模板创建项目" class="headerlink" title="有模板的项目，要以统一的模板创建项目"></a>有模板的项目，要以统一的模板创建项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git.com:your-project/your-project.git</span><br></pre></td></tr></table></figure><h3 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h3><p>git commit 提交样式标准</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;type(scope): 描述(#issue)&quot;</span><br></pre></td></tr></table></figure><blockquote><p>git commit -m “type(类型): 描述(#issue)”</p></blockquote><h4 id="lt-类型-gt"><a href="#lt-类型-gt" class="headerlink" title="&lt;类型&gt;"></a><strong style="color: #c7254e;background-color: #f9f2f4;">&lt;类型&gt;</strong></h4><p>用于说明 commit 的类别，只允许使用下面 7 个标识。</p><ul><li>feat：新功能（feature）</li><li>fix：修补 bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><h4 id="lt-内容-gt"><a href="#lt-内容-gt" class="headerlink" title="&lt;内容&gt;"></a><strong style="color: #c7254e;background-color: #f9f2f4;">&lt;内容&gt;</strong></h4><p>对本次 commit 的详细描述，可以分成多行，可详细说明代码变动的动机</p><h4 id="lt-结尾-gt"><a href="#lt-结尾-gt" class="headerlink" title="&lt;结尾&gt;"></a><strong style="color: #c7254e;background-color: #f9f2f4;">&lt;结尾&gt;</strong></h4><p>如果当前 commit 针对某个 issue，那么可以在 Footer 部分关闭这个 issue：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #234</span><br></pre></td></tr></table></figure><blockquote><p><strong>commitizen 使用说明</strong><br>全局安装：</p><p><code>npm install -g commitizen</code></p><p>进入到<code>.git</code>目录</p><p><code>commitizen init cz-conventional-changelog --save --save-exact</code></p><p>用<code>git cz</code>命令来取代<code>git commit</code></p></blockquote><h3 id="版本号规范"><a href="#版本号规范" class="headerlink" title="版本号规范"></a>版本号规范</h3><p>初期开发版本号从 0.1.0 开始</p><p>初次上线版本号更换为 1.0.0</p><p>使用 npm install -g mversion 更新版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mversion</span><br></pre></td></tr></table></figure><p><strong>版本号修改规则及命令：</strong></p><p>v1.0.0 （主版本号.次版本号.修订版）</p><ul><li>主版本号：当功能模块有较大的变动（不向下兼容），比如增加多个模块或者整体架构有较大改动的情况<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mversion m // 1.0.0 =&gt; 2.0.0</span><br></pre></td></tr></table></figure></li><li>子版本号：当功能有一定的增加或变化（向下兼容），比如增加了对权限控制、增加登录校验……<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mversion i // 1.0.0 =&gt; 1.1.0</span><br></pre></td></tr></table></figure></li><li>修订号：一般是<code>Bug</code>修复或是一些小的变动（向下兼容），要经常发布修订版，时间间隔短<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mversion p // 1.0.0 =&gt; 1.0.1</span><br></pre></td></tr></table></figure></li></ul><p>修改完成测试通过后在项目文档中写入更新内容，新建 tag 并推送到远程分支</p><p>可在.mversionrc 中添加 hooks 自动添加 tag</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;preupdate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo &#x27;Bumping version&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;postupdate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git add package.json &amp;&amp; git commit -m v%s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;precommit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo &#x27;precommit&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;postcommit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo &#x27;postcommit&#x27;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.com/package/mversion">mversion 文档</a></p><p><code>git tag -a v1.4 -m &#39;version 1.4&#39;</code></p><p><code>git push --tags</code></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><code>commit</code>统一规范</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;type(scope): 描述(#issue)&#x27;</span><br></pre></td></tr></table></figure><p>切换到指定 tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure><p>使用<code>git tag</code>命令添加一个新的标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m &#x27;version 1.4&#x27;</span><br></pre></td></tr></table></figure><p>删除本地<code>tag</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d tag_name</span><br></pre></td></tr></table></figure><p>从指定 tag 新建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure><p>clone 指定 tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch [tags标签] [git地址]</span><br></pre></td></tr></table></figure><h3 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git flow"></a>Git flow</h3><blockquote><p>新项目第一次必须执行</p></blockquote><p><code>git flow init</code></p><h4 id="分支操作说明"><a href="#分支操作说明" class="headerlink" title="分支操作说明"></a>分支操作说明</h4><h5 id="feature-新功能开发：从-dev-新建-feature-分支-开发完成后会合并到-dev"><a href="#feature-新功能开发：从-dev-新建-feature-分支-开发完成后会合并到-dev" class="headerlink" title="feature 新功能开发：从 dev 新建 feature 分支 开发完成后会合并到 dev"></a>feature 新功能开发：从 dev 新建 feature 分支 开发完成后会合并到 dev</h5><p><code>git flow feature start [version]</code></p><p>some commit…</p><p><code>git flow feature publish [version]</code></p><p><code>git flow feature finish [version]</code></p><p><code>git push</code></p><h5 id="release：从-dev-新建-release-分支-gt-最后会合并到-master-和-dev-gt-发布新版"><a href="#release：从-dev-新建-release-分支-gt-最后会合并到-master-和-dev-gt-发布新版" class="headerlink" title="release：从 dev 新建 release 分支 -&gt; 最后会合并到 master 和 dev -&gt; 发布新版"></a>release：从 dev 新建 release 分支 -&gt; 最后会合并到 master 和 dev -&gt; 发布新版</h5><p><code>git flow release start [version]</code></p><p><code>mversion p</code> &#x2F;&#x2F; 更新版本号</p><p>some commit…</p><p><code>git flow release publish [version]</code></p><p><code>git flow release finish [version]</code></p><p><code>git push --all &amp;&amp; git push --tag</code></p><h5 id="修复线上-bug：从-master-新建-hotfix-分支-gt-合并-master-和-dev-gt-发布新版"><a href="#修复线上-bug：从-master-新建-hotfix-分支-gt-合并-master-和-dev-gt-发布新版" class="headerlink" title="修复线上 bug：从 master 新建 hotfix 分支 -&gt; 合并 master 和 dev -&gt; 发布新版"></a>修复线上 bug：从 master 新建 hotfix 分支 -&gt; 合并 master 和 dev -&gt; 发布新版</h5><p><code>git flow hotfix start [version]</code></p><p><code>mversion p</code> &#x2F;&#x2F; 更新版本号</p><p><code>some commit…</code></p><p><code>git flow hotfix publish [version]</code></p><p><code>git flow hotfix finish [version]</code></p><p><code>git push --all &amp;&amp; git push --tag</code></p><h3 id="Git-Flow-的常用分支"><a href="#Git-Flow-的常用分支" class="headerlink" title="Git Flow 的常用分支"></a>Git Flow 的常用分支</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><ul><li>主分支 , 产品的功能全部实现后 , 最终在 master 分支对外发布</li><li>该分支为只读唯一分支 , 只能从其他分支(release&#x2F;hotfix)合并 , 不能在此分支修改</li><li>另外所有在 master 分支的推送应该打标签做记录,方便追溯</li><li>例如 release 合并到 master , 或 hotfix 合并到 master</li></ul><h4 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h4><ul><li>主开发分支 , 基于 master 分支克隆</li><li>包含所有要发布到下一个 release 的代码</li><li>该分支为只读唯一分支 , 只能从其他分支合并</li><li>feature 功能分支完成 , 合并到 develop(不推送)</li><li>develop 拉取 release 分支 , 提测</li><li>release&#x2F;hotfix 分支上线完毕 , 合并到 develop 并推送</li></ul><h4 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h4><ul><li>功能开发分支 , 基于 develop 分支克隆 , 主要用于新需求新功能的开发</li><li>功能开发完毕后合到 develop 分支(未正式上线之前不推送到远程中央仓库!!!)</li><li>feature 分支可同时存在多个 , 用于团队中多个功能同时开发 , 属于临时分支 , 功能完成后可选删除</li></ul><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><ul><li>测试分支 , 基于 feature 分支合并到 develop 之后 , 从 develop 分支克隆</li><li>主要用于提交给测试人员进行功能测试 , 测试过程中发现的 BUG 在本分支进行修复 , 修复完成上线后合并到 develop&#x2F;master 分支并推送(完成功能) , 打 Tag</li><li>属于临时分支 , 功能上线后可选删除</li></ul><h4 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a>hotfix</h4><ul><li>补丁分支 , 基于 master 分支克隆 , 主要用于对线上的版本进行 BUG 修复</li><li>修复完毕后合并到 develop&#x2F;master 分支并推送 , 打 Tag</li><li>属于临时分支 , 补丁修复上线后可选删除</li><li>所有 hotfix 分支的修改会进入到下一个 release</li></ul><h3 id="Git-flow-分支流程图"><a href="#Git-flow-分支流程图" class="headerlink" title="Git flow 分支流程图"></a>Git flow 分支流程图</h3><p><img src="/img/2022/git-flow/20210720145803822.png"></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在没有父母的老屋，我只是一个过客</title>
      <link href="/2022/a-passer-by/a-passer-by/"/>
      <url>/2022/a-passer-by/a-passer-by/</url>
      
        <content type="html"><![CDATA[<p>今天，我想给大家分享一篇，让我感受特别深情的散文：</p><blockquote><p>在没有父母的老屋，我只是一个过客</p><p>作者 孙道荣</p></blockquote><p style="text-indent:2em">老家亲戚的孩子结婚，邀请我回去喝喜酒，我欣然应允。</p><p style="text-indent:2em">到了故乡，从车站走出来，我却是有点儿恍惚了。喜宴是明天，我不知道是直奔亲属家好，还是该首先找个酒店住下，明天再赶过去。</p><p style="text-indent:2em">这是母亲去世之后我第一次返乡。父亲早年就已经过世了，三年前，母亲也走了。</p><p style="text-indent:2em">办完母亲的丧事，我在县城的妹妹家小住了几日。离别的时候，妹妹对我说：“哥，你以后回来就上我家来住吧。”当时我点了一点头。但是等我再次回来，站在熟悉却又陌生的车站门口之后，我忽然发现，不知道该往哪去了。</p><p><img src="/img/2022/a-passer-by/nviueafoeu.webp"></p><p style="text-indent:2em">以前当然不是这样的。</p><p style="text-indent:2em">父母在的时候，每次回来，不管多晚，我都不担心。我会搭个车，直奔县城二十里外的家，那个我从小长大的乡村。</p><p style="text-indent:2em">有些时候，我会提前告诉父母我要回来；有些时候，也会突然就出现在了家门口，让父母又惊又喜，嗔怪我搞突然袭击。有些时候并不着急回家，而是先到县城的妹妹家落个脚，然后，再和妹妹全家一大帮子人浩浩荡荡地回乡。</p><p style="text-indent:2em">一到村口，就能够看到手搭额头眺望的老母亲，露水已经打湿了她的衣脚，天知道她从几点就已经站在了村口，一定是妹妹提前告诉了老母亲。</p><p style="text-indent:2em">每次这样兴师动众地回来，这陈旧的老宅忽然被人声塞满，兴奋地吱吱作响。这老宅在我们回来的那一刻，再一次呈现出欢乐、饱满的样子。这才是我熟悉的老宅的味道，家的味道。</p><p><img src="/img/2022/a-passer-by/light.webp"></p><p style="text-indent:2em">这一次，我恍然不知所措。我自然还是可以像以前那样，先到妹妹家去。</p><p style="text-indent:2em">我和妹妹很亲，妹妹的女儿也和我这个舅舅很亲，但那终归是妹妹的家。以前落个脚甚至小住几日都没有关系，因为我有自己家的父母在家里等着我，我随时可以回家。现在去妹妹家，只能是住那儿了，而不是中转一下，我真正地成为了一个借居的客人。想到这儿，我突然提不起兴致去妹妹家，还是先回老屋看一看吧。我在心里，用了老屋这个词，而不是家。这父母不在呀，那里也不就是家了。</p><p style="text-indent:2em">我和妹妹很亲，妹妹的女儿也和我这个舅舅很亲，但那终归是妹妹的家。以前落个脚甚至小住几日都没有关系，因为我有自己家的父母在家里等着我，我随时可以回家。现在去妹妹家，只能是住那儿了，而不是中转一下，我真正地成为了一个借居的客人。想到这儿，我突然提不起兴致去妹妹家，还是先回老屋看一看吧。我在心里，用了老屋这个词，而不是家。这父母不在呀，那里也不就是家了。</p><p style="text-indent:2em">我绕着老屋转了几圈，残破的老屋，和我心中那个家，一起坍塌了一地。</p><p><img src="/img/2022/a-passer-by/ldkgao8e.webp"></p><p style="text-indent:2em">在村口我遇到了一个邻居。和邻居说了一会儿话，话说了一半儿就变成了邀请：“要不，上我家坐一坐吧。”我谢了乡邻，那一刻我意识到，对于这个从小长大的村庄来说，我已经是客了。</p><p><img src="/img/2022/a-passer-by/dsai3r8294ulke.webp"></p><p style="text-indent:2em">乘车回了城入住一家酒店。犹豫了一下，还是给妹妹打了电话，告诉她，我在县城，住在某某宾馆。妹妹嗔怪地说：“哎呀！住什么酒店呐，咋不来家里住呢？”我只能讪笑无语。妹妹又说，“那你过来吃晚饭吧。”我答应了。</p><p style="text-indent:2em">在妹妹家的楼下，遇见了买菜回来的妹妹。邻居看见了她说：“家里来客人啦？”这妹妹立刻说：“什么客人呐，这是我哥！”妹妹的话让我很感动，可是，我知道，那个邻居说的没错，在妹妹家，我是客；在故乡，我也是客。</p><p style="text-indent:2em">那一天晚上我喝了不少。回到酒店，迷迷糊糊地接到儿子的一个电话，儿子问：“爸你明天在家吗？我们明天要回家。”我告诉儿子：“我回老家了，你妈在家呢。” </p><p style="text-indent:2em">放下电话，我泪流满面。在家乡，我已是客人。但是，只要有我在，妻子在，这远方的家就还是儿子的家。</p><p style="text-indent:2em">年少不觉家乡好，年老方知乡愁长。家有父母亲常在，思乡念亲至白头。</p>]]></content>
      
      
      <categories>
          
          <category> 日记心事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记心事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Mac】 奇怪的软件+1，用来快速查看上班进度条的「钱条」</title>
      <link href="/2022/moyu-qiantiao/qiantiao/"/>
      <url>/2022/moyu-qiantiao/qiantiao/</url>
      
        <content type="html"><![CDATA[<p>一个上班的进度条，开始搬砖吧。</p><p>一个可以在macOS顶部显示当日搬砖金额，点击可以显示老板当日欠你多少钱。</p><p>安装后需要简单设置下平均每日工资然后就可以显示进度和金额，然后任务栏会显示图标以及动态的计数器。</p><p>当前版本还不支持直接修改文案内容，该软件为开源软件，有能力大佬们可以自己<a href="https://github.com/Lakr233/MoneyProgress">下载源代码</a>按需进行定制。</p><p>从<code>Mac App Store</code>商店下载安装钱条：<a href="https://apps.apple.com/app/%E9%92%B1%E6%9D%A1-%E4%B8%8A%E7%8F%AD%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1/id1614349717">钱条 - 上班的进度条 </a></p><blockquote><p>钱条效果图：</p></blockquote><p><img src="/img/2022/moyu-qiantiao/MenuBarPreview.png"></p><blockquote><p>钱条设置图：</p></blockquote><p><img src="/img/2022/moyu-qiantiao/ClientPreview.png"></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摸鱼 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 项目中生成类似 GitHub 的随机头像</title>
      <link href="/2022/random-avatar-md5/random-avatar-md5/"/>
      <url>/2022/random-avatar-md5/random-avatar-md5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近个人项目中有头像需求，就想起<code>GitHub</code>的随机头像，通过<code>identicon.js</code>和<code>blueimp-md5</code>两个第三方库实现了，记录一下。</p></blockquote><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="/img/2022/random-avatar-md5/1.png"></p><h3 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img class=&quot;avatar&quot; :src=&quot;url&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Identicon from &#x27;identicon.js&#x27;</span><br><span class="line">  import md5 from &#x27;blueimp-md5&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      num: [Number]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      url() &#123;</span><br><span class="line">        return &#x27;data:image/png;base64,&#x27; + new Identicon(md5(this.num || 0), 420).toString()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">  .avatar &#123;</span><br><span class="line">    width: 40px;</span><br><span class="line">    height: 40px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>第15行的<code>new Identicon(...)</code>必须使用new初始化，具体原因还不清楚，如果有人清楚欢迎在下方评论。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/stewartlord/identicon.js">identicon.js</a></li><li><a href="https://github.com/blueimp/JavaScript-MD5">JavaScript-MD5</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exceljs 导出表格</title>
      <link href="/2022/exceljs/index/"/>
      <url>/2022/exceljs/index/</url>
      
        <content type="html"><![CDATA[<p>工作中我们可能会遇到制作表格的需求，那么针对nodejs如何制作一个汇总表格呢？今天我们就在此介绍下<a href="https://github.com/guyonroche/exceljs">exceljs</a>的基本使用，应该可以满足我们大部分的需求。</p><h3 id="第一部分-下载"><a href="#第一部分-下载" class="headerlink" title="第一部分 下载"></a>第一部分 下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install exceljs</span><br></pre></td></tr></table></figure><h3 id="第二部分-基本的配置"><a href="#第二部分-基本的配置" class="headerlink" title="第二部分 基本的配置"></a>第二部分 基本的配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Excel</span> = <span class="built_in">require</span>(<span class="string">&quot;exceljs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workbook = <span class="keyword">new</span> <span class="title class_">Excel</span>.<span class="title class_">Workbook</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本的创建信息</span></span><br><span class="line">workbook.<span class="property">creator</span> = <span class="string">&quot;Me&quot;</span>;</span><br><span class="line">workbook.<span class="property">lastModifiedBy</span> = <span class="string">&quot;Her&quot;</span>;</span><br><span class="line">workbook.<span class="property">created</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1985</span>, <span class="number">8</span>, <span class="number">30</span>);</span><br><span class="line">workbook.<span class="property">modified</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">workbook.<span class="property">lastPrinted</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图大小， 打开Excel时，整个框的位置，大小</span></span><br><span class="line">workbook.<span class="property">views</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">firstSheet</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">activeTab</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">visibility</span>: <span class="string">&quot;visible&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签创建</span></span><br><span class="line"><span class="keyword">var</span> worksheet = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第一个标签&quot;</span>);</span><br><span class="line">  <span class="comment">// 带颜色的</span></span><br><span class="line"><span class="keyword">var</span> worksheet2 = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第二个标签&quot;</span>, &#123; <span class="attr">properties</span>: &#123; <span class="attr">tabColor</span>: &#123; <span class="attr">argb</span>: <span class="string">&quot;FFC0000&quot;</span> &#125; &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历标签</span></span><br><span class="line">workbook.<span class="title function_">eachSheet</span>(<span class="function">(<span class="params">worksheet, sheetId</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;标签ID：&quot;</span>, sheetId)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(worksheet);</span></span><br><span class="line"><span class="comment">// 删除一个标签</span></span><br><span class="line">workbook.<span class="title function_">removeWorksheet</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstSheet = workbook.<span class="title function_">getWorksheet</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;标签信息-id&quot;</span>, firstSheet.<span class="property">id</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取总的：行/实际行 /列/实际列 个数： &quot;</span>, firstSheet.<span class="property">rowCount</span>, firstSheet.<span class="property">actualColumnCount</span>, firstSheet.<span class="property">columnCount</span>, firstSheet.<span class="property">actualColumnCount</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加那个筛选箭头</span></span><br><span class="line">worksheet.<span class="property">autoFilter</span> = <span class="string">&#x27;A1:C1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">worksheet.<span class="title function_">getRow</span>(<span class="number">5</span>).<span class="property">font</span> = &#123; <span class="attr">size</span>: <span class="number">14</span>, <span class="attr">bold</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&quot;A2&quot;</span>).<span class="property">value</span> = <span class="string">&quot;Site&quot;</span>;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&quot;A2&quot;</span>).<span class="property">font</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Arial Black&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: &#123; <span class="attr">argb</span>: <span class="string">&quot;FF00FF00&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">family</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">italic</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">bold</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save workbook to disk</span></span><br><span class="line">workbook.<span class="property">xlsx</span>.<span class="title function_">writeFile</span>(<span class="string">&quot;first.xlsx&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;saved&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="第三部分-行列的操作"><a href="#第三部分-行列的操作" class="headerlink" title="第三部分 行列的操作"></a>第三部分 行列的操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Excel</span> = <span class="built_in">require</span>(<span class="string">&quot;exceljs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workbook = <span class="keyword">new</span> <span class="title class_">Excel</span>.<span class="title class_">Workbook</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签创建</span></span><br><span class="line"><span class="keyword">var</span> worksheet = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第一个标签&quot;</span>);</span><br><span class="line"><span class="comment">// 带颜色的</span></span><br><span class="line"><span class="keyword">var</span> worksheet2 = workbook.<span class="title function_">addWorksheet</span>(<span class="string">&quot;第二个标签&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">        <span class="attr">tabColor</span>: &#123;</span><br><span class="line">            <span class="attr">argb</span>: <span class="string">&quot;FFC0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置列</span></span><br><span class="line">worksheet.<span class="property">columns</span> = [&#123;</span><br><span class="line">        <span class="attr">header</span>: <span class="string">&#x27;Rating Period&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">38</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">header</span>: <span class="string">&#x27;Name&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">32</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">header</span>: <span class="string">&#x27;D.O.B.&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;DOB&#x27;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">numFmt</span>: <span class="string">&#x27;dd/mm/yyyy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 根据ID添加值</span></span><br><span class="line">worksheet.<span class="title function_">addRow</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">dob</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;);</span><br><span class="line">worksheet.<span class="title function_">addRow</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">dob</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1965</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="number">1</span>).<span class="property">value</span> = <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A6&#x27;</span>).<span class="property">value</span> = <span class="string">&quot;1989&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并单元格</span></span><br><span class="line">worksheet.<span class="title function_">mergeCells</span>(<span class="string">&#x27;A4:A7&#x27;</span>);</span><br><span class="line"><span class="comment">// 合并四个格子</span></span><br><span class="line">worksheet.<span class="title function_">mergeCells</span>(<span class="string">&#x27;A10&#x27;</span>, <span class="string">&#x27;B11&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 格式化显示，</span></span><br><span class="line"><span class="comment">// 数字 1.6 显示 &#x27;1 3/5&#x27;</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">value</span> = <span class="number">1.6</span>;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">numFmt</span> = <span class="string">&#x27;# ?/?&#x27;</span>;</span><br><span class="line"><span class="comment">// 显示 1.60%</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;B1&#x27;</span>).<span class="property">value</span> = <span class="number">0.016</span>;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;B1&#x27;</span>).<span class="property">numFmt</span> = <span class="string">&#x27;0.00%&#x27;</span>;</span><br><span class="line"><span class="comment">// ===== 字体显示</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A3&#x27;</span>).<span class="property">font</span> = &#123;</span><br><span class="line">    <span class="comment">// 字体名</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Comic Sans MS&#x27;</span>,</span><br><span class="line">    <span class="comment">// Font family for fallback. An integer value.</span></span><br><span class="line">    <span class="attr">family</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="attr">size</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="comment">// 下划线</span></span><br><span class="line">    <span class="attr">underline</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 加粗</span></span><br><span class="line">    <span class="attr">bold</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A3&#x27;</span>).<span class="property">value</span> = <span class="string">&quot;测试字体&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 对齐方式</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">alignment</span> = &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">    <span class="attr">horizontal</span>: <span class="string">&#x27;left&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;B1&#x27;</span>).<span class="property">alignment</span> = &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="string">&#x27;middle&#x27;</span>,</span><br><span class="line">    <span class="attr">horizontal</span>: <span class="string">&#x27;center&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;C1&#x27;</span>).<span class="property">alignment</span> = &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="string">&#x27;bottom&#x27;</span>,</span><br><span class="line">    <span class="attr">horizontal</span>: <span class="string">&#x27;right&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 边框</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">border</span> = &#123;</span><br><span class="line">    <span class="attr">top</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;double&#x27;</span>,</span><br><span class="line">        <span class="attr">color</span>: &#123;</span><br><span class="line">            <span class="attr">argb</span>: <span class="string">&#x27;FF00FF00&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">left</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;double&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">bottom</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;thin&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;thin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 填充颜色</span></span><br><span class="line">worksheet.<span class="title function_">getCell</span>(<span class="string">&#x27;A1&#x27;</span>).<span class="property">fill</span> = &#123;</span><br><span class="line">    <span class="comment">// 模式</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;pattern&#x27;</span>,</span><br><span class="line">    <span class="comment">// 填充</span></span><br><span class="line">    <span class="attr">pattern</span>: <span class="string">&#x27;solid&#x27;</span>,</span><br><span class="line">    <span class="comment">// fgColor: &#123;</span></span><br><span class="line">    <span class="comment">//     argb: &#x27;FFFF0000&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// 背景色</span></span><br><span class="line">    <span class="attr">bgColor</span>: &#123;</span><br><span class="line">        <span class="attr">argb</span>: <span class="string">&#x27;FF0000FF&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 图片相关操作直接看GitHub就好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建一个Excel表</span></span><br><span class="line">workbook.<span class="property">xlsx</span>.<span class="title function_">writeFile</span>(<span class="string">&quot;second.xlsx&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;saved&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公开真题库：公务员、事业单位、教资、软考等考试题库</title>
      <link href="/2022/gkzjk/index/"/>
      <url>/2022/gkzjk/index/</url>
      
        <content type="html"><![CDATA[<p>公开真题库提供公务员考试、事业单位考试、教师资格考试、软考等真题整套在线打印和下载服务，包含行测、申论、面试、综合基础知识、职能测试、软考等。</p><p>真题包含答案和解析，需要的可以看看，或者发给身边需要的朋友。</p><p><img src="/img/2022/gkztk/20220316151009.png"></p><p>访问地址：<a href="https://www.gkzenti.cn/">https://www.gkzenti.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 文献资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献整理中国古代气功文化资料大全</title>
      <link href="/2022/gudaiqigongwenhua/index/"/>
      <url>/2022/gudaiqigongwenhua/index/</url>
      
        <content type="html"><![CDATA[<blockquote><p>中国古代气功历史悠久，流派多，内容丰富。自先秦到清代，有气功文献数千种。以下对一些主要的气功古籍，按年代进行整理，并对主要内容进行介绍，希望能对气功爱好者有所帮助。</p></blockquote><h3 id="先秦"><a href="#先秦" class="headerlink" title="先秦"></a>先秦</h3><h4 id="周易"><a href="#周易" class="headerlink" title="周易"></a>周易</h4><p>简称《易》，分经与传两部分。传说由伏羲、周文王、孔子演络共同完成此书。它原是占筮之书，但它的丰富哲学内涵使它成为儒家群书之首。书中认为阴阳二气相互作用，是产生万物的根本，与气功内炼要求达到“阴平阳秘，精神乃治”的目的相通。书中阐述了气功意念入静的道理。后世气功家尤其是内丹家，十分重视该书。东汉魏伯阳等人依据《周易》原理，结合黄帝、老子的学说，以及炼丹的经验，著成“万古丹经王”——《周易参同契》以及北宋张伯瑞著的《悟真篇》均用卦象来说明内炼过程。后世内丹养炼的书，在理论上很少有离开易象来描述的。可以说《周易》的哲学思想是炼养内丹的原头。</p><h4 id="老子"><a href="#老子" class="headerlink" title="老子"></a>老子</h4><p>道家经典著作。分为八十一章。又名《道德经》、《老子五千文》。为周李耳著。书中提出以“道”为核心的哲学体系，主张清静无为、贵柔、守雌、返朴归真、顺其自然，含有朴素的辩证法思想。以养生的道理解释治国，以治国的道理指导养生，融汇了古代气功学说的精华，被后人尊为气功经典。北宋张伯瑞在《悟真篇》中说：“《阴符》宝字愈三百，《道德》灵文止五千。今古上仙无限数，尽从此处达真诠。”《老子》说：“谷神不死，是谓玄牝，玄牝之门，是谓天地根，绵绵若存，用之不勤”、“载形魄抱一，能无离乎”等。这些论述已成为气功实践的指导思想。尽管后世功法千变万化，但基本要点乃与《老子》相同。</p><h4 id="庄子"><a href="#庄子" class="headerlink" title="庄子"></a>庄子</h4><p>道家经典著作。为周庄周撰。又称《南华真经》，全书三十三篇，多以寓言阐述哲理，其中也有不少关于气功的论述。如“踵息”、“心斋”、“坐忘”、“缘督以为经”、“吹喣呼吸，吐故纳新”等等，对后世影响较大。</p><h4 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h4><p>道家经典著作。为周列御寇撰。又称《冲虚至德真经》，全书八篇。以“至虚”、“终天”的思想家为本，其宗旨与《老子》、《庄子》相同。书中很多阐述与气功养生有关，为后世气功重视。</p><h4 id="管子"><a href="#管子" class="headerlink" title="管子"></a>管子</h4><p>为周管仲撰。实系稷下学派论著的大汇编，全书七十六篇，内容庞杂，其中《心术》、《内业》等篇与气功有关。书中的精气学说，对气功养生有一定影响。</p><h4 id="黄帝内经"><a href="#黄帝内经" class="headerlink" title="黄帝内经"></a>黄帝内经</h4><p>中医经典著作。为黄帝撰。全书分《灵枢》与《素问》两大部分，各八十一篇。以问答形式阐述中国医学的基本理论。其学术思想，基本上是朴素的唯物论和辩证法思想。对于生命运动以及人与自然的关系、疾病的成因等都有精辟的论述，其摄生学说与气功养生的关系更为密切。《素问》中的《上古天真论》，《四气调神大论》以及《灵枢》中的《本神》等篇，提倡“恬淡虚无，真气从之，精神内守，病安从来”，任为“提挈天地，把握阴阳，呼吸精气，独立守神，肌肉若一，故能寿敝天地，无有终时”。为中国医学和气功理论的发展奠定了基础。</p><h4 id="阴符经"><a href="#阴符经" class="headerlink" title="阴符经"></a>阴符经</h4><p>道教经典著作。传为黄帝撰。全称为《黄帝阴符经》一篇。该书自唐代李筌公开传播以来，就受到道教学者的重视，各以心得注解，今存四十余种注本。书中某些论述对气功养生有指导意义。</p><h4 id="行气玉佩铭"><a href="#行气玉佩铭" class="headerlink" title="行气玉佩铭"></a>行气玉佩铭</h4><p>气功养生名篇。为战国传世实物上的铭文，共四十四字。全文描述了炼气功时，内气运行的全过程，相当系统完整。</p><h3 id="汉"><a href="#汉" class="headerlink" title="汉"></a>汉</h3><h4 id="养生方"><a href="#养生方" class="headerlink" title="养生方"></a>养生方</h4><p>气功养生著作。湖南长沙马王堆西汉古墓出土。全书分四篇，即《十问》、《合阴阳方》、《杂禁方》《天下至道谈》。内容以养生、服食、吐纳、房中为主，而尤以“房中”为详细，是研究气功养生的可贵资料。</p><h4 id="却谷食气篇"><a href="#却谷食气篇" class="headerlink" title="却谷食气篇"></a>却谷食气篇</h4><p>气功服气辟谷名篇。马王堆西汉古幕出土。全篇四百字。专门研究解绍服气辟谷，方法具体，并任为加服药饵，有相辅相成作用。</p><h4 id="淮南子"><a href="#淮南子" class="headerlink" title="淮南子"></a>淮南子</h4><p>西汉道家思想代表作。为西汉刘安等人撰。又名《淮南鸿烈》，二十一篇。此书是对西汉前期道家思想的总结。在养生方面，发展了道家清静无为的学说，可供气功研究之用。</p><h4 id="周易参同契"><a href="#周易参同契" class="headerlink" title="周易参同契"></a>周易参同契</h4><p>炼丹经典著作。东汉魏伯阳等撰。全书三篇，附《鼎器歌》一首。该书汇通“易”学理论、“黄”、“老”学说与炼丹经验，建立了一个完整的炼丹体系。后世炼丹者无一能出其范围，故称“万古丹经王”，是公认的气功内丹术的经典著作。书中论述了炼丹的三大要素：鼎炉、药物、火侯。以乾卦与坤卦代表鼎炉，以坎卦与离卦代表药物，以屯卦与蒙卦等六十卦代表火侯，药物则杂用黑白、金水、龙虎、魂魄等隐名，火侯又参用纳甲之法，真谓“词韵皆古，奥雅难通”。该书有四十多个注本，流传较广的有五代彭晓的《周易参同契分章通真义》、宋朱熹的《周易参同契考异》、元陈至虚的《周易参同契分章注》、清董德宁的《周易参同契正义》等。其中以董氏注文平实易懂，是入门者的良好读本。</p><h4 id="太平经"><a href="#太平经" class="headerlink" title="太平经"></a>太平经</h4><p>道教早期经典著作。原书一百七十卷，今存五十七卷。东汉于吉等著。该书阐述了精、气、神三者合一的长生不死的神仙思想，以及天、地、人三者合一的治国方法。此经内容庞杂，无所不包，对后世气功的发展有一定影响。</p><h4 id="大安般守意经"><a href="#大安般守意经" class="headerlink" title="大安般守意经"></a>大安般守意经</h4><p>禅观经典著作。两卷。东汉安世高译。为最早传入中国的佛教修习禅观典籍之一。主要内容为论述数息、相随、止、观还、净等六事，以及与三十七道品之关系。书中十分重视数息法，提出了“四相”之说，对后世有深远影响。</p><h3 id="晋"><a href="#晋" class="headerlink" title="晋"></a>晋</h3><h4 id="黄庭经"><a href="#黄庭经" class="headerlink" title="黄庭经"></a>黄庭经</h4><p>道教气功经典著作。书分三种：《黄庭内景经》、《黄庭外景经》、《黄庭中景经》，各一卷。《内景经》成书于西晋太康年间，《外景经》成书于东晋年间，《中景经》约成书于南北朝间，是在“内”、“外”两经的基础上综合加工而成。《黄庭经》提出的“三黄庭”、“三丹田”之说，渊源于《太平经》的“三元合一”论。黄庭即上丹田，于身指脑，为百神之主宰；中黄庭即中丹田，于身指心，为脏腑之根本；下黄庭即下丹田，于身指脐下关元穴，为阴阳之门户、精气之命脉。只要如法存想黄庭，养炼丹田，就能固精全气，长生久世。具体做法三经各有不同。</p><h4 id="抱朴子内篇"><a href="#抱朴子内篇" class="headerlink" title="抱朴子内篇"></a>抱朴子内篇</h4><p>道教仙学经典著作。二十卷。东晋葛洪撰。次书包括道教理论、神仙方药、鬼怪变化、养生延年等内容，为道教仙学集成之作。书中阐述了长生不老学说，提供了先秦以来各类内炼养生方法。其中有关气功的内容，集中地反映在《对俗》、《至理》、《释滞》、《杂应》、《地真》等篇章中。明代的刊本《抱朴子内篇》，末附《别旨》一卷，专述吐故导引，为气功专篇，极有参考价值。</p><h4 id="灵剑子"><a href="#灵剑子" class="headerlink" title="灵剑子"></a>灵剑子</h4><p>气功导引著作。一卷。东晋许逊撰。书中以四季配五脏，设计了一十六个姿式，主合成一套完整的动功功法。每个姿式详述具体炼法及功效，简单易行。许氏另撰《灵剑子引导子午记卷》，为站式功法，共有八个姿式，又称八段锦。</p><h4 id="达摩多罗禅经"><a href="#达摩多罗禅经" class="headerlink" title="达摩多罗禅经"></a>达摩多罗禅经</h4><p>禅观经典著作。二卷。东晋佛陀跋陀罗译。全书共一十七章，阐述禅观的修炼。书中“方便道”主要指数息观和不净观，“胜道”主要指心识、行持上的变化，“退、进、住”分别是指习禅上的退步、进步、定止。这些内容可作研究气功的参考。</p><h3 id="南北朝"><a href="#南北朝" class="headerlink" title="南北朝"></a>南北朝</h3><h4 id="上清握中诀"><a href="#上清握中诀" class="headerlink" title="上清握中诀"></a>上清握中诀</h4><p>道教养炼著作。三卷。梁陶弘景撰。汇道教上清派的炼养法诀，举凡存私、内视、守一、吐纳、导引等法均有记载，是研究道教气功的重要参考资料。</p><h4 id="养性延命录"><a href="#养性延命录" class="headerlink" title="养性延命录"></a>养性延命录</h4><p>道教气功养生代表作。两卷。梁陶弘景撰。全书分六篇：教戒、食戒、杂戒忌禳害祈善、服气疗病、导引按摩、御女损益。食戒篇介绍饮食宜忌，杂戒篇介绍起居言行宜忌，服气篇介绍吐纳咽津，导引篇介绍动功锻炼，御女篇介绍房中卫生。书中介绍的五禽戏为最早的文献记载。</p><h4 id="正一法文修真旨要"><a href="#正一法文修真旨要" class="headerlink" title="正一法文修真旨要"></a>正一法文修真旨要</h4><p>道教炼养著作。一卷。南北朝时著作。作者轶名。书中载有存思、服气、导引等多种功法，并主张辩证施功，以治疾病。书中对诊断、病理也有叙述，对后世的医疗气功颇有启发。</p><h4 id="太上老君养生诀"><a href="#太上老君养生诀" class="headerlink" title="太上老君养生诀"></a>太上老君养生诀</h4><p>气功养生著作。一卷。南北朝时著作。托名华佗传授吴晋作。主要内容为五禽戏的具体炼法，六字气诀结合脏腑的论述及其详细的炼法，统论养生的重要性和日常养生的要点。此书是珍贵的气功文献资料。</p><h4 id="易筋经"><a href="#易筋经" class="headerlink" title="易筋经"></a>易筋经</h4><p>武术气功代表作。一卷。北魏菩提达摩撰。全书为一套完整的动功功法，由十余种姿势组成。此功能强筋壮骨，增加体力。相传为达摩授与少林寺僧的秘法。其续篇是《洗髓经》。一卷。由五言古风组成，结合禅学静功和叩齿、咽津等保健功法，成为一套独特的动功功法。</p><h4 id="胎息经"><a href="#胎息经" class="headerlink" title="胎息经"></a>胎息经</h4><p>气功胎息经典著作。一卷。南北朝时佚名作。全文只有八十三字，论述胎息的定义、方法与作用，极为简单扼要。现存最早注本为唐朝幻真先生的《胎息经疏》，流行颇广。</p><h4 id="古文龙虎经"><a href="#古文龙虎经" class="headerlink" title="古文龙虎经"></a>古文龙虎经</h4><p>气功炼丹术著作。又名《金碧潜通诀》。三卷。南北朝刘演撰。其理论渊源于《周易参同契》，对内外丹修炼均有指导作用。</p><h4 id="禅秘要法经"><a href="#禅秘要法经" class="headerlink" title="禅秘要法经"></a>禅秘要法经</h4><p>禅观经典著作。三卷。姚秦鸠摩罗什译。共列三十三种观想法。</p><h4 id="五门禅经要法"><a href="#五门禅经要法" class="headerlink" title="五门禅经要法"></a>五门禅经要法</h4><p>禅观代表作。二卷。南北朝昙摩密多译。分述安般、不净、慈心、观缘、念佛等五门禅法。尤以观缘法论述为祥细。</p><h3 id="隋"><a href="#隋" class="headerlink" title="隋"></a>隋</h3><h4 id="诸病源候论"><a href="#诸病源候论" class="headerlink" title="诸病源候论"></a>诸病源候论</h4><p>中医症候学专著。又名《诸病源候总论》。五十卷。隋巢元方等撰。本书为我国现存第一部详细论述病因、症候的专著，对后世影响很大。书中不载治疗方药，只载气功导引方法。全书载一百五十三种疾病，采用气功导引方法二百九十余条。此后唐代王焘编撰《外台秘要》，转录了气功导引的全部内容。清末廖平则摘出汇编，后由民国曹炳章补辑，定名为《巢氏病源补养宣导法》，刊入《中国医学大成》中。</p><h4 id="内观经"><a href="#内观经" class="headerlink" title="内观经"></a>内观经</h4><p>气功存思内炼著作。又名《太上老君内观经》。一卷。隋唐间著作，不著撰人。此经强调内观澄心、恬淡虚无、精神内守，对养生长寿的积极作用。</p><h4 id="定观经"><a href="#定观经" class="headerlink" title="定观经"></a>定观经</h4><p>气功存思内炼著作。又称《洞玄灵宝定观经》。一卷。隋唐间著作，不著撰人。此经汇通道家“内观”、佛家“定慧”、儒家“中和”思想，阐述内观法修炼步骤及功后效验。</p><h4 id="太清调气经"><a href="#太清调气经" class="headerlink" title="太清调气经"></a>太清调气经</h4><p>气功服气著作。一卷。隋唐间著作，不著撰人。主要内容为讲述服气的基本要领与法则，并介绍了调气、固气、闭气、委气等具体炼功方法。</p><h4 id="太清导引养生经"><a href="#太清导引养生经" class="headerlink" title="太清导引养生经"></a>太清导引养生经</h4><p>气功导引经典著作。一卷。隋唐间著作，不著撰人。此经系搜集并精选多种气功导引文献编辑而成，内容丰富，可供取资。如赤松子导引法、宁先生导引法，蛤蟆行气法等。此外，对导引的要领、补泻原则、辩证施功等内容，有较详细的解绍。</p><h4 id="摩诃止观"><a href="#摩诃止观" class="headerlink" title="摩诃止观"></a>摩诃止观</h4><p>天台宗止观经典著作。十卷。隋智顗撰。共十章，原缺末章。其中第六章为止观的具体内容，第七章为天台一家的圆顿观行方法。本书的注释，以唐湛然的《止观辅行传弘诀》最为有名。</p><h4 id="童蒙止观"><a href="#童蒙止观" class="headerlink" title="童蒙止观"></a>童蒙止观</h4><p>天台宗止观代表作。有名《修习止观坐禅法要》、《小止观》。二卷，隋智顗撰。书分十章，即具缘、诃欲、弃盖、调和、方便行、正修、善根发、觉智魔事、治病和证果。</p><h4 id="六妙门"><a href="#六妙门" class="headerlink" title="六妙门"></a>六妙门</h4><p>天台宗禅观代表作。一卷。隋智顗撰。六妙门是由数、随、止、观、还净六个禅法组成的修持系统，适用范围广。其特色是把六妙门分作十门，各门中又摄入许多禅法，并含有巧妙的相互转变运用功能，是一套微妙的禅修法门。</p><h3 id="唐"><a href="#唐" class="headerlink" title="唐"></a>唐</h3><h4 id="千金要方"><a href="#千金要方" class="headerlink" title="千金要方"></a>千金要方</h4><p>中医综合性著作。全称《备急千金要方》。三十卷。唐孙思邈撰。作者认为“人命至重，贵于千金，一方济之，德逾于此”，故以“千金”命名。其书总结隋代以前的医学成就，为临床实用的医学百科全书。内容包括医论、医方、诊法、针灸、气功等。其中“养性”一章，堪称集唐以前医疗之大成，要言不烦，颇为实用。对六字气诀描述极其详细。</p><h4 id="存神炼气铭"><a href="#存神炼气铭" class="headerlink" title="存神炼气铭"></a>存神炼气铭</h4><p>气功养生名篇。又名《太清存神炼气五时七候诀》。唐孙思邈撰。首叙方法，先须绝粒，安心气海，存神丹田，摄心静虑，专心修炼；次分五时，条列炼功时各种不同的入静方法；末列七候，是炼功后体验到的各种身心效应。</p><h4 id="清静经"><a href="#清静经" class="headerlink" title="清静经"></a>清静经</h4><p>道教经典著作。全称《太上老君说常清静妙经》。一卷。唐代著作，不著撰人。此经本着老子“清静无为”的宗旨，认为人能清静，即可得道，住世长年。而获得清静之法，唯有观空。</p><h4 id="了心经"><a href="#了心经" class="headerlink" title="了心经"></a>了心经</h4><p>道教经典著作。全称《太上老君说了心经》。一卷。唐代著作。不著撰人。书中认为“心为神主，动静从心”，只有从澄心定神入手，修炼才能成功。</p><h4 id="天机经"><a href="#天机经" class="headerlink" title="天机经"></a>天机经</h4><p>道教经典著作。又名《阴符天机经》。一卷。唐代著作，不著撰人。此经为阐发《阴符经》而作。</p><h4 id="幻真先生服内元气诀"><a href="#幻真先生服内元气诀" class="headerlink" title="幻真先生服内元气诀"></a>幻真先生服内元气诀</h4><p>气功服气著作。一卷。唐代幻真先生撰。全书十五章，一至五章为一套完整的服气法；六至十一章是六个独立的服气功法；十二至十四章为服气注意事项；十五章为服气胎息诀，是几种功法的综合。本书自成体系，文字流畅，是唐代服气著作中的代表作。</p><h4 id="长生胎元神用经"><a href="#长生胎元神用经" class="headerlink" title="长生胎元神用经"></a>长生胎元神用经</h4><p>道教炼养著作。一卷。唐代著作，不著撰人。主要阐述气功养生的基本原理和实践方法。书中杂引各家学说为多。</p><h4 id="太上洞房内经"><a href="#太上洞房内经" class="headerlink" title="太上洞房内经"></a>太上洞房内经</h4><p>气功存思内炼著作。一卷。唐代著作，不著撰人。此经内容以存神、内视为主，其学术渊源出于《黄庭经》。经末附有平旦及日入时存想五方云气之方法。</p><h4 id="胎息精微论"><a href="#胎息精微论" class="headerlink" title="胎息精微论"></a>胎息精微论</h4><p>气功胎息著作。一卷。唐代著作，不著撰人。本书既重胎息功夫，又兼取还精补脑诸法。</p><h4 id="气法要妙至诀"><a href="#气法要妙至诀" class="headerlink" title="气法要妙至诀"></a>气法要妙至诀</h4><p>气功服气著作。一卷。唐代著作，不著撰人。书分五章。主要论述服气方法，主张结合导引是其特点。</p><h4 id="延陵先生集新旧服气经"><a href="#延陵先生集新旧服气经" class="headerlink" title="延陵先生集新旧服气经"></a>延陵先生集新旧服气经</h4><p>气功服气著作。一卷。唐延陵先生撰。全书分十五章，广集隋唐以前之多种服气、胎息方法，去伪存真，无论对理论研究或指导炼功实践，均有重要参考价值。</p><p>中山玉柜服气经气功服气著作。一卷。唐碧岩先生撰。书分四章，盛赞服气胎息为养生至宝。其法讲究“收息缩气，摄腹咽下”，直入食脉，与其他的服气功法有所不同。</p><h4 id="太清中黄真经"><a href="#太清中黄真经" class="headerlink" title="太清中黄真经"></a>太清中黄真经</h4><p>气功服气辟谷经典著作。又名《胎藏中黄经》。二卷。原题“九仙君撰，中黄真人注”，系唐代道教学者托名。全书十八章，主要论述人体生理病理及气功养生诸问题。注文详述服气胎息与绝欲辟谷的方法，以及三丹田、脏腑的关系，颇有参考价值。</p><h4 id="心印经"><a href="#心印经" class="headerlink" title="心印经"></a>心印经</h4><p>气功内丹术著作。全称《高上玉皇心印经》。一卷。唐代著作。不著撰人。此经为四言韵文，共五十句。主要讲述内丹术的基本理论，阐发精、气、神的含义及它们之间的关系，对后世有较大影响。</p><h4 id="太上九要心印经"><a href="#太上九要心印经" class="headerlink" title="太上九要心印经"></a>太上九要心印经</h4><p>气功内丹著作。一卷。唐张果撰。全书九篇，分专题论述内炼丹术中的关键文题。</p><h4 id="内丹经"><a href="#内丹经" class="headerlink" title="内丹经"></a>内丹经</h4><p>气功内丹术著作。又称《太上老君内丹经》。一卷。唐代著作，不著撰人。书中推崇内丹的长生久视作用，论述内丹基本理论及功效，重道德修养。</p><h4 id="玉轴经"><a href="#玉轴经" class="headerlink" title="玉轴经"></a>玉轴经</h4><p>气功养生著作。全称《上清黄庭五脏六府真人玉轴经》。一卷。此书以六字气诀泗、呵、嘘、呼吹、嘻，分别配合脏腑肺、心、肝、脾、肾、胆，以吐气为泻，吸气为补，结合五脏一腑（胆）之生理病理应用，极有实用价值。</p><h4 id="黄庭内景五藏六府补泻图"><a href="#黄庭内景五藏六府补泻图" class="headerlink" title="黄庭内景五藏六府补泻图"></a>黄庭内景五藏六府补泻图</h4><p>气功养生著作。一卷。唐胡惜撰。此书以《黄庭内景经》的理论为指导思想，取《玉轴经》的六字气诀为炼功基础，再参照《千金要方》等诸家养生文献，结合自己的实践经验，创编出一套完整的养生方法。书中以五脏六腑（胆）为纲，各系一图，下列六气法、修养法、相病法、治病法、食病法、导引法诸目，既可治病，又能防病强身，方便易行，故后世流行甚广。</p><h4 id="神气养形论"><a href="#神气养形论" class="headerlink" title="神气养形论"></a>神气养形论</h4><p>气功养生著作。一卷。唐代著作，不著撰人。主要阐述神、气、形的相互关系，认为只有收视返听，涵养精神，使神内守而不外扬，才能形体坚固，长生久视。</p><h4 id="将摄保命篇"><a href="#将摄保命篇" class="headerlink" title="将摄保命篇"></a>将摄保命篇</h4><p>气功养生著作。一卷。唐代著作，不著撰人。认为祛病之导，不仅要加强气功锻炼，而且还要注意精神道德修养。</p><h4 id="天隐子"><a href="#天隐子" class="headerlink" title="天隐子"></a>天隐子</h4><p>气功养生著作。又名《天隐子养生书》。一卷。唐司马承祯撰，托名天隐子。书分八章，大抵以炼形养心为宗旨。</p><h4 id="坐忘论"><a href="#坐忘论" class="headerlink" title="坐忘论"></a>坐忘论</h4><p>气功养生著作。一卷。唐司马承祯撰。作者根据《庄子大宗师》中的“坐忘”之说，加以阐述发挥，书中详细论述坐忘安心法，认为养生之关键在于静定功夫。行文流畅，影响深远。</p><h4 id="服气精义论"><a href="#服气精义论" class="headerlink" title="服气精义论"></a>服气精义论</h4><p>气功服气代表著作。一卷。唐司马承祯撰。全书九篇，此书于众多的服气著作中较少虚妄。作者主张服气与导引、符水、药物诸法相结合，与他家只重一发者有异。书中贯穿医理最为可信。正统《道藏》洞神部方法类所收者并非完本，仅原书之第一、二篇。后七篇另作《修真精义杂论》，收在洞真部众术类。《云笈七签》中所收者为完本，并明确标有序数。</p><h3 id="五代"><a href="#五代" class="headerlink" title="五代"></a>五代</h3><h4 id="入药镜"><a href="#入药镜" class="headerlink" title="入药镜"></a>入药镜</h4><p>气功内丹术经典著作。一卷。五代崔希范撰。作者“以吾心为镜，身为之台，以神为药”，入药者是将五脏所禀五行之气入于丹田，此为《入药镜》篇名之本意。全书为三言歌诀，共八十二句。每四句讲述内丹养炼中的一个重要问题。描绘内炼过程及其感受，效法天体运行规律，为唐代以后道家重视内炼奠定了理论基础。</p><h4 id="钟吕传道集"><a href="#钟吕传道集" class="headerlink" title="钟吕传道集"></a>钟吕传道集</h4><p>气功内丹术经典著作。3卷。又名《真仙传道集》或《钟吕传道记》。五代，施肩吾撰。全书以钟离权与吕岩师徒问答的形式，论述内丹术要义共18卷论真仙、大道、天地、日月、四时、五行、水火、龙虎、丹药、铅汞、抽添、河车、还丹、练形、朝元、内观、磨难、征验。全书以天人合一思想为基础，阴阳五行学说为核心，炼形炼气炼神为方法，系统完整地论述了气功学说的精华—内丹学说.建立了钟吕派内丹体系，对后世影响甚大。</p><h4 id="西山群仙真记"><a href="#西山群仙真记" class="headerlink" title="西山群仙真记"></a>西山群仙真记</h4><p>气功养生著作。5卷。五代施肩吾撰。简称《西山记》。洪州西山（今江西新建县内）乃作者隐居之处，自序称“欲论得道而超脱者，西山十余人矣。遂从前圣后圣，秘密参同契，而成此书。采遮各书，如《太上隐书》、《灵宝内观经》、《上清玄格》、《洞玄经》等，共20余种，保存不少五代迢家内丹术资料。</p><h4 id="养生辩疑诀"><a href="#养生辩疑诀" class="headerlink" title="养生辩疑诀"></a>养生辩疑诀</h4><p>气功养生著作。五代施肩吾撰。作者批评世人学养生而不知本源，因而不效，却疑得道者乃“有灵骨”之故，误以为非常人“可学而得之”的观点。</p><h4 id="灵宝毕法"><a href="#灵宝毕法" class="headerlink" title="灵宝毕法"></a>灵宝毕法</h4><p>气功内丹术经典著作。3卷。五代钟离权撰。作者称于终南山石壁间得《灵宝经》30卷：上部金浩书，元始所著，中部玉书录元皇所述，下部真源义，太上所传。共数千言。经朝暮研习，“乃悟阴中有阳，阳中有阴，本天地升降之宜；气中生水，水中生气，亦心肾交合之理”。于是摄其大要撰成此书。书中分三乘十门。小乘安乐延年法四门：匹配阴阳第一，聚散水火第二，交媾龙虎第三，烧炼丹药第四；中乘长生不死法三门：肋后飞金晶第五，玉液还丹第六，金液还丹第七；大乘超凡入圣法三门：朝元炼气第八，内观交换第九，超脱分形第十。每门中列“金诰”、“玉书”、“真源”之有关论述外，再依次分“比喻、“真诀”、“道要”等内容。本书属清净派著作，“以八卦运十二时而其要在艮位；以三田互相反复，而其要在泥丸（《道藏精华录提要》）为其特色。</p><h4 id="破迷正道歌"><a href="#破迷正道歌" class="headerlink" title="破迷正道歌"></a>破迷正道歌</h4><p>气功养生著作。1卷。五代钟离权撰。全书为五言古风1篇。凡244句，1708字。排斥各种养生方法，而独尊内丹术。</p><h4 id="纯阳真人浑成集"><a href="#纯阳真人浑成集" class="headerlink" title="纯阳真人浑成集"></a>纯阳真人浑成集</h4><p>道教炼养著作。2卷。五代吕岩撰。前有条阳清真道人何志渊序。称“于藏室中得其诗章二百有余，厘为二卷，名之曰《浑成集》，以其浑然天成，非人为所能及也。所收诗与《吕祖志》大多互见，亦有《吕祖志》中未见者。</p><h4 id="陈先生内丹诀"><a href="#陈先生内丹诀" class="headerlink" title="陈先生内丹诀"></a>陈先生内丹诀</h4><p>气功内丹术著作。1卷。五代陈朴撰。又名《九转金丹秘诀》本书世传有两种本子：一本收在《道藏太玄部》，名《陈先生内丹诀》；一本收在《道藏洞真部》中《修真十书》卷十七，名《九转金丹秘诀》。前者系分句作解，后者则每首诗词后合解。文句略有出入而各有所长，可互相参证。本书为论述九转金丹修炼方法的重要著作。九转者：一转降丹，二转交媾，三转养阳，四转养阴，五转换骨，六转换肉，七转换五脏六腑，八转育火，九转飞升。</p><h3 id="宋"><a href="#宋" class="headerlink" title="宋"></a>宋</h3><h4 id="云笈七签"><a href="#云笈七签" class="headerlink" title="云笈七签"></a>云笈七签</h4><p>道教练养类书。122卷。宋张君房编。北宋大中祥将五年（1012），张君房奉命校正秘阁道书，至天禧三年（1019）编成《大宋天宫宝藏》4565卷，再摄其精要，总万余条，辑成本书。称《云笈七签》者，“云笈”是珍藏道书的书箱，“七签”是指道书总有七大部：三洞（洞真、洞玄、洞神），四辅（太玄、太平、太清、正一）。1—28卷，总论经教宗旨及仙真位籍之事，其中涉及气功内容的，有《黄庭经》、《中黄真经》、《老君清静心经》、《洞玄灵宝定观经》等经注。29—86卷，分列道家服食练气、内丹外丹、方药符图、守庚申、尸解诸术，其中32——36卷与56——62卷所介绍的种种服气、胎息等法，皆为重要气功内容。87——122卷，则为道教文字及诗歌、传记之属，其中如《七部语录》、《七部名数要记》，均为论述养生要旨之佳作。与气功有密切关系。此书虽然摘录，不加论说，但去芜存精.分类编排，条理清楚。书中还保存了部分佚失道书的篇章，涉及气功的如《墨子闭气行气法》、《昙鸾法师服气法》等，均有研究参考价值。</p><h4 id="洞元子内丹诀"><a href="#洞元子内丹诀" class="headerlink" title="洞元子内丹诀"></a>洞元子内丹诀</h4><p>气功内丹术著作。2卷。宋洞元子撰。凡21篇，论述玄元、坎宫、离宫、既济、未济、乾宫、坤宫、兑艮二宫、变象、水火、焚魔、交媾、元火、沐浴、母子、抱元守一，道数、神光、总要、广玄等内容。除变象、总要、广玄三篇外，每论论述后以歌诀形式再作概括，除毋子篇为五言诗外，其余均为七言诗。本书主以易理、易象解说内丹修练之术，为其特色。</p><h4 id="内丹还元诀"><a href="#内丹还元诀" class="headerlink" title="内丹还元诀"></a>内丹还元诀</h4><p>气功内丹术著作。1卷。宋代著作，不题撰人。全篇约850字，简要解释内丹术语如五行（肝、肺、心、肾、脾）、四象（金翁、姹女、婴儿、黄婆）、七宝（津、水、唾、血、神、气、精）及九仙真气（口鼻谷道气之出入及嘘、呵、四、吹、呼、嘻、喜、怒）。</p><h4 id="内丹秘诀"><a href="#内丹秘诀" class="headerlink" title="内丹秘诀"></a>内丹秘诀</h4><p>气功内丹术著作。1卷。宋代著作，不题编者。系集《内丹赋》、《阴丹诗》、《海蟾子还丹赋》、《至真歌》、《中颊先生增马处士歌》、《青城山后岩栖谷子灵泉井歌》、《金虎白龙诗》（张果述，21首）成一辑，诗赋文辞华丽，有数篇属阴阳派著作。</p><h4 id="太清真人绝命诀"><a href="#太清真人绝命诀" class="headerlink" title="太清真人绝命诀"></a>太清真人绝命诀</h4><p>气功养生著作。1卷。宋太清真人撰。其法以存思为主，第一先存五兽，第二历藏，第三守地，第四守人，第五守天。兼以咽津服气，俾得益寿延年。</p><h4 id="保生要录"><a href="#保生要录" class="headerlink" title="保生要录"></a>保生要录</h4><p>气功养生著作。1卷。宋蒲虔贯撰。全书分养神气门、调肢体门、论衣服门、论饮食门、他居处门、论药食门。论述平易简明，切于实用。</p><h4 id="紫清指玄集"><a href="#紫清指玄集" class="headerlink" title="紫清指玄集"></a>紫清指玄集</h4><p>气功内丹术著作。2卷。宋白玉蟾撰。内容有玄关显秘论、修辨惑论、性命日月论、谷神不死论、阴阳升降论、金液还丹赋、学道自勉文、东楼小参文、冬至小参文、丹语法语、题张紫阳薛紫贤二真人像、谢陈仙师寄书词、鹤林问道篇，以及必竟凭地歌、快活歌等，共40余篇。作者精通内丹术，善属文辞，且喜交游。</p><h4 id="金丹直指"><a href="#金丹直指" class="headerlink" title="金丹直指"></a>金丹直指</h4><p>气功内丹术著作。1卷。宋周无所住撰。前有自序，作于淳偌庚戌（1250）年。书前胪列玄关一窍颂、真土颂、阳晶颂、玄化颂、龙虎颂、铅汞颂、真炉鼎颂、真药物颂、斤两颂、抽添颂、火候颂、法度颂、口诀颂、沫浴颂、工夫颂、温养颂，共16颂。颂中内丹术语，概从性功解释，或问中亦宜指：“金丹喻本性长存，是名金刚不坏，……性即命，命即性”。</p><h4 id="诸真论还丹诀"><a href="#诸真论还丹诀" class="headerlink" title="诸真论还丹诀"></a>诸真论还丹诀</h4><p>气功内丹术著作。1卷。宋代著作，不著撰人。杂录前人内丹歌诀。内容有玉壶颂10首、青霞子赞《金碧龙虎经》、赞魏伯阳《参同契》、容成公内丹歌诀、曹圣图铅汞歌，以及论真鼎、明水火、明火候、明至药等口诀，共18首。其中曹圣图铅汞歌为五言古风，其余均为七言，或绝句，或律、成为俚歌。所收有属双修派内容。</p><h4 id="了明篇"><a href="#了明篇" class="headerlink" title="了明篇"></a>了明篇</h4><p>气功内丹术著作。1卷。宋宋先生撰，毛日新编。首为遇真歌，自述遏钟离权授口诀得真道之情；继为解迷歌，讲述内炼要旨；未为和朗然子诗30首及其他词22首。均系论道谈玄，成言内丹炼养心得之作。</p><h4 id="修真太极混元指玄图"><a href="#修真太极混元指玄图" class="headerlink" title="修真太极混元指玄图"></a>修真太极混元指玄图</h4><p>气功内丹术著作。1卷。宋代著作，不题撰人。全书以图诀相配形式讲述内丹炼养方法，其中多涉五脏气化，为其特色。具体内容为匹配阴阳胎息诀图，真龙虎交媾内丹诀图，周天火候诀图，肘后飞金晶诀图，还丹诀图，炼形秘图，三国既济诀图，炼气成神朝元诀图，内观起火仙丹交换召，弃壳升仙人圣超凡诀图。</p><h4 id="龙虎手鉴图"><a href="#龙虎手鉴图" class="headerlink" title="龙虎手鉴图"></a>龙虎手鉴图</h4><p>气功内丹术著作。1卷。宋代著作，不题撰人。其图从《周易参同契》立论，以天地阴阳合化、乾坤门户、坎离匡郭、囊合动静等说来阐述龙虎内丹之修炼。次列龙虎、灵药、还丹、文武、神运、黄芽、白汞、金虎、玄曜、真旨、流殊、住世、成真、出世、河车等15个条目，分述内丹修炼的法则。</p><h4 id="道枢"><a href="#道枢" class="headerlink" title="道枢"></a>道枢</h4><p>道教炼养类书。42卷。宋曾糙撰。书名源于《庄子齐物论》中“彼是莫得偶，谓之道枢”，含道术真要之意。全书共108篇，广辑南宋以前道教有关文献资料而成，是研究道教史，道教的思想与方术，以及气功内丹术的重要参考书籍。其中各章。有讨论《阴符经》、《黄庭经》、《悟真篇》等典藉要旨而名阴符、黄庭、内景、外景、悟莫者，有阐释道家理论而名太极、元气、虚白、火侯、归根者，有介绍道家修炼方法而名胎息、调气、运火、大还金丹者。各篇中除引用著名道教学者之论述外，如至朴子、朝元子、纯粹子、嵩岳真人等唐宋时代隐居民间之道教学者，其遗文亦为网罗收入。篇中常有曾氏本人论述，反映了他反对双修而主清修的观点。</p><h4 id="太极图说"><a href="#太极图说" class="headerlink" title="太极图说"></a>太极图说</h4><p>儒家哲学经典著作。1卷。宋周敦颐撰。作者绘有太极图，并撰文字诠释，其所列最高哲学范畴是无极，以下依次为太极、阴阳、五行、二气交感、化生万物。万物之中，惟人最灵，而为人之最高境界，就是圣人倡导的“定之以中正仁义而主静”。自此以后，宋明理学家都重主静之说，且喜静坐。据清黄宗炎考证，周氏太极图系由北宋初著名道家学者陈传之无极图演化而来。无极图本为阐明内丹术而设，由“玄牝门”、“炼精化气”逐层而上，至顶层为“炼神还虚，复归无极”。周氏则将无极图自下而上之递进关系颠倒，作自上而下之衍化，并改换有关名称，将道家气功思想引进儒家哲学畴。</p><h4 id="调息箴"><a href="#调息箴" class="headerlink" title="调息箴"></a>调息箴</h4><p>气功养生名篇。宋朱熹撰。所调“调息”，即调整呼吸以养生之意。此箴取佛道两家气功之内容。如“鼻端有白，我其观之”，在佛典《楞严经》卷五载孙陀罗难陀“观鼻端白，我初谛观……”；面“守一处和，千二百岁”，乃源自《庄子在宥》篇。</p><h4 id="元气论"><a href="#元气论" class="headerlink" title="元气论"></a>元气论</h4><p>气功养生名篇。宋张澡撰。文中认为自然界一切均由元气化生，亦讲到人生命，“禀天地之元气为神为形，受元一气为液为精”。主张返老还童，需七返九还，而其七返九还说则与他说不同：“液化为精，精化为气，气化为神、神复化为液，液复化精，精复化为气，气复化为神”。特别推重服气法，认为“夫长生之术，莫过乎服元气，胎息内固灵液，金丹之上药”。书中对服气法有详细介绍。该论见存于《云笈七签》卷五十六。</p><h4 id="圣济总录"><a href="#圣济总录" class="headerlink" title="圣济总录"></a>圣济总录</h4><p>中医类书。200卷。宋徽宗主编，系政和年间诏命医官编纂，历时7年（1111——1117年）而成。该书广泛收集历代方书及民间方药，并摘录道家修炼方法，以供选用。属于道家气功修炼的内容有神仙导引、神仙服气、神仙炼丹等篇章。</p><h4 id="修真十书"><a href="#修真十书" class="headerlink" title="修真十书"></a>修真十书</h4><p>气功内丹术丛书。旧题宋石泰辑，不确。收书12种，共60卷。计有《杂著指玄篇》8卷，元萧廷芝《金丹大成集》5卷，唐施肩吾《钟吕传道集》3卷，《杂著捷径》9卷，宋张伯端《悟真篇》5卷，《玉隆集》6卷、《上清集》8卷、《武夷集》8卷（以上三集为宋白玉蟾撰），元王志谨《盘山语录》1卷，唐胡惜《黄庭内景五藏六府图》1卷，《黄庭外景玉经注》3卷（以上二书为唐梁丘子撰）。</p><h3 id="金元"><a href="#金元" class="headerlink" title="金元"></a>金元</h3><h4 id="重阳真人授丹阳二十四诀"><a href="#重阳真人授丹阳二十四诀" class="headerlink" title="重阳真人授丹阳二十四诀"></a>重阳真人授丹阳二十四诀</h4><p>气功内丹术著作。1卷。金王哲撰。此书是王氏答其第子马钰所提的30多个问题，主要阐述内丹术语、内炼口诀中所含的内丹理论思想。包括祖宗、性命、根蒂、龙虎、铅汞、刀圭、金公、黄婆、婴儿、姹女、龙蛇、心猿、意马、宾主、觉照、太上、三宝、九星、五刚、三才、抽添火候、金丹、七返、三命、九窍等。共内炼思想主要体现在：一少言语养内气，二戒心性养精气，三薄滋味养血气，四戒嗔怒养肺气，五养饮食养胃气，六少思虑养肝气，七寡嗜欲养心气。认为“凡人出家，绝名弃利，忘情去欲，则心虚。心虚则气住，气住则神清，神清则德合道生矣”。突出明心见性的思想。</p><h4 id="重阳真人金关五锁诀"><a href="#重阳真人金关五锁诀" class="headerlink" title="重阳真人金关五锁诀"></a>重阳真人金关五锁诀</h4><p>气功内丹术著作。1卷。金王直公撰。内容涉及较广，主要以问答方式解说全真道的内丹理论和修炼方法。书中将道教秘传内炼法分为三乘，来阐述修炼的基本过程。炼者先从小乘入手，而后入中乘、大乘。并记载了九转还丹法、黄芽穿膝法、射九重铁鼓法、太子游四门法、金鞭轮法、陈希夷大睡法、仙人钓鱼法、金关玉锁法、七返还丹法、肘后飞金晶法、搬精补脑法、三车搬运法、抽添加减法、灌想法、黄婆匹配法等治病与修炼的小、乘功法。这些法诀多为北七真所继承发挥，成为全真道内丹法的基础。</p><h4 id="丹阳真人直言"><a href="#丹阳真人直言" class="headerlink" title="丹阳真人直言"></a>丹阳真人直言</h4><p>道教炼养著作。1卷。金马钰撰。本书是作者在龙门山重阳会土讲述的内炼丹法理论与功诀的记录。作者认为修道贵在无为清静，不能急于求成。指出“长要心定，行住坐卧，皆是行道。诸公休起心动念，疾搜性命；但能澄心遣欲，便是仙”。并指出性命、龙虎、铅汞、水火、婴姥、阴阳等全是神气二字的演变，不可执著。但欲成内丹，还以清净为本，“欲要养气全神.须常屏尽万缘，表里清净，绵绵固守动。三年不漏，下丹结；六年不漏，中丹结；九年不漏，大丹结圆备。此名九转大功，亦名三千功满，三因圆奋，谓之丹法，身轻举，永为神仙。”</p><h4 id="丹阳真人语录"><a href="#丹阳真人语录" class="headerlink" title="丹阳真人语录"></a>丹阳真人语录</h4><p>道教练养著作。1卷。金马钰撰，王颐中编。主要论述全真道修心养性的理法，以清静无为、柔弱谦下为主。清为清其心源，净为净其气海。心源清则外物不能扰，故情定而神明；气海净则邪欲不能于、故精全面腹实。突出输净之法在修道中的重要性，“故道家留丹经子书，千经万论，可一言以蔽之，曰清静”。此外，还主张薄滋味以养气，去嗲怒以养性，效污下以养德，守恬淡以养性。</p><h4 id="孙不二元君法语"><a href="#孙不二元君法语" class="headerlink" title="孙不二元君法语"></a>孙不二元君法语</h4><p>气功内丹术女功代表作。1卷。金孙不二撰。专论女子内丹理论与功法。全书有神道功夫次第诗14首（收心、养气、行功、斩龙、养丹、胎息、符火、接药、练神、服食、辟谷、面壁、出神、冲举），女功内丹诗7首。为女子习炼内丹所必读之作。</p><h4 id="上清太玄九阳图"><a href="#上清太玄九阳图" class="headerlink" title="上清太玄九阳图"></a>上清太玄九阳图</h4><p>气功内丹术著作。1卷。金侯善渊撰。主要描述内丹修炼过程中的不同境界，并对练功与时辰关系作了探讨。全书以图为主，首列太玄混沌图、未见图等，次按月出、上弦、照望、平阳、下弦、月尽之序，分别配以震、兑、乾、翼、良、坤卦，及离中虚在天为日在人为目，坎中实在天为月在人为耳，亦辅以图，分述神功运移之法规；最后是太玄九阳修真图，概述炼丹的全过程。</p><h4 id="启真集"><a href="#启真集" class="headerlink" title="启真集"></a>启真集</h4><p>道教炼养著作。3卷。金刘志渊撰。主要讲述内丹修炼方法。简明易懂方法可行，对后世内丹术的发展较有影响。卷上有七言绝句71首，七言律诗4首；卷中有词56首；卷下分13章，即真心章，天中天章、真土章、心息相依章、死阴生阳章等，皆为内丹修炼之要诀。</p><h4 id="大丹直指"><a href="#大丹直指" class="headerlink" title="大丹直指"></a>大丹直指</h4><p>气功内丹术著作。2卷。元丘处机撰。本书是早期全真道最系统完备的内丹著作，发挥了王品的内丹理论，将其分为三成九法。首先阐述了内丹修炼的基本理。认为人与天地禀受一同，始因父母二气交感，混合成珠，肉藏一点元阳真气，与母命蒂相连，受母气滋养，是为先天之气。出生之后，先天之气徽于九窍，呼吸从口鼻而出入，是为后天之气。先天真气逐时耗散，以至病夭。炼内丹求长生，关键在于用神火烹炼真精实气，使气满神壮。次用图、诀、诀义的形式详述九种内丹功法的修炼，其中五行颠倒龙虎媾法、五行颠倒周天火候法、三田返复肘后飞金精法为小成法，三返复金液还丹法、五气朝元太阳炼形法、神水交合三田既济法为中成法，五气朝元炼神入顶法、内观起火炼神合道法、弃壳升仙超凡入圣法为大成法。大成法为内丹最高境界。三成九法由浅入深，较完整阐述了内丹修炼的法则，其核心是修炼性命。此外，还叙述了炼功入静时可能出现的10类幻景及排除方法。只有时闻乐声，异香阵阵，红光闪闪，状如莲花，遍身赛笼罩，色若金光，才是真境妙界。后世内丹家对此书评价甚高，誉之为“北宗丹经之首”。</p><h4 id="金丹大成集"><a href="#金丹大成集" class="headerlink" title="金丹大成集"></a>金丹大成集</h4><p>气功内丹术代表作。5卷。元萧廷芝撰。书中以无极太极之理，《周易》八卦之数，天地阴阳、水火囊合升降之机，作为说理根据，来论述内丹的修炼。其中所称“金液还丹”者，即为内丹。载有无极图、天心图、玄地图、既济鼎图、河车图、周天火候图、泄天符火候图、六十卦火候图、大衍数图、金丹囊合图等图，囊合歌、金液还丹赋、金液还丹诗、金液还丹论、金丹问答、七言绝句、乐道歌、茅庐得意歌、剑歌等文，以及崔公《入药镜》与吕公《沁园春》的注解。有图有文，便于理解。全书内容丰富，说理透彻，其中《金丹问答》一篇，尤为初习内丹术者所必读。</p><h4 id="金丹大要"><a href="#金丹大要" class="headerlink" title="金丹大要"></a>金丹大要</h4><p>气功内丹术代表作。10卷。元陈致虚撰。作者融合南北两宗内丹理论，对气功内丹术作了较为完备的阐述。书中十分重视精气神的作用，以先天精气神为本，后天精气神为用，养生内炼之士贵在宝其精、壮其气、旺其神。同时还对金丹、药物、器、采取、真土、火候、神化等内炼要诀作了详细的论述。并对内丹修炼须知作了7个方面的说明，即：运火行符、朔望弦晦、防危护失、卵酉刑德、冰浴心虑、生杀爻铢、脱胎换鼎。书中还常出现儒家伦理道德思想，又援引佛家之说来论述明心见性之理，三教合一的思想较为浓厚。是收为内丹理论较为成熟时期的著作，因此比较全面地反映了内丹术的基本内容。此书原为10卷，《道藏》本析为16卷。</p><h4 id="规中指南"><a href="#规中指南" class="headerlink" title="规中指南"></a>规中指南</h4><p>气功内丹术代表作。2卷。元陈冲素撰。上卷九章，从止念、采药、识炉鼎、入药起火、坎离交媾、乾坤交媾、攒簇火候、阳神脱胎、忘神合虚等方面，介绍具体炼养方法。下卷三论，从玄化、药物、火候等阐述内丹机理，颇为精辟。书中认为玄牝即规中，在肾之上，心之下，人身上下左右之中，是内丹炼养之处。然此又系虚设之处，故“不可以有心守，不可以无心求。以有心守之，终莫之有；以无心求之，终见其无”。并详论药物与火候的辩证关系，认为“盖采时谓之药。药之中有火焉；炼财调之火，火之中有药焉”，而火候的要诀，“尤当于真息中求之”。“盖息从心起，心停息调，息息归根，金丹之母”。此书直指内丹奥秘，要言不繁，颇受后代学者重视。</p><h4 id="中和集"><a href="#中和集" class="headerlink" title="中和集"></a>中和集</h4><p>道教炼养代表作。6卷。元李道纯撰。作者精通《周易》与《礼记》，故书中炼养虽重三教合一、性命双修的观点，但援儒入道的倾向却非常明显。卷一为玄门宗旨，卷二为金丹妙诀，卷三为问答语录全真话法，卷四为论、说、歌，卷五为诗，卷六为词及隐语。其论丹法以“守中”为要诀，“致和”为目的。具体作法强调先虚其心以修性，后保其身以修命，最终取得性命双圆、形神俱妙之正果。书中将丹法分成渐与顿两类。渐法为循序渐进之法；又分三系，下乘是安乐法，中乘是养命法，上乘是延生法，由修命入手，取得成功。顿法为最上乘法，只有非常有根基者才能修炼而有所成就，只须一直了性，则自然了命。是书之内丹学说，自成体系，极有自己的特色，具有代表性。</p><h4 id="三天易髓"><a href="#三天易髓" class="headerlink" title="三天易髓"></a>三天易髓</h4><p>道教炼养著作。1卷。元李道纯撰。主要以儒、道、释三教之理论，阐释内丹理法。共有3篇，一为“儒曰大极——火符直指”，二为“道曰金丹——金丹了然图”，三为“释曰圆党——心经直指”。书未附《阴符经》注释。</p><h4 id="还真集"><a href="#还真集" class="headerlink" title="还真集"></a>还真集</h4><p>道教练养著作。3卷。元王介撰。其内丹理论参合南北两家，强调只有性命混融，才能始成内丹。上卷为图说，中卷为论文及歌词，下卷为诗词。认为“凡诸学道至人，参禅高士，不可执著，必以性命双修，方成大事”。在具体修炼方法上，书中强调三要，“一要知鼎器，二要知药物，三要知火候。知此三者分明，方许下手修之”。并开列鼎器异名39个，药物异名46个，火候异名12个，有解疑惑，提高修炼效果之功效。</p><h4 id="悟玄篇"><a href="#悟玄篇" class="headerlink" title="悟玄篇"></a>悟玄篇</h4><p>气功内丹术著作。1卷。元余洞真撰。是书着重探讨天地阴阳交合化生之理及水火交化进退之机在内丹修炼中的作用，而特别突出玄牝的地位。认为“夫人身中窍，名曰玄牝，若人得此窍，期三才万物悉备于我矣。此之一窍，非泥于物也，其理别于他术.止不过忘形灭念，如守其中矣。久久纯熟，中宫静极，则身中阳气自然生也，阳气渐生，阴气渐剥，乃曰阳长阴消之意矣”。此外，书中对形化、气化、坐工、口诀、沐浴、药物、火候、玄关、抱一、解胎等都作了具体的分析与探讨，并附图以资补述。</p><h4 id="谷神篇"><a href="#谷神篇" class="headerlink" title="谷神篇"></a>谷神篇</h4><p>气功内丹术著作。2卷。元林辕撰。自叙中曰：“篇目之曰谷神，不过以谷养气而已。”上卷为大药还丹诗、理一真篇、火候行持绝句诗等，其论大药云：“大药其最要法，在乎神水华池，为诸丹之基，大道之祖。存守则谓之宝珠，交会则谓之金丹。”下卷为图论，计有五气朝元图、投壶口诀图、含元抱朴之图、木金间闻体用图、元气生成图及静动虚名论、元气论等。对静定、真定、入定、得性等问题进行了探讨，对元气的生成、功用及其化生变化作了阐述。</p><h4 id="析疑指迷论"><a href="#析疑指迷论" class="headerlink" title="析疑指迷论"></a>析疑指迷论</h4><p>气功内丹术著作。1卷。元牛道淳撰。书中分析疑与指述两部分，以问答形式叙述。旨在使学者明了全真性命之理和修行次第之法。其析疑主论心性万物，认为人心“元无一物，等同太虚，本来清净”，为万法之本；“心即性用，性印心体”，心性以“虚寂为体，觉照为用”。指迷则主论性命内丹，认为性命本一，故应兼修。“夫人以精为根，以命为本，以性为宗，命者气也，性者神也。失神、气、精三者，成原于一，而未尝离也”。书中将炼丹之法分为三门九品，渐次修炼，较好地体现出性命双修的内练思想。</p><h4 id="抱一子三峰老人丹诀"><a href="#抱一子三峰老人丹诀" class="headerlink" title="抱一子三峰老人丹诀"></a>抱一子三峰老人丹诀</h4><p>气功内丹术著作。1卷。元金月岩编，黄公望传。重视心肾水火，性命双修是其特点。认为炼丹要求真铅真汞，真铅真汞即是神气性命；又须明心肾水火、三宫五行变化之理。指出假性命为出阴神，是鬼仙小成之法；真性命乃出阳神，是天仙大成之法。书中还有金蝉脱壳天仙之图、尾闾骨图及七言绝句。</p><h4 id="纸舟先生全真直指"><a href="#纸舟先生全真直指" class="headerlink" title="纸舟先生全真直指"></a>纸舟先生全真直指</h4><p>气功内丹术著作。1卷。元金月崖编，黄公望传。全书分为2篇。上篇为“七返七真合同印子”，有诗（并图）7首，分述内丹修炼的7个阶段。即形神相顾、人道初真，形神相伴、名目得真，形神相入、名目守真，形神相抱、名目全真，形神俱妙、与道合真，形神双合、名曰证真，普度后学、以真觉真。下篇为“入室节目筑室阔狭各自定例”，讲入室静坐功夫及各种景验。其内丹观点仍讲求性命双修。</p><h4 id="六根归道篇"><a href="#六根归道篇" class="headerlink" title="六根归道篇"></a>六根归道篇</h4><p>气功养生著作。1卷。元代著作，不题撰人。主要论述六根清净在内丹修炼中的重要性。其方法为“守道先须守心”，在内心意不乱，则身能正于外；目视耳闻各得守，则“五色得正，而邪者不干吾之目；五声得其节，而淫者不干吾之耳”；“芬碧之馨，不可以养吾之性”，故无味无馨，则“鼻舌不为我之患矣”。</p><h4 id="真仙直指语录"><a href="#真仙直指语录" class="headerlink" title="真仙直指语录"></a>真仙直指语录</h4><p>道教练养著作。2卷。元玄全子编。系全真派师徒授课记录，卷上录有马钰语录约30条，并录谭处端、刘处玄、郝大通等人的语录及丘处机的《寄西州道友书》，卷下隶尹志平语录。所录者多为全真道修行法诀。</p><h4 id="诸真内丹集要"><a href="#诸真内丹集要" class="headerlink" title="诸真内丹集要"></a>诸真内丹集要</h4><p>气功内丹术著作。3卷。元玄全子编。卷上收有老子《函谷关记》、钟离正阳《还丹歌》、张紫阳《石桥歌》、马自然《金石诰》、吕纯阳《玄牝歌》及《大丹歌》和《性命歌》、李仙君《金丹赋》、天来子《青龙歌》和《白戊歌》、刘海蟾《还丹破迷歌》等。卷中收有《王母口诀》、《太上内观正诀》、《玄无口诀》、《鼎器歌》、《金丹火候秘诀十二句》、《金丹证验》、《金丹类名》等。卷下收有青霞真人《内用秘文》。书中广集名篇，对修炼内丹之士来说，是一部很好的参考书。</p><h4 id="三元延寿参赞书"><a href="#三元延寿参赞书" class="headerlink" title="三元延寿参赞书"></a>三元延寿参赞书</h4><p>气功养生著作。5卷。元李鹏飞撰。成书于1291年。作者自称受一官姓道人的三元养生之术，认为人之寿命分天元六十、地元六十、人元六十，三元共一百八十岁，不知保养则日益减少。如精气不固则天元之寿暗损，谋为过度则地元之寿暗损，饮食不节则人元之寿暗损。故在保养同时还宜避忌，以使精神内壮。如何趋益避损，其法在《黄帝内经》、《老子》、《庄子》并名医论著及孔孟之说中均有论述。是书禀承此旨，以医家与道家之论为主干，以各家养生精论为辅，取《中庸》“赞化育，参天地”之意而定书名。共核心内容为：“天元之寿，精气不耗者得之”，下列欲不可绝等9目；“地元之寿，起居有常者得之”，下列养生之道等23目；“人元之寿，饮食有度者得之”，下列五味等10目。另外，还分类辑录诸家养生要语，极有参考价值。</p><h4 id="泰定养生主论"><a href="#泰定养生主论" class="headerlink" title="泰定养生主论"></a>泰定养生主论</h4><p>中医气功养生著作。16卷。元王硅撰。本书是一部医道结合论述养生祛病的著作，对养生祛病之法作了较为祥尽的叙述，并涉及导引、按摩之法。“首以原心为发明之始；次序婚合、孕育、婴幼、童壮、衰老宜摄避忌，以御未然之病；次论运气、标本、阴阳、虚实、脉病、证治，以为全生去病之法；然后类方对证，以为规矩之用”（《自序》）。</p><h4 id="寿亲养老新书"><a href="#寿亲养老新书" class="headerlink" title="寿亲养老新书"></a>寿亲养老新书</h4><p>综合性养生著作。4卷。元邹铉撰。本书论述养生方法较详，主要针对老人。卷一原名《养老奉亲书》，为宋陈直撰；卷二至卷四为邹铉续增。卷一讲饮食调养、形证脉候及简妙老人备急方等15篇，共223条，节宣之法详备；卷二分保养、服药诸篇，罗列古今丸、丹、膏、散、酒、粥、糕、饼等具体方药与主治；卷三与卷四为寝、兴、器、服、饮、膳、药石之忌宜，附妇儿食治诸方，共256条。其中卷三中的“太上玉轴六字气诀，为古代记载最详细的六字气诀；尚有“食后将息法”（系摘录沈括《杯山录》，此书现很少见到，颇有参考价值）及“养性”等气功养生方面的内容。</p><h3 id="明"><a href="#明" class="headerlink" title="明"></a>明</h3><h4 id="玄要篇"><a href="#玄要篇" class="headerlink" title="玄要篇"></a>玄要篇</h4><p>气功内丹术著作。2卷。明张三丰撰。收入《张三丰全集》中。书中突出先修性后全命的观点，重视元气与真息，强调水火阴阳升降化生在内丹修练中的作用。上卷有发，尤其是强调修心养性为练丹修真之首要。“性者内也，命者外也，以内接外，合而为一，则大道成”；“大道以修心炼性为首，性在心内，心包性外，是性为定理之主人，心为牺牲之庐舍”；“学道之士，须要清心清意，方得真清之药物也”。附篇为《三丰先生辑录》，节录了白玉蟾（紫清）、陆西星（潜虚）、李西月（涵虚）等人的内丹名言，各有特色。</p><h4 id="无根树"><a href="#无根树" class="headerlink" title="无根树"></a>无根树</h4><p>气功内丹术著作。1卷。明张三丰撰。是《张三丰全集玄要篇》中的重要组成部分，也是张三丰的代表作、颇为后人所推崇。讲述阴阳匹配双修在内丹修炼中的重要作用。丹词作于武当山中，约在明太祖洪武十七年（1384）。《无根树》是道情体裁的内丹秘诀，包括自题词2首和道情24首，提出了一套“阴阳裁接”功法，在内丹功法中别树一帜。丹词中云：“无根树，花正微，材老重新接嫩枝。梅寄柳，桑接梨，传与修真作样儿”；“无根树，花正偏，离了阴阳道不全。金隔木，汞隔铅，阳寡阴孤各一边。世上阴阳男配女，生子生孙代代传。顺为凡，逆为仙，只在中间颠倒颠”；“女子无夫为怨女，男子无妻是旷夫。叹迷徒，太模糊，静坐孤修气转枯”等。都将阴阳匹配作为修练内丹、成仙成圣的重要法门和手段，可谓别开生面，另劈蹊径，自成一个流派。何西复认为《无根树》在学术地位上，与《悟真篇》先后伯仲。清代龙门派传人刘一明与西派代表人物李西月，先后给该丹词作注，有《无根树二注》行世。</p><h4 id="玄肤论"><a href="#玄肤论" class="headerlink" title="玄肤论"></a>玄肤论</h4><p>气功内丹术著作。不分卷。明陆西星撰。全书共20篇，每篇一论。系统地论述了东派丹法原理和功夫次第，具有代表性。首论三元，认为丹有三元，即天元、地元、人元，而又突出人元。人元又谓之“大丹”，乃“创鼎于外，炼药于内，取坎填离，盗机逆用之谓也”。以后19篇专论人元丹法，从内外药物、阴阳互藏、先后天论、精气神、性命等方面对其丹法作了深刻的探析。书中内丹二诀以练神调息为要，神即是性，性定则神自安，神安则精住，精住则气自生。炼神又分澄神、养神、凝神三部，缺一不可。书中力求使其丹法理论和功诀显明易懂，其丹法思想南宗，而仍主以阴阳双修。</p><h4 id="金丹就正篇"><a href="#金丹就正篇" class="headerlink" title="金丹就正篇"></a>金丹就正篇</h4><p>气功内丹术著作。不分卷。明陆西星撰。书共3篇，其要旨在阐述成大丹必须阴阳双修的观点。认为金丹之道必资阴阳相合而成，“阴阳者，一男一女也，一离一坎也，一铅一汞也，此大丹之药物也。夫坎之真气谓之铅，离之真精谓之汞，先天之精积于我，先天之气取予彼。何以故?彼坎也，外阴而内阳，于象为水为月，其于人也为女。我离也，外阳而内阴，于象为火为日，其于人也为男。故夫男女阴阳之道，顺之则生人，逆之则成丹”。同时指出男子修丹，必须得先天其一之气方成，而真一之气必须向外求之，这进一步阐明阴阳双修才为内丹之正统。</p><h4 id="性命圭旨"><a href="#性命圭旨" class="headerlink" title="性命圭旨"></a>性命圭旨</h4><p>气功内丹术代表作。不分卷。明代著作，不题撰人，相传为尹真人弟子所著。全称《性命双修万神圭旨》。全书分元、亨、利、贞四集，图文相配，以三教合一、性命双修观点介绍内丹理论及具体功法。元集多作图说，指点窍妙；亨、利、贞三集则采儒、释、道三教名家语录及口诀，编成一套完整之功法。尤侗在序中云：“至其精要，尤在真意一说。盖人身真意，是为真土，动极而静，此意属阴，是为已土；静极而动。此意属阳，是为戊土。炼已土者，得离日之汞；炼戊土者，得坎月之铅。铅汞既归，金丹自结。戊已者、重土之象也，斯其有取于圭旨者乎”。可谓对其论内丹之中心思想的高度概括。</p><h4 id="金丹真传"><a href="#金丹真传" class="headerlink" title="金丹真传"></a>金丹真传</h4><p>气功内丹术代表作。1卷。明孙汝忠撰。书中继承南家内丹学说，主张阴阳双修，认为阴阳双修是炼丹修仙的大道。全书包括《西江月词》9首、《葫芦歌》1首、《明道歌》4首及《修真入门》、《修真大略》、《金丹五百字》、《扫邪归正歌》各1篇。对筑基、得药、结丹、炼已、还丹、温养、脱胎、玄珠等丹诀作了较为详细的论述。</p><h4 id="天仙正理直论"><a href="#天仙正理直论" class="headerlink" title="天仙正理直论"></a>天仙正理直论</h4><p>气功内丹术代表作。不分卷。明伍守阳撰。是书为内丹伍柳派的代表作。前有自序，首为道原浅说篇，次为直论九章。九章包括先天后天二气、药物、鼎器、火候、炼已、筑基、炼药、伏气、胎息等内丹精要之论。其自序云：“以二气为论，所以明生人生仙佛之理也；药物为论，所以明脱死超生之功也；而火候集古为经，所以合群圣仙机列为次第之宜也；喻筑基论二气，渐证于不漏；借炼药论二气，成一而不离，阐伏气论藏之内而不驰诸外，虽反复言气而不见其繁，立一名，彰一义也；论炼已者，论其成始成终之在其我，专言神而不见其简，操一机，贯一义也；鼎器之论，见神气之互相依；胎息之论，密指胎其神而息其气，此又合神气而归其妙，化于神而虚者也”。由此可见是书之大旨。</p><h4 id="仙佛合宗语录"><a href="#仙佛合宗语录" class="headerlink" title="仙佛合宗语录"></a>仙佛合宗语录</h4><p>气功内丹术著作。不分卷。明伍守阳撰。书中以道释之论，来证性命双修之旨。前为论丹道9篇，后附门人问答29条，及评古类13条。自序云：“仙宗果位，了证长生；佛宗果位，了证无生。然而了证无生，必以了证长生为宾指；了证长生，必以了证无生为终始，所谓性命双修者也”。其内丹说以佛证仙，是明白无疑的。</p><h4 id="遵生八笺"><a href="#遵生八笺" class="headerlink" title="遵生八笺"></a>遵生八笺</h4><p>综合性养生著作。20卷。明高濂撰。全书分《清修妙论笺》、《四时调摄笺》、《起居安乐笺》、《延年却病笺》、《饮肴服食笺》、《燕闲清赏笺》、《灵秘丹药笺》、《坐外退举笺》八个部分，阐述养生祛病大旨，故称“八笺”。书中广集前人文论、诸子百家的养生名言，儒释道三教并重。内容涉及衣、食、住、行诸方面，既重视物质调养，又重视精神调摄。同时作者对自身养生心得作了总结介绍。颇有参考价值。</p><h4 id="活人心法"><a href="#活人心法" class="headerlink" title="活人心法"></a>活人心法</h4><p>气功养生著作。2卷。明朱权撰。书中强调修心养性在养生中的作用，认为“真人以道治心”、“心静可似通乎神明”。全书主要内容有养生之法、治心、导引法、去病廷藩六字法、四季养生歌，以及中和汤、和气丸等。其中导引法附有行动图8幅，颇为实用。</p><h4 id="养生肤语"><a href="#养生肤语" class="headerlink" title="养生肤语"></a>养生肤语</h4><p>气功养生著作。1卷。明陈继么儒撰。以笔记形式记叙作者本人及前辈的养生观点和实践体会，通俗简易，大要在于葆精、炼气、养神。</p><h4 id="养生四要"><a href="#养生四要" class="headerlink" title="养生四要"></a>养生四要</h4><p>气功养生著作。5卷。明万全撰。书中以医理论述气功养生之理，强调寡欲、慎动、法时的养生观。全书分寡欲、慎动、法时、却疾、养生总论5部分。所记叙的气功养生内容多为实例，不同于一般泛泛之谈，所论切实可行，无玄虚妄诞之论，很是可贵。</p><h4 id="保生心鉴"><a href="#保生心鉴" class="headerlink" title="保生心鉴"></a>保生心鉴</h4><p>气功养生著作。1卷。明铁蜂居士撰。书中以医理为主，阐述养生却疾之方法，内容充实，也较为实用。观作者所言，是书乃在《圣贤保修通鉴》一书的基础上，参详《礼记月令》及《素问》、《灵枢》、《运气论奥》、《十四经发挥》等书，反复论证，并将《活人心法》中的八幅导引图改绘成三十二幅，共成此佚。书中对练功前准备、修炼要领、五运六气枢要、脏腑配经络、经络配四时等都作了详细的图说；并重点介绍了《二十四气导引图》，分述二十四节气的练功方法及所治疾病，图文并重，简易实用，对后世医疗气功的发展有较大的影响。</p><h4 id="摄生要义"><a href="#摄生要义" class="headerlink" title="摄生要义"></a>摄生要义</h4><p>气功养生著作。1卷。明王廷相撰。全书凡十篇，所论多为日常摄生方法，且多为作者自身体验者，颇有心得。其序中云：“余自壮年以来，颇讲此术，缘动达形，缘虚达气，下不著伎，上不泥仙，似于摄生之秘，超然有得。乃会综群文，诠取要旨，以著论十篇，用发蒙学。”十篇为存想、调气、按摩、导引、形景、饮食、居处、房中、四时、杂忌。</p><h4 id="卫生真诀"><a href="#卫生真诀" class="headerlink" title="卫生真诀"></a>卫生真诀</h4><p>气功养生著作。2卷。明罗洪先撰。书中对导引、内丹、外丹、气功处方等均有论述。上卷载运气口诀、导引要法及内丹、外丹的炼法等。下卷载有气功处方49则，故又名《仙传四十九方》，每方均有名称、功法、图像、主治病证、配用方药、诗歌等。</p><h4 id="万寿仙书"><a href="#万寿仙书" class="headerlink" title="万寿仙书"></a>万寿仙书</h4><p>气功养生著作。4卷。明罗洪先撰。清曹无极增辑。卷一主要收辑历代名人的养生理论及功法要点；卷二主要收辑著名的导引功法，如六字诀、八段锦坐功捷径等；卷三为诸仙导引图，按病证开列导引处方，并附有方药；卷四为延年总论，辑前人的养生观点而成，似是曹氏所增。</p><h4 id="修龄要旨"><a href="#修龄要旨" class="headerlink" title="修龄要旨"></a>修龄要旨</h4><p>气功养生著作。1卷。明冷谦撰。全书系9篇养生诗文编集而成，分述四时调摄、起居调摄、延年六字诀、四季却病歌、长生一十六字妙诀、十六段锦、八段锦导引法、导引却病歌诀、却病八则。</p><h4 id="锦身机要"><a href="#锦身机要" class="headerlink" title="锦身机要"></a>锦身机要</h4><p>气功养生著作。3卷。明混撼沌子撰，鲁至刚注。书中完整地介绍了一套以导引术揉合内丹术及房中术的功法，共有36式。每式先列名称、图像，次列歌诀与注文。上、中、下卷各12式，内容详备。鲁氏在序中云：“其筑基之法，养生之方，龙虎争驰，内外交炼，无不备焉。”</p><h4 id="类修要诀"><a href="#类修要诀" class="headerlink" title="类修要诀"></a>类修要诀</h4><p>气功养生著作。2卷，续附3卷。明胡文焕编。书中收集了古人有关修身明性、养生却病的论述，认为养生之关键在于慎寒暑、节口腹、寡嗜欲。此外，对饮食起居、四时调摄、劳逸房室、七情忌宜、导引按摩，以及内丹术等方面的内容均有论述。</p><h4 id="养生导引法"><a href="#养生导引法" class="headerlink" title="养生导引法"></a>养生导引法</h4><p>气功导引著作。1卷。明胡文焕编。书中主要讲述导引养生祛病法。共列病症27门，每门列功法若干条，可供选用。其选功法基本上依据（诸病源侯论）中所载的“养生方导引法”。此外，补益与老人二门中还收辑了《太清导引养生经》、《通玄集》等书的部分内容。</p><h4 id="保生秘要"><a href="#保生秘要" class="headerlink" title="保生秘要"></a>保生秘要</h4><p>气功导引著作。明曹士珩撰。原书少见，佚存未知。其内容散见于《古今图书集成》及《沈氏尊生书》。一为南北规中，共列7法。其中旧元、周天为南旋式，垠背、行庭、通关、绦法、涤秽为北旋式。一为诸病导引；分述咳嗽、哮喘、伤食呕吐、噎膈、鼓胀等病证的导引治疗，有较强的实用性。</p><h4 id="赤凤髓"><a href="#赤凤髓" class="headerlink" title="赤凤髓"></a>赤凤髓</h4><p>气功导引著作。3卷。明周履清编。书中重视导引的作用，广为搜罗，图文并茂。卷一为太上玉轴六字气诀、幻真先生服内元气诀、李真人长生一十六字妙诀、胎息、秘要歌诀、去病延年六字法、五禽戏圈诀、八段锦导引图诀等；卷二为圣真秘传四十六长生图诀；卷三为华山十二睡功图诀。均较为实用，对后世气功导引术的发展与推广有较大贡献。</p><h4 id="听心斋客问"><a href="#听心斋客问" class="headerlink" title="听心斋客问"></a>听心斋客问</h4><p>气功内丹术著作。1卷。明万尚父撰。作者用简明的语言，以客问主答的形式，对65个内丹术问题进行了阐释。如元精与交感之精的区别，元神与思虑之神伪异同等等。所论准确明白，直揭底蕴，对初习内丹术之人颇为实用。</p><h4 id="脉望"><a href="#脉望" class="headerlink" title="脉望"></a>脉望</h4><p>气功内丹术著作。8卷。明赵台鼎撰。是书系作者读书练功的笔记，书中采摘了大量内炼要语，且有自己的见解，对练功中的问题作了明白的解释，有一定的参考价值。</p><h4 id="真诠"><a href="#真诠" class="headerlink" title="真诠"></a>真诠</h4><p>道教炼养著作。3卷。明阳道生传，清彭定求校刻。此书对内丹修炼的认识颇有独到之处。认为内丹的锤炼，一为虚无大道，即“虚极静至，精自然化气，气自然化神，神自然还虚”；二为以神驭气，即“虚静以为体，火符以为用，炼精成气，练气成神，炼神还虚”。两者殊途同归，相辅相成，且均能得长寿之益。鼓氏指出其父对是书的评价甚高，云：“平生阅历四方丹书甚多，迷谬错出，不如此书洁净精微。”</p><h4 id="寥阳殿问答"><a href="#寥阳殿问答" class="headerlink" title="寥阳殿问答"></a>寥阳殿问答</h4><p>气功内丹术著作。1卷。明尹实人撰。全称为《尹真人寥阳殿问答编》。书中认为内丹修炼宜治心理气为先，返观内照、凝神入气穴、聚火开关、卯酉周天为次，最后才是长养圣胎。全书共分6篇，分述内丹修练要诀，重视调息与丹田，讲究周天功夫，是其特点。</p><h4 id="静坐说"><a href="#静坐说" class="headerlink" title="静坐说"></a>静坐说</h4><p>气功静坐著作。明高攀龙撰。主说静坐功夫，静坐以平常为要诀，而平常即清静自然。“以其清静不容一物，故谓之平常”，“静中妄念即净，昏气自清，只体认本性、原来本色，还他湛然而巳”，“湛然动去，静时与动时一色，动时与静时一色，所以一色者，只是一个平常也。故曰无动无静，学者不过借静坐中认此无动无静之体云尔”。在其后的《书静坐说后》中，又把理学的“主一”观引入作者的静坐论，认为“必收敛身心，以主于——即平常之体也，主则有意存焉，如意非著意，盖心中无事之谓，一著意则非一也。”可见作者的静坐说并非一味讲静，具有以静为主，动静交养的含意。</p><h4 id="静坐要诀"><a href="#静坐要诀" class="headerlink" title="静坐要诀"></a>静坐要诀</h4><p>气功静坐著作。1卷。明袁黄撰。书中主要从佛教心法论述静坐功夫。其论以天台宗的止观法、六妙法为基础，结合云谷、妙峰二位圣僧的修习心得及作者自身的实践，对静坐进行了详细的论述。全书分辨志、修证、调息、遣欲、广爱等六篇。摄生三要气功养生著作。明袁黄撰。三要者，即聚精、养气、存神。强精强调寡欲、节劳、息怒、戒酒、慎味等；养气提倡从调息起手，并介绍了胎息、胎食之法；存神则介绍了意守各窍之效应，及佛教修禅之法。</p><h4 id="古今医统大全"><a href="#古今医统大全" class="headerlink" title="古今医统大全"></a>古今医统大全</h4><p>综合性医药著作。100卷。明徐春圃撰。简称《古今医统》。书中罗列的资料十分丰富，既引古人之说，又有已见，重点论述医药方面的内容，其中卷九十九与卷一百为养生内容。其养生宗三元之说，也重视其他炼养方法。认为“天元之寿精气不耗者得之”、“地元之寿起居有常者得之”、“人元之寿饮食有度者得之”。摄生要义章则专论存想、调气、按摩、导引等，服饵章则专论服日月、服日精月华、服三气等。</p><h4 id="医学入门"><a href="#医学入门" class="headerlink" title="医学入门"></a>医学入门</h4><p>综合性医药著作。8卷，首1卷。明李挺撰。全书重点讨论医药上的问题，对医学理论、临床各科、历代医家、本草等均有论述。首卷的保养篇中，着重讨论养生方法。集中的导引法论述颇有见地，认为“人之精神极欲静，气血极欲动”、“导引为虚损气血不同面设”，列有开关法、起脾法、开郁法、治腰痛、治积聚、治遗精、治痰壅等导引法术，较为实用。</p><h4 id="寿世保元"><a href="#寿世保元" class="headerlink" title="寿世保元"></a>寿世保元</h4><p>综合性医药著作。10卷。明龚廷贤撰。书中在大量论述医学问题的同时，十分重视气功养生的祛病延年作用。卷四补益篇中特列吕洞宾补屋修墙养生诀与呼吸静功妙诀，其“妙块”中强调“人生以气为本，以息为之，以心为根，以肾为蒂”，故“人呼吸常在心肾之间，则血气自顺，元气自固，七情不炽，百骸之病自消矣”。可见十分重祝呼吸的养生保健作用。书中并列有具体功法，也颇为实用。</p><h4 id="红炉点雪"><a href="#红炉点雪" class="headerlink" title="红炉点雪"></a>红炉点雪</h4><p>中医理虚专著。4卷。明龚居中撰。又名《痰火点雪》。书中主要讨论痰火劳损病证的鉴别与治疗，颇有特色。卷四中祛病秘诀，列举了许多对痰火虚损病证的养生调息之法。如却病延年一十六句之术、动功六字延寿诀、静坐功夫等。方法简单，易学易练，较为实用，对肺痨的防治有一定参考价值。</p><h4 id="五福全书"><a href="#五福全书" class="headerlink" title="五福全书"></a>五福全书</h4><p>气功养生著作。7卷。明末龚居中撰。论气功养生参合医理，并有图说，是其特点。卷一至卷三列有修真要图、修真至说、修真秘诀，均系内丹之论，卷四为修真金丹，是外丹之论；卷五为修真种玉；卷六、卷七论述饮食忌宜。</p><h4 id="奇经八脉考"><a href="#奇经八脉考" class="headerlink" title="奇经八脉考"></a>奇经八脉考</h4><p>中医经络学专著。1卷。明李时珍撰。书中系统地论述了奇经八脉的循行线路、功能、主治病证，对针灸、气功、中医临床各科的辨治等均有重要指导意义。同时对奇经八脉在气功养生中的作用也作了详细的论述.认为医生不知奇经八脉难以探讨病机，气功养生者不知奇经之理，则难以确立养生之法。“任督二脉，人身之子午也，乃丹家阳火阴符升降之道，坎水离火交媾之乡”，“任督二脉是元气之所由生，真息之所由起，修丹之士，不明此窍，真息不生，神化无基也”。可见奇经八脉在气功养生中的作用是很重要的。</p><h4 id="针灸大成"><a href="#针灸大成" class="headerlink" title="针灸大成"></a>针灸大成</h4><p>中医针灸学专著。10卷。明杨继洲撰。书中对针灸学进行全面而系统的论述，对针灸学的发展有较大的影响。同时对气功祛病方面的知识也进行了介绍，如将小周天功法进行仔细的分新，“默想黍米之珠……徐徐咽气一口，缓缓纳入丹田，冲起命门，引督脉过尾闾，而上升泥丸，追动性元，引任脉降重楼，而下返气海。二脉上下，旋转如圆，前降后升，络绎不绝”。此外，还记述了不少与道家气功有关的内容，如吐纳、六害、十少等。将调神、调息法用于针刺疗法中，也是其特色。</p><h4 id="道藏"><a href="#道藏" class="headerlink" title="道藏"></a>道藏</h4><p>道教典籍总汇。收书1426种.共计1305卷。明张宇初主编，张字清续成。明成祖朱隶初即位时，即下诏编修，直至英宗朱祁镇正统十年（l445），才全部刻成。按三洞四辅十二类分类，用千字文编号，分装48O函。内容十分庞杂。除道教经书外，还收入诸子百家文集，保留了许多珍贵的科技史料。在此之前，历史上还有唐玄宗时的《开元道藏》、宋初的《大宋天宫宝藏》和《崇宁重校道藏》，藏经刊印始于宋徽宗政和中的《万寿道藏》，金元时期都以此为蓝本，金代有《大金玄都宝藏》，元代增订后仍称《会都宝藏》等，这些《道藏》现皆不存。</p><h4 id="续道藏"><a href="#续道藏" class="headerlink" title="续道藏"></a>续道藏</h4><p>道教典籍总汇。收书50种，共计180卷。明张国祥编。明神宗万历三十五年，为了弥补《正统道藏》的不足而下诏编修。分装32函，仍以千中文编号，起“杜”字，迄“缨”字，上接《正统道藏》。</p><h4 id="诸真玄奥集成"><a href="#诸真玄奥集成" class="headerlink" title="诸真玄奥集成"></a>诸真玄奥集成</h4><p>气功内丹术丛书。明涵蟾子编。收书9种，共计9卷。卷一为黄自如的《金丹四百字解》，卷二为石泰的《还源篇》，卷三为薛式的《还丹复命篇》，卷四为陈楠的《翠虚篇》，卷五为涵蟾子的《金液还丹思金图发摄》，卷六为白玉蟾的《指玄篇》，卷七为萧廷芝的《金丹大成集》，卷八为赵友钦的《仙佛同源》，卷九为许逊的《石函记》，均为内丹名著，很有参考价值。</p><h4 id="道言内外秘诀全书"><a href="#道言内外秘诀全书" class="headerlink" title="道言内外秘诀全书"></a>道言内外秘诀全书</h4><p>道教炼养全书。收书56种，共计63卷。明彭好古编。所收均为道教练养名著，如《阴符经》、《道德经》、《胎息经》、《钟吕二仙传道集》、《金丹歌》、《得道歌》、《古文参同契》等。其中《参同契》、《入药镜》、《悟真篇》、《金丹四百字》、《金碧古文龙虎上经》等，均系彭氏自注，有其自己的心得和见解。</p><h4 id="方壶外史"><a href="#方壶外史" class="headerlink" title="方壶外史"></a>方壶外史</h4><p>气功内丹术丛书。收书15种，共计8卷。明陆西星撰。又名《方壶外史丛编》。陆西星为内丹东派之领袖，著述颇多。万历初年，赵宋汇集陆氏著作10种，分为8卷刊印，名曰《方壶外史》，后陆续有补刻。然而流传时久。逐渐散佚。民国4年，郑观应等据明版《方壶外史丛编》目录，重新排印，将书依乾、坤、离、坎、屯、蒙、既、未八字分为8集，共收陆氏著述15种。曰《无上玉皇心印妙经测疏》、《黄帝阴符经测疏》、《老子道德经玄览》、《周易参同契测疏》、《周易参同契口义》、《张紫阳悟真篇小序》、《崔公入药镜测疏》、《吕真人百字碑测疏》、《张紫阳金丹四百字测疏》、《龙眉子金丹印证测疏》、《丘真人青天歌测疏》、《玄肤论》、《金丹就正篇》、《金丹大旨图》、《七破论》。或阐释丹经，或答疑解惑，其论精当全面，直揭丹道玄奥，颇具特色。</p><h3 id="清"><a href="#清" class="headerlink" title="清"></a>清</h3><h4 id="金仙证论"><a href="#金仙证论" class="headerlink" title="金仙证论"></a>金仙证论</h4><p>气功内丹术著作。不分卷。清柳华阳撰注。柳华阳为伍守阳弟子，世称“伍柳派”。此书共20篇，专论小周天功夫，自称“又恐学者错认门户，重加亲注，道合仙佛之真机，工用自己之效验，诚为二门登堂入室之良方者矣”。可见作者颇为自信。柳华阳继承师说，亦以火候为小周天功夫的要领，特撰《风火经》（第六章）大书特书，确实做到了无幽不阐、无微不显的程度。由于此书比较浅显明白，容易读懂，并且步骤井然，易学易练，因此受到后世的普遍欢迎。</p><h4 id="慧命经"><a href="#慧命经" class="headerlink" title="慧命经"></a>慧命经</h4><p>气功内丹术著作。不分卷。清柳华阳撰注。全书共20篇，图文并茂，内容精细。全经强调性命双修，《正道禅机直论》指出：“不识性命.则大道无所成。”又曰：“佛道性命喻龙虎，龙虎喻动静，动静喻禅机。”性指心与神，命指身与气，心肾相交，水火既济，阴平阳秘，则慧命而不外耗，以风喻呼吸，以火喻意念，凝神气穴，风吹火炼而成真神，这是全书的要点，故曰《慧命经》。</p><h4 id="金华宗旨"><a href="#金华宗旨" class="headerlink" title="金华宗旨"></a>金华宗旨</h4><p>气功内丹术著作。1卷。清代著作，托名于吕岩。又名《太乙金华宗旨》。论气功静坐要旨，共13篇。书中称“法子欲入静，先调摄身心，自在安和，放下万缘，一丝不挂，天心正位乎中。然后两目垂帘，……次以二目内照坎宫（腹），光华所到。真阳即出以应之。……诶其冥冥中，忽然天心一动，此则一阳来复，活子时也。……天心一动，即以真意上升乾宫（首），面神光视顶，为导引焉。此动而应时者也。天心既升乾顶，游扬自得，忽而欲寂，急以真意引入黄庭，而目光视中黄神室焉。……即此便是凝神入气穴”（《逍遥决第八》）。入手工夫，不外乎此。总之，强调“心传”、“心法”，简明直截，不似伍柳派内丹功法的节目繁多，这是它的特点。书未附有（金华宗旨阐幽问答）1卷。不题撰人。共20条，独标心学，是气功中受禅学、陆王心学影响后的作品，对理解《金华宗旨》有一定帮助。</p><h4 id="天仙金丹心法"><a href="#天仙金丹心法" class="headerlink" title="天仙金丹心法"></a>天仙金丹心法</h4><p>气功内丹术著作。2卷。清代著作，托名吕岩等撰，八洞仙祖合注。卷首有托名张道陵等序及心法发凡等17篇，卷未有抑守元等后跋8窟。正文16藏：立志、端品、悔过、迁善、筑基、炼已、安炉、采药、起火、熄火、结胎、养婴、积行、行动、面壁、飞升。主张性命双修，培补后天以复先天。</p><h4 id="玄宗正旨"><a href="#玄宗正旨" class="headerlink" title="玄宗正旨"></a>玄宗正旨</h4><p>道教炼养著作。1卷。清代著作，托名吕岩等仙真降笔。前有柳守元题词，称此书“于以见南北玄学宗旨在是。凡金丹至秘之诀，妙道至极之功，无不备载于此中”，可谓推崇备至。其书虽系伪托，然说理明白。功法简要，对于初学较为便捷，因此流传颇广。</p><h4 id="唱道真言"><a href="#唱道真言" class="headerlink" title="唱道真言"></a>唱道真言</h4><p>道教炼养著作。5卷。清鹤曜子编录。此书系乱坛降笔，首言炼心，次炼命，次炼丹、炼气、炼神、炼形等，终至于还虚成功。此书强调炼心的重要性，认为必须炼得方寸之间，如一粒水晶珠子，如一座琉璃宝瓶。无穷妙义，便从自已心源悟出，念念圆通，心心朗彻，则自古来仙家不传之秘，至此无不了然，结丹在此，玄关一窍亦在此。其学术思想渊源于道家北宗，而侧重融禅入玄，尤具自己特色。陈樱宁先生对此书评价颇高，认为“书中道理讲得不错，自成一家言，比较现在的乩坛文章，真有霄壤之别”（《道教与养生答复苏州张道初君十五问》）。</p><h4 id="乐育堂语录"><a href="#乐育堂语录" class="headerlink" title="乐育堂语录"></a>乐育堂语录</h4><p>气功内丹术著作。5卷。清黄元吉撰。作者在清代道光、咸丰年间（1821—1860）讲道于四川乐育堂，传授进门心法，由其弟子记录，并经核正而刊为此书。其书授儒入道，因佛证真，理事兼举，性命并重。始则修性以立命，继则修命以了性，终则福慧双圆，性命合一，而证入圣登真之功。道家传授气功内丹修炼的典籍，古称“丹经”，为数虽然不少，然而大多隐晦曲折，奥雅难通。往往不病于偏执枯滞，即病于玄奥幽眇，不隐于龙虎铅汞，即遁于坎离水火，使读者不穷毕生之精力，即难得融会贯通，不获明师之指点，即难以心领神会。本书则一扫此弊，说理朴实而不奥，述义精细而易明，对于行功次第，更是步骤井然。道教学者萧天石先生认为此书：“深者能得其深，浅者能得其浅，无论上智下愚，皆可循此而升堂入室，诚性学之梯航，命家之津逮也”。</p><h4 id="道窍谈"><a href="#道窍谈" class="headerlink" title="道窍谈"></a>道窍谈</h4><p>气功内丹术著作。不分卷。清李西月撰。全书共40章，详论西派丹法要抄。计有藐诸友书、开关问答、后天集解、筑基炼已、养已炼已、后天次序、内外二药、药物相类、三品互养、炼功五关、产药层次、药物层次、丹砂二种、神气性命、先天直指、神气精论、精气神论、性命顺逆、玄关一窍、玄关再说、两孔穴法、玄牡根基、中字直指、药物直陈、铅汞的辩、鼎器直说、乾坤离坎、采炼炒用、河车细旨、真心论、心神直说、神息妙用、神意再论、气息妙用、神意妙用等章。这些内容基本上包括了内丹修炼中的各种技术问题，故对初学者有入门引路的作用。</p><h4 id="三车秘旨"><a href="#三车秘旨" class="headerlink" title="三车秘旨"></a>三车秘旨</h4><p>气功内丹术著作。不分卷。清李西月撰。书中论述了以下问题：入门初步收心法、第一河车、第二河车、第三河车、河车细旨、勤字说、共争不朽之论等。所言三车，是指三件河车：第一件运气，即小周天，子午运火也；第二件运精，即玉液河车，运水温养也；第三件精气兼运，即大周天，运先天金汞，七返还丹，九还大丹也。此三车者，皆以其神真意斡乎其中，人能知三车秘谛，则精、气、神三品圆全，天、地、人三仙成就。该书对内丹修炼中河车理论抉幽发微，阐述透彻，颇能给人以启迪。</p><h4 id="玄微心印"><a href="#玄微心印" class="headerlink" title="玄微心印"></a>玄微心印</h4><p>气功内丹术著作。2卷。清喻太真等合撰。全书本东派宗旨而论阴阳双修丹法。卷上有论阴阳门户、黄金土釜、奇经八脉、任督两脉等37章；卷下有胎息、铸剑、筑基等7章。</p><h4 id="元真录"><a href="#元真录" class="headerlink" title="元真录"></a>元真录</h4><p>气功内丹术著作。3卷。清董德宁撰。内收《丹道发微》、《仙传宗源》、《性学筌蹄》各1卷。收入《道贯真源》中。</p><h4 id="试金石"><a href="#试金石" class="headerlink" title="试金石"></a>试金石</h4><p>气功内丹术著作。1卷。清傅金铨撰。该书篇首强调内丹长生之道，以炼已筑基，修复巳损元体为本。认为“筑基成则具六通之一，所谓无漏尽通，即可以长生不死”。特别是对老年体衰之人，男子精枯气竭.须要使其无精而复有精，然后由有精而炼至无精，“并无精窍，小便缩如童子”；女子气血久亏，要使无血而生血，复有月信，然后由有经水而炼至无经水，“斩断赤龙，身如处女”，精血皆得化气，则筑基之功成矣。论述筑基之法，力主“神仙栽接”之双修，以为“只知独坐孤修，不知离宫入定，坎府求玄”，是“爱身家而不惜性命”、难得长生。书中通过与弟子答问的形式，就双修、可笑、心肾、家中、黄婆、伴侣、炉鼎、铅汞、火药、子时、潮信、卯酉、沐浴等24个方面的问题，引经据典，证诸圣真，作了具体的阐述。</p><h4 id="修真辩难"><a href="#修真辩难" class="headerlink" title="修真辩难"></a>修真辩难</h4><p>气功内丹术著作。2卷。清刘一明撰。其书以师徒问答形式，阐述内丹功理。作者认为内丹乃性命凝结而成，所以必须性命双修，指出性命之道与阴阳之道密切相关，性命为阴阳之体，阴阳为性命之用。性即理，命即气，气不离理，理不离气，因此性不离命，命不离性，浑然一体，不容分割。修性即能立命，所以修行者必须重视修性，“不能修性，焉能立命?益性者命之寄，命者性之存，性命原是一家，焉得不修性?”要求性命双修而侧重先性后命。</p><h4 id="修真九要"><a href="#修真九要" class="headerlink" title="修真九要"></a>修真九要</h4><p>道教炼养著作。1卷。清刘一明撰。此书系作者传述其师砻谷老人之说。共九要为：勘破世事第一，积德修行第二，尽心穷理第三.访求真师第四，练已筑基第五，和合阴阳第六，审明火候第七，外药了命第八，内药了性第九。作者认为修真之道，乃天下至大至难大事，非深明造化，洞晓阴阳，存经久不易之志。循序渐进者不能行之，故提出修真纲领由浅入深，总为九条。</p><h4 id="上品丹法节次"><a href="#上品丹法节次" class="headerlink" title="上品丹法节次"></a>上品丹法节次</h4><p>气功内丹术著作。1卷。清闵一得编撰。本书论述内丹功法层次，简明扼要，全书共12篇。前3篇系李德洽原著，文未均有闵一得详细注释。所论上品丹法实熔道教南北宗之内丹功法。作者以儒合道，从养生角度来谈内丹修炼，强调“存诚”。后9篇系闵氏所撰，基本属于《性命圭旨》所架设的内丹体系。</p><h4 id="女宗双修宝筏"><a href="#女宗双修宝筏" class="headerlink" title="女宗双修宝筏"></a>女宗双修宝筏</h4><p>内丹术女功著作。1卷。清沈一炳撰。全称《泥丸李祖师女宗双修宝筏》，原书有副标题《女功指南》。作者述其师李泥丸女丹要诀，再传弟子闵一得重订。陈樱宁论女子修炼有六派，其中“孙不二元君派”以“斩赤龙”下手为特征《教道与养生》。本书即属此体系。全书共分9节每节先列“泥丸氏曰”为正文再低一字列“大虚氏（沈一炳号）曰”为法文。书未有闵一得跋。</p><h4 id="女修正途"><a href="#女修正途" class="headerlink" title="女修正途"></a>女修正途</h4><p>内丹术女功著作。1卷。清闵一得编撰。全称《西王母女修正途十则》。原题吕祖师申正重题，孙元君遵剔补述大虚翁沈太师授，受业弟子闵一得注。本书系道教北宗龙门派女子内丹功法之一，属“孙不二元君派”体系，全书10则，每则皆冠“若曰”二字。每则正文之后皆有闵一得的注文，以“谨接”二字识之。</p><h4 id="养生十三则阐微"><a href="#养生十三则阐微" class="headerlink" title="养生十三则阐微"></a>养生十三则阐微</h4><p>气功养生著作。1卷。清闵一得撰。内容为两手握固、舌抵上腭、神游水府等13则。前1O则内容与传统的八段锦、十二段锦相似；后3则强调练功时静态要求。</p><h4 id="梅华问答编"><a href="#梅华问答编" class="headerlink" title="梅华问答编"></a>梅华问答编</h4><p>气功内丹术著作。1卷。清薛阳桂撰。作者为闵一得弟子，此书即禀承师说，发挥北宗龙门派内丹术的理论与功法。书中实为作者与来客陶既若、韩洞然、僧慧澈、许洞雷诸人，于八月望日赏桂于竹影梅华馆讨论内丹术。由作者记录上述诸人之发言，编成此书。</p><h4 id="大成捷要"><a href="#大成捷要" class="headerlink" title="大成捷要"></a>大成捷要</h4><p>气功内丹术著作。3卷。清代著作，不题撰人。据说此书原为柳华阳的修道练功笔记，亦有可能是民国时人精选各种丹经要语汇编而成。此书原藏于河南登封县嵩山崇福官，后道士王乾一云游至该宫，从常住马宇秀炼师处获观此书，抄录一通携归，藏于山东崂山太清宫。于民国初年传出。本书编排虽欠清整，然其“节次功夫戌臻玄妙，拟义立论尤其精工”，从下手以迄成功，一一详细说明，颇有参考价值。</p><h4 id="老老恒言"><a href="#老老恒言" class="headerlink" title="老老恒言"></a>老老恒言</h4><p>气功养生著作。清曹庭栋撰。又名《养生随笔》。作者参阅三百余家有关养生的著作，并结合日常生活衣食住行等方面，总结出一整套简便易行的养生方法。书中详细介绍了老年人的安寝、晨兴、梳洗、饮食、散步等饮食起居、养生导引方法。作者认为“静养为摄生首务”，但也强调老年人必须经常修炼气功或运动，借以活动关节，强壮筋骨。</p><h4 id="勿药元诠"><a href="#勿药元诠" class="headerlink" title="勿药元诠"></a>勿药元诠</h4><p>气功养生著作。清汪昂撰。作者为明末诸生入请弃举子业而潜心医学。撰有医学普及著作多种。《勿药元诠》为《医方集解》之附录，介绍养生修炼方法，其中如调息、小周天等，经此书介绍流传日广。</p><h4 id="寿世青编"><a href="#寿世青编" class="headerlink" title="寿世青编"></a>寿世青编</h4><p>气功养生著作。2卷。清尤乘撰。上卷为“勿药须知”主要讨论气功养生方法；下卷为“服药须知”，主要讨论服药却病忌宜。书未附有“病后调理服食法”。“勿药须知”主要强调通过调心神、养性情来修身防病，达到长寿的目的。书中对有关保健内容作了专题论述。还载有导引却病法、小周天法等气功内容。</p><h4 id="寿世传真"><a href="#寿世传真" class="headerlink" title="寿世传真"></a>寿世传真</h4><p>气功养生著作。8卷。清徐文弼撰。作者主张气功导引应与综合调摄并重，提出修养宜行内外功，要宝精宝气宝神，还须知要知忌知伤，注意四时调理和饮食调理。在外功方面，有针对五官、四肢、腰背的按摩之术，及提倡应用十二段锦、八段锦和六字真言。内功则是静坐运气方法。本书内容涉及广泛，收罗前人经验甚多对后世的保健养生有一定的影响。</p><h4 id="陆地仙经"><a href="#陆地仙经" class="headerlink" title="陆地仙经"></a>陆地仙经</h4><p>气功养生著作。清马齐撰。本书由五言二十句组成，共计百字，作者通过注解，介绍了养生调摄及气功导引的体方法。</p><h4 id="内功图说"><a href="#内功图说" class="headerlink" title="内功图说"></a>内功图说</h4><p>气功养生著作。1卷。清潘霓撰。原名《卫生要术》，1935年韩慕侠重印此书，改名《健康之路》。内收十二段锦、分行内外功、易筋经、却病延年法等功法，载有姿式图35帧并配以简单的文字说明，图文并茂，易于摹仿学习。故历年来翻印较多。</p><h4 id="彩墨导引图"><a href="#彩墨导引图" class="headerlink" title="彩墨导引图"></a>彩墨导引图</h4><p>气功导引图谱。1卷。清昆岚编绘。此书按病证设问以导引治法及简要治疗机理作答。并按式绘图，施以彩色，墨线勾勒，颇为细致。其中坐式9幅，立式、卧式各6幅，蹲式2幅，跪式1幅，共计24幅。</p><h4 id="寿人经"><a href="#寿人经" class="headerlink" title="寿人经"></a>寿人经</h4><p>气功导引著作。清汪思撰。内容包括：理脾土诀、理肺金诀、理肾水诀、理肝木诀、理心火诀、坐功诀、导引诀。介绍了一套调治五脏为主的动功锻炼养生方法。</p><h4 id="延年九转法"><a href="#延年九转法" class="headerlink" title="延年九转法"></a>延年九转法</h4><p>气功按摩著作。清方开撰。此法以转摩腹脘为特色，共计九法，每法均有图与图解。最后“全图说”指出：“摩腹之法，以动化静，以静运动，合乎阴阳，顺乎五行，发其生机，神其变化。故能通和上下，分理阴阳，去旧生新，充实五脏，驱外感之诸邪，清内生之百证，补不足，泻有余，消食之道，妙应无穷，何须借药烧丹，自有却病延年实效耳”。</p><h4 id="调气圭臬图说"><a href="#调气圭臬图说" class="headerlink" title="调气圭臬图说"></a>调气圭臬图说</h4><p>气功养生著作。清李九华撰。全套功法共46式，配图32幅。前23式以导引配合深呼吸中4式以导引配合自然呼吸，末19式以自我捶打导气。所有功式均以禽鸟动态命名，如风翥鸾停等。本功取《拳经》壮气强筋之要诀，导源于武术。</p><h4 id="张氏医通"><a href="#张氏医通" class="headerlink" title="张氏医通"></a>张氏医通</h4><p>综合性医药著作。16卷。清张潞撰。本书“神志门”中详尽描述了“走火入魔”的原因、表现与药物治疗。作者认为炼士坐功运气之走火与常人有别，但遍考方书，从无及此，故详推治例，撰成此篇。此外、作者<br>对养性也颇有见地。</p><h4 id="杂病源流考"><a href="#杂病源流考" class="headerlink" title="杂病源流考"></a>杂病源流考</h4><p>中医内科专著。30卷。清沈金鳌撰。为丛书《沈氏尊生书》中之一种。作者认为“导引运功本养生家修炼要诀，但欲长生，必先却病，其所导所运，皆属却病之法，令附于篇未，病者遵而行之，实可佐参药力所不逮”。对于疾病治疗，罗列方药、导引、运功各项治法。卷首总论脉象，并附录明曹士珩《保生秘要》运功规法，相当于练功原则与通用功法。</p><h4 id="重刊道藏辑要"><a href="#重刊道藏辑要" class="headerlink" title="重刊道藏辑要"></a>重刊道藏辑要</h4><p>道教要籍丛书。收书300余种，共计若干卷。清彭定求编。光绪三十三年（1906），成都二仙庵重刻，由阎永和删除2种，增加20种，并新增贺龙壤所编《重刊道藏辑要总目》1卷、《重刊道藏辑要子目初编》及《续篇》一卷，《道门一切经总目》4卷。全书按二十八宿字号分为28集，择要收录道教重要经典、历代祖师著作、科仪戒律、碑传谱记、气功摄生诸类著作。不仅深得《道藏》之精要，而且保存了不少明清两代道教的重要著作。</p><h4 id="古书隐楼藏书"><a href="#古书隐楼藏书" class="headerlink" title="古书隐楼藏书"></a>古书隐楼藏书</h4><p>道教炼养丛书。收书38种，共计51卷。清闵一得编。这是一部著名的气功学文献丛书。多数由编者自撰。计有《碧菀坛经》5卷、《修真辩难参证》2卷、《阴符经玄解正义》l卷、《金丹四百字注解》1卷、《太乙金华宗旨》1卷、《吕祖师三尼医世说述》1卷、《吕祖师三尼医世功诀》1卷、《皇极阐辟证道仙经》3卷、《寥阳殿问答编》1卷，等等。全书内容复杂，既有对道佛气功经典的注释，又有个人修炼心得的阐述；既对各种丹家邪说加以大力批驳，又对学道修炼的各种清规戒律作详尽论述。提倡三教功法合一，而于道教功法尤为推崇，故于道教内炼之法，论述特别详尽。</p><h4 id="道统大成"><a href="#道统大成" class="headerlink" title="道统大成"></a>道统大成</h4><p>气功内丹术丛书。收书10种，共计25卷。清汪启菱编。计有《周易参同契阐幽》3卷、《周易参同契测疏》3卷、《周易参同契口义》2卷、《中和集》6卷、《规中指南》6卷、《入药镜》1卷、《金丹四百字测疏》1卷、《明道篇》1卷、《列位女真诗歌》1卷、《坤道丹诀》1卷。</p><h4 id="张三丰全集"><a href="#张三丰全集" class="headerlink" title="张三丰全集"></a>张三丰全集</h4><p>道教炼养丛书。收书近2O种，共计8卷。清李西月编。原书卷一为序、浩、传、仙派、正讹、显迹；卷二为古文、隐鉴；卷三为大道论、玄机直讲、道言浅近说；卷四为玄要篇；卷五为云水集；卷六为天口篇、训世文，卷七为九皇经、三教经、度人经、菩提经、钟揭；卷八为水石闲谈、古今题赠、隐镜、汇记。</p><h4 id="道贯真源"><a href="#道贯真源" class="headerlink" title="道贯真源"></a>道贯真源</h4><p>气功内丹术丛书。收书9种，共计28卷。清董德宁编撰。作者自撰的有《用易参同契正义》3卷，《悟真篇正义》3卷、《元丹篇》1卷、《大上黄庭经发微》2卷、《黄帝阴符经本义》2卷、《老子道德经本义》2卷、《元真录》3卷（含《丹道发微》、《仙传宗源》、《性学筌蹄》各1卷）。辑录的有《修真六书》9卷，还有章世乾的《元丹篇约注》3卷。所收多为内丹术要籍。</p><h4 id="修真六书"><a href="#修真六书" class="headerlink" title="修真六书"></a>修真六书</h4><p>气功内丹术丛书。收书6种，共计8巷。靖董德宁编。该书收入了道教南宗五祖及其传人最著名的内丹文献，计有张伯端《悟真外篇》2卷，石泰《还源篇》1卷，薛式《复命篇》1卷，陈楠《翠虚篇》1卷，白玉蟾《紫清指玄集》2卷，以及白玉蟾的再传弟子萧廷芝的《金丹大成集》2卷。</p><h4 id="道言五种"><a href="#道言五种" class="headerlink" title="道言五种"></a>道言五种</h4><p>气功内丹术丛书。收书5种，共计11卷。清陶素耜编撰。其中作者自撰的为《周易参同契脉望》3卷，《悟真篇约注》3卷，《承志录》3卷，订定的为《金丹就正篇玄肤论》1卷，《金丹大要》1卷。作者反映南宗中双修一派观点。</p><h4 id="证道秘书"><a href="#证道秘书" class="headerlink" title="证道秘书"></a>证道秘书</h4><p>气功内丹术丛书。收书10种，共计17卷。清傅金铨编撰。其中自撰的有《杯溪录》3卷，《赤水吟》1卷，《丹经示读》1卷，《天仙正理读法点睛》1卷，《道海津梁》1卷。他人所撰的有邱处机的《邱祖全书》1卷，喻太真等的《玄微心印》2卷，张三丰的《三丰丹诀》1卷，以及不署撰人姓名的《外金丹》、《内金丹》各1卷。</p><h4 id="济一子道书"><a href="#济一子道书" class="headerlink" title="济一子道书"></a>济一子道书</h4><p>道教炼养丛书。收书7种，共计32卷。清傅金铨撰。其中为《一贯真机易简录》12卷，《度人梯经》8卷，《自题所画》1卷，《性天正皓》1卷，《摄阳经》1卷《附集1卷》，《心学》3卷，《道书五篇注》5卷（含《黄鹤赋》、《百句章》、《真经歌》、《鼎器歌》、《采金歌》各1卷）。其主要内容是将道教前贤有关修身养性及内炼的语录分门别类加以集录，并作注解。民国时上海江左书林留将该书与《证道秘书》合刊，题名《道书十七种》印行。</p><h4 id="道书十二种"><a href="#道书十二种" class="headerlink" title="道书十二种"></a>道书十二种</h4><p>道教炼养丛书。收书12种，共计39卷。清刘一明撰。计有《周易阐真》4卷，《卦图》1卷，《孔易阐真》2卷，《参同契经文直指》2卷，《参同契直指笺注》2卷，《参同契直指三相类》2卷，《悟真直指》4卷，《会心集内集》2卷，《会心集外集》2卷，《指南针》12卷（含《阴符经注》等10种），《象言破疑》2卷，《通关文》2卷，《悟道录》2卷。</p><h4 id="伍柳仙宗"><a href="#伍柳仙宗" class="headerlink" title="伍柳仙宗"></a>伍柳仙宗</h4><p>气功内丹术丛书。收书4种。清邓徽绩编。内收明伍守阳的《天仙正理直论》、《仙佛合宗语录》和清柳华阳的《慧命经》、《金仙证论》。该书汇集了伍柳派气功内丹术的精华，刊行之后风行遐迩，影响甚大，甚至远及日本与东南亚。</p><h4 id="女丹合编"><a href="#女丹合编" class="headerlink" title="女丹合编"></a>女丹合编</h4><p>气功内丹术女功丛书。收书17种，共计19卷。清贺龙骧编，计有孙不二撰《坤元经》1卷，《坤诀》1卷，《女修程途》1卷（即《不二元君法语》），清烈古佛撰《女丹十则》1卷，周中贞撰《女金丹》2卷，傅金铨述《樵阳经女工修炼》1卷，不著撰人《坤宁经》1卷，二蛾山人述《女工炼已还丹田说》1卷等。</p><h4 id="颐身集"><a href="#颐身集" class="headerlink" title="颐身集"></a>颐身集</h4><p>气功养生丛书。收书5种，共计5卷。清叶志铣编。计收邱处机撰《摄生消息论》1卷，冷谦撰《修龄要旨》1卷，汪昂撰《勿药元论》1卷，汪政撰《寿人经》1卷，方开撰《延年九转法》1卷，均为气功养生名著。</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 文献资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10商业版和消费者版的区别</title>
      <link href="/2022/winows10-diffrent/index/"/>
      <url>/2022/winows10-diffrent/index/</url>
      
        <content type="html"><![CDATA[<hr><p>很多朋友发现，在去下载Win10系统ISO镜像的时候发现会标注商业版Business和消费版Consumer，那么Windows10商业版和消费者版有什么区别，我们要下载哪个版本使用呢？</p><h3 id="用户群体的区别"><a href="#用户群体的区别" class="headerlink" title="用户群体的区别"></a>用户群体的区别</h3><ul><li><p>消费者版：通俗来说就是零售版，是一个非常适合个人用户和家庭用户购买的版本。</p></li><li><p>商业版：适合大客户使用的版本，而且还比较适合企业用户使用以及进行批量部署。</p></li></ul><h3 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h3><ul><li><p>消费者版Consumer editions包括：<br>  家庭版、家庭单语言版、教育版、专业版、专业教育版、专业工作站版（相当于之前的零售版）</p></li><li><p>商业版Business editions包括：<br>  企业版、教育版、专业版（相当于之前的VL版）</p></li></ul><h3 id="基础功能区别"><a href="#基础功能区别" class="headerlink" title="基础功能区别"></a>基础功能区别</h3><ul><li><p>消费版：<br>  自定义开始菜单，Windows Defender 与Windows防火墙，节电模式，Windows更新。</p></li><li><p>商业版：<br>  设备加密，Bitlocker加密，企业模式IE浏览器，远程桌面，Direct Access（直接访问），Windows To Go创建工具，Applocker（应用程序锁定），BranchCache（分支缓存）。</p></li></ul><h3 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h3><h4 id="消费版："><a href="#消费版：" class="headerlink" title="消费版："></a>消费版：</h4><p>以家庭版为基础，增添了管理设备和应用，保护敏感的企业数据，支持远程和移动办公，使用云计算技术。另外，它还带有Windows Update for Business，微软承诺该功能可以降低管理成本、控制更新部署，让用户更快地获得安全补丁软件。</p><h4 id="商业版："><a href="#商业版：" class="headerlink" title="商业版："></a>商业版：</h4><p>以专业版为基础，增添了大中型企业用来防范针对设备、身份、应用和敏感企业信息的现代安全威胁的先进功能，供微软的批量许可（Volume Licensing）客户使用，用户能选择部署新技术的节奏，其中包括使用Windows Update for Business的选项。作为部署选项，Windows 10企业版将提供长期服务分支（Long Term Servicing Branch）。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>消费版和商业版在同版本的情况下，如同是专业版，那么功能上是没有任何区别的。但是微软授权方式不同，激活方式也不同，零售版单一授权，商业版批量授权。</p><p>所有普通用户下载Win10消费版就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【速存】长期更新，2022公务员国考省考笔试课程合辑</title>
      <link href="/2022/2022-gongwuyuan/2022ziliao/"/>
      <url>/2022/2022-gongwuyuan/2022ziliao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>欢迎留言补充、指正！</p></blockquote><hr><p>多要求自己，你会更加独立，少要求别人，你会减少失望。宁愿花时间去修炼不完美的自己，也不要浪费时间去期待完美的别人。</p><hr><h4 id="2022-x2F-03更新"><a href="#2022-x2F-03更新" class="headerlink" title="2022&#x2F;03更新"></a><center>2022&#x2F;03更新</center></h4><h5 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a>资源目录</h5><blockquote><p>【公考面试】公务员事业编面试-结构化面试通用(有字幕)<br>【公务员面试】面试热点合集(持续更新)全国通用上岸村适用：2022国考，2022省考，2022公安联考，2022事业单位<br>2022年最新版国考国家公务员考试笔试课程 【高端精品系统班】（完整版含讲义）<br>2022国考笔试考试课程公务员-行测申论<br>2022国家公务员考试课程</p></blockquote><p>资源地址：<a href="https://www.aliyundrive.com/s/YeKPfCRwSoz">https://www.aliyundrive.com/s/YeKPfCRwSoz</a></p><h4 id="国考-持续更新-："><a href="#国考-持续更新-：" class="headerlink" title="国考(持续更新)："></a><center>国考(持续更新)：</center></h4><table><thead><tr><th>平台</th><th>链接</th><th>提取码</th></tr></thead><tbody><tr><td>中g</td><td><a href="https://pan.baidu.com/share/init?surl=ChrOGMcyhcZCRNugVhjz1A">https://pan.baidu.com/share/init?surl=ChrOGMcyhcZCRNugVhjz1A</a></td><td>8527</td></tr><tr><td>zhan长</td><td><a href="https://pan.baidu.com/share/init?surl=TnnYdFbZ-vKS7E_7bW1gtQ">https://pan.baidu.com/share/init?surl=TnnYdFbZ-vKS7E_7bW1gtQ</a></td><td>8527</td></tr><tr><td>某粉</td><td><a href="https://pan.baidu.com/share/init?surl=xfsnJBDaD6k70m60el4XjA">https://pan.baidu.com/share/init?surl=xfsnJBDaD6k70m60el4XjA</a></td><td>8527</td></tr><tr><td>某粉</td><td><a href="https://pan.baidu.com/share/init?surl=OxmvWAMjbUFECglYhX2fcg">https://pan.baidu.com/share/init?surl=OxmvWAMjbUFECglYhX2fcg</a></td><td>93yk</td></tr></tbody></table><hr><h4 id="公考-持续更新-："><a href="#公考-持续更新-：" class="headerlink" title="公考(持续更新)："></a><center>公考(持续更新)：</center></h4><table><thead><tr><th>平台</th><th>链接</th><th>提取码</th></tr></thead><tbody><tr><td>g不了沉</td><td><a href="https://pan.baidu.com/share/init?surl=5KtTlr_PdtPn6K4a8Y8KqA">https://pan.baidu.com/share/init?surl=5KtTlr_PdtPn6K4a8Y8KqA</a></td><td>8527</td></tr><tr><td>xiao宝</td><td><a href="https://pan.baidu.com/s/15Yg7CwZ_lOWBgivqu5XJNw#list/path=%2F">https://pan.baidu.com/s/15Yg7CwZ_lOWBgivqu5XJNw#list/path=%2F</a></td><td>8527</td></tr><tr><td>刘w超</td><td><a href="https://pan.baidu.com/share/init?surl=6Wne4UYCKF5Jq0GxbzFO7Q">https://pan.baidu.com/share/init?surl=6Wne4UYCKF5Jq0GxbzFO7Q</a></td><td>8527</td></tr><tr><td>中g</td><td><a href="https://pan.baidu.com/share/init?surl=ChrOGMcyhcZCRNugVhjz1A">https://pan.baidu.com/share/init?surl=ChrOGMcyhcZCRNugVhjz1A</a></td><td>8527</td></tr><tr><td>qi麟</td><td><a href="https://pan.baidu.com/share/init?surl=Gy3zX5gITJWFfyxH8-7kDQ">https://pan.baidu.com/share/init?surl=Gy3zX5gITJWFfyxH8-7kDQ</a></td><td>8527</td></tr><tr><td>华t</td><td><a href="https://pan.baidu.com/share/init?surl=j9Q8wCwhEb8i-jIsvl9-Rg">https://pan.baidu.com/share/init?surl=j9Q8wCwhEb8i-jIsvl9-Rg</a></td><td>8527</td></tr><tr><td>上an村</td><td><a href="https://pan.baidu.com/share/init?surl=-lwhC-oBVbB4p9PANp3QbA">https://pan.baidu.com/share/init?surl=-lwhC-oBVbB4p9PANp3QbA</a></td><td>8527</td></tr><tr><td>ha生</td><td><a href="https://pan.baidu.com/share/init?surl=N2g2ADqvigItgRf4lKujig">https://pan.baidu.com/share/init?surl=N2g2ADqvigItgRf4lKujig</a></td><td>8527</td></tr><tr><td>zhan长</td><td><a href="https://pan.baidu.com/share/init?surl=TnnYdFbZ-vKS7E_7bW1gtQ">https://pan.baidu.com/share/init?surl=TnnYdFbZ-vKS7E_7bW1gtQ</a></td><td>8527</td></tr></tbody></table><hr><h4 id="省考-持续更新-："><a href="#省考-持续更新-：" class="headerlink" title="省考(持续更新)："></a><center>省考(持续更新)：</center></h4><table><thead><tr><th>地区</th><th>链接</th><th>提取码</th></tr></thead><tbody><tr><td>浙江</td><td><a href="https://pan.baidu.com/share/init?surl=6U4bCmcL8ziwHEy1OWLQdQ">https://pan.baidu.com/share/init?surl=6U4bCmcL8ziwHEy1OWLQdQ</a></td><td>8527</td></tr><tr><td>广东</td><td><a href="https://pan.baidu.com/share/init?surl=g5dZmnFjLSf_iitXu-ZiQQ">https://pan.baidu.com/share/init?surl=g5dZmnFjLSf_iitXu-ZiQQ</a></td><td>8527</td></tr><tr><td>江苏</td><td><a href="https://pan.baidu.com/share/init?surl=op4roMSGJRq0aAWBt8K30Q">https://pan.baidu.com/share/init?surl=op4roMSGJRq0aAWBt8K30Q</a></td><td>8527</td></tr><tr><td>山东</td><td><a href="https://pan.baidu.com/share/init?surl=X6tkHTjuNXJ4_SqMm52p5A">https://pan.baidu.com/share/init?surl=X6tkHTjuNXJ4_SqMm52p5A</a></td><td>: 8527</td></tr><tr><td>联考</td><td><a href="https://pan.baidu.com/share/init?surl=p2sZWC0-daxo-cg7w6cMmA">https://pan.baidu.com/share/init?surl=p2sZWC0-daxo-cg7w6cMmA</a></td><td>8527</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 文献资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么创建一个良好的Git提交信息</title>
      <link href="/2021/git-commit-message/index/"/>
      <url>/2021/git-commit-message/index/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 原文：<a href="https://dev.to/chrissiemhrk/git-commit-message-5e21">https://dev.to/chrissiemhrk/git-commit-message-5e21</a></p></blockquote><p>提交信息是对提交之前添加和更改的文件所做的更改的简短描述。</p><p>良好的提交信息不仅对你所参与的项目上其它的团队成员很重要，对你自己而言也很重要，你需要跟踪所有提交，并确切知道在提交期间发生的变动。</p><p>即使你开发的是个人项目，我也建议你开始养成编写良好的提交信息的习惯。</p><p>可以随着你的个人习惯和公司来改变</p><h2 id="文字规范"><a href="#文字规范" class="headerlink" title="文字规范"></a>文字规范</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: subject</span><br><span class="line"></span><br><span class="line">body (可选)</span><br><span class="line"></span><br><span class="line">footer (可选)</span><br></pre></td></tr></table></figure><p>不过也有人说commit一共应该由5个部分组成，具体内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type: subject</span><br><span class="line"></span><br><span class="line">scope: doc, middleware, core, config, plugin</span><br><span class="line"></span><br><span class="line">subject:</span><br><span class="line"></span><br><span class="line">body (可选)</span><br><span class="line"></span><br><span class="line">footer (可选)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、-type"><a href="#1、-type" class="headerlink" title="1、 type"></a>1、 type</h3><p>提交 commit 的类型，包括以下几种</p><ul><li>feat: 新功能</li><li>fix: 修复问题</li><li>docs: 修改文档</li><li>style: 修改代码格式，不影响代码逻辑</li><li>refactor: 重构代码，理论上不影响现有功能</li><li>perf: 提升性能</li><li>test: 增加修改测试用例</li><li>chore: 修改工具相关（包括但不限于文档、代码生成等）</li><li>deps: 升级依赖</li></ul><h3 id="2、scope"><a href="#2、scope" class="headerlink" title="2、scope"></a>2、scope</h3><p>修改文件的范围（包括但不限于 doc, middleware, core, config, plugin）</p><h3 id="3、subject"><a href="#3、subject" class="headerlink" title="3、subject"></a>3、subject</h3><p>用一句话清楚的描述这次提交做了什么，它应该包含对所做更改的简短描述。长度不能超过50个字符，应以大写字母开头，命令式的语法。“Add”，而不是 “Added” 或 “Adds”。</p><h3 id="4、body"><a href="#4、body" class="headerlink" title="4、body"></a>4、body</h3><p>正文用于说明你进行了哪些更改以及进行更改的原因。补充 subject，适当增加原因、目的等相关因素，也可不写。并非所有提交都很复杂，需要一个正文，尤其是如果你仅是开发一个个人的项目，因此正文是可选的。</p><h3 id="5、footer"><a href="#5、footer" class="headerlink" title="5、footer"></a>5、footer</h3><p>页脚也是可选的，主要在你使用issue追踪引用issue ID时使用。</p><ul><li>当有非兼容修改(Breaking Change)时必须在这里描述清楚</li><li>关联相关 issue，如 <code>Closes #1</code>, <code>Closes #2, #3</code></li><li>如果功能点有新增或修改的，还需要关联文档<code>doc</code></li></ul><h2 id="emoji规范"><a href="#emoji规范" class="headerlink" title="emoji规范"></a>emoji规范</h2><blockquote><p>注：以下emoji表情在git提交时已经完全支持，哪怕下面的表情显示不完整也不用慌，可以直接在git-submit里使用。</p></blockquote><table><thead><tr><th>emoji</th><th>emoji代码</th><th>commit说明</th></tr></thead><tbody><tr><td>🎨 (调色板)</td><td>:art:</td><td>改进代码结构&#x2F;代码格式</td></tr><tr><td>⚡️ (闪电)</td><td>:zap:</td><td>提升性能</td></tr><tr><td>🐎 (赛马)</td><td>:racehorse:</td><td>提升性能</td></tr><tr><td>🔥 (火焰)</td><td>:fire:</td><td>移除代码或文件</td></tr><tr><td>🐛 (bug)</td><td>:bug:</td><td>修复 bug</td></tr><tr><td>🚑 (急救车)</td><td>:ambulance:</td><td>重要补丁</td></tr><tr><td>✨ (火花)</td><td>:sparkles:</td><td>引入新功能</td></tr><tr><td>📝 (铅笔)</td><td>:pencil:</td><td>撰写文档</td></tr><tr><td>🚀 (火箭)</td><td>:rocket:</td><td>部署功能</td></tr><tr><td>🎉 (庆祝)</td><td>:tada:</td><td>初次提交</td></tr><tr><td>✅ (白色复选框)</td><td>:white_check_mark:</td><td>增加测试</td></tr><tr><td>🔒 (锁)</td><td>:lock:</td><td>修复安全问题</td></tr><tr><td>🍎 (苹果)</td><td>:apple:</td><td>修复 macOS 下的问题</td></tr><tr><td>🐧 (企鹅)</td><td>:penguin:</td><td>修复 Linux 下的问题</td></tr><tr><td>🏁 (旗帜)</td><td>:checked_flag:</td><td>修复 Windows 下的问题</td></tr><tr><td>🔖 (书签)</td><td>:bookmark:</td><td>发行&#x2F;版本标签</td></tr><tr><td>🚨 (警车灯)</td><td>:rotating_light:</td><td>移除 linter 警告</td></tr><tr><td>🚧 (施工)</td><td>:construction:</td><td>工作进行中</td></tr><tr><td>💚 (绿心)</td><td>:green_heart:</td><td>修复 CI 构建问题</td></tr><tr><td>⬇️ (下降箭头)</td><td>:arrow_down:</td><td>降级依赖</td></tr><tr><td>(上升箭头)</td><td>:arrow_up:</td><td>升级依赖</td></tr><tr><td>👷 (工人)</td><td>:construction_worker:</td><td>添加 CI 构建系统</td></tr><tr><td>📈 (上升趋势图)</td><td>:chart_with_upwards_trend:</td><td>添加分析或跟踪代码</td></tr><tr><td>🔨 (锤子)</td><td>:hammer:</td><td>重大重构</td></tr><tr><td>➖ (减号)</td><td>:heavy_minus_sign:</td><td>减少一个依赖</td></tr><tr><td>🐳 (鲸鱼)</td><td>:whale:</td><td>相关工作</td></tr><tr><td>➕ (加号)</td><td>:heavy_plus_sign:</td><td>增加一个依赖</td></tr><tr><td>🔧 (扳手)</td><td>:wrench:</td><td>修改配置文件</td></tr><tr><td>🌐 (地球)</td><td>:globe_with_meridians:</td><td>国际化与本地化</td></tr><tr><td>✏️ (铅笔)</td><td>:pencil2:</td><td>修复 typo</td></tr></tbody></table><hr><p>这是Udacity学生git提交信息的例子<a href="https://udacity.github.io/git-styleguide/">Udacity Git Commit Message Style Guide</a></p><blockquote><p>feat: 少于50个字符的更改概括。</p><p>如有必要，提供更详细的说明文字，约72字符左右。在某些情况下，第一行被视为提交的主题，其余文本作为正文。 将摘要与正文分开的空行至关重要（除非没有正文）；各种工具，例如 log，shortlog和rebase，如果同时运行两者，可能会造成混乱。</p><p>解释该提交解决的问题。注意说明为什么做这个更改（代码作了注释）。另一方面，是否会导致负面的作用或其他不直观的后果？这也是需要说明的地方。</p><p>空白行之后是其它段落。</p><ul><li>项目要点也可以加进来</li><li>通常在项目符号前使用连字符或星号，用一个空格隔开，中间有空白行，但是约定在这里变化</li></ul><p>如果你使用issue追踪，可以在footer中写上对issue的关联，就像这样：</p><p>Resolves: #123See<br>also: #456, #789</p></blockquote><p>这是一个实际的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs: Fix typo in README.md</span><br></pre></td></tr></table></figure><hr><h2 id="正文之外同样有一些有意思的评论："><a href="#正文之外同样有一些有意思的评论：" class="headerlink" title="正文之外同样有一些有意思的评论："></a>正文之外同样有一些有意思的评论：</h2><hr><p>简短明了，感谢你的这篇文章！<br>我倾向于使用表情符号作为类型——一看就显示了提交的类型，例如：</p><p>➕ :heavy_plus_sign: 添加文件或实现功能时<br>🔨 :hammer: 修复bug或处理issue时<br>💚 :green_heart: 在改进代码或注释时<br>⚡ :zap: 在提高性能时<br>📜 :scroll: 更新文档或readme时<br>🔑 :key: 在处理安全相关时<br>🔁 :repeat: 更新依赖或数据时<br>✅ :white_check_mark: 建立一个新的release时<br>👕 :shirt: 重构或删除linter警告时<br>❌ :x: 删除代码或文件时</p><p>…提交历史看起来很棒：</p><p><img src="/img/2021082220342679.png"></p><hr><p>我讨厌别人这么做。它在git日志中看起来令人困惑。只需使用unicode表情符号，它们就可以在任何地方使用。</p><p>顺便说一下，我最喜欢的表情符号用于提交信息：🎆🎊🎉😖💢😅 （我通常将它们放在提交信息的末尾）</p><hr><p>我目前使用git alias创建带有表情符号的漂亮提交消息，我的提交信息结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[emoji] &lt;type&gt;(scope): &lt;message&gt;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">🐞 FIX(pages): security issue fix on pages table</span><br></pre></td></tr></table></figure><p>这是我的.gitconfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Git Commit, Add all and Push — in one step.</span><br><span class="line">cap = &quot;!f() &#123; git commit -m \&quot;$@\&quot;; &#125;; f&quot;</span><br><span class="line"># NEW.</span><br><span class="line">new = &quot;!f() &#123; git cap \&quot;📦 NEW($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># IMPROVE.</span><br><span class="line">imp = &quot;!f() &#123; git cap \&quot;👌 IMPROVE($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># UPDATE.</span><br><span class="line">up = &quot;!f() &#123; git cap \&quot;✍🏻 UPDATE($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># FIX.</span><br><span class="line">fix = &quot;!f() &#123; git cap \&quot;🐞 FIX($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># RELEASE.</span><br><span class="line">rlz = &quot;!f() &#123; git cap \&quot;🚀 RELEASE($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># DOC.</span><br><span class="line">doc = &quot;!f() &#123; git cap \&quot;📖 DOC($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># TEST.</span><br><span class="line">tst = &quot;!f() &#123; git cap \&quot;🤖 TEST($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># BREAKING CHANGE.</span><br><span class="line">brk = &quot;!f() &#123; git cap \&quot;‼️ BREAKING CHANGES($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># REMOVE</span><br><span class="line">remove = &quot;!f() &#123; git cap \&quot;🗑 REMOVE($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># REFACTOR</span><br><span class="line">ref = &quot;!f() &#123; git cap \&quot;♻️ REFACTOR($1): $2\&quot;; &#125;; f&quot;</span><br><span class="line"># INITIAL COMMIT</span><br><span class="line">int = &quot;!f() &#123; git cap \&quot;🎉 INITIAL COMMIT($1): $2\&quot;; &#125;; f&quot;</span><br></pre></td></tr></table></figure><hr><p>感谢你的提议！</p><p>这是Git表情符号的一个网站：<a href="https://gitmoji.carloscuesta.me/">https://gitmoji.carloscuesta.me/</a></p><p><img src="/img/20210822204707398.png"></p><p>🎉 ：tada:初次提交<br>🚀 ：rocket:[Add] 实现新功能时<br>🔨 ：hammer:[Fix]修复bug或处理issue时<br>🎨 ：art:[Refactor] 当重构&#x2F;改善代码时<br>🚧 ：construction: [WIP]<br>📝 ：pencil: [Minor] 一些小更新</p><hr><p>大家可以使用随机提交信息生成网站。享受它吧！</p><p><a href="https://paulospx.github.io/some_if_statements/commits.html">https://paulospx.github.io/some_if_statements&#x2F;commits.html</a></p><p><img src="/img/2021082221021797.png"></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【曝光】火币HT和币安“搬砖套利”骗局重现，韭菜要避免被骗</title>
      <link href="/2020/2020-baoguang1/index/"/>
      <url>/2020/2020-baoguang1/index/</url>
      
        <content type="html"><![CDATA[<p><strong>如果你看不懂我的文章，我根本没有时间搭理你，我也不会和你有过多的交谈，文章的币圈经验都是所长多年血亏的历练，请尊重原创，尊重你自己，认真看文。</strong></p><p>在币圈大多都知道“搬砖套利”，利用不同的交易所之间的差价来实现盈利，如今一些智能机器人也可以实现不同交易对的套利，可以说搬砖套利是真实存在的，风险较低，其实这个也叫什么？叫量化，这玩意是从外汇那里引进币圈的。</p><p>近期发现有非法分子以火币的名义进行诈骗，受害者也是越来越多，前前后后共受骗了200W个ETH，诱导用户将个人ETH转入某钱包中，组建名为“火币Global官方搬砖套利中文群”的Telegram群进行诈骗，分散差异钱包，无非都是以当下最火爆的资金盘模式或者币的搬砖模式进行诈骗。</p><p>一个以太坊就会赚到接近600元的套利息， Huobi官方套利群按照套利群的以太坊地址查询，1ETH&#x3D;2740价值的HT，诈骗金额累计已超200万个ETH，而且已经获得警方的受案回执。<br><img src="/img/2020/02/bitebi/frc-cee490fbf0dfe58028a5688df53e1e3c.jpeg"></p><p>在“搬砖套利”骗局中，诈骗者先建立伪造的官方Telegram群，并拉进大量机器人，这些机器人平均一分钟发送一条信息宣称搬砖套利的各种好处，从而迷惑韭菜的贪婪之心。</p><p>群管理员首先会发布群公告教用户如何搬砖，然后引导用户下载imToken钱包并购买ETH，并引导用户将ETH打到公告中提及的ETH地址，最后诈骗者通过合约地址，返还给用户一定数量的虚假HT。</p><p><img src="/img/2020/02/bitebi/frc-f642ad7b76e98ea546b0926e0b1ec6b2.jpeg"></p><p>早在2018年11月，就出现过假借币安名义的搬砖套利骗局。诈骗者在Telegram群中，诱导用户将以太坊打入某个智能合约地址，就可以获取相应的PAX（与美元挂钩的稳定币），兑换比例是1∶200。将PAX充入币安交易所再买回以太坊，即可获得中间利润。</p><p>实际上诈骗者利用以太坊的智能合约功能，开发了一个高仿的假PAX，因此受害用户的钱包收到是假的PAX，即空气币。由于空气币无法转入币安交易所进行交易，诈骗者就会编造谎言，最后把受害用户踢出Telegram群。</p><p><img src="/img/2020/02/bitebi/frc-9ca2a07bdb35f8cde195b323143c60e4.jpeg"></p><p>之前一位朋友无意中加了一个telegram群，群名是币安搬砖套利中文讨论群之类的，群里显示有一万多人，有很多人在聊天，聊得都是搬砖套利，根据他们的聊天内容，貌似很多人都搬砖成功了，于是我这位韭菜朋友也想尝试一下，根据他们公布在群里的教程，所长朋友在im Token钱包里转了ETH币，再把ETH币转到他们提供的合约地址上，他们的合约地址是：0xf4d39c011799389c27bd10f5e70b85700951fc21</p><p><img src="/img/2020/02/bitebi/frc-f2cae9195bcf416b9361ed4b029df512.jpeg"></p><p>第一次我朋友转了9.141个ETH，过了半个小时不到，返回了411.23个USDC，根据他们的教程，我朋友就把这411.23个USDC充值到我的币安交易所上，但是过了很久也没到账，这个时候，群管理主动找我聊天了，我问他为什么交易所没到账，他说最少要充值1100个USDC，其中100个USDC是作为手续费，不管充多少手续费100个USDC是固定的，为了挽回前面充的那2419个ETH，于是第二次又向他们的合约地址：0xf4d39c011799389c27bd10f5e70b85700951fc21</p><p><img src="/img/2020/02/bitebi/frc-2b97f73fcf76a30658235478eca12105.jpeg"></p><p>转了3.2663个ETH，这次返回了555个USDC，问群管理，是不是这次转555USDC到交易所上，是不是能到账，群管理说可以到账。</p><p>群主又跟我朋友说，说我向合约地址转账的时候，没有备注USDC，交易所是没法到账的，为了补救，只能再次向合约地址发送相同数目的ETH数量，再加备注，才能成功，于是我朋友第四次向他们又打了13个ETH。</p><p>到最后还是交易所没有到账，这时群组里有一个人私信我朋友，告诉被骗了，为了弥补损失需要向钱包里充值两倍数量的ETH进行虚拟碰撞，回滚交易，这时我朋友意识到自己被骗了，也意识到他们是同伙，于是没再操作了。</p><p>以上曝光信息是由社区韭菜提供，并非本人亲自调查。今天社群讨论这个问题太多了，所以不更文，顺应大家意思发一下火币的这个曝光。</p><p>大家要知道的是：</p><blockquote><p>炒币者的格局只有一句：<br>分批建仓，不杀跌、不追涨。<br>我们总不能：<br>它涨啦！我要追上去…<br>它涨啦！不上车没有机会….<br>它涨啦！我不买它就会错过机会….<br>我们更不能：<br>它跌啦！我要杀进去…<br>它跌啦！我不止损会亏更多…<br>它跌啦！我卖它，到时候再接回来…</p></blockquote><p><img src="/img/2020/02/bitebi/frc-ee63901ae6ba5a8ae9be6373207d7323.jpeg"></p><p><strong>风险提示：本文如有出现币种现货合约等投资建议或者是项目、币种、交易所、币圈名人等分析揭秘仅代表所长个人观点，数字货币是一种高风险的投资方式，请投资者谨慎参与，在决定买卖之前慎重考虑本人能够承受风险的程度，阅读文章时要三思文章揭秘内容是否属实，自己理性判断所长的文章内容，注意投资风险。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
          <category> 曝光 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曝光 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【vue】3.0 keep-alive实现动态缓存以及缓存销毁</title>
      <link href="/2020/vue-keep-alive/index/"/>
      <url>/2020/vue-keep-alive/index/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><code>keep-alive</code><ul><li><code>keep-alive</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和<code>transition</code>相似，<code>keep-alive</code>是一个抽象组件：它自身不会渲染一个<code>DOM</code>元素，也不会出现在父组件链中。</li><li><a href="https://cn.vuejs.org/v2/api/#keep-alive">keep-alive: vue文档</a></li></ul></li><li>组件内的守卫-<code>beforeRouteLeave</code><ul><li>导航离开该组件的对应路由时调用</li><li>可以访问组件实例<code>this</code></li><li><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">组件内的守卫:<code>vue-router</code>文档</a></li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>后台管理系统中，左侧为功能菜单栏，点击菜单列表，右侧显示该菜单的功能页面，本来是一个非常简单的后台管理系统布局，现在增加了tabs菜单按钮；<br>点击左侧菜单栏时，右侧页面头部header显示当前的页面标题，形成一个tabs列表，点击可切换页面内容和关闭tab；<br>现在的需求：<br>  打开之后需要保留的页面在tab不关闭的情况下，保留上一次的状态，而在tab关闭之后，则下次打开会重新请求数据，不会保留上次状态。</p><p>  <img src="/img/2020/01/vue/15794851288763.png"></p><h2 id="初步解决"><a href="#初步解决" class="headerlink" title="初步解决"></a>初步解决</h2><p>第一想到的就是利用vue的功能组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>但是这种情况只能实现缓存所有页面，就是不能根据需求实现动态缓存，所有状态都存着呢，愁啊。</p><h2 id="解决方案构想："><a href="#解决方案构想：" class="headerlink" title="解决方案构想："></a>解决方案构想：</h2><blockquote><p>路由元信息内添加特定字段如：<code>keepAlive</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/foo&#x27;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;bar&#x27;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          // a meta field</span><br><span class="line">          meta: &#123;</span><br><span class="line">            keepAlive: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>父组件内根据路由中的<code>keepAlive</code>字段动态使用<code>keep-alive</code>标签</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line"></span><br><span class="line">    get keepAlive () &#123;</span><br><span class="line">      <span class="comment">// 获取当前路由的元信息中的keepAlive字段</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">meta</span>.<span class="property">keepAlive</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private render () &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;</span></span><br><span class="line"><span class="language-xml">            !this.keepAlive &amp;&amp; <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">              this.keepAlive &amp;&amp; <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Home</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于现在组件的<code>keep-alive</code>是动态根据路由元信息中的<code>keepAlive</code>字段进行动态使用的，所以只要动态改变对应路由元信息的<code>keepAlive</code>字段就可以实现动态缓存。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>利用<code>beforeRouteLeave</code>改变<code>from</code>的<code>keepAlive</code>实现（原思路，网络解决方案之一，有bug）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to: any, from: any, next: any) &#123;</span><br><span class="line">  // 导航离开该组件的对应路由时调用</span><br><span class="line">  // 判断是否是去往页面 C</span><br><span class="line">  if (to.name !== &#x27;C&#x27;) &#123;</span><br><span class="line">    // 不是去 C 页面，不缓存</span><br><span class="line">    from.meta.keepAlive = false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 是去 C 页面，缓存</span><br><span class="line">    from.meta.keepAlive = true</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>bug：首次去C页面，再返回B页面，B并没有缓存，第二次再进入C页面，B页面缓存，且进A页面并不能清除B页面的缓存</p></blockquote><h3 id="方案二（网络方案）"><a href="#方案二（网络方案）" class="headerlink" title="方案二（网络方案）"></a>方案二（网络方案）</h3><p><code>$destroy()</code>销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to: any, from: any, next: any) &#123;</span><br><span class="line">  // 导航离开该组件的对应路由时调用</span><br><span class="line">  // 判断是否是去往页面 C</span><br><span class="line">  if (to.name !== &#x27;C&#x27;) &#123;</span><br><span class="line">    // 不是去 C 页面，不缓存</span><br><span class="line">    this.$destroy()</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>bug：销毁之后永远不会被缓存</p></blockquote><h3 id="方案三（网络方案）"><a href="#方案三（网络方案）" class="headerlink" title="方案三（网络方案）"></a>方案三（网络方案）</h3><ul><li>根据源码看来缓存的组件都会设置一个cache属性，可以通过代码强行移除掉。缺点就是没有彻底销毁依旧占内存</li><li><a href="https://segmentfault.com/a/1190000015845117">具体实现参考</a></li></ul><h3 id="方案四（最优解）"><a href="#方案四（最优解）" class="headerlink" title="方案四（最优解）"></a>方案四（最优解）</h3><p>利用<code>keep-alive</code>的<code>include</code>属性，利用<code>vuex</code>动态控制<code>include</code>达到动态管理缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=&quot;keepAliveList&quot;&gt;</span><br><span class="line">    &lt;router-view :key=&quot;$route.fullPath&quot;/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>利用计算属性和vuex获取缓存列表</p><blockquote><p>这里可以使用你自己的规则，原因请继续往下看</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--vuex--&gt;</span><br><span class="line">state: &#123;</span><br><span class="line">    keepAliveList:&#x27;&#x27;,//保存缓存的列表</span><br><span class="line">&#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">    setKeepAliveLists(state,arrListString)&#123;</span><br><span class="line">        state.keepAliveList = arrListString;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--视图组件中--&gt;</span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">    keepAliveList()&#123;</span><br><span class="line">        // 获取缓存的路由列表</span><br><span class="line">        return this.$store.state.keepAliveList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成缓存列表，列表的值为各组件中name的值集合拼接的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#x27;setKeepAliveLists&#x27;,routerComponentNameList.join())</span><br></pre></td></tr></table></figure><p>点击左侧菜单栏时，更新缓存列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 点击左侧菜单的事件函数 --&gt;</span><br><span class="line">handleSelect(name) &#123;</span><br><span class="line">    if(this.routerNameMap.has(name))&#123;//如果当前点击的路由已经在缓存列表中，则先清除缓存列表，再添加；</span><br><span class="line">        this.resetKeepAive(name,this.keepAliveList);//删除缓存路由</span><br><span class="line">        this.tabChangeRoute(name);//切换路由</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.routerNameMap.add(name)</span><br><span class="line">        this.tabChangeRoute(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 更新要缓存的路由列表</span><br><span class="line">resetKeepAive(name,cacheList) &#123;</span><br><span class="line">    const conf = this.keepAliveList;</span><br><span class="line">    let arr = cacheList.split(&#x27;,&#x27;);</span><br><span class="line">    if (name &amp;&amp; typeof name === &#x27;string&#x27;) &#123;</span><br><span class="line">        let i = arr.indexOf(name);</span><br><span class="line">        if (i &gt; -1) &#123;</span><br><span class="line">            arr.splice(i, 1);</span><br><span class="line">            this.$store.commit(&#x27;setKeepAliveLists&#x27;,arr.join());</span><br><span class="line">            this.$nextTick(() =&gt; &#123;//添加缓存路由</span><br><span class="line">                this.$store.commit(&#x27;setKeepAliveLists&#x27;,conf);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击右侧tabs关闭标签删除缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeTab(name)&#123;</span><br><span class="line">    // 点击tab上的关闭按钮，清除当前路由的缓存</span><br><span class="line">    this.routerNameMap.delete(name);</span><br><span class="line">    this.resetKeepAive(name,this.keepAliveList);//删除缓存路由</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面为主要代码，监听当前路由是否被移除缓存，如果移除缓存则需要销毁该组件，否则内容中的缓存组件会越来越来，影响使用性能；<br>创建一个<code>mixin.js</code>文件，然后引入到需要被动态缓存的路由组件中即可；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 路由缓存管理</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        keepAliveConf()&#123;</span><br><span class="line">            return this.$store.state.keepAliveList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line">        keepAliveConf(e)&#123;</span><br><span class="line">            // 监听缓存列表的变化，如果缓存列表中没有当前的路由或组件则在缓存中销毁该实例</span><br><span class="line">            let name = this.$options.name;</span><br><span class="line">            if(!e.split(&#x27;,&#x27;).includes(name)) &#123;</span><br><span class="line">                this.$destroy()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于在<code>$store</code>中保存和删除的过程，各人有各人的方法，我这边只是一种参考，不过多讨论。</p><p>不过关于<code>keep-alive</code>的<code>include</code>原理，这里简单介绍下，官方(截止到2020年1月)给的方案是正则白名单，也就是说在<code>include</code>中包含的字段，只要路由的<code>name</code>满足正则要求，则会缓存，<code>exclude</code>的规则同样满足，所以这就造成匿名路由的童鞋无法使用<code>keep-alive</code>。不过也有解决方案，使用<code>beforeRouteLeave</code>监听，自己做缓存，不过目前我还没试过，后续我试完会新写的。</p><p>以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作具有一定的参考学习价值，如果有疑问大家可以留言交流，谢谢大家对我的支持。😘✔</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试用期工作总结--IOTA</title>
      <link href="/2020/shiyongqizongjie/index/"/>
      <url>/2020/shiyongqizongjie/index/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9490eb8e9cddbb2d996a6cc56157d1f3d706ff9ce72771de471363252abea37f">979a0d46691689000a5f8cc1238865cea4659795f1d47f620e7e75b6b9d915be5a7226a1422cee473c98290aecc66dcba7e76ab7022b86bbf31a6dca0290194a8a8603396b4e8f0a04d748baeaacca4e8cbe0cf04f8f7724bb1eec87984c5f6d0a341929b274c49f27857eea71417bde84088e6d9da6ce960e9897603990e6a8b4a685cda6587a3e91119c9781a79a9951c91da3fb44dfe16672f85ea7301b77d4d833c3b3f7c381f487f3b2a8230328b89fd8728c82e3a2fab87c43965b9fc21546b320ccefb872194c3d259a4e061b810645f32273c8e10b8ed4875f0122876bbc3deabaa4f3fb07d046f0b6fb9cd7124e9ae5b2b761853b5feafded8bbf7353dfb735a52a29e8b6f6321d5be5e6e9871180dde803de2d7acc41dcd15d3e0ff1c377a282661516abc984d65af626d2c034f3271fc5d8ae74d7cae8cfb61ff464eef3c9477107b3dae4a060bba1852bd8496697d5022cd6952b967703132c7b745f5fb3481b768d3709825572cb85ef258958184a5015a56b45d972588dedcc496f51ea14344986a8807b1e1fc9b2a09bfa85a629c5ee79e92d23bd5f455689ec492c48f3f2bb3dda6342b87f6af146d3bc3e45912be7d90f480370505f03d6518a925c94ed9a5e83bf8a2bd9375bb3626c267cfa5f403836d51380a4263034914bf21b76148c077e31d4275bb9abce89e6843db0dd3d6f1ede51d7a90f65158aba15aab80febd1593c2722b12f2cce3a69337c88bce3cdc4bd2d01968151d37959d94406f37cdc3190a756ba944a7eb25a4c417d74f61e2c013adae46a5454a1633dc4fb3d46bffff4643de9c23826e22f5f7d2513bc3106a44013124a300c2cbcd8ae80d93132b9778ffddde5be59a2362d91bf5f91a1ad653aa119960f8376b34d78fb8800cb687253074d78a1c5cc895b448a79cc60cc9b60269b780c70c8129f48baf597274d2e5a756384bdae6d33529f797e637648b032f79dbcb1e6bc8654e21cc94b773992032d022e58f4174a154b83eb365d663d6c2e257f883b3f7354906e6691643d5a5b1d9e79384a8c1903928c1b75183116d1af6d52e2a3825f6be78e53d6e8982818823c91a2742bdadc722e8c21b2988474ad6b99e4101303bac215df1e397a5246c83bb5528038e2fb79aca22970ee8530d71c8488967cf6a09f091b71a928a6c38e25e35a51750be275776e2ffcf73549210f02bca50f38c40a48acd2316f52edb8af286b3046af3458549cb1dc52f67cfd53ff5226da9b5bb7f02ac2c455c1f872cb378c5b1d09c52e23e0186f045dfde0224d4250cfe4637439df5af982f4d1a87b771f769a47233eab493288e8ee046e29aaae8740a25c8390cc080f78c5c7cb36af44b963f691afc81ebe5bb014060605d7642513f6989a64214092e561eb213704c4df87d9c66fee21da5c8802910154f70c272a2ac37aa897ad3ed9710e699a618a8c86d40485e6c7061794503bb03a8a83fd0e1ec195480c1559334a21c949a83c4f32538cc720e8caf031f18d3228fccfa81ed965f2f0ca72d1c79e761e63c65dba970d7b2088f2801ef7d6cc67b23ec3be4343684d2f5362570a650da4259f6f3636956b3358c5596f33b8abcf8d4c1d149a033fce94e51a0223b43738bd674dcb666487fdd86392c5466aeee8aa5abf5a09ab26587c632cf9fae6382fa9ceadf0567e421389289e5a8e3722089d57afcad0c0fc4b6fe21e8e70a1def8aab8eddf3ae306505195b16aa8c5b66536c0c7951f1fc8e4ca8330aee1da0d67b6ad5a23a23fcec14bf27a2e7d956d1f96eaf4263fed0d1029e3897d0c6b3a9597bbd5d9944a41352e53453bde74e526993f66d7505973cd11743c86cf4b17e82345fddb79597bfdcf5db9eb6fefcbcd054f0acb7bb86f5526fe0bb0d8a1a4d9c0362e8817564fe90ef519668d25b46ac6bf4a78f88b0f139add2465edcce08c5a375ceb0e1ba8b0c3170418c3939f779ed8785f52b420541456cb65a98a170520da517d14c8a554b234edc6bb7741949a8bdc5066c1341ed81d0bb18d6d07d23d6e439bbcdee3e739ffbb29f9d45c74bdb8561ddff304edeed4dc1b09759848048f5c4b70464e780c3651ae671955796a5eac4e6fdd61477433401d75630dd301edd7aab9366a900bcaefe4fb345dbf94a0285d7cf4b95902853b3519e2a685c64045bc7fc8c1f2467b69941f443411222308e44da55de8520214ede17b5372151c1c992d03078ecb25f59ca7900149d649108842c56cac1de0d13dc0d22ffd77efe7a7b9b7b008cce463dca4252017fde905cdcab62663c90809954f2627e36071124aefa6308e5bd6ba0ba839aea29e7246509837c76a37134a79646cd34c44fdc479f6ba86a2ce8ce29d048b72c83a39419ad9d6a6b54954bb196781ca03db890132a1a64346f2e557029566db57eb0ad8e77f5baf9e5aef116d238da5fe017b0a16247635dad41e2845191145f320ad4cfd491e05430c70c826d695068e3eafd9ab2349504283b782e44eff12256e3b31bbae71a77e47f48a21f73563cb83975b23968f910b1440aa011638424a947406682c71a34145cccc6f7283243f76f7834e895a4e46198fc5978aa86fd4ad63b18772074eb6c3073ee817b853fda583b4a27eeb91941a1b75efe7b2afa87cd696e9ec792bc8efa18fe7039f606eff56e10737ecacdc9a6d1625f39ca5204470784e10e0aa048cedc19eb162cc79d44c6bd2ececa8bfc3409c78290ad82100da8417d80ccb14dac14edc122e539a64fbfbf2c6f829881c7db41d03f2fa97f2205e88809aef9899d1dbb4c2d19d687f3e38b1e365e6ff5c6e86009b04606334700cc9ed7a3e41316de3345eed8e337f15e7bcbfda045875c1bfb898836f80dfcc459ce3a49c13cd70bb5c4aeb5846f9cc726890a160486d16f1921037469b0379220b1efa729b43211345b90f3abf06b846d75cef13318f19df0ace5aa09445da80950f32c089743af312967bb244e19112dd4df726673455c1d694f5a382800668b5bd44f026a5e2fb4a14101aeda32329ea10500a072bc41eef378c15802ca1db4285d9ee4bb6de3ef12fe039a49baff9c4baf0ba07e9dc33f8e212025de6d88cf29a5dcc061c415e8b9a10fa5dd3fd380ee73dd873b6a57dfda9a2addc07120a721aa981e412f94adcbab54515f525bb8396e9f1a8b1ac15afce3638bf300363f96193d5d486a995243bfa33df7e0fd761d49777ddd2aa3216b294ae7e596bbed2cafd6d7fc6718daac907321777e2cf3df0194538225bdbe77610b2a7a2e16a48ebe1f1264189935af4585af37e4e82801fa035d862cf0577477f05c82476fb1054bebd3eec21b0c310b82c45ae7068596eea8b8423cde2098746af1ad36d7c754095a78ce7355d8fb3ee55e39fe45f5ab1fb3a0e286bf3700309dc03a59cf1ef67000598ea1d27ec3c7d647d884b0380a45cfc29887179d7b06451d9fd1e166f4f47f8ee108591dc49b6e5f1cb5cdfcf4a845f67da55c54d831a145add1746f7508c5217f9deb0741e162b72f147de0127a8fe23a6050246e6f8bf5f0df794dec4f77b4b15b38ee66d19b5549d3ab7853c619abf5f572a8cfd2d2700d7d5f2f54c6ba89ebdb35eb764e3cdd9e48df074f19b7189c3b9c293eacd1a53b41b77c4c1bdb131927fd01839d4607e18afba82b43098d9fb09d47a1aa442b14c5efd8f426063171cde898e121bff9148196e3de77631dbd60081b491f49463b046f2cb195c5e762860947d6d3f982ff62b7260437975d25c71a1512d46cb6044b63431</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
          <category> 工作总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【vue】路由不变的情况下，刷新页面</title>
      <link href="/2020/vue-reload-norefresh/index/"/>
      <url>/2020/vue-reload-norefresh/index/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在vue写的后台管理项目中，经常会有增、删、改、查的操作，这些操作只是跟用接口跟后台交互下，既然用接口交互，那肯定就是<code>axios</code>的异步请求，那么就是说后台数据发生了改变，但是前台的数据并没有实时的更新（每次操作完后台把列表数据重新返给你例外，但是这样的话每次交互的数据量就偏大了），所以就有了<code>动态路由</code>。在使用动态路由配置<code>/detail/:id</code>这样的情况下，由于<code>router-view</code>是复用的，单纯的改变<code>id</code>的值并不会刷新<code>router-view</code>所以就要想一个办法，让后台执行完操作后，给前台返一个操作结果，然后前台手动刷新页面，一开始我想到的是用<code>window.location.reload()</code>或者<code>this.$router.go(0)</code>这两个方法，但是后来发现这两个方法消耗都很大，用户体验并不太好，违背了<code>vueRouter</code>的初衷，所以就放弃了，看了下别人的做法，整理下面两种方法：</p><h3 id="第一种：中转站的方式"><a href="#第一种：中转站的方式" class="headerlink" title="第一种：中转站的方式"></a>第一种：中转站的方式</h3><p>用一个空白组件在每次操作之后进行跳转，相当于<code>Nginx</code>的<code>反向代理</code>一样。意思就是让每次操作完成以后，都让路由跳转到这个中转站页面，然后这个页面获取到进来路由的路径再返回去就可以了。这种方式如果说你的路由是显性的，就是直接显示在浏览器地址栏，你会发现，一直在换，而我目前使用的则是第二种方式。</p><h3 id="第二种：provide-x2F-inject-的方式"><a href="#第二种：provide-x2F-inject-的方式" class="headerlink" title="第二种：provide &#x2F; inject 的方式"></a>第二种：provide &#x2F; inject 的方式</h3><p>这种方式与<code>Spring boot</code>中的切面&#x2F;注解有点类似，就是通过<code>provide</code>让<code>App.vue</code>为所有子组件注入一个<code>reload</code>方法，然后在需要使用的页面，通过<code>inject</code>注入即可、请看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      reload: this.reload</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isRouterAlive: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reload() &#123;</span><br><span class="line">      this.isRouterAlive = false;</span><br><span class="line">      this.$nextTick(function() &#123;</span><br><span class="line">        this.isRouterAlive = true;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在需要调用的子页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;!--你的子页面布局--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    //...</span><br><span class="line">    inject: [&#x27;reload&#x27;],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        delData()&#123;</span><br><span class="line">            //在axios成功的回调里面</span><br><span class="line">            this.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作具有一定的参考学习价值，如果有疑问大家可以留言交流，谢谢大家对我的支持。😘✔</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 乐固加固后手动签名</title>
      <link href="/2020/legu-jiagu/index/"/>
      <url>/2020/legu-jiagu/index/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在刚做完一个教育类的项目，然后要上架到应用宝，不过要加固。但是最近的某度搜索引擎的确是不好用，找了半天才找到教程。为了以后不麻烦搜索引擎，特此记录。</p><h2 id="第一步，写代码"><a href="#第一步，写代码" class="headerlink" title="第一步，写代码"></a>第一步，写代码</h2><p>当然是写好你自己的代码辣，还有喔，要保护好自己的发际线。</p><h2 id="第二步，打包"><a href="#第二步，打包" class="headerlink" title="第二步，打包"></a>第二步，打包</h2><h3 id="首先，生成密钥"><a href="#首先，生成密钥" class="headerlink" title="首先，生成密钥"></a>首先，生成密钥</h3><p>都0202年了，还不用<code>Android studio</code>的同事们，你们真的老辣，嘿嘿。<br>Android应用打包，各位都会吧。不会的话我简单唠两句。</p><ol><li>首先当然是生成密钥啦。可以直接用Android studio自带的工具生成，不过要填的东西可不少：</li></ol><p>点击最上方的导航栏<code>Build</code>，然后点击<code>Generate SignedBundle / APK ...</code>；<br>接下来使用默认选中的<code>APK</code>，点击<code>Next</code>；<br>会有一个选项 <code>Key store path</code>, 如果你有生成过打包密钥，可以直接选择<code>Choose existing</code>就行，没有的话点击<code>Create new ...</code>，内容的话，如果是工作室或者公司还是正经点填吧，不是的话，你开心就好。</p><table><thead><tr><th>填空的名称</th><th>对应的意思</th><th>是否必填</th></tr></thead><tbody><tr><td>key Store path</td><td>密钥库位置(要保存在哪里)</td><td>是</td></tr><tr><td>Password</td><td>密钥库的密码</td><td>是</td></tr><tr><td>Confirm</td><td>重复上面的密码</td><td>是</td></tr><tr><td>Alias</td><td>密钥别名(一个密钥可以有多个别名)</td><td>是</td></tr><tr><td>Password</td><td>密钥密码</td><td>是</td></tr><tr><td>Validity(years)</td><td>密钥有效期(默认25年)</td><td>-</td></tr><tr><td>First and LastName</td><td>你的名称(英文)</td><td>是</td></tr><tr><td>Organizational Unit</td><td>机构代码</td><td>是</td></tr><tr><td>Organization</td><td>组织机构(英文&#x2F;拼音)</td><td>是</td></tr><tr><td>City or Locality</td><td>城市拼音</td><td>是</td></tr><tr><td>State or Province</td><td>地区</td><td>是</td></tr><tr><td>Country Code (xx)</td><td>国家编号，国内一般填86</td><td>是</td></tr></tbody></table><p>填完就直接下一步。<br>为了安全起见还是<code>v1</code>、<code>v2</code>都勾上，打包也是4k对齐的，而且也缓解一下我作为处女座的强迫症。然后选择<code>Finish</code>，就开始打包了。打包生成的APK文件会在选择<code>v1</code>、<code>v2</code>的上面，有个<code>APK Destination Folder</code>，这个路径里面。</p><p>当然，也有早就创建好签名的，或者想要自动打包的，直接在<code>app</code>目录下的<code>build.gradle</code>中修改</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias <span class="string">&#x27;&#x27;</span>           <span class="comment">//别名</span></span><br><span class="line">            keyPassword <span class="string">&#x27;&#x27;</span>        <span class="comment">//别名密码</span></span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">&#x27;&#x27;</span>)    <span class="comment">//.jks/密钥库 的路径</span></span><br><span class="line">            storePassword <span class="string">&#x27;&#x27;</span>      <span class="comment">//密钥库的密码</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            keyAlias <span class="string">&#x27;&#x27;</span>           <span class="comment">//别名</span></span><br><span class="line">            keyPassword <span class="string">&#x27;&#x27;</span>        <span class="comment">//别名密码</span></span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">&#x27;&#x27;</span>)    <span class="comment">//.jks/密钥库 的路径</span></span><br><span class="line">            storePassword <span class="string">&#x27;&#x27;</span>      <span class="comment">//密钥库的密码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样填完就可以直接用<code>gradle</code>的<code>assembleRelease</code>直接打包了。</p><ol start="2"><li>第二种方式就比较牛批了，直接手撸的。</li></ol><p>首先，你要知道<code>Android</code>中APK签名工具<code>jarsigner</code>和<code>apksigner</code>。</p><ul><li>工具介绍</li></ul><p>  <code>jarsigner</code>是JDK提供的针对jar包签名的通用工具,位于JDK&#x2F;bin&#x2F;jarsigner.exe</p><p>  <code>apksigner</code>是Google官方提供的针对Android APK签名及验证的专用工具,位于Android SDK&#x2F;build-tools&#x2F;SDK版本&#x2F;apksigner.bat</p><p>  不管是apk包,还是jar包,本质都是zip格式的压缩包,所以它们的签名过程都差不多(仅限V1签名),以上两个工具都可以对Android APK包进行签名.</p><ul><li><p><code>v1</code>和<code>v2</code>的区别</p><blockquote><p>在 Android Studio 中点击菜单 Build-&gt;Generate signed apk… 打包签名过程中,可以看到两种签名选项 V1( Jar Signature ) V2( Full APK Signature )</p></blockquote><ul><li><p>V1签名：</p><ul><li>来自 JDK （ jarsigner ）,对 zip 压缩包的每个文件进行验证，签名后还能对压缩包修改（移动&#x2F;重新压缩文件）</li><li>对V1签名的 apk&#x2F;jar 解压,在 META-INF 存放签名文件( MANIFEST.MF, CERT.SF, CERT.RSA )</li><li>其中 MANIFEST.MF 文件保存所有文件的 SHA1 指纹(除了 META-INF 文件),由此可知:V1签名是对压缩包中单个文件签名验证</li></ul></li><li><p>V2签名：</p><ul><li>来自 Google（apksigner），对 zip 压缩包的整个文件验证，签名后不能修改压缩包(包括 zipalign )</li><li>对V2签名的 apk 解压,没有发现签名文件,重新压缩后V2签名就失效, 由此可知: V2签名是对整个 APK 签名验证</li></ul></li><li><p>V2签名的优点：</p><ul><li>签名更安全（不能修改压缩包）</li><li>签名验证时间更短（不需要解压验证），因此安装速度更快</li></ul></li></ul><p><strong>注意：</strong> <code>apksigner</code>工具默认同时使用V1和V2签名，以兼容Android7.0以下系统版本</p></li><li><p>zipalign 和V2签名</p><p>位于 Android SDK&#x2F;build-tools&#x2F;SDK 版本 &#x2F;zipalign.exe<br>zipalign 是对 zip 包对齐的工具，使APK包内未压缩的数据有序排列对齐，从而减少 APP 运行时消耗</p><blockquote><p>zipalign -v 4 in.apk out.apk &#x2F;&#x2F;4字节对齐优化命令<br>zipalign -c -v 4 in.apk      &#x2F;&#x2F;检查 APK 是否对齐</p></blockquote><p><strong>zipalign 可以在V1签名后执行，但 zipalign 不能在V2签名之后执行，只能在V2签名之前执行！</strong></p></li><li><p>签名步骤</p><ul><li><p>生成密钥对（已有密钥库，可忽略）</p><p>Eclipse或Android Studio在Debug时,对App签名都会使用一个默认的密钥库:<br>  默认在C:\Users\用户名.android\debug.keystore<br>  密钥库名: debug.keystore<br>  密钥别名: androiddebugkey<br>  密钥库密码: android</p></li></ul><p><strong>生成密钥对</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -keystore 密钥库名 -alias 密钥别名 -validity 天数 -keyalg RSA</span><br></pre></td></tr></table></figure><p>参数：</p><blockquote><p>-genkeypair 生成一条密钥对（由私钥和公钥组成）<br>-keystore 密钥库名字及存储位置（默认当前目录）<br>-alias 密钥对的别名（密钥库可以存在多个密钥对，用于区分不同密钥对）<br>-validity 密钥对的有效期（单位：天）<br>-keyalg 生成密钥对的算法（常用 RSA&#x2F;DSA ，DSA 只用于签名，默认采用DSA ）</p></blockquote><p>提示：可重复使用此命令，在同一密钥库中创建多条密钥对</p><p>例如：<br>在 debug.keystore 中新增一对密钥，别名是release</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -keystore debug.keystore -alias release -validity 3000</span><br></pre></td></tr></table></figure><p><strong>查看密钥库</strong></p><p>  进入 JDK&#x2F;bin，输入命令</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore 密钥库名</span><br></pre></td></tr></table></figure><p>  参数：</p><blockquote><p>-list 查看密钥列表<br>-v 查看密钥详情</p></blockquote><p>  例如：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore debug.keystore</span><br></pre></td></tr></table></figure></li></ul><p>好了，现在生成密钥了，也就可以签名了。</p><h3 id="有密钥了，当然要给APK签名了"><a href="#有密钥了，当然要给APK签名了" class="headerlink" title="有密钥了，当然要给APK签名了"></a>有密钥了，当然要给APK签名了</h3><ol><li>方法一（ jarsigner ，只支持V1签名）<br>进入JDK&#x2F;bin, 输入命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -keystore 密钥库名 xxx.apk 密钥别名</span><br></pre></td></tr></table></figure><p>从JDK7开始, jarsigner默认算法是SHA256, 但Android 4.2以下不支持该算法,所以需要修改算法, 添加参数 -digestalg SHA1 -sigalg SHA1withRSA</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -keystore 密钥库名 -digestalg SHA1 -sigalg SHA1withRSA xxx.apk 密钥别名</span><br></pre></td></tr></table></figure><p>参数：</p><blockquote><p>-digestalg 摘要算法<br>-sigalg 签名算法</p></blockquote><p>例如：<br>用 JDK7 及以上 jarsigner 签名，不支持 Android4.2 以下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -keystore debug.keystore app.apk androiddebugkey</span><br></pre></td></tr></table></figure><p>用 JDK7 及以上 jarsigner 签名，兼容 Android4.2 以下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -keystore debug.keystore -digestalg SHA1 -sigalg SHA1withRSA app.apk androiddebugkey</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二（ apksigner ，默认同时使用V1和V2签名）<br>进入Android SDK&#x2F;build-tools&#x2F;SDK版本, 输入命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --ks 密钥库名 --ks-key-alias 密钥别名 xxx.apk</span><br></pre></td></tr></table></figure><p>若密钥库中有多个密钥对,则必须指定密钥别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --ks 密钥库名 --ks-key-alias 密钥别名 xxx.apk</span><br></pre></td></tr></table></figure><p>禁用V2签名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --v2-signing-enabled false --ks 密钥库名 xxx.apk</span><br></pre></td></tr></table></figure><p>参数：</p><blockquote><p>–ks-key-alias 密钥库别名，若密钥库只有一个密钥对，则可省略，反之必选<br>–v1-signing-enabled 是否开启V1签名，默认开启<br>–v2-signing-enabled 是否开启V2签名，默认开启</p></blockquote><p>例如：<br>在 debug.keystore 密钥库只有一个密钥对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --ks debug.keystore app.apk</span><br></pre></td></tr></table></figure><p>在 debug.keystore 密钥库中有多个密钥对，所以必须指定密钥别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --ks debug.keystore --ks-key-alias androiddebugkey app.apk</span><br></pre></td></tr></table></figure><h3 id="签名验证，康康自己的成果"><a href="#签名验证，康康自己的成果" class="headerlink" title="签名验证，康康自己的成果"></a>签名验证，康康自己的成果</h3><ol><li>方法一（ keytool ，只支持V1签名校验）<br>进入 JDK&#x2F;bin , 输入命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert -jarfile app.apk （显示签名信息）</span><br></pre></td></tr></table></figure><p>参数：</p><blockquote><p>-printcert 打印证书内容<br>-jarfile <filename> 已签名的 jar 文件或 apk 文件</p></blockquote><ol start="2"><li>方法二（ apksigner ，支持V1和V2签名校验）<br>进入 Android SDK&#x2F;build-tools&#x2F;SDK 版本, 输入命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner verify -v --print-certs xxx.apk</span><br></pre></td></tr></table></figure></li></ol><p>参数：</p><blockquote><p>-v,–verbose 显示详情（显示是否使用V1和V2签名）<br>–print-certs 显示签名证书信息</p></blockquote><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apksigner verify -v app.apk</span><br><span class="line"></span><br><span class="line">Verifies</span><br><span class="line">Verified using v1 scheme (JAR signing): true</span><br><span class="line">Verified using v2 scheme (APK Signature Scheme v2): true</span><br><span class="line">Number of signers: 1</span><br></pre></td></tr></table></figure><ol start="3"><li>方法三(GetApkInfo.jar 支持v1,v2，并且是中文显示)</li></ol><p>下载<a href="https://www.lanzous.com/i8ot4ni">GetApkInfo.jar</a></p><p>查看包名，版本号，签名等信息,以qq为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java -jar GetApkInfo.jar qq.apk</span><br><span class="line"></span><br><span class="line">执行结果: 成功</span><br><span class="line">应用信息:</span><br><span class="line">  包名: com.tencent.mobileqq</span><br><span class="line">  版本名: 7.8.8</span><br><span class="line">  版本号: 942</span><br><span class="line">  签名文件MD5: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">  SDK版本:</span><br><span class="line">      minSdkVersion:xx</span><br><span class="line">      targetSdkVersion:xx</span><br><span class="line">  V1签名验证通过: true</span><br><span class="line">  使用V2签名: true</span><br><span class="line">  V2签名验证通过: true</span><br></pre></td></tr></table></figure><p>可以拿到包名，版本名称，版本号，签名文件md5值，sdk最小版本，应用支持的最低系统版本，v1和v2的签名情况</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>到这里你就把这篇文章看的七七八八了。但是你会产生一个疑问：为什么没写乐固加固过程？，因为现在乐固加固已经不是说用工具加固了，至少我在官网找了好久都没找到SDK或者包括Windows、Mac OS、Linux这几大平台的工具，一直都没找到。只有去<a href="https://console.cloud.tencent.com/ms">腾讯乐固</a>这里登录账号上传apk文件打包了，挺快的，二十分钟左右吧。</p><p>但是，上传之后要<strong>注意</strong>了：</p><blockquote><p>上传之后是没有签名的，必须自己再重新签名！</p></blockquote><p>也就是说，哪怕你是之前打包签名好的，但是你加固了，下载后的<code>xxx_legu.apk</code>也是没有签名的，必须自己签名，至于签名方法，在前面啦。祝各位好运^_^</p><p>以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作具有一定的参考学习价值，如果有疑问大家可以留言交流，谢谢大家对我的支持。😘✔</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 加固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年终总结</title>
      <link href="/2020/2019-the-end/index/"/>
      <url>/2020/2019-the-end/index/</url>
      
        <content type="html"><![CDATA[<p><strong>一个人活着，不一定要鲜艳，但一定要有自己的颜色。</strong></p><p><img src="/img/16f607487585c9c6.jpeg"></p><p>已经有整整一年没写博客了，虽然没人看，但是人活一次，总得留点什么给自己。作为一个云程序员，今年我又来了，来写自己的年终总结。</p><p>回想这一年里，我感觉自己真的变了许多，当然有些话不便明言，我只是会举例子，具体自己悟。自己也毕业3年了，从最初的满怀信心到现在的泯(hun)然(chi)众(deng)人(si)，也有了三年的时间了。第一年，我刚从学校出来，虽然参加过两次省级比赛，不过由于自己基础不够，很怂，就在老师的推荐下跟着学长后面吃灰了。这灰一直吃了两年，第二年其实本来是想10月走的，后来被某些公众号推文一吓，再问问同学的就业情况我顿时熄灭了这个想法。别说，我当时都把自己的什么简历啊什么的还有面试题都搞了一遍，可惜没有那个胆子去迈出那一步。这也就导致了我又跟着学长吃了一年灰。第三年我本来觉得暂时先这样吧，不过后来到夏季的时候，就发现有点问题，一是各种活动什么的少了，二是工作量也不多了，三是两个跟老总玩的比较好的同事相继离职了。这种情况下我自然就是会发现不同。后来我跟另一个学长聊天的之后才发现，我自己的确该离开了，也是到了离开的时候了。本来是打算去vivo外包拼一拼的，还跟hr聊的挺好的，不过后来被主管否了，都没让面试，惨兮兮。还有一个苏州的，说不给交社保，直接给钱，我是喜欢钱，但是我不喜欢饮鸩止渴，这种明显对将来没好处的事，我自己是不会干的。后来到了这个公司，感觉还不错，一直到现在。</p><p>我用了两年时间，从一个舒适区走了出来。不过可怕的并不是这个，可怕的是我现在的习惯，已经完完全全是一种混吃等死的习惯，没有爱好，没有爱做的事，没有想做的事。唯一想做的恐怕就是待在家，什么也不做。这或许已经成为一种习惯，我虽然想起来的时候觉得很恐怖，但是我现在好像并没有什么能力去改变它。我大部分时候也是很废物的。</p><p>前些天逛小破站的时候发现了一个视频，在线占卜的。我当然试了试。别说，试完后突然觉得生活变成彩色的了。现在想想，或许并不是世界是灰色的，而是自己一个人沉浸在自己的世界中太久了。就像一本书，一直没人去翻看它，它自然就会发霉。有人说，你现在的气质里，藏着你走过的路。这句话我个人觉得很有道理，当你经历过一些事情，你当时可能不会去因为它而改变，但是，未来的某一个时刻，你就会因为你曾今经历过的事而发生改变，这就是成长的过程。<br><img src="/img/2019/the-end/t01b11174e3eca6230a.jpg"></p><p>对于接下来的2020，有人说是“爱你爱你”，我对于这个说法挺赞同的。人嘛~，从出生的那一刻开始就在面向死亡，但是区别于其他生物的是我们有能够表达出的感情，而不是只是某些依赖。2019年我没有好好活着，没有记录与自己所爱的人的每一刻，2020我会做的更好。</p><ul><li>想一千次</li><li>不如行动一次</li><li>唯有努力</li><li>不负光明</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年终总结</title>
      <link href="/2018/2018-the-end/index/"/>
      <url>/2018/2018-the-end/index/</url>
      
        <content type="html"><![CDATA[<p>当聖誕夜過去，也意味著這一年即將結束，迎來嶄新的開始。一年的時光既短暫又漫長，当離開人生的舒適區，講迎來一個又一個的挑戰。</p><p>如果說一個人的優秀，取決於它的天賦，以及他為之付出的額外努力，那麼問一問自己，是否真的認真的付齣了嗎？</p><p>迴顧我的2018，年初把上個項目結尾並且交接完，然後就是<text style="font-size: x-large">水</text>！對！沒錯！一直在水。</p><p>其實也沒有啦，就是東一榔頭西一棒這樣子。可以這麼講吧，年前的項目投入了太多的精力，然後整個人就緊繃繃的。放個假，就懶散了，正好後來項目暫時交接出去，手上沒有項目，我又比較關注新技術，就什麼都開始試試。就是啥也沒做齣來就是。做過的有：</p><ul><li>微信公眾號創建、上線、運營、引流…</li><li>微信小程序，就包括剛剛還上線了一個天氣的(地址看心情吧，貼不貼)。</li><li>個人博客(有WordPress的，有CMS的，後來嫌棄麻煩就重新弄了這個。然後為了引流，還寫了簡書、CSDN、sina博客)</li><li>Python爬蟲，原因是為了幫別人完成畢業論文，結果還是沒找我要數據。不過還是用了Python進行數據整理的。也算是幫了個小忙吧。</li><li>用過Excel幫以前小姐姐同學處理數據。</li><li>買了好多本書，數據結構，代碼重構，設計模式，《Thinking in JAVA》，還有几本湊單的《相對論》、英語語法入門…還有從同學那拿來的《高等數學》…</li><li>堅持過去圖書館，不過失敗了。</li><li>花50塊買了個英語單詞教學視頻，看了一單元不看了。</li><li>打算過報名軟考，考研。也隻是想想。</li><li>用買的服務器挖礦，掙得0.000005$吧。</li><li>用找到的源碼搭建<a href="http://xs.buerya.cn/">小說站</a>和<a href="http://movie.buerya.cn/">影視站①</a>還有<a href="http://mv.buerya.cn/">影視站②</a><br>  …</li></ul><p>付齣了非常多的努力，但是卻沒能穫得足夠令人滿意的收貨。總體而言，不是說自己能力不夠，主要還是自己目前太浮躁，想的太多，做的太少。高估了自己的能力，沒有腳踏實地做事、學習。也許表面上看，似乎能夠把事情完美的護理，但是卻實際上已經無法真的能夠方方面面考慮週全。</p><p>目前雖然講是國內的互聯網寒鼕，不過我個人卻不這麼看。這並不是寒鼕，而是結構的調整。因為國內之前的環境是由於人才少，導緻供需問題尖銳，才有了互聯網泡沫。從之前的快速興起到現在的穩步發展、百花齊放，整個大環境開始整合，導緻那些泡沫必然會破滅。</p><p>我片面的認為，IT技術時代，本質上來說，依然是靠技術來驅動。也許談不上改變時代，卻至少應該給時代帶來便利。也許國外的工資的確很高，但是人傢是有很好的數學功底和編程經驗的，妳一個專科畢業兩年的怎麼跟別人相比。經過了上面許許多多的事情之後，我發現自己已經沒有了当初奮鬥的力氣，不知道什麼時候放棄了奮鬥者的格言，成為了舒適區的溫水青蛙。</p><p>舒適區，容易讓人放棄目標，迷惑自己。雖然我之前做的事是在學習，但是這种隻注重表面的學習是沒有任何的實用性的。是建立在別人的基礎之上所產生的成果，沒有自己的想法，永遠跟著別人的腳步，無法超越。</p><p>我知道，技術者最忌諱的是雲程序猿，就是那种彎彎繞繞一套一套的，說起來頭頭是道，但是正兒八經用起來，不過是啞彈一枚。因為隻是了解了皮毛而已。必須承認，知道皮毛，不過是大道三千，你隻記住了書名，其實什麼用都沒有。最關鍵的，不是浮於表面，而是深入核心用心的去領悟和思考，隻有這樣才能掌控自己的知識體系。</p><p>迴顧職場，實際上已經走在了云程序員這條錯誤的路上，進入了空談主義的錯誤路線，以為自己接觸過的，都會！</p><p>但是真正的工程師，往往必須真正掌握一种屬於自己的知識體系。弱水三千，取一瓢飲。如果廣度太大，反而成為一种負擔。因此，我應該把時間花在學習技術本源之中。</p><p>竹子用了4年的時間，僅僅長了3釐米。但是從第五年開始，以每天30釐米的速度瘋狂的生長，僅僅用了6週的時間就到了15米。其實，在前面的4年，竹子講根在土壤裡延伸了數百平米。做人做事都是這樣。</p><p>不要担心此刻的付出没有回报，熬过三厘米，才能一飞冲天。也不要自责时间的逝去，总是难以一次性把事情做对的话，至少走在了正确的道路上，也是一种积累。</p><p>要坚信一点，你此刻的沉沦和沉淀，都会像熏肉一般，一点一点熏进你的灵魂。他们将为你铺路，或把你埋葬，或让你登顶。</p><p>自省。</p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 操作 (二)</title>
      <link href="/2018/git_step_2/index/"/>
      <url>/2018/git_step_2/index/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文摘自【<a href="https://github.com/k88hudson/git-flight-rules">git-flight-rules</a>】</p></blockquote><h1 id="Git飞行规则-Flight-Rules"><a href="#Git飞行规则-Flight-Rules" class="headerlink" title="Git飞行规则(Flight Rules)"></a>Git飞行规则(Flight Rules)</h1><p>🌍<br><em><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README.md">English</a> ∙ <a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_es.md">Español</a>  ∙  <a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_ru.md">Русский</a> ∙ <a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md">简体中文</a>∙ <a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_kr.md">한국어</a>  ∙  <a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_vi.md">Tiếng Việt</a> ∙ <a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_fr.md">Français</a></em></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>英文原版<a href="https://github.com/k88hudson/git-flight-rules/blob/master/README.md">README</a></li><li>翻译可能存在错误或不标准的地方，欢迎大家指正和修改，谢谢！</li></ul><h4 id="什么是”飞行规则”"><a href="#什么是”飞行规则”" class="headerlink" title="什么是”飞行规则”?"></a>什么是”飞行规则”?</h4><p>一个 <a href="http://www.jsc.nasa.gov/news/columbia/fr_generic.pdf">宇航员指南</a> (现在, 程序员们都在使用GIT) 是关于出现问题过后应该怎么操作。</p><blockquote><p> <em>飞行规则(Flight Rules)</em> 是记录在手册上的来之不易的一系列知识，记录了某个事情发生的原因，以及怎样一步一步的进行处理。本质上, 它们是特定场景的非常详细的标准处理流程。 […]</p></blockquote><blockquote><p>自20世纪60年代初以来，NASA一直在捕捉(capturing)我们的失误，灾难和解决方案, 当时水星时代(Mercury-era)的地面小组首先开始将“经验教训”收集到一个纲要(compendium)中，该纲现在已经有上千个问题情景，从发动机故障到破损的舱口把手到计算机故障，以及它们对应的解决方案。</p></blockquote><p>&amp;mdash; Chris Hadfield, *一个宇航员的生活指南(An Astronaut’s Guide to Life)*。</p><h4 id="这篇文章的约定"><a href="#这篇文章的约定" class="headerlink" title="这篇文章的约定"></a>这篇文章的约定</h4><p>为了清楚的表述，这篇文档里的所有例子使用了自定义的bash 提示，以便指示当前分支和是否有暂存的变化(changes)。分支名用小括号括起来，分支名后面跟的<code>*</code>表示暂存的变化(changes)。</p><p><a href="https://gitter.im/k88hudson/git-flight-rules?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge">Join the chat</a> <img src="https://badges.gitter.im/Join%20Chat.svg"></p><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="编辑提交-editting-commits"><a href="#编辑提交-editting-commits" class="headerlink" title="编辑提交(editting commits)"></a>编辑提交(editting commits)</h2><p><a name="diff-last"></a></p><h3 id="我刚才提交了什么"><a href="#我刚才提交了什么" class="headerlink" title="我刚才提交了什么?"></a>我刚才提交了什么?</h3><p>如果你用 <code>git commit -a</code> 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前<code>HEAD</code>上的最近一次的提交(commit):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git show</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n1 -p</span><br></pre></td></tr></table></figure><p><a name="#i-wrote-the-wrong-thing-in-a-commit-message"></a></p><h3 id="我的提交信息-commit-message-写错了"><a href="#我的提交信息-commit-message-写错了" class="headerlink" title="我的提交信息(commit message)写错了"></a>我的提交信息(commit message)写错了</h3><p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --only</span><br></pre></td></tr></table></figure><p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --only -m <span class="string">&#x27;xxxxxxx&#x27;</span></span><br></pre></td></tr></table></figure><p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p><p><a name="commit-wrong-author"></a></p><h3 id="我提交-commit-里的用户名和邮箱不对"><a href="#我提交-commit-里的用户名和邮箱不对" class="headerlink" title="我提交(commit)里的用户名和邮箱不对"></a>我提交(commit)里的用户名和邮箱不对</h3><p>如果这只是单个提交(commit)，修改它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author <span class="string">&quot;New Authorname &lt;authoremail@mydomain.com&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页.</p><p><a href="#i-want-to-remove-a-file-from-a-commit"></a></p><h3 id="我想从一个提交-commit-里移除一个文件"><a href="#我想从一个提交-commit-里移除一个文件" class="headerlink" title="我想从一个提交(commit)里移除一个文件"></a>我想从一个提交(commit)里移除一个文件</h3><p>通过下面的方法，从一个提交(commit)里移除一个文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD^ myfile</span><br><span class="line">git add -A</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。</p><p><a name="delete-pushed-commit"></a></p><h3 id="我想删除我的的最后一次提交-commit"><a href="#我想删除我的的最后一次提交-commit" class="headerlink" title="我想删除我的的最后一次提交(commit)"></a>我想删除我的的最后一次提交(commit)</h3><p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^ --hard</span><br><span class="line">git push -f [remote] [branch]</span><br></pre></td></tr></table></figure><p>如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(my-branch*)git reset --soft HEAD@&#123;1&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是rebase-safe的 (例如： 其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>； 更多, 请参考 <a href="#deleteremove-last-pushed-commit">the above section</a>。</p><p><a name="delete-any-commit"></a></p><h3 id="删除任意提交-commit"><a href="#删除任意提交-commit" class="headerlink" title="删除任意提交(commit)"></a>删除任意提交(commit)</h3><p>同样的警告：不到万不得已的时候不要这么做.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT</span><br><span class="line">git push -f [remote] [branch]</span><br></pre></td></tr></table></figure><p>或者做一个 <a href="#interactive-rebase">交互式rebase</a> 删除那些你想要删除的提交(commit)里所对应的行。</p><p><a name="#force-push"></a></p><h3 id="我尝试推一个修正后的提交-amended-commit-到远程，但是报错："><a href="#我尝试推一个修正后的提交-amended-commit-到远程，但是报错：" class="headerlink" title="我尝试推一个修正后的提交(amended commit)到远程，但是报错："></a>我尝试推一个修正后的提交(amended commit)到远程，但是报错：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/yourusername/repo.git</span><br><span class="line">! [rejected]        mybranch -&gt; mybranch (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;https://github.com/tanay1337/webmaker.org.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>注意, rebasing(见下面)和修正(amending)会用一个<strong>新的提交(commit)代替旧的</strong>, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。 注意 &amp;ndash; <em>总是</em> 确保你指明一个分支!</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git push origin mybranch -f</span><br></pre></td></tr></table></figure><p>一般来说, <strong>要避免强推</strong>. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p><p><a href="undo-git-reset-hard"></a></p><h3 id="我意外的做了一次硬重置-hard-reset-，我想找回我的内容"><a href="#我意外的做了一次硬重置-hard-reset-，我想找回我的内容" class="headerlink" title="我意外的做了一次硬重置(hard reset)，我想找回我的内容"></a>我意外的做了一次硬重置(hard reset)，我想找回我的内容</h3><p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git reflog</span><br></pre></td></tr></table></figure><p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git reset --hard SHA1234</span><br></pre></td></tr></table></figure><p>这样就完成了。</p><h2 id="暂存-Staging"><a href="#暂存-Staging" class="headerlink" title="暂存(Staging)"></a>暂存(Staging)</h2><p><a href="#i-need-to-add-staged-changes-to-the-previous-commit"></a></p><h3 id="我需要把暂存的内容添加到上一次的提交-commit"><a href="#我需要把暂存的内容添加到上一次的提交-commit" class="headerlink" title="我需要把暂存的内容添加到上一次的提交(commit)"></a>我需要把暂存的内容添加到上一次的提交(commit)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(my-branch*)git commit --amend</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="commit-partial-new-file"></a></p><h3 id="我想要暂存一个新文件的一部分，而不是这个文件的全部"><a href="#我想要暂存一个新文件的一部分，而不是这个文件的全部" class="headerlink" title="我想要暂存一个新文件的一部分，而不是这个文件的全部"></a>我想要暂存一个新文件的一部分，而不是这个文件的全部</h3><p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --patch filename.x</span><br></pre></td></tr></table></figure><p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -N filename.x</span><br></pre></td></tr></table></figure><p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p><p><a href="stage-in-two-commits"></a></p><h3 id="我想把在一个文件里的变化-changes-加到两个提交-commit-里"><a href="#我想把在一个文件里的变化-changes-加到两个提交-commit-里" class="headerlink" title="我想把在一个文件里的变化(changes)加到两个提交(commit)里"></a>我想把在一个文件里的变化(changes)加到两个提交(commit)里</h3><p><code>git add</code> 会把整个文件加入到一个提交. <code>git add -p</code> 允许交互式的选择你想要提交的部分.</p><p><a href="unstaging-edits-and-staging-the-unstaged"></a></p><h3 id="我想把暂存的内容变成未暂存，把未暂存的内容暂存起来"><a href="#我想把暂存的内容变成未暂存，把未暂存的内容暂存起来" class="headerlink" title="我想把暂存的内容变成未暂存，把未暂存的内容暂存起来"></a>我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</h3><p>这个有点困难， 我能想到的最好的方法是先stash未暂存的内容， 然后重置(reset)，再pop第一步stashed的内容, 最后再add它们。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash -k</span><br><span class="line">git reset --hard</span><br><span class="line">git stash pop</span><br><span class="line">git add -A</span><br></pre></td></tr></table></figure><h2 id="未暂存-Unstaged-的内容"><a href="#未暂存-Unstaged-的内容" class="headerlink" title="未暂存(Unstaged)的内容"></a>未暂存(Unstaged)的内容</h2><p><a href="move-unstaged-edits-to-new-branch"></a></p><h3 id="我想把未暂存的内容移动到一个新分支"><a href="#我想把未暂存的内容移动到一个新分支" class="headerlink" title="我想把未暂存的内容移动到一个新分支"></a>我想把未暂存的内容移动到一个新分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my-branch</span><br></pre></td></tr></table></figure><p><a href="move-unstaged-edits-to-old-branch"></a></p><h3 id="我想把未暂存的内容移动到另一个已存在的分支"><a href="#我想把未暂存的内容移动到另一个已存在的分支" class="headerlink" title="我想把未暂存的内容移动到另一个已存在的分支"></a>我想把未暂存的内容移动到另一个已存在的分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout my-branch</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p><a href="i-want-to-discard-my-local-uncommitted-changes"></a></p><h3 id="我想丢弃本地未提交的变化-uncommitted-changes"><a href="#我想丢弃本地未提交的变化-uncommitted-changes" class="headerlink" title="我想丢弃本地未提交的变化(uncommitted changes)"></a>我想丢弃本地未提交的变化(uncommitted changes)</h3><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># one commit</span></span><br><span class="line">(my-branch)git reset --hard HEAD^</span><br><span class="line"><span class="comment"># two commits</span></span><br><span class="line">(my-branch)git reset --hard HEAD^^</span><br><span class="line"><span class="comment"># four commits</span></span><br><span class="line">(my-branch)git reset --hard HEAD~4</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">(master)git checkout -f</span><br></pre></td></tr></table></figure><p>重置某个特殊的文件, 你可以用文件名做为参数:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure><p><a href="i-want-to-discard-specific-unstaged-changes"></a></p><h3 id="我想丢弃某些未暂存的内容"><a href="#我想丢弃某些未暂存的内容" class="headerlink" title="我想丢弃某些未暂存的内容"></a>我想丢弃某些未暂存的内容</h3><p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p><p>签出(checkout)不需要的内容，保留需要的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -p</span><br><span class="line"><span class="comment"># Answer y to all of the snippets you want to drop</span></span><br></pre></td></tr></table></figure><p>另外一个方法是使用 <code>stash</code>， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash -p</span><br><span class="line"><span class="comment"># Select all of the snippets you want to save</span></span><br><span class="line">git reset --hard</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>或者, stash 你不需要的部分, 然后stash drop。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash -p</span><br><span class="line"><span class="comment"># Select all of the snippets you don&#x27;t want to save</span></span><br><span class="line">git stash drop</span><br></pre></td></tr></table></figure><h2 id="分支-Branches"><a href="#分支-Branches" class="headerlink" title="分支(Branches)"></a>分支(Branches)</h2><p><a name="pull-wrong-branch"></a></p><h3 id="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"><a href="#我从错误的分支拉取了内容，或把内容拉取到了错误的分支" class="headerlink" title="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"></a>我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h3><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前HEAD的指向。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(master)git reflog</span><br><span class="line">ab7555f HEAD@&#123;0&#125;: pull origin wrong-branch: Fast-forward</span><br><span class="line">c5bc55a HEAD@&#123;1&#125;: checkout: checkout message goes here</span><br></pre></td></tr></table></figure><p>重置分支到你所需的提交(desired commit):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard c5bc55a</span><br></pre></td></tr></table></figure><p>完成。</p><p><a href="discard-local-commits"></a></p><h3 id="我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致"><a href="#我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致" class="headerlink" title="我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致"></a>我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</h3><p>先确认你没有推(push)你的内容到远程。</p><p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git status</span><br><span class="line"><span class="comment"># On branch my-branch</span></span><br><span class="line"><span class="comment"># Your branch is ahead of &#x27;origin/my-branch&#x27; by 2 commits.</span></span><br><span class="line"><span class="comment">#   (use &quot;git push&quot; to publish your local commits)</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>一种方法是:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git reset --hard origin/my-branch</span><br></pre></td></tr></table></figure><p><a name="commit-wrong-branch"></a></p><h3 id="我需要提交到一个新分支，但错误的提交到了master"><a href="#我需要提交到一个新分支，但错误的提交到了master" class="headerlink" title="我需要提交到一个新分支，但错误的提交到了master"></a>我需要提交到一个新分支，但错误的提交到了master</h3><p>在master下创建一个新分支，不切换到新分支,仍在master下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git branch my-branch</span><br></pre></td></tr></table></figure><p>把master分支重置到前一个提交:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p><p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的hash(<code>git log</code> 能够完成)， 然后重置到这个hash。 使用<code>git push</code> 同步内容到远程。</p><p>例如, master分支想重置到的提交的hash为<code>a13b85e</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(master)git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure><p>签出(checkout)刚才新建的分支继续工作:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git checkout my-branch</span><br></pre></td></tr></table></figure><p><a name="keep-whole-file"></a></p><h3 id="我想保留来自另外一个ref-ish的整个文件"><a href="#我想保留来自另外一个ref-ish的整个文件" class="headerlink" title="我想保留来自另外一个ref-ish的整个文件"></a>我想保留来自另外一个ref-ish的整个文件</h3><p>假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(solution)git add -A &amp;&amp; git commit -m <span class="string">&quot;Adding all changes from this spike into one big commit.&quot;</span></span><br></pre></td></tr></table></figure><p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p><p>假设你有:</p><ul><li>分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li><li>分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li></ul><p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(develop)git checkout solution -- file1.txt</span><br></pre></td></tr></table></figure><p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># On branch develop</span></span><br><span class="line"><span class="comment"># Your branch is up-to-date with &#x27;origin/develop&#x27;.</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        modified:   file1.txt</span></span><br></pre></td></tr></table></figure><p>然后, 正常提交。</p><p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ <a href="https://en.wikipedia.org/wiki/Extreme_programming_practices">Wikipedia</a>.</p><p><a name="cherry-pick"></a></p><h3 id="我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里"><a href="#我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里" class="headerlink" title="我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里"></a>我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</h3><p>假设你有一个<code>master</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(master)git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit e3851e817c451cc36f2e6f3049db528415e3c114</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:27 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#21 - Added CSRF protection</span></span><br><span class="line"></span><br><span class="line">commit 5ea51731d150f7ddc4a365437931cd8be3bf3131</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:12 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#14 - Fixed spacing on title</span></span><br><span class="line"></span><br><span class="line">commit a13b85e984171c6e2a1729bb061994525f626d14</span><br><span class="line">Author: Aki Rose &lt;akirose@example.com&gt;</span><br><span class="line">Date:   Tue Jul 21 01:12:48 2014 -0400</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure><p>让我们用提交hash(commit hash)标记bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p><p>首先, 我们把<code>master</code>分支重置到正确的提交(<code>a13b85e</code>):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(master)git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure><p>现在, 我们对 bug #21 创建一个新的分支:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(master)git checkout -b 21</span><br><span class="line">(21)$</span><br></pre></td></tr></table></figure><p>接着, 我们用 <em>cherry-pick</em> 把对bug #21的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(21)git cherry-pick e3851e8</span><br></pre></td></tr></table></figure><p>这时候, 这里可能会产生冲突， 参见<a href="#interactive-rebase">交互式 rebasing 章</a> <a href="#merge-conflict"><strong>冲突节</strong></a> 解决冲突.</p><p>再者， 我们为bug #14 创建一个新的分支, 也基于<code>master</code>分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(21)git checkout master</span><br><span class="line">(master)git checkout -b 14</span><br><span class="line">(14)$</span><br></pre></td></tr></table></figure><p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(14)git cherry-pick 5ea5173</span><br></pre></td></tr></table></figure><p><a name="delete-stale-local-branches"></a></p><h3 id="我想删除上游-upstream-分支被删除了的本地分支"><a href="#我想删除上游-upstream-分支被删除了的本地分支" class="headerlink" title="我想删除上游(upstream)分支被删除了的本地分支"></a>我想删除上游(upstream)分支被删除了的本地分支</h3><p>一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure><p><a name='restore-a-deleted-branch'></a></p><h3 id="我不小心删除了我的分支"><a href="#我不小心删除了我的分支" class="headerlink" title="我不小心删除了我的分支"></a>我不小心删除了我的分支</h3><p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(master)git checkout -b my-branch</span><br><span class="line">(my-branch)git branch</span><br><span class="line">(my-branch)<span class="built_in">touch</span> foo.txt</span><br><span class="line">(my-branch)<span class="built_in">ls</span></span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure><p>添加文件并做一次提交</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git add .</span><br><span class="line">(my-branch)git commit -m <span class="string">&#x27;foo.txt added&#x27;</span></span><br><span class="line">(my-branch)foo.txt added</span><br><span class="line"> 1 files changed, 1 insertions(+)</span><br><span class="line"> create mode 100644 foo.txt</span><br><span class="line">(my-branch)git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012</span><br><span class="line">Author: siemiatj &lt;siemiatj@example.com&gt;</span><br><span class="line">Date:   Wed Jul 30 00:34:10 2014 +0200</span><br><span class="line"></span><br><span class="line">    foo.txt added</span><br><span class="line"></span><br><span class="line">commit 69204cdf0acbab201619d95ad8295928e7f411d5</span><br><span class="line">Author: Kate Hudson &lt;katehudson@example.com&gt;</span><br><span class="line">Date:   Tue Jul 29 13:14:46 2014 -0400</span><br><span class="line"></span><br><span class="line">    Fixes <span class="comment">#6: Force pushing after amending commits</span></span><br></pre></td></tr></table></figure><p>现在我们切回到主(master)分支，‘不小心的’删除<code>my-branch</code>分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">(master)git branch -D my-branch</span><br><span class="line">Deleted branch my-branch (was 4e3cd85).</span><br><span class="line">(master)<span class="built_in">echo</span> oh noes, deleted my branch!</span><br><span class="line">oh noes, deleted my branch!</span><br></pre></td></tr></table></figure><p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(master)git reflog</span><br><span class="line">69204cd HEAD@&#123;0&#125;: checkout: moving from my-branch to master</span><br><span class="line">4e3cd85 HEAD@&#123;1&#125;: commit: foo.txt added</span><br><span class="line">69204cd HEAD@&#123;2&#125;: checkout: moving from master to my-branch</span><br></pre></td></tr></table></figure><p>正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(master)git checkout -b my-branch-help</span><br><span class="line">Switched to a new branch <span class="string">&#x27;my-branch-help&#x27;</span></span><br><span class="line">(my-branch-help)git reset --hard 4e3cd85</span><br><span class="line">HEAD is now at 4e3cd85 foo.txt added</span><br><span class="line">(my-branch-help)<span class="built_in">ls</span></span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure><p>看! 我们把删除的文件找回来了。 Git的 <code>reflog</code> 在rebasing出错的时候也是同样有用的。</p><p><a name="i-want-to-delete-a-branch"></a></p><h3 id="我想删除一个分支"><a href="#我想删除一个分支" class="headerlink" title="我想删除一个分支"></a>我想删除一个分支</h3><p>删除一个远程分支:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git push origin --delete my-branch</span><br></pre></td></tr></table></figure><p>你也可以:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git push origin :my-branch</span><br></pre></td></tr></table></figure><p>删除一个本地分支:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git branch -D my-branch</span><br></pre></td></tr></table></figure><p><a name="i-want-to-checkout-to-a-remote-branch-that-someone-else-is-working-on"></a></p><h3 id="我想从别人正在工作的远程分支签出-checkout-一个分支"><a href="#我想从别人正在工作的远程分支签出-checkout-一个分支" class="headerlink" title="我想从别人正在工作的远程分支签出(checkout)一个分支"></a>我想从别人正在工作的远程分支签出(checkout)一个分支</h3><p>首先, 从远程拉取(fetch) 所有分支:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git fetch --all</span><br></pre></td></tr></table></figure><p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(master)git checkout --track origin/daves</span><br><span class="line">Branch daves <span class="built_in">set</span> up to track remote branch daves from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;daves&#x27;</span></span><br></pre></td></tr></table></figure><p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p><p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p><h2 id="Rebasing-和合并-Merging"><a href="#Rebasing-和合并-Merging" class="headerlink" title="Rebasing 和合并(Merging)"></a>Rebasing 和合并(Merging)</h2><p><a name="undo-rebase"></a></p><h3 id="我想撤销rebase-x2F-merge"><a href="#我想撤销rebase-x2F-merge" class="headerlink" title="我想撤销rebase&#x2F;merge"></a>我想撤销rebase&#x2F;merge</h3><p>你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase&#x2F;merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase&#x2F;merge前的状态是很容易的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git reset --hard ORIG_HEAD</span><br></pre></td></tr></table></figure><p><a name="force-push-rebase"></a></p><h3 id="我已经rebase过-但是我不想强推-force-push"><a href="#我已经rebase过-但是我不想强推-force-push" class="headerlink" title="我已经rebase过, 但是我不想强推(force push)"></a>我已经rebase过, 但是我不想强推(force push)</h3><p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(master)git checkout my-branch</span><br><span class="line">(my-branch)git rebase -i master</span><br><span class="line">(my-branch)git checkout master</span><br><span class="line">(master)git merge --ff-only my-branch</span><br></pre></td></tr></table></figure><p>更多, 参见 <a href="http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push">this SO thread</a>.</p><p><a name="interactive-rebase"></a></p><h3 id="我需要组合-combine-几个提交-commit"><a href="#我需要组合-combine-几个提交-commit" class="headerlink" title="我需要组合(combine)几个提交(commit)"></a>我需要组合(combine)几个提交(commit)</h3><p>假设你的工作分支将会做对于 <code>master</code> 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 <em>所有</em> 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git reset --soft master</span><br><span class="line">(my-branch)git commit -am <span class="string">&quot;New awesome feature&quot;</span></span><br></pre></td></tr></table></figure><p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git rebase -i master</span><br></pre></td></tr></table></figure><p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD~2</code> 进行rebase， 组合最近3次提交(commit), 相对于<code>HEAD~3</code>, 等等。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">pick b729ad5 fixup</span><br><span class="line">pick e3851e8 another <span class="keyword">fix</span></span><br><span class="line"></span><br><span class="line"># Rebase <span class="number">8074</span>d12..b729ad5 onto <span class="number">8074</span>d12</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  <span class="keyword">p</span>, pick = use commit</span><br><span class="line">#  r, reword = use commit, but <span class="keyword">edit</span> the commit message</span><br><span class="line">#  <span class="keyword">e</span>, <span class="keyword">edit</span> = use commit, but <span class="keyword">stop</span> <span class="keyword">for</span> amending</span><br><span class="line">#  s, squash = use commit, but meld into <span class="keyword">previous</span> commit</span><br><span class="line">#  <span class="keyword">f</span>, fixup = like <span class="string">&quot;squash&quot;</span>, but discard this commit<span class="string">&#x27;s log message</span></span><br><span class="line"><span class="string">#  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p><p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p><p>例如, 如果你想 <strong>单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面</strong>, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line"><span class="keyword">f</span> b729ad5 fixup</span><br><span class="line"><span class="keyword">f</span> e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure><p>如果你想组合这些提交(commit) <strong>并重命名这个提交(commit)</strong>, 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">s b729ad5 fixup</span><br><span class="line">s e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure><p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Newer, awesomer features</span><br><span class="line"></span><br><span class="line"># Please enter the commit message <span class="keyword">for</span> your <span class="keyword">changes</span>. Lines starting</span><br><span class="line"># with <span class="string">&#x27;#&#x27;</span> will <span class="keyword">be</span> ignored, <span class="built_in">and</span> <span class="keyword">an</span> <span class="built_in">empty</span> message aborts the commit.</span><br><span class="line"># rebase in progress; onto <span class="number">8074</span>d12</span><br><span class="line"># You are currently editing <span class="keyword">a</span> commit <span class="keyword">while</span> rebasing branch <span class="string">&#x27;master&#x27;</span> <span class="keyword">on</span> <span class="string">&#x27;8074d12&#x27;</span>.</span><br><span class="line">#</span><br><span class="line"># Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">#modified:   README.md</span><br><span class="line">#</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果成功了, 你应该看到类似下面的内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure><h4 id="安全合并-merging-策略"><a href="#安全合并-merging-策略" class="headerlink" title="安全合并(merging)策略"></a>安全合并(merging)策略</h4><p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 <code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git merge --no-ff --no-commit my-branch</span><br></pre></td></tr></table></figure><h4 id="我需要将一个分支合并成一个提交-commit"><a href="#我需要将一个分支合并成一个提交-commit" class="headerlink" title="我需要将一个分支合并成一个提交(commit)"></a>我需要将一个分支合并成一个提交(commit)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git merge --squash my-branch</span><br></pre></td></tr></table></figure><p><a name="rebase-unpushed-commits"></a></p><h4 id="我只想组合-combine-未推的提交-unpushed-commit"><a href="#我只想组合-combine-未推的提交-unpushed-commit" class="headerlink" title="我只想组合(combine)未推的提交(unpushed commit)"></a>我只想组合(combine)未推的提交(unpushed commit)</h4><p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git rebase -i @&#123;u&#125;</span><br></pre></td></tr></table></figure><p>这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder&#x2F;fix&#x2F;squash 都是安全的。</p><p><a name="check-if-all-commits-on-a-branch-are-merged"></a></p><h3 id="检查是否分支上的所有提交-commit-都合并-merge-过了"><a href="#检查是否分支上的所有提交-commit-都合并-merge-过了" class="headerlink" title="检查是否分支上的所有提交(commit)都合并(merge)过了"></a>检查是否分支上的所有提交(commit)都合并(merge)过了</h3><p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git <span class="built_in">log</span> --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll</span><br></pre></td></tr></table></figure><p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git <span class="built_in">log</span> master ^feature/120-on-scroll --no-merges</span><br></pre></td></tr></table></figure><h3 id="交互式rebase-interactive-rebase-可能出现的问题"><a href="#交互式rebase-interactive-rebase-可能出现的问题" class="headerlink" title="交互式rebase(interactive rebase)可能出现的问题"></a>交互式rebase(interactive rebase)可能出现的问题</h3><p><a name="noop"></a></p><h4 id="这个rebase-编辑屏幕出现’noop’"><a href="#这个rebase-编辑屏幕出现’noop’" class="headerlink" title="这个rebase 编辑屏幕出现’noop’"></a>这个rebase 编辑屏幕出现’noop’</h4><p>如果你看到的是这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noop</span><br></pre></td></tr></table></figure><p>这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 <em>领先(ahead)</em> 当前分支。 你可以尝试:</p><ul><li>检查确保主(master)分支没有问题</li><li>rebase  <code>HEAD~2</code> 或者更早</li></ul><p><a name="merge-conflict"></a></p><h4 id="有冲突的情况"><a href="#有冲突的情况" class="headerlink" title="有冲突的情况"></a>有冲突的情况</h4><p>如果你不能成功的完成rebase, 你可能必须要解决冲突。</p><p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git status</span><br><span class="line">On branch my-branch</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br></pre></td></tr></table></figure><p>在这个例子里面, <code>README.md</code> 有冲突。 打开这个文件找到类似下面的内容:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">some code</span><br><span class="line">=========</span><br><span class="line">some code</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="keyword">new</span>-commit</span><br></pre></td></tr></table></figure><p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p><p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master*)git mergetool -t opendiff</span><br></pre></td></tr></table></figure><p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续rebase。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git add README.md</span><br><span class="line">(my-branch)git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p><p>任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)git rebase --abort</span><br></pre></td></tr></table></figure><p><a name="miscellaneous-objects"></a></p><h2 id="杂项-Miscellaneous-Objects"><a href="#杂项-Miscellaneous-Objects" class="headerlink" title="杂项(Miscellaneous Objects)"></a>杂项(Miscellaneous Objects)</h2><p><a name="clone-submodules"></a></p><h3 id="克隆所有子模块"><a href="#克隆所有子模块" class="headerlink" title="克隆所有子模块"></a>克隆所有子模块</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive git://github.com/foo/bar.git</span><br></pre></td></tr></table></figure><p>如果已经克隆了:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p><a name="delete-tag"></a></p><h3 id="删除标签-tag"><a href="#删除标签-tag" class="headerlink" title="删除标签(tag)"></a>删除标签(tag)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tag_name&gt;</span><br><span class="line">git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt;</span><br></pre></td></tr></table></figure><p><a name="recover-tag"></a></p><h3 id="恢复已删除标签-tag"><a href="#恢复已删除标签-tag" class="headerlink" title="恢复已删除标签(tag)"></a>恢复已删除标签(tag)</h3><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fsck --unreachable | grep tag</span><br></pre></td></tr></table></figure><p>记下这个标签(tag)的hash，然后用Git的 <a href="http://git-scm.com/docs/git-update-ref">update-ref</a>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref refs/tags/&lt;tag_name&gt; &lt;<span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure><p>这时你的标签(tag)应该已经恢复了。</p><p><a name="deleted-patch"></a></p><h3 id="已删除补丁-patch"><a href="#已删除补丁-patch" class="headerlink" title="已删除补丁(patch)"></a>已删除补丁(patch)</h3><p>如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p><p>做完提交后, 再修改作者，参见<a href="#commit-wrong-author">变更作者</a>。 然后, 应用变化, 再发起一个新的pull request。</p><h2 id="跟踪文件-Tracking-Files"><a href="#跟踪文件-Tracking-Files" class="headerlink" title="跟踪文件(Tracking Files)"></a>跟踪文件(Tracking Files)</h2><p><a href="i-want-to-change-a-file-names-capitalization-without-changing-the-contents-of-the-file"></a></p><h3 id="我只想改变一个文件名字的大小写，而不修改内容"><a href="#我只想改变一个文件名字的大小写，而不修改内容" class="headerlink" title="我只想改变一个文件名字的大小写，而不修改内容"></a>我只想改变一个文件名字的大小写，而不修改内容</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git <span class="built_in">mv</span> --force myfile MyFile</span><br></pre></td></tr></table></figure><p><a href="remove-from-git"></a></p><h3 id="我想从Git删除一个文件，但保留该文件"><a href="#我想从Git删除一个文件，但保留该文件" class="headerlink" title="我想从Git删除一个文件，但保留该文件"></a>我想从Git删除一个文件，但保留该文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)git <span class="built_in">rm</span> --cached log.txt</span><br></pre></td></tr></table></figure><h2 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h2><p><a name="adding-command-aliases"></a></p><h3 id="我想给一些Git命令添加别名-alias"><a href="#我想给一些Git命令添加别名-alias" class="headerlink" title="我想给一些Git命令添加别名(alias)"></a>我想给一些Git命令添加别名(alias)</h3><p>在 OS X 和 Linux 下, 你的 Git的配置文件储存在 <code>~/.gitconfig</code>。我在<code>[alias]</code> 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">    <span class="keyword">a</span> = <span class="built_in">add</span></span><br><span class="line">    amend = commit --amend</span><br><span class="line">    <span class="keyword">c</span> = commit</span><br><span class="line">    <span class="keyword">ca</span> = commit --amend</span><br><span class="line">    ci = commit -<span class="keyword">a</span></span><br><span class="line">    <span class="keyword">co</span> = checkout</span><br><span class="line">    d = diff</span><br><span class="line">    dc = diff --changed</span><br><span class="line">    <span class="keyword">ds</span> = diff --staged</span><br><span class="line">    <span class="keyword">f</span> = fetch</span><br><span class="line">    loll = <span class="built_in">log</span> --graph --decorate --pretty=oneline --abbrev-commit</span><br><span class="line">    <span class="keyword">m</span> = merge</span><br><span class="line">    one = <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">    outstanding = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    s = status</span><br><span class="line">    unpushed = <span class="built_in">log</span> @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    wc = whatchanged</span><br><span class="line">    wip = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    zap = fetch -<span class="keyword">p</span></span><br></pre></td></tr></table></figure><p><a name="credential-helper"></a></p><h3 id="我想缓存一个仓库-repository-的用户名和密码"><a href="#我想缓存一个仓库-repository-的用户名和密码" class="headerlink" title="我想缓存一个仓库(repository)的用户名和密码"></a>我想缓存一个仓库(repository)的用户名和密码</h3><p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推&#x2F;拉(push&#x2F;pull)的时候都输入，Credential helper能帮你。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br><span class="line"><span class="comment"># Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper <span class="string">&#x27;cache --timeout=3600&#x27;</span></span><br><span class="line"><span class="comment"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure><p><a href="#ive-no-idea-what-i-did-wrong"></a></p><h2 id="我不知道我做错了些什么"><a href="#我不知道我做错了些什么" class="headerlink" title="我不知道我做错了些什么"></a>我不知道我做错了些什么</h2><p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p><p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(master)git reflog</span><br><span class="line">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD~2</span><br><span class="line">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class="line">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure><p>上面的reflog展示了从master分支签出(checkout)到2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@&#123;0&#125;</code>标识.</p><p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前master上指向的提交(0254ea7)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 0254ea7</span><br></pre></td></tr></table></figure><p>然后使用git reset就可以把master改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。</p><p>(<a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-reflog">摘自</a>).</p><h1 id="其它资源-Other-Resources"><a href="#其它资源-Other-Resources" class="headerlink" title="其它资源(Other Resources)"></a>其它资源(Other Resources)</h1><h2 id="书-Books"><a href="#书-Books" class="headerlink" title="书(Books)"></a>书(Books)</h2><ul><li><a href="https://git-scm.com/book/en/v2">Pro Git</a> - Scott Chacon’s excellent git book</li><li><a href="https://github.com/pluralsight/git-internals-pdf">Git Internals</a> - Scott Chacon’s other excellent git book</li></ul><h2 id="教程-Tutorials"><a href="#教程-Tutorials" class="headerlink" title="教程(Tutorials)"></a>教程(Tutorials)</h2><ul><li><a href="https://learngitbranching.js.org/">Learn Git branching</a> 一个基于网页的交互式 branching&#x2F;merging&#x2F;rebasing 教程</li><li><a href="https://medium.com/@porteneuve/getting-solid-at-git-rebase-vs-merge-4fa1a48c53aa">Getting solid at Git rebase vs. merge</a></li><li><a href="https://github.com/asmeurer/git-workflow">git-workflow</a> - <a href="https://github.com/asmeurer">Aaron Meurer</a>的怎么使用Git为开源仓库贡献</li><li><a href="http://hugogiraudel.com/2015/08/13/github-as-a-workflow/">GitHub as a workflow</a> - 使用GitHub做为工作流的趣事, 尤其是空PRs</li></ul><h2 id="脚本和工具-Scripts-and-Tools"><a href="#脚本和工具-Scripts-and-Tools" class="headerlink" title="脚本和工具(Scripts and Tools)"></a>脚本和工具(Scripts and Tools)</h2><ul><li><a href="http://firstaidgit.io/">firstaidgit.io</a> 一个可搜索的最常被问到的Git的问题</li><li><a href="https://github.com/unixorn/git-extra-commands">git-extra-commands</a> - 一堆有用的额外的Git脚本</li><li><a href="https://github.com/tj/git-extras">git-extras</a> - GIT 工具集 – repo summary, repl, changelog population, author commit percentages and more</li><li><a href="https://github.com/qw3rtman/git-fire">git-fire</a> - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。</li><li><a href="https://github.com/git-tips/tips">git-tips</a> - Git小提示</li><li><a href="https://github.com/Originate/git-town">git-town</a> - 通用，高级Git工作流支持！ <a href="http://www.git-town.com/">http://www.git-town.com</a></li></ul><h2 id="GUI客户端-GUI-Clients"><a href="#GUI客户端-GUI-Clients" class="headerlink" title="GUI客户端(GUI Clients)"></a>GUI客户端(GUI Clients)</h2><ul><li><a href="https://www.gitkraken.com/">GitKraken</a> - 豪华的Git客户端 Windows, Mac &amp; Linux</li><li><a href="https://git-cola.github.io/">git-cola</a> - 另外一个Git客户端 Windows &amp; OS X</li><li><a href="https://github.com/git-up/GitUp">GitUp</a> - 一个新的Git客户端，在处理Git的复杂性上有自己的特点</li><li><a href="https://rowanj.github.io/gitx/">gitx-dev</a> - 图形化的Git客户端 OS X</li><li><a href="https://www.sourcetreeapp.com/">Source Tree</a> - 免费的图形化Git客户端 Windows &amp; OS X</li><li><a href="http://www.git-tower.com/">Tower</a> - 图形化Git客户端 OS X(付费)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 操作 (一)</title>
      <link href="/2018/git_step_1/index/"/>
      <url>/2018/git_step_1/index/</url>
      
        <content type="html"><![CDATA[<h1 id="Git的奇技淫巧-see-no-evil"><a href="#Git的奇技淫巧-see-no-evil" class="headerlink" title="Git的奇技淫巧:see_no_evil:"></a>Git的奇技淫巧:see_no_evil:</h1><blockquote><p>Git常用命令集合，Fork于<a href="https://github.com/git-tips/tips">tips</a>项目</p></blockquote><p>Git是一个“分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过“回撤”这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用“回撤”是找不回来的。而“版本管理工具”能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。</p><p>下面的内容就是列举了常用的Git命令和一些小技巧，可以通过”页面内查找”的方式进行快速查询：<code>Ctrl/Command+f</code>。</p><h2 id="开卷必读"><a href="#开卷必读" class="headerlink" title="开卷必读"></a>开卷必读</h2><p><em>如果之前未使用过Git，可以学习<a href="/posts/Tips/Git/2018-12-08-git_step.html">Git小白教程</a>入门</em></p><ol><li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li><li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li><li>统一概念：<ul><li>工作区：改动（增删文件和内容）</li><li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了‘暂存区’</li><li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。</li><li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了‘远程仓库’（GitHub等)</li><li>commit-id：输出命令：<code>git log</code>，最上面那行<code>commit xxxxxx</code>，后面的字符串就是commit-id</li></ul></li><li>如果喜欢这个项目，欢迎Star、提交Pr、<a href="https://github.com/521xueweihan/git-tips/issues">反馈问题</a>😊</li></ol><h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> -g</span><br></pre></td></tr></table></figure><h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master</span><br></pre></td></tr></table></figure><h2 id="重设第一个commit"><a href="#重设第一个commit" class="headerlink" title="重设第一个commit"></a>重设第一个commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的commit</strong>，这样就可以重新提交第一个commit了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref -d HEAD</span><br></pre></td></tr></table></figure><h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的different(不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>还可以展示本地仓库中任意两个commit之间的文件变动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本(commit)的different(不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本(commit)的different(不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v <span class="string">&#x27;^\*\|  master&#x27;</span> | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code>就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/mybranch</span><br></pre></td></tr></table></figure><p>或者在push时加上<code>-u</code>参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin/mybranch -u</span><br></pre></td></tr></table></figure><h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r参数相当于：remote</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;local-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>展示当前分支的最近的tag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --tags --abbrev=0</span><br></pre></td></tr></table></figure><h2 id="查看标签详细信息"><a href="#查看标签详细信息" class="headerlink" title="查看标签详细信息"></a>查看标签详细信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -ln</span><br></pre></td></tr></table></figure><h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;version-number&gt;</span><br></pre></td></tr></table></figure><p>默认tag是打在最近的一次commit上，如果需要指定commit打tag：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;version-number&gt; -m <span class="string">&quot;v1.0 发布(描述)&quot;</span> &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;local-version-number&gt;</span><br></pre></td></tr></table></figure><p>一次性推送所有标签，同步到远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure><h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure><p>放弃所有修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rev-list -n 1 HEAD -- &lt;file_path&gt; <span class="comment">#得到 deleting_commit</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; <span class="comment">#回到删除文件 deleting_commit 之前的状态</span></span><br></pre></td></tr></table></figure><h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和revert的区别：reset命令会抹去某个commit id之后的所有commit</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  <span class="comment">#默认就是-mixed参数。</span></span><br><span class="line"></span><br><span class="line">git reset –mixed HEAD^  <span class="comment">#回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span></span><br><span class="line"></span><br><span class="line">git reset –soft HEAD~3  <span class="comment">#回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  </span></span><br><span class="line"></span><br><span class="line">git reset –hard &lt;commit-id&gt;  <span class="comment">#彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span></span><br></pre></td></tr></table></figure><h2 id="修改上一个commit的描述"><a href="#修改上一个commit的描述" class="headerlink" title="修改上一个commit的描述"></a>修改上一个commit的描述</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="查看commit历史"><a href="#查看commit历史" class="headerlink" title="查看commit历史"></a>查看commit历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame的意思为‘责怪’，你懂的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="显示本地更新过HEAD的git命令记录"><a href="#显示本地更新过HEAD的git命令记录" class="headerlink" title="显示本地更新过HEAD的git命令记录"></a>显示本地更新过HEAD的git命令记录</h2><p>每次更新了HEAD 的git 命令比如 commint、amend、cherry-pick、reset、revert等都会被记录下来（不限分支），就像shell的history一样。<br>这样你可以reset 到任何一次更新了HEAD 的操作之后，而不仅仅是回到当前分支下的某个commit 之后的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author=<span class="string">&#x27;Author Name &lt;email@address.com&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git whatchanged --since=<span class="string">&#x27;2 weeks ago&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="把A分支的某一个commit，放到B分支上"><a href="#把A分支的某一个commit，放到B分支上" class="headerlink" title="把A分支的某一个commit，放到B分支上"></a>把A分支的某一个commit，放到B分支上</h2><p>这个过程需要<code>cherry-pick</code>命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928">参考</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="给git命令起别名"><a href="#给git命令起别名" class="headerlink" title="给git命令起别名"></a>给git命令起别名</h2><p>简化命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="built_in">alias</span>.&lt;handle&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">比如：git status 改成 git st，这样可以简化命令</span><br><span class="line"></span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><h2 id="存储当前的修改，但不用提交commit"><a href="#存储当前的修改，但不用提交commit" class="headerlink" title="存储当前的修改，但不用提交commit"></a>存储当前的修改，但不用提交commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000">廖雪峰老师的git教程</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><h2 id="保存当前状态，包括untracked的文件"><a href="#保存当前状态，包括untracked的文件" class="headerlink" title="保存当前状态，包括untracked的文件"></a>保存当前状态，包括untracked的文件</h2><p>untracked文件：新建的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure><h2 id="展示所有stashes"><a href="#展示所有stashes" class="headerlink" title="展示所有stashes"></a>展示所有stashes</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><h2 id="回到某个stash的状态"><a href="#回到某个stash的状态" class="headerlink" title="回到某个stash的状态"></a>回到某个stash的状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br></pre></td></tr></table></figure><h2 id="回到最后一个stash的状态，并删除这个stash"><a href="#回到最后一个stash的状态，并删除这个stash" class="headerlink" title="回到最后一个stash的状态，并删除这个stash"></a>回到最后一个stash的状态，并删除这个stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h2 id="删除所有的stash"><a href="#删除所有的stash" class="headerlink" title="删除所有的stash"></a>删除所有的stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="从stash中拿出某个文件的修改"><a href="#从stash中拿出某个文件的修改" class="headerlink" title="从stash中拿出某个文件的修改"></a>从stash中拿出某个文件的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure><h2 id="展示所有tracked的文件"><a href="#展示所有tracked的文件" class="headerlink" title="展示所有tracked的文件"></a>展示所有tracked的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -t</span><br></pre></td></tr></table></figure><h2 id="展示所有untracked的文件"><a href="#展示所有untracked的文件" class="headerlink" title="展示所有untracked的文件"></a>展示所有untracked的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure><h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure><h2 id="强制删除untracked的文件"><a href="#强制删除untracked的文件" class="headerlink" title="强制删除untracked的文件"></a>强制删除untracked的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。<code>clean</code>命令，<strong>注意两点</strong>：</p><ol><li>clean后，删除的文件无法找回</li><li>不会影响tracked的文件的改动，只会删除untracked的文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;file-name&gt; -f</span><br></pre></td></tr></table></figure><h2 id="强制删除untracked的目录"><a href="#强制删除untracked的目录" class="headerlink" title="强制删除untracked的目录"></a>强制删除untracked的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除untracked的文件。详情见上一条</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;directory-name&gt; -<span class="built_in">df</span></span><br></pre></td></tr></table></figure><h2 id="展示简化的commit历史"><a href="#展示简化的commit历史" class="headerlink" title="展示简化的commit历史"></a>展示简化的commit历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面<code>git bundle create</code>命令导出的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="执行rebase之前自动stash"><a href="#执行rebase之前自动stash" class="headerlink" title="执行rebase之前自动stash"></a>执行rebase之前自动stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --autostash</span><br></pre></td></tr></table></figure><h2 id="从远程仓库根据ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据ID，拉下某一状态，到本地分支"></a>从远程仓库根据ID，拉下某一状态，到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin pull/&lt;<span class="built_in">id</span>&gt;/head:&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --word-diff</span><br></pre></td></tr></table></figure><h2 id="清除gitignore文件中记录的文件"><a href="#清除gitignore文件中记录的文件" class="headerlink" title="清除gitignore文件中记录的文件"></a>清除gitignore文件中记录的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -X -f</span><br></pre></td></tr></table></figure><h2 id="展示所有alias和configs"><a href="#展示所有alias和configs" class="headerlink" title="展示所有alias和configs"></a>展示所有alias和configs</h2><p><strong>注意：</strong> config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --list (当前目录)</span><br><span class="line">git config --global --list (全局)</span><br></pre></td></tr></table></figure><h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status --ignored</span><br></pre></td></tr></table></figure><h2 id="commit历史中显示Branch1有的，但是Branch2没有commit"><a href="#commit历史中显示Branch1有的，但是Branch2没有commit" class="headerlink" title="commit历史中显示Branch1有的，但是Branch2没有commit"></a>commit历史中显示Branch1有的，但是Branch2没有commit</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> Branch1 ^Branch2</span><br></pre></td></tr></table></figure><h2 id="在commit-log中显示GPG签名"><a href="#在commit-log中显示GPG签名" class="headerlink" title="在commit log中显示GPG签名"></a>在commit log中显示GPG签名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --show-signature</span><br></pre></td></tr></table></figure><h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> &lt;entry-name&gt;</span><br></pre></td></tr></table></figure><h2 id="新建并切换到新分支上，同时这个分支没有任何commit"><a href="#新建并切换到新分支上，同时这个分支没有任何commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何commit"></a>新建并切换到新分支上，同时这个分支没有任何commit</h2><p>相当于保存修改，但是重写commit历史</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;branch-name&gt;:&lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="clone下来指定的单一分支"><a href="#clone下来指定的单一分支" class="headerlink" title="clone下来指定的单一分支"></a>clone下来指定的单一分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</span><br></pre></td></tr></table></figure><h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged path/to/file</span><br></pre></td></tr></table></figure><p>恢复 track 指定文件的改动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --no-assume-unchanged path/to/file</span><br></pre></td></tr></table></figure><h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.fileMode <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="以最后提交的顺序列出所有Git分支"><a href="#以最后提交的顺序列出所有Git分支" class="headerlink" title="以最后提交的顺序列出所有Git分支"></a>以最后提交的顺序列出所有Git分支</h2><p>最新的放在最上面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git for-each-ref --<span class="built_in">sort</span>=-committerdate --format=<span class="string">&#x27;%(refname:short)&#x27;</span> refs/heads/</span><br></pre></td></tr></table></figure><h2 id="在commit-log中查找相关内容"><a href="#在commit-log中查找相关内容" class="headerlink" title="在commit log中查找相关内容"></a>在commit log中查找相关内容</h2><p>通过grep查找，given-text：所需要查找的字段</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --grep=<span class="string">&#x27;&lt;given-text&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h2><p>不添加参数，默认是-mixed</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 操作</title>
      <link href="/2018/git_step/index/"/>
      <url>/2018/git_step/index/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://git-scm.com/download/mac">下载 git OSX 版</a></p><p><a href="http://git-for-windows.github.io/">下载 git Windows 版</a></p><p><a href="http://book.git-scm.com/2_installing_git.html">下载 git Linux 版</a></p><p>&#x3D;&#x3D;&#x3D;</p><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新文件夹，打开，然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>以创建新的 git 仓库。</p><p>&#x3D;&#x3D;</p><h2 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h2><p>执行如下命令以创建一个本地仓库的克隆版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /path/to/repository</span><br></pre></td></tr></table></figure><p>如果是远端服务器上的仓库，你的命令会是这个样子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> username@host:/path/to/repository</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的<code>工作目录</code>，它持有实际文件；第二个是<code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是<code>HEAD</code>，它指向你最后一次提交的结果。<br><img src="/img/img/git_step/trees.png"></p><p>&#x3D;&#x3D;&#x3D;</p><h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><p>你可以提出更改（把它们添加到暂存区），使用如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加文件 filename</span></span><br><span class="line">git add &lt;filename&gt;</span><br><span class="line"><span class="comment"># 添加所有文件</span></span><br><span class="line">git add *</span><br></pre></td></tr></table></figure><p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;代码提交信息&quot;</span></span><br></pre></td></tr></table></figure><p>现在，你的改动已经提交到了<code>HEAD</code>，但是还没到你的远端仓库。</p><p>&#x3D;&#x3D;</p><h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>可以把<code>master</code>换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><p>&#x3D;&#x3D;&#x3D;</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。<br><img src="/img/img/git_step/branches.png"></p><p>&#x3D;&#x3D;</p><p>创建一个叫做“feature_x”的分支，并切换过去：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换回主分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>再把新建的分支删掉：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;</p><h2 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h2><p>要更新你的本地仓库至最新改动，执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>以在你的工作目录中 获取(fetch)并合并(merge)远端的改动。<br>要合并其他分支到你的当前分支（例如<code>master</code>），执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;</p><p>在这两种情况下，git都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>在合并改动之前，你可以使用如下命令预览差异：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 1.0.0 1b2e1d63ff</span><br></pre></td></tr></table></figure><p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。</p><p>&#x3D;&#x3D;&#x3D;</p><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><h1 id="如果你想了解本地仓库的历史记录，最简单的命令就是使用-你可以添加一些参数来修改他的输出，从而得到自己想要的结果。-只看某一个人的提交记录-一个压缩后的每一条提交记录只占一行的输出"><a href="#如果你想了解本地仓库的历史记录，最简单的命令就是使用-你可以添加一些参数来修改他的输出，从而得到自己想要的结果。-只看某一个人的提交记录-一个压缩后的每一条提交记录只占一行的输出" class="headerlink" title="如果你想了解本地仓库的历史记录，最简单的命令就是使用:你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:一个压缩后的每一条提交记录只占一行的输出:"></a>如果你想了解本地仓库的历史记录，最简单的命令就是使用:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><br>你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=bob</span><br></pre></td></tr></table></figure><br>一个压缩后的每一条提交记录只占一行的输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure></h1><p>或者你想通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure><p>看看哪些文件改变了:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --name-status</span><br></pre></td></tr></table></figure><p>这些只是你可以使用的参数中很小的一部分。更多的信息，参考：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;</p><h2 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h2><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;</p><h3 id="实用小贴士"><a href="#实用小贴士" class="headerlink" title="实用小贴士"></a>实用小贴士</h3><p>内建的图形化 git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure><p>彩色的 git 输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>显示历史记录时，每个提交的信息只显示一行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config format.pretty oneline</span><br></pre></td></tr></table></figure><p>交互式添加文件到暂存区：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;</p><h1 id="链接与资源"><a href="#链接与资源" class="headerlink" title="链接与资源"></a>链接与资源</h1><p>&#x3D;&#x3D;</p><h3 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h3><p><a href="http://gitx.laullon.com/">GitX (L) (OSX, 开源软件)</a><br><a href="http://www.git-tower.com/">Tower (OSX)</a><br><a href="http://www.sourcetreeapp.com/">Source Tree (OSX, 免费)</a><br><a href="http://mac.github.com/">GitHub for Mac (OSX, 免费)</a><br><a href="https://itunes.apple.com/gb/app/gitbox/id403388357?mt=12">GitBox (OSX, App Store)</a></p><p>&#x3D;&#x3D;</p><h3 id="指南和手册"><a href="#指南和手册" class="headerlink" title="指南和手册"></a>指南和手册</h3><p><a href="http://book.git-scm.com/">Git 社区参考书</a><br><a href="http://progit.org/book/">专业 Git</a><br><a href="http://think-like-a-git.net/">像 git 那样思考</a><br><a href="http://help.github.com/">GitHub 帮助</a><br><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList与LinkedList遍历性能比较</title>
      <link href="/2018/arratlist-linkedlist-performance/index/"/>
      <url>/2018/arratlist-linkedlist-performance/index/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为前段时间去了一个同学给介绍的企业去面试，然后面试官问了我这个问题，我之前有看过相关的博客，不过当时一时没有想起来，回来就自己试试咯。<br>以下是正文</p></blockquote><p>用实例测试ArrayList与LinkedList遍历性能。</p><h2 id="结构差别"><a href="#结构差别" class="headerlink" title="结构差别:"></a>结构差别:</h2><p>我们常用的List有两种，ArrayList和LinkedList，虽然两者都是LIst，但由于内部存储结构的不同，使用不同的遍历方法性能却是千差万别的。</p><table><thead><tr><th>List</th><th>存储结构</th><th>特点</th></tr></thead><tbody><tr><td>ArrayList</td><td>数组结构</td><td>可以根据下标直接取值。</td></tr><tr><td>LinkedList</td><td>链表结构</td><td>如果需要寻找某一个下标的数值必须从头遍历。</td></tr></tbody></table><h2 id="常见做法"><a href="#常见做法" class="headerlink" title="常见做法:"></a>常见做法:</h2><p>我们在遍历List的时候可能会这样做(从C语言上带来的习惯):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopList</span><span class="params">(List&lt;Integer&gt; lists)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; lists.size(); i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> lists.get(i);</span><br><span class="line">        <span class="comment">// TODO 处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法很直观，乍一看并没有什么问题，但是仔细分析一下就能知道，在这种情况下使用ArrayList与LinkedList性能是完全不同的。</p><table><thead><tr><th>List</th><th align="center">循环时间复杂度</th><th align="center">get(i)时间复杂度</th><th align="center">总时间复杂度</th></tr></thead><tbody><tr><td>ArrayList</td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">O(n)</td></tr><tr><td>LinkedList</td><td align="center">O(n)</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td></tr></tbody></table><p>从时间复杂度上两者就直接差了一个数量级，可能这样说不明显，为了直观的表示，下面用代码测试处理10000条数据效率:</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试:"></a>性能测试:</h3><p>创建数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">    arrayList.add(i);</span><br><span class="line">    linkedList.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试For循环用时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> startTime1=System.currentTimeMillis();   <span class="comment">//获取开始时间</span></span><br><span class="line">loopList(arrayList);</span><br><span class="line">iteratorList(arrayList);</span><br><span class="line"><span class="type">long</span> endTime1=System.currentTimeMillis(); <span class="comment">//获取结束时间</span></span><br><span class="line">Log.i(<span class="string">&quot;Time&quot;</span>, <span class="string">&quot;For-ArrayList： &quot;</span>+(endTime1-startTime1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> startTime2=System.currentTimeMillis();   <span class="comment">//获取开始时间</span></span><br><span class="line">loopList(linkedList);</span><br><span class="line"><span class="type">long</span> endTime2=System.currentTimeMillis(); <span class="comment">//获取结束时间</span></span><br><span class="line">Log.i(<span class="string">&quot;Time&quot;</span>, <span class="string">&quot;For-LinkedList：&quot;</span>+(endTime2-startTime2)+<span class="string">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.gcssloop.alltest I/Time: For-ArrayList： 20ms</span><br><span class="line">com.gcssloop.alltest I/Time: For-LinkedList：648ms</span><br></pre></td></tr></table></figure><p>可以看到，仅仅处理10000条数据两者所需时间简直不能比较，当数据量越来越大的时候，LinkedList必然会耗费更多时间。</p><h2 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法:"></a>处理办法:</h2><p>我们在Java中有 迭代器(Iterator) 以及 ForEach 循环，可以用它们来替代掉这个原始的 for 循环。</p><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator):"></a>迭代器(Iterator):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iteratorList</span><span class="params">(List&lt;Integer&gt; lists)</span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; it = lists.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> it.next();</span><br><span class="line">        <span class="comment">// TODO 处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码与上面类似，就省略了。</p><p>结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.gcssloop.alltest I/Time: Iterator-ArrayList： 4ms</span><br><span class="line">com.gcssloop.alltest I/Time: Iterator-LinkedList：6ms</span><br></pre></td></tr></table></figure><p><strong>可以看到，两者最终耗费时间差不多而且均有大幅度提升。</strong></p><h3 id="ForEach循环"><a href="#ForEach循环" class="headerlink" title="ForEach循环:"></a>ForEach循环:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foreachList</span><span class="params">(List&lt;Integer&gt; lists)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : lists) &#123;</span><br><span class="line">        <span class="comment">// TODO 处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.gcssloop.alltest I/Time: ForEach-ArrayList： 5ms</span><br><span class="line">com.gcssloop.alltest I/Time: ForEach-LinkedList：5ms</span><br></pre></td></tr></table></figure><p>由于 ForEach 循环底层使用的也是迭代器，所以和迭代器性能类似。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><strong>推荐使用 迭代器(Iterator) 和 ForEach 遍历 List，不要使用传统的 For 循环。</strong></p><p>以下是测试处理10000条数据性能:</p><blockquote><p>数值仅供参考，与运行环境相关，每次测试结果都可能稍有差别。</p></blockquote><table><thead><tr><th align="center">迭代方式</th><th align="center">ArrayList</th><th align="center">LinkedList</th></tr></thead><tbody><tr><td align="center">For循环</td><td align="center">20ms</td><td align="center">648ms</td></tr><tr><td align="center">Iterator</td><td align="center">4ms</td><td align="center">6ms</td></tr><tr><td align="center">for-each循环</td><td align="center">5ms</td><td align="center">5ms</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Java </category>
          
          <category> List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发最佳实践</title>
      <link href="/2018/android-best-practices/index/"/>
      <url>/2018/android-best-practices/index/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-开发最佳实践"><a href="#Android-开发最佳实践" class="headerlink" title="Android 开发最佳实践"></a>Android 开发最佳实践</h1><blockquote><p>原文地址:<a href="https://github.com/futurice/android-best-practices">android-best-practices</a></p></blockquote><p>从<a href="http://www.futurice.com/">Futurice</a>公司Android开发者中学到的经验。<br>遵循以下准则，避免重复发明轮子。若你对开发iOS或Windows Phone 有兴趣，<br>请看<a href="https://github.com/futurice/ios-good-practices"><strong>iOS Good Practices</strong></a> 和 <a href="https://github.com/futurice/win-client-dev-good-practices"><strong>Windows client Good Practices</strong></a> 这两篇文章。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>使用 Gradle 和它推荐的工程结构</li><li>把密码和敏感数据放在gradle.properties</li><li>不要自己写 HTTP 客户端,使用Volley或OkHttp库</li><li>使用Jackson库解析JSON数据</li><li>避免使用Guava同时使用一些类库来避免<em>65k method limit</em>（一个Android程序中最多能执行65536个方法）</li><li>使用 Fragments来呈现UI视图</li><li>使用 Activities 只是为了管理 Fragments</li><li>Layout 布局是 XMLs代码，组织好它们</li><li>在layoutout XMLs布局时，使用styles文件来避免使用重复的属性</li><li>使用多个style文件来避免单一的一个大style文件</li><li>保持你的colors.xml 简短DRY(不要重复自己)，只是定义调色板</li><li>总是使用dimens.xml DRY(不要重复自己)，定义通用常数</li><li>不要做一个深层次的ViewGroup</li><li>在使用WebViews时避免在客户端做处理，当心内存泄露</li><li>使用Robolectric单元测试，Robotium 做UI测试</li><li>使用Genymotion 作为你的模拟器</li><li>总是使用ProGuard 和 DexGuard混淆来项目</li></ul><h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p>将你的<a href="https://developer.android.com/sdk/installing/index.html?pkg=tools">Android SDK</a>放在你的home目录或其他应用程序无关的位置。<br>当安装有些包含SDK的IDE的时候，可能会将SDK放在IDE同一目录下，当你需要升级（或重新安装）IDE或更换的IDE时，会非常麻烦。<br>此外，如果你的IDE是在普通用户下运行，而不是在root下运行，还要避免把SDK放到一下需要sudo权限的系统级别目录下。</p><h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><p>你的默认编译环境应该是<a href="http://tools.android.com/tech-docs/new-build-system">Gradle</a>.<br>Ant 有很多限制，也很冗余。使用Gradle，完成以下工作很方便：</p><ul><li>构建APP不同版本的变种</li><li>制作简单类似脚本的任务</li><li>管理和下载依赖</li><li>自定义秘钥</li><li>更多</li></ul><p>同时，Android Gradle插件作为新标准的构建系统正在被Google积极的开发。</p><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>有两种流行的结构：老的Ant &amp; Eclipse ADT 工程结构，和新的Gradle &amp; Android Studio 工程结构，<br>你应该选择新的工程结构，如果你的工程还在使用老的结构，考虑放弃吧，将工程移植到新的结构。</p><p>老的结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">old-structure</span><br><span class="line">├─ assets</span><br><span class="line">├─ libs</span><br><span class="line">├─ res</span><br><span class="line">├─ src</span><br><span class="line">│  └─ com/futurice/project</span><br><span class="line">├─ AndroidManifest.xml</span><br><span class="line">├─ build.gradle</span><br><span class="line">├─ project.properties</span><br><span class="line">└─ proguard-rules.pro</span><br></pre></td></tr></table></figure><p>新的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new-structure</span><br><span class="line">├─ library-foobar</span><br><span class="line">├─ app</span><br><span class="line">│  ├─ libs</span><br><span class="line">│  ├─ src</span><br><span class="line">│  │  ├─ androidTest</span><br><span class="line">│  │  │  └─ java</span><br><span class="line">│  │  │     └─ com/futurice/project</span><br><span class="line">│  │  └─ main</span><br><span class="line">│  │     ├─ java</span><br><span class="line">│  │     │  └─ com/futurice/project</span><br><span class="line">│  │     ├─ res</span><br><span class="line">│  │     └─ AndroidManifest.xml</span><br><span class="line">│  ├─ build.gradle</span><br><span class="line">│  └─ proguard-rules.pro</span><br><span class="line">├─ build.gradle</span><br><span class="line">└─ settings.gradle</span><br></pre></td></tr></table></figure><p>主要的区别在于，新的结构明确的分开了’source sets’ (<code>main</code>,<code>androidTest</code>)，这是Gradle的一个理念。<br>通过这个你可以做到，例如，添加源组‘paid’和‘free’在src中，让你的应用程序具有付费和免费的两种模式的源代码。</p><p>你的项目引用第三方项目库时（例如，library-foobar），拥有一个顶级包名<code>app</code>从第三方库项目区分你的应用程序是非常有用的。<br>然后<code>settings.gradle</code>不断引用这些库项目，其中<code>app/build.gradle</code>可以引用。</p><h3 id="Gradle-配置"><a href="#Gradle-配置" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h3><p><strong>常用结构</strong> 参考<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">Google’s guide on Gradle for Android</a></p><p><strong>小任务</strong> 除了(shell, Python, Perl, etc)这些脚本语言，你也可以使用Gradle 制作任务。<br>更多信息请参考<a href="http://www.gradle.org/docs/current/userguide/userguide_single.html#N10CBF">Gradle’s documentation</a>。</p><p><strong>密码</strong> 在做版本release时你app的 <code>build.gradle</code>你需要定义 <code>signingConfigs</code>.此时你应该避免以下内容：</p><p><em>不要做这个</em> . 这会出现在版本控制中。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">release &#123;</span><br><span class="line">storeFile file(<span class="string">&quot;myapp.keystore&quot;</span>)</span><br><span class="line">storePassword <span class="string">&quot;password123&quot;</span></span><br><span class="line">keyAlias <span class="string">&quot;thekey&quot;</span></span><br><span class="line">keyPassword <span class="string">&quot;password789&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而是，建立一个不加入版本控制系统的<code>gradle.properties</code>文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KEYSTORE_PASSWORD=password123</span><br><span class="line">KEY_PASSWORD=password789</span><br></pre></td></tr></table></figure><p>那个文件是gradle自动引入的，你可以在<code>buld.gradle</code>文件中使用，例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">release &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">storeFile file(<span class="string">&quot;myapp.keystore&quot;</span>)</span><br><span class="line">storePassword KEYSTORE_PASSWORD</span><br><span class="line">keyAlias <span class="string">&quot;thekey&quot;</span></span><br><span class="line">keyPassword KEY_PASSWORD</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidUserDataException(<span class="string">&quot;You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.properties.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Maven 依赖方案代替使用导入jar包方案</strong> 如果在你的项目中你明确使用某些<br>jar文件，那么它们可能成为固定的版本，如<code>2.1.1</code>.下载jar包更新他们是很繁琐的，<br>这个问题Maven很好的解决了，这在Android Gradle构建中也是推荐的方法。你可<br>以指定版本的一个范围，如<code>2.1.+</code>,然后Maven会自动升级到制定的最新版本，例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">compile <span class="string">&#x27;com.netflix.rxjava:rxjava-core:0.19.+&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.netflix.rxjava:rxjava-android:0.19.+&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.fasterxml.jackson.core:jackson-databind:2.4.+&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.fasterxml.jackson.core:jackson-core:2.4.+&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.fasterxml.jackson.core:jackson-annotations:2.4.+&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.squareup.okhttp:okhttp:2.0.+&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.squareup.okhttp:okhttp-urlconnection:2.0.+&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IDEs-and-text-editors"><a href="#IDEs-and-text-editors" class="headerlink" title="IDEs and text editors"></a>IDEs and text editors</h3><h3 id="IDE集成开发环境和文本编辑器"><a href="#IDE集成开发环境和文本编辑器" class="headerlink" title="IDE集成开发环境和文本编辑器"></a>IDE集成开发环境和文本编辑器</h3><p><strong>无论使用什么编辑器，一定要构建一个良好的工程结构。</strong> 编辑器每个人都有自己的<br>选择，让你的编辑器根据工程结构和构建系统运作，那是你自己的责任。</p><p>当下首推<a href="https://developer.android.com/sdk/installing/studio.html">Android Studio</a>,因为他是由谷歌开发，很好地支持Gradle，包含很多有用的检测和分析工具，默认使用最新的工程结构，它就是为Android开发定制的。</p><p>你也可以使用纯文版编辑器如Vim，Sublime Text，或者Emacs。如果那样的话，你需要使用Gradle和<code>adb</code>命令行。</p><p>不再推荐使用Eclipse和ADT开发，因为<a href="https://android-developers.googleblog.com/2015/06/an-update-on-eclipse-android-developer.html">谷歌在2015年年末结束了对ADT的支持</a>，并呼吁开发者尽快迁移到Android Studio。</p><p>无论你使用何种开发工具，避免将你的编辑器配置文件（比如Android Studio的iml文件）加入到版本控制，因为这些文件通常包含与本地机器有关的配置，可能会影响你的同事。</p><p>最后，善待其他开发者，不要强制改变他们的开发工具和偏好。</p><h3 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h3><p><strong><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a></strong> 是一个将java对象转换成JSON与JSON转化java类的类库。<a href="https://code.google.com/p/google-gson/">Gson</a><br>是解决这个问题的流行方案，然而我们发现Jackson更高效,因为它支持替代的方法处理JSON:流、内存树模型,和传统JSON-POJO数据绑定。不过，请记住，<br>Jsonkson库比起GSON更大，所以根据你的情况选择，你可能选择GSON来避免APP 65k个方法的限制。其它选择: <a href="https://code.google.com/p/json-smart/">Json-smart</a> and <a href="https://github.com/RichardHightower/boon/wiki/Boon-JSON-in-five-minutes">Boon JSON</a></p><p><strong>网络请求，缓存，图片</strong> 执行请求后端服务器，有几种交互的解决方案，你应该考虑实现你自己的网络客户端。使用 <a href="https://android.googlesource.com/platform/frameworks/volley">Volley</a><br>或<a href="http://square.github.io/retrofit/">Retrofit</a>。Volley 同时提供图片缓存类。如果你选择使用Retrofit,那么考虑使用<a href="http://square.github.io/picasso/">Picasso</a><br>来加载图片和缓存，同时使用<a href="http://square.github.io/okhttp/">OkHttp</a>作为高效的网络请求。Retrofit，Picasso和OkHttp都是同一家公司开发（注：<br>是由<a href="https://github.com/square">Square</a> 公司开发），所以它们能很好的在一起运行。<a href="http://stackoverflow.com/questions/24375043/how-to-implement-android-volley-with-okhttp-2-0/24951835#24951835">OkHttp 同样可以和Volley在一起使用 Volley</a>.</p><p><strong>RxJava</strong> 是函数式反应性的一个类库，换句话说，能处理异步的事件。<br>这是一个强大的和有前途的模式，同时也可能会造成混淆，因为它是如此的不同。<br>我们建议在使用这个库架构整个应用程序之前要谨慎考虑。<br>有一些项目是使用RxJava完成的，如果你需要帮助可以跟这些人取得联系：<br>Timo Tuominen, Olli Salonen, Andre Medeiros, Mark Voit, Antti Lammi, Vera Izrailit, Juha Ristolainen.<br>我们也写了一些博客：<br><a href="http://blog.futurice.com/tech-pick-of-the-week-rx-for-net-and-rxjava-for-android">[1]</a>, <a href="http://blog.futurice.com/top-7-tips-for-rxjava-on-android">[2]</a>,<br><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">[3]</a>,<br><a href="http://blog.futurice.com/android-development-has-its-own-swift">[4]</a>.</p><p>如若你之前有使用过Rx的经历，开始从API响应应用它。<br>另外，从简单的UI事件处理开始运用，如单击事件或在搜索栏输入事件。<br>若对你的Rx技术有信心，同时想要将它应用到你的整体架构中，那么请在复杂的部分写好Javadocs文档。<br>请记住其他不熟悉RxJava的开发人员，可能会非常难理解整个项目。<br>尽你的的全力帮助他们理解你的代码和Rx。</p><p><strong><a href="https://github.com/evant/gradle-retrolambda">Retrolambda</a></strong> 是一个在Android和预JDK8平台上的使用Lambda表达式语法的Java类库。<br>它有助于保持你代码的紧凑性和可读性，特别当你使用如RxJava函数风格编程时。<br>使用它时先安装JDK8，在Android Studio工程结构对话框中把它设置成为SDK路径，同时设置<code>JAVA8_HOME</code>和<code>JAVA7_HOME</code>环境变量，<br>然后在工程根目录下配置 build.gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">classpath <span class="string">&#x27;me.tatarka:gradle-retrolambda:2.4.+&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在每个module 的build.gradle中添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;retrolambda&#x27;</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">compileOptions &#123;</span><br><span class="line">sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retrolambda &#123;</span><br><span class="line">jdk System.getenv(<span class="string">&quot;JAVA8_HOME&quot;</span>)</span><br><span class="line">oldJdk System.getenv(<span class="string">&quot;JAVA7_HOME&quot;</span>)</span><br><span class="line">javaVersion JavaVersion.VERSION_1_7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android Studio 提供Java8 lambdas表带是代码提示支持。如果你对lambdas不熟悉，只需参照以下开始学习吧：</p><ul><li>任何只包含一个接口的方法都是”lambda friendly”同时代码可以被折叠成更紧凑的语法</li><li>如果对参数或类似有疑问，就写一个普通的匿名内部类，然后让Android Studio 为你生成一个lambda。</li></ul><p><strong>当心dex方法数限制，同时避免使用过多的类库</strong> Android apps，当打包成一个dex文件时，有一个65535个应用方法强硬限制<a href="https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71">[1]</a> <a href="http://blog.persistent.info/2014/05/per-package-method-counts-for-androids.html">[2]</a> <a href="http://jakewharton.com/play-services-is-a-monolith/">[3]</a>。<br>当你突破65k限制之后你会看到一个致命错误。因此，使用一个正常范围的类库文件，同时使用<a href="https://github.com/mihaip/dex-method-counts">dex-method-counts</a><br>工具来决定哪些类库可以再65k限制之下使用，特别的避免使用Guava类库，因为它包含超过13k个方法。</p><h3 id="Activities-and-Fragments"><a href="#Activities-and-Fragments" class="headerlink" title="Activities and Fragments"></a>Activities and Fragments</h3><p><a href="http://developer.android.com/guide/components/fragments.html">Fragments</a>应该作为你实现UI界面默认选择。你可以重复使用Fragments用户接口来<br>组合成你的应用。我们强烈推荐使用Fragments而不是activity来呈现UI界面，理由如下：</p><ul><li><p><strong>提供多窗格布局解决方案</strong> Fragments 的引入主要将手机应用延伸到平板电脑，所以在平板电脑上你可能有A、B两个窗格，但是在手机应用上A、B可能分别充满<br>  整个屏幕。如果你的应用在最初就使用了fragments，那么以后将你的应用适配到其他不同尺寸屏幕就会非常简单。</p></li><li><p><strong>屏幕间数据通信</strong> 从一个Activity发送复杂数据(例如Java对象)到另外一个Activity，Android的API并没有提供合适的方法。不过使用Fragment，你可以使用<br>一个activity实例作为这个activity子fragments的通信通道。即使这样比Activity与Activity间的通信好，你也想考虑使用Event Bus架构，使用如<br><a href="https://square.github.io/otto/">Otto</a> 或者 <a href="https://github.com/greenrobot/EventBus">greenrobot EventBus</a>作为更简洁的实现。<br>如果你希望避免添加另外一个类库，RxJava同样可以实现一个Event Bus。</p></li><li><p><strong>Fragments 一般通用的不只有UI</strong> 你可以有一个没有界面的fragment作为Activity提供后台工作。<br>进一步你可以使用这个特性来创建一个<a href="http://stackoverflow.com/questions/12363790/how-many-activities-vs-fragments/12528434#12528434">fragment 包含改变其它fragment的逻辑</a><br>而不是把这个逻辑放在activity中。</p></li><li><p><strong>甚至ActionBar 都可以使用内部fragment来管理</strong> 你可以选择使用一个没有UI界面的fragment来专门管理ActionBar,或者你可以选择使用在每个Fragment中<br>添加它自己的action 来作为父Activity的ActionBar.<a href="http://www.grokkingandroid.com/adding-action-items-from-within-fragments/">参考</a>.</p></li></ul><p>很不幸，我们不建议广泛的使用嵌套的<a href="https://developer.android.com/about/versions/android-4.2.html#NestedFragments">fragments</a>，因为<br>有时会引起<a href="http://delyan.me/android-s-matryoshka-problem/">matryoshka bugs</a>。我们只有当它有意义(例如，在水平滑动的ViewPager在<br>像屏幕一样fragment中)或者他的确是一个明智的选择的时候才广泛的使用fragment。</p><p>在一个架构级别，你的APP应该有一个顶级的activity来包含绝大部分业务相关的fragment。你也可能还有一些辅助的activity ，这些辅助的activity与主activity<br>通信很简单限制在这两种方法<br><a href="http://developer.android.com/reference/android/content/Intent.html#setData(android.net.Uri)"><code>Intent.setData()</code></a> 或 <a href="http://developer.android.com/reference/android/content/Intent.html#setAction(java.lang.String)"><code>Intent.setAction()</code></a>或类似的方法。</p><h3 id="Java-包结构"><a href="#Java-包结构" class="headerlink" title="Java 包结构"></a>Java 包结构</h3><p>Android 应用程序在架构上大致是Java中的<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-View-Controller</a>结构。<br>在Android 中 Fragment和Activity通常上是控制器类(<a href="http://www.informit.com/articles/article.aspx?p=2126865">http://www.informit.com/articles/article.aspx?p=2126865</a>).<br>换句话说，他们是用户接口的部分，同样也是Views视图的部分。</p><p>正是因为如此，才很难严格的将fragments (或者 activities) 严格的划分成 控制器controlloers还是视图 views。<br>最还是将它们放在自己单独的 <code>fragments</code> 包中。只要你遵循之前提到的建议，Activities 则可以放在顶级目录下。<br>如果你规划有2到3个以上的activity，那么还是同样新建一个<code>activities</code>包吧。</p><p>然而，这种架构可以看做是另一种形式的MVC，<br>包含要被解析API响应的JSON数据，来填充的POJO的<code>models</code>包中。<br>和一个<code>views</code>包来包含你的自定义视图、通知、导航视图，widgets等等。<br>适配器Adapter是在数据和视图之间。然而他们通常需要通过<code>getView()</code>方法来导出一些视图，<br>所以你可以将<code>adapters</code>包放在<code>views</code>包里面。</p><p>一些控制器角色的类是应用程序级别的，同时是接近系统的。<br>这些类放在<code>managers</code>包下面。<br>一些繁杂的数据处理类，比如说”DateUtils”,放在<code>utils</code>包下面。<br>与后端交互负责网络处理类，放在<code>network</code>包下面。</p><p>总而言之，以最接近用户而不是最接近后端去安排他们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">com.futurice.project</span><br><span class="line">├─ network</span><br><span class="line">├─ models</span><br><span class="line">├─ managers</span><br><span class="line">├─ utils</span><br><span class="line">├─ fragments</span><br><span class="line">└─ views</span><br><span class="line">   ├─ adapters</span><br><span class="line">   ├─ actionbar</span><br><span class="line">   ├─ widgets</span><br><span class="line">   └─ notifications</span><br></pre></td></tr></table></figure><h3 id="资源文件-Resources"><a href="#资源文件-Resources" class="headerlink" title="资源文件 Resources"></a>资源文件 Resources</h3><ul><li><strong>命名</strong> 遵循前缀表明类型的习惯，形如<code>type_foo_bar.xml</code>。例如：<code>fragment_contact_details.xml</code>,<code>view_primary_button.xml</code>,<code>activity_main.xml</code>.</li></ul><p><strong>组织布局文件</strong> 如果你不确定如何排版一个布局文件，遵循一下规则可能会有帮助。</p><ul><li>每一个属性一行，缩进4个空格</li><li><code>android:id</code> 总是作为第一个属性</li><li><code>android:layout_****</code> 属性在上边</li><li><code>style</code> 属性在底部</li><li>关闭标签<code>/&gt;</code>单独起一行，有助于调整和添加新的属性</li><li>考虑使用<a href="http://tools.android.com/tips/layout-designtime-attributes">Designtime attributes 设计时布局属性</a>，Android Studio已经提供支持，而不是硬编码<code>android:text</code><br>(译者注：墙内也可以参考stormzhang的这篇博客<a href="http://stormzhang.com/devtools/2015/01/11/android-studio-tips1/">链接</a>)。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/name&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">&quot;@string/name&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;@style/FancyText&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/reusable_part&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>作为一个经验法则,<code>android:layout_****</code>属性应该在 layout XML 中定义,同时其它属性<code>android:****</code> 应放在 styler XML中。此规则也有例外，不过大体工作<br>的很好。这个思想整体是保持layout属性(positioning, margin, sizing) 和content属性在布局文件中，同时将所有的外观细节属性（colors, padding, font）放<br>在style文件中。</p><p>例外有以下这些:</p><ul><li><code>android:id</code> 明显应该在layout文件中</li><li>layout文件中<code>android:orientation</code>对于一个<code>LinearLayout</code>布局通常更有意义</li><li><code>android:text</code> 由于是定义内容，应该放在layout文件中</li><li>有时候将<code>android:layout_width</code> 和 <code>android:layout_height</code>属性放到一个style中作为一个通用的风格中更有意义，但是默认情况下这些应该放到layout文件中。</li></ul><p><strong>使用styles</strong> 几乎每个项目都需要适当的使用style文件，因为对于一个视图来说有一个重复的外观是很常见的。<br>在应用中对于大多数文本内容，最起码你应该有一个通用的style文件，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;ContentText&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>@dimen/font_normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>@color/basic_black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应用到TextView 中:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">&quot;@string/price&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;@style/ContentText&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>你或许需要为按钮控件做同样的事情，不要停止在那里。将一组相关的和重复<code>android:****</code>的属性放到一个通用的style中。</p><p><strong>将一个大的style文件分割成多个文件</strong> 你可以有多个<code>styles.xml</code> 文件。Android SDK支持其它文件，<code>styles</code>这个文件名称并没有作用，起作用的是在文件<br>里xml的<code>&lt;style&gt;</code>标签。因此你可以有多个style文件<code>styles.xml</code>,<code>style_home.xml</code>,<code>style_item_details.xml</code>,<code>styles_forms.xml</code>。<br>不用于资源文件路径需要为系统构建起的有意义，在<code>res/values</code>目录下的文件可以任意命名。</p><p><strong><code>colors.xml</code>是一个调色板</strong> 在你的<code>colors.xml</code>文件中应该只是映射颜色的名称一个RGBA值，而没有其它的。不要使用它为不同的按钮来定义RGBA值。</p><p><em>不要这样做</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;button_foreground&quot;</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;button_background&quot;</span>&gt;</span>#2A91BD<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;comment_background_inactive&quot;</span>&gt;</span>#5F5F5F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;comment_background_active&quot;</span>&gt;</span>#939393<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;comment_foreground&quot;</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;comment_foreground_important&quot;</span>&gt;</span>#FF9D2F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;comment_shadow&quot;</span>&gt;</span>#323232<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用这种格式，你会非常容易的开始重复定义RGBA值，这使如果需要改变基本色变的很复杂。同时，这些定义是跟一些环境关联起来的，如<code>button</code>或者<code>comment</code>,<br>应该放到一个按钮风格中，而不是在<code>color.xml</code>文件中。</p><p>相反，这样做:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- grayscale --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>     &gt;</span>#FFFFFF<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;gray_light&quot;</span>&gt;</span>#DBDBDB<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;gray&quot;</span>      &gt;</span>#939393<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;gray_dark&quot;</span> &gt;</span>#5F5F5F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>     &gt;</span>#323232<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- basic colors --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;green&quot;</span>&gt;</span>#27D34D<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>#2A91BD<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>#FF9D2F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span>&gt;</span>#FF432F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>向应用设计者那里要这个调色板，名称不需要跟”green”, “blue”, 等等相同。<br>“brand_primary”, “brand_secondary”, “brand_negative” 这样的名字也是完全可以接受的。<br>像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。<br>通常一个具有审美价值的UI来说，减少使用颜色的种类是非常重要的。</p><p><strong>像对待colors.xml一样对待dimens.xml文件</strong> 与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。<br>一个好的例子，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- font sizes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;font_larger&quot;</span>&gt;</span>22sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;font_large&quot;</span>&gt;</span>18sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;font_normal&quot;</span>&gt;</span>15sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;font_small&quot;</span>&gt;</span>12sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- typical spacing between two views --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;spacing_huge&quot;</span>&gt;</span>40dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;spacing_large&quot;</span>&gt;</span>24dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;spacing_normal&quot;</span>&gt;</span>14dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;spacing_small&quot;</span>&gt;</span>10dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;spacing_tiny&quot;</span>&gt;</span>4dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- typical sizes of views --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;button_height_tall&quot;</span>&gt;</span>60dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;button_height_normal&quot;</span>&gt;</span>40dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;button_height_short&quot;</span>&gt;</span>32dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局时在写 margins 和 paddings 时，你应该使用<code>spacing_****</code>尺寸格式来布局，而不是像对待String字符串一样直接写值。<br>这样写会非常有感觉，会使组织和改变风格或布局是非常容易。</p><p><strong>避免深层次的视图结构</strong> 有时候为了摆放一个视图，你可能尝试添加另一个LinearLayout。你可能使用这种方法解决：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即使你没有非常明确的在一个layout布局文件中这样使用，如果你在Java文件中从一个view inflate（这个inflate翻译不过去，大家理解就行） 到其他views当中，也是可能会发生的。</p><p>可能会导致一系列的问题。你可能会遇到性能问题，因为处理起需要处理一个复杂的UI树结构。<br>还可能会导致以下更严重的问题<a href="http://stackoverflow.com/questions/2762924/java-lang-stackoverflow-error-suspected-too-many-views">StackOverflowError</a>.</p><p>因此尽量保持你的视图tree：学习如何使用<a href="https://developer.android.com/guide/topics/ui/layout/relative.html">RelativeLayout</a>,<br>如何 <a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html">optimize 你的布局</a> 和如何使用<br><a href="http://stackoverflow.com/questions/8834898/what-is-the-purpose-of-androids-merge-tag-in-xml-layouts"><code>&lt;merge&gt;</code> 标签</a>.</p><p><strong>小心关于WebViews的问题.</strong> 如果你必须显示一个web视图，<br>比如说对于一个新闻文章，避免做客户端处理HTML的工作，<br>最好让后端工程师协助，让他返回一个 “<em>纯</em>“ HTML。<br>当绑定WebViews到引用它的Activity,而不是绑定到ApplicationContext时。<br><a href="http://stackoverflow.com/questions/3130654/memory-leak-in-webview">WebViews 也能导致内存泄露</a>。<br>当使用简单的文字或按钮时，避免使用WebView，这时使用TextView或Buttons更好。</p><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>Android SDK的测试框架还处于初级阶段，特别是关于UI测试方面。Android Gradle<br>目前实现了一个叫<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Testing"><code>connectedAndroidTest</code></a>的测试，<br>它<a href="http://developer.android.com/reference/android/test/package-summary.html">使用一个JUnit 为Android提供的扩展插件 extension of JUnit with helpers for Android</a>.可以跑你生成的JUnit测试，</p><p><strong>只当做单元测试时使用 <a href="http://robolectric.org/">Robolectric</a> ，views 不用</strong><br>它是一个最求提供”不连接设备的”为了加速开发的测试，<br>非常时候做 models 和 view models 的单元测试。<br>然而，使用Robolectric测试时不精确的，也不完全对UI测试。<br>当你对有关动画的UI元素、对话框等，测试时会有问题，<br>这主要是因为你是在 “在黑暗中工作”（在没有可控的界面情况下测试）</p><p>**<a href="https://code.google.com/p/robotium/">Robotium</a> 使写UI测试非常简单。<br>** 对于UI测试你不需 Robotium 跑与设备连接的测试。<br>但它可能会对你有益，是因为它有许多来帮助类的获得和分析视图，控制屏幕。<br>测试用例看起来像这样简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">solo.sendKey(Solo.MENU);</span><br><span class="line">solo.clickOnText(<span class="string">&quot;More&quot;</span>); <span class="comment">// searches for the first occurence of &quot;More&quot; and clicks on it</span></span><br><span class="line">solo.clickOnText(<span class="string">&quot;Preferences&quot;</span>);</span><br><span class="line">solo.clickOnText(<span class="string">&quot;Edit File Extensions&quot;</span>);</span><br><span class="line">Assert.assertTrue(solo.searchText(<span class="string">&quot;rtf&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h3><p>如果你全职开发Android App,那么买一个<a href="http://www.genymotion.com/">Genymotion emulator</a>license吧。<br>Genymotion 模拟器运行更快的秒帧的速度，比起典型的AVD模拟器。他有演示你APP的工具，高质量的模拟网络连接，GPS位置，等等。它同时还有理想的连接测试。<br>你若涉及适配使用很多不同的设备，买一个Genymotion 版权是比你买很多真设备便宜多的。</p><p>注意：Genymotion模拟器没有装载所有的Google服务，如Google Play Store和Maps。你也可能需<br>要测试Samsung指定的API，若这样的话你还是需要购买一个真实的Samsung设备。</p><h3 id="混淆配置"><a href="#混淆配置" class="headerlink" title="混淆配置"></a>混淆配置</h3><p><a href="http://proguard.sourceforge.net/">ProGuard</a> 是一个在Android项目中广泛使用的压缩和混淆打包的源码的工具。</p><p>你是否使用ProGuard取决你项目的配置，当你构建一个release版本的apk时，通常你应该配置gradle文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">debug &#123;</span><br><span class="line">minifyEnabled <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">release &#123;</span><br><span class="line">signingConfig signingConfigs.release</span><br><span class="line">minifyEnabled <span class="literal">true</span></span><br><span class="line">proguardFiles <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了决定哪些代码应该被保留，哪些代码应该被混淆，你不得不指定一个或多个实体类在你的代码中。<br>这些实体应该是指定的类包含main方法，applets，midlets，activities，等等。<br>Android framework 使用一个默认的配置文件，可以在<code>SDK_HOME/tools/proguard/proguard-android.txt</code><br>目录下找到。自定义的工程指定的 project-specific 混淆规则，如在<code>my-project/app/proguard-rules.pro</code>中定义，<br>会被添加到默认的配置中。</p><p>关于 ProGuard 一个普遍的问题，是看应用程序是否崩溃并报<code>ClassNotFoundException</code> 或者 <code>NoSuchFieldException</code> 或类似的异常，<br>即使编译是没有警告并运行成功。<br>这意味着以下两种可能：</p><ol><li>ProGuard 已经移除了类，枚举，方法，成员变量或注解，考虑是否是必要的。</li><li>ProGuard 混淆了类，枚举，成员变量的名称，但是这些名字又被拿原始名称使用了，比如通过Java的反射。</li></ol><p>检查<code>app/build/outputs/proguard/release/usage.txt</code>文件看有问题的对象是否被移除了。<br>检查 <code>app/build/outputs/proguard/release/mapping.txt</code> 文件看有问题的对象是否被混淆了。</p><p>In order to prevent ProGuard from <em>stripping away</em> needed classes or class members, add a <code>keep</code> options to your proguard config:<br>以防 ProGuard <em>剥离</em> 需要的类和类成员，添加一个 <code>keep</code>选项在你的 proguard 配置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep class com.futurice.project.MyClass &#123; *; &#125;</span><br></pre></td></tr></table></figure><p>防止 ProGuard <em>混淆</em> 一些类和成员，添加 <code>keepnames</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepnames class com.futurice.project.MyClass &#123; *; &#125;</span><br></pre></td></tr></table></figure><p>更多例子请参考<a href="http://proguard.sourceforge.net/#manual/examples.html">Proguard</a>。</p><p><strong>在构建项目之初，发布一个版本</strong> 来检查ProGuard规则是否正确的保持了重要的部分。<br>同时无论何时你添加了新的类库，做一个发布版本，同时apk在设备上跑起来测试一下。<br>不要等到你的app要发布 “1.0”版本了才做版本发布，那时候你可能会碰到好多意想不到的异常，需要一些时间去修复他们。</p><p><strong>Tips</strong>每次发布新版本都要写 <code>mapping.txt</code>。每发布一个版本，如果用户遇到一个bug，同时提交了一个混淆过的堆栈跟踪。<br>通过保留<code>mapping.txt</code>文件，来确定你可以调试的问题。</p><p><strong>DexGuard</strong> 如果你需要核心工具来优化，和专门混淆的发布代码，考虑使用<a href="http://www.saikoa.com/dexguard">DexGuard</a>,<br>一个商业软件，ProGuard 也是有他们团队开发的。<br>它会很容易将Dex文件分割，来解决65K个方法限制问题。</p><p>###数据存储</p><p><strong>SharedPreferences</strong></p><p>如果你只是需要持久化存储简单的标记位，并且你的应用运行在单一进程，那么SharedPreferences可能就满足了你的需求。它是一个非常好的选择。</p><p>这里有两个使你可能不使用SharedPreferences的原因：</p><ul><li>Performance: Your data is complex or there is a lot of it</li><li>性能问题：你的很多数据结构负责的数据需要存储。</li><li>Multiple processes accessing the data: You have widgets or remote services that run in their own processes and require synchronized data</li><li>多线程访问数据：你有多个控件或者运行在各自线程上的远程的服务需要同步数据。</li></ul><p><strong>ContentProviders</strong></p><p>如果SharedPreferences不足以满足你的需求，那么你可以使用平台标准的ContentProviders，它不仅快速，并且线程安全。</p><p>使用ContentProviders的唯一问题是建立他们需要大量的模板代码，并且少有高质量的教程。如果可以，我们可以通过使用第三方库Schematic，极大降低了冗余操作，去生成ContentProviders.</p><p>你可能仍然需要亲自写一些解析代码去从Sqlite读取数据对象，或者进行相反的操作。如果可以序列化数据对象，例如通过Gson，只持久化存储最终是字符串。通过这种方式虽然会降低性能，但是从另一个角度来讲，你不需要为每一个数据结构声明表结构。</p><p><strong>使用ORM</strong>我们通常不推荐使用对象关系映射第三方库除非你有非常复杂的数据结构，并且你确定你真的需要它。他们通常比较复杂，并且需要时间去学习。如果你决定了在你的应用中使用ORM，你应该注意它是否是线程安全的，而对于目前大多数ORM解决方案都是非线程安全的。</p><p><strong>使用Stetho</strong>Stetho 是一个Facebook 开源的Android调试工具，它是Chrome Developer Tools的扩展。通过它可以检测应用的网络情况。它也允许你可以检测应用的数据库，shared preferences。但是，你应该确保Stetho只有在Debug状态下得以开启，而不是在正式发布版本中。</p><p><strong>使用LeakCanary</strong>LeakCanary 是可以在应用运行中检测，定位内存泄露的Java库。使用它应是你开发应用过程中的一部分。更多详细的配置和使用情况请参照wiki。你只需要记得它在你的正式版本中你是不需要配置的。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>感谢Antti Lammi, Joni Karppinen, Peter Tackage, Timo Tuominen, Vera Izrailit, Vihtori Mäntylä, Mark Voit, Andre Medeiros, Paul Houghton 这些人和Futurice 开发者分享他们的Android开发经验。</p><h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p><a href="www.futurice.com">Futurice Oy</a><br>Creative Commons Attribution 4.0 International (CC BY 4.0)</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>Translated to Chinese by <a href="https://github.com/andyiac">andyiac</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年Android面试题整理</title>
      <link href="/2018/questioninterview2018/index/"/>
      <url>/2018/questioninterview2018/index/</url>
      
        <content type="html"><![CDATA[<p>这是我近段时间收集的面试题，献给打算年后找工作的同学们。文中涉及的知识比较广也可能比较零散，并且一些较为基础的知识我都略去了（比如Android四大组件是什么这类问题），有些我附上了自己的理解，有些附上了详细的相关文章链接。大家挑自己感兴趣的内容查看即可，后期我也会继续不断补充。</p><h2 id="基础组件篇"><a href="#基础组件篇" class="headerlink" title="基础组件篇"></a>基础组件篇</h2><h3 id="横竖屏切换时Activity的生命周期变化"><a href="#横竖屏切换时Activity的生命周期变化" class="headerlink" title="横竖屏切换时Activity的生命周期变化"></a>横竖屏切换时Activity的生命周期变化</h3><ul><li>如果自己没有配置<code>android:ConfigChanges</code>，这时默认让系统处理，就会重建Activity，此时Activity的生命周期会走一遍。</li></ul><p><img src="/img/img/questioninterview2018/161bb552a99f8490_tplv-t2oaga2asx-watermark.awebp"></p><blockquote><h2 id="onSaveInstanceState-与-onRestoreIntanceState"><a href="#onSaveInstanceState-与-onRestoreIntanceState" class="headerlink" title="onSaveInstanceState() 与 onRestoreIntanceState()"></a><code>onSaveInstanceState() 与 onRestoreIntanceState()</code></h2><p>资源相关的系统配置发生改变或者资源不足：例如屏幕旋转，当前Activity会销毁，并且在onStop之前回调onSaveInstanceState保存数据，在重新创建Activity的时候在onStart之后回调onRestoreInstanceState。其中Bundle数据会传到onCreate（不一定有数据）和onRestoreInstanceState（一定有数据）。<br>用户或者程序员主动去销毁一个Activity的时候不会回调，其他情况都会调用，来保存界面信息。如代码中finish（）或用户按下back，不会回调。</p></blockquote><ul><li>如果设置<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</code>，此时Activity的生命周期不会重走一遍，Activity不会重建，只会回调onConfigurationChanged方法。</li></ul><h3 id="activity的startActivity和context的startActivity的区别"><a href="#activity的startActivity和context的startActivity的区别" class="headerlink" title="activity的startActivity和context的startActivity的区别"></a>activity的startActivity和context的startActivity的区别</h3><ol><li>从Activity中启动新的Activity时可直接mContext.startActivity(intent)就好；</li><li>如果从其他Context中启动Activity则必须给intent设置Flag:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">mContext.startActivity(intent);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="介绍下Android应用程序启动过程"><a href="#介绍下Android应用程序启动过程" class="headerlink" title="介绍下Android应用程序启动过程"></a>介绍下Android应用程序启动过程</h3><p>整个应用程序的启动过程要执行很多步骤，但是整体来看，主要分为以下五个阶段：</p><blockquote><ol><li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</li><li>ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</li><li>Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</li><li>ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</li><li>ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</li></ol></blockquote><h3 id="如何保证Service不被杀死？"><a href="#如何保证Service不被杀死？" class="headerlink" title="如何保证Service不被杀死？"></a>如何保证Service不被杀死？</h3><ul><li><p>提供进程优先级，降低进程被杀死的概率<br>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。<br>方法二：启动前台service。<br>方法三：提升service优先级：<br>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority &#x3D; “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p></li><li><p>在进程被杀死后，进行拉活<br>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等<br>方法二：双进程相互唤起。<br>方法三：依靠系统唤起。<br>方法四：onDestroy方法里重启service：service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p></li><li><p>依靠第三方 根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A&#x2F;B Test。</p></li></ul><h3 id="简述下Activity任务栈和使用方法"><a href="#简述下Activity任务栈和使用方法" class="headerlink" title="简述下Activity任务栈和使用方法"></a>简述下Activity任务栈和使用方法</h3><p>任务栈是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名.</p><ol><li><code>standard</code> <strong>默认模式</strong> 每次启动都会创建一个新的Activity对象，放到目标任务栈中。</li><li><code>singleTop</code> 判断当前的任务栈顶是否存在相同的activity对象，如果存在，则直接使用，如果不存在，那么创建新的activity对象放入栈中</li><li><code>singleTask</code> 在任务栈中会判断是否存在相同的activity，如果存在，那么会清除该activity之上的其他activity对象显示，如果不存在，则会创建一个新的activity放入栈顶</li><li><code>singleIntance</code> 会在一个新的任务栈中创建activity，并且该任务栈种只允许存在一个activity实例，其他调用该activity的组件会直接使用该任务栈种的activity对象</li></ol><p>方法一： 使用android:launchMode&#x3D;”standard|singleInstance|single Task|singleTop”来控制Acivity任务栈。<br>方法二： Intent Flags：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Intent intent=<span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClass(MainActivity.<span class="built_in">this</span>, MainActivity2.class);</span><br><span class="line">intent.addFlags(Intent. FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Flags有很多，比如：<br>Intent.FLAG_ACTIVITY_NEW_TASK 相当于singleTask<br>Intent. FLAG_ACTIVITY_CLEAR_TOP 相当于singleTop</p><h3 id="Context相关问题"><a href="#Context相关问题" class="headerlink" title="Context相关问题"></a>Context相关问题</h3><p>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper.<br>每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象<br>getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法.getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。</p><p>Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application.<br>那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。</p><h3 id="怎么在Service中创建Dialog对话框"><a href="#怎么在Service中创建Dialog对话框" class="headerlink" title="怎么在Service中创建Dialog对话框"></a>怎么在Service中创建Dialog对话框</h3><ol><li>在我们取得Dialog对象后，需给它设置类型，即：<br><code>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)</code></li><li>在Manifest中加上权限:<br><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code></li></ol><h2 id="View篇"><a href="#View篇" class="headerlink" title="View篇"></a>View篇</h2><h3 id="非UI线程可以更新UI吗？"><a href="#非UI线程可以更新UI吗？" class="headerlink" title="非UI线程可以更新UI吗？"></a>非UI线程可以更新UI吗？</h3><p>可以<br>当访问UI时，<code>ViewRootImpl</code>会调用<code>checkThread()</code>方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常<br>执行<code>onCreate</code>方法的那个时候<code>ViewRootImpl</code>还没创建，无法去检查当前线程<code>ViewRootImpl</code>的创建在<code>onResume()</code>方法回调之后.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非UI线程是可以刷新UI的，前提是它要拥有自己的<code>ViewRoot</code>,即更新UI的线程和创建<code>ViewRoot</code>是同一个,或者在执行<code>checkThread()</code>前更新UI.</p><h3 id="解决ScrollView嵌套ListView和GridView冲突的方法"><a href="#解决ScrollView嵌套ListView和GridView冲突的方法" class="headerlink" title="解决ScrollView嵌套ListView和GridView冲突的方法"></a>解决ScrollView嵌套ListView和GridView冲突的方法</h3><p>重写ListView的onMeasure方法，来自定义高度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">expandSpec</span> <span class="operator">=</span> MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; <span class="number">2</span>, MeasureSpec.AT_MOST);</span><br><span class="line">    <span class="built_in">super</span>.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要考察对MeasureSpec的三种模式的理解,<a href="http://blog.csdn.net/btt2013/article/details/53447649">相关文章</a>.</p><h3 id="自定义View优化策略"><a href="#自定义View优化策略" class="headerlink" title="自定义View优化策略"></a>自定义View优化策略</h3><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p><p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p><p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p><p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p><h2 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h2><h3 id="Handler、Message、Looper、MessageQueue"><a href="#Handler、Message、Looper、MessageQueue" class="headerlink" title="Handler、Message、Looper、MessageQueue"></a>Handler、Message、Looper、MessageQueue</h3><h4 id="相关概念的解释"><a href="#相关概念的解释" class="headerlink" title="相关概念的解释"></a>相关概念的解释</h4><ul><li>主线程（UI线程）<br>定义：当程序第一次启动时，Android会同时启动一条主线程（Main Thread）<br>作用：主线程主要负责处理与UI相关的事件</li><li>Message（消息）<br>定义：Handler接收和处理的消息对象（Bean对象）<br>作用：通信时相关信息的存放和传递</li><li>ThreadLocal<br>定义：ThreadLocal是线程内部的存储类，通过它可以实现在每个线程中存储自己的私有数据。即数据存储以后，只能在指定的线程中获取这个存储的对象，而其它线程则不能获取到当前线程存储的这个对象。<br>作用：负责存储和获取本线程的Looper</li><li>MessageQueue（消息队列）<br>定义：采用单链表的数据结构来存储消息列表<br>作用：用来存放通过Handler发过来的Message，按照先进先出执行</li><li>Handler（处理者）<br>定义：Message的主要处理者<br>作用：负责发送Message到消息队列&amp;处理Looper分派过来的Message</li><li>Looper（循环器）<br>定义：扮演Message Queue和Handler之间桥梁的角色<br>作用：<br>消息循环：循环取出Message Queue的Message<br>消息派发：将取出的Message交付给相应的Handler</li></ul><h4 id="自己画下图解"><a href="#自己画下图解" class="headerlink" title="自己画下图解"></a>自己画下图解</h4><p><img src="/img/img/questioninterview2018/fff72bb7eec021cd437e03e0f655152d.jfif"></p><h4 id="Handler发送消息有哪几种方式？"><a href="#Handler发送消息有哪几种方式？" class="headerlink" title="Handler发送消息有哪几种方式？"></a>Handler发送消息有哪几种方式？</h4><ul><li>sendMessage(Message msg)</li><li>post(Runnable r)</li></ul><h4 id="Handler处理消息有哪几种方式"><a href="#Handler处理消息有哪几种方式" class="headerlink" title="Handler处理消息有哪几种方式"></a>Handler处理消息有哪几种方式</h4><p>直接看源码<code>dispatchMessage()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1. post()方法的处理方法</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. sendMessage()方法的处理方法</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. post()方法的最终处理方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. sendMessage()方法的最终处理方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Message、Handler、MessageQueue、Looper的之间的关系？"><a href="#Message、Handler、MessageQueue、Looper的之间的关系？" class="headerlink" title="Message、Handler、MessageQueue、Looper的之间的关系？"></a>Message、Handler、MessageQueue、Looper的之间的关系？</h4><p>首先，是这个MessagQueue，MessageQueue是一个消息队列，它可以存储Handler发送过来的消息，其内部提供了进队和出队的方法来管理这个消息队列，其出队和进队的原理是采用单链表的数据结构进行插入和删除的，即enqueueMessage()方法和next()方法。这里提到的Message，其实就是一个Bean对象，里面的属性用来记录Message的各种信息。</p><p>然后，是这个Looper，Looper是一个循环器，它可以循环的取出MessageQueue中的Message，其内部提供了Looper的初始化和循环出去Message的方法，即prepare()方法和loop()方法。在prepare()方法中，Looper会关联一个MessageQueue，而且将Looper存进一个ThreadLocal中，在loop()方法中，通过ThreadLocal取出Looper，使用MessageQueue的next()方法取出Message后，判断Message是否为空，如果是则Looper阻塞，如果不是，则通过dispatchMessage()方法分发该Message到Handler中，而Handler执行handlerMessage()方法，由于handlerMessage()方法是个空方法，这也是为什么需要在Handler中重写handlerMessage()方法的原因。这里要注意的是Looper只能在一个线程中只能存在一个。这里提到的ThreadLocal，其实就是一个对象，用来在不同线程中存放对应线程的Looper。</p><p>最后，是这个Handler，Handler是Looper和MessageQueue的桥梁，Handler内部提供了发送Message的一系列方法，最终会通过MessageQueue的enqueueMessage()方法将Message存进MessageQueue中。我们平时可以直接在主线程中使用Handler，那是因为在应用程序启动时，在入口的main方法中已经默认为我们创建好了Looper。</p><h4 id="为什么在子线程中创建Handler会抛异常？"><a href="#为什么在子线程中创建Handler会抛异常？" class="headerlink" title="为什么在子线程中创建Handler会抛异常？"></a>为什么在子线程中创建Handler会抛异常？</h4><p>Handler的工作是依赖于Looper的，而Looper（与消息队列）又是属于某一个线程（ThreadLocal是线程内部的数据存储类，通过它可以在指定线程中存储数据，其他线程则无法获取到），其他线程不能访问。因此Handler就是间接跟线程是绑定在一起了。因此要使用Handler必须要保证Handler所创建的线程中有Looper对象并且启动循环。因为子线程中默认是没有Looper的，所以会报错。<br>正确的使用方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Handler <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> mHandler;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">          mHandler.getLooper().quit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.run();</span><br><span class="line">          <span class="comment">//创建该线程对应的Looper,</span></span><br><span class="line">          <span class="comment">// 内部实现</span></span><br><span class="line">          <span class="comment">// 1。new Looper（）</span></span><br><span class="line">          <span class="comment">// 2。将1步中的lopper 放在ThreadLocal里，ThreadLocal是保存数据的，主要应用场景是：线程间数据互不影响的情况</span></span><br><span class="line">          <span class="comment">// 3。在1步中的Looper的构造函数中new MessageQueue();</span></span><br><span class="line">          <span class="comment">//其实就是创建了该线程对用的Looper，Looper里创建MessageQueue来实现消息机制</span></span><br><span class="line">          <span class="comment">//对消息机制不懂得同学可以查阅资料，网上很多也讲的很不错。</span></span><br><span class="line">          Looper.prepare();</span><br><span class="line">          mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                  <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">                  Log.d(<span class="string">&quot;WorkThread&quot;</span>, (Looper.getMainLooper() == Looper.myLooper()) + <span class="string">&quot;,&quot;</span> + msg.what);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="comment">//开启消息的死循环处理即：dispatchMessage</span></span><br><span class="line">          Looper.loop();</span><br><span class="line">          <span class="comment">//注意这3个的顺序不能颠倒</span></span><br><span class="line">          Log.d(<span class="string">&quot;WorkThread&quot;</span>, <span class="string">&quot;end&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><ol><li><p>HandlerThread作用<br>当系统有多个耗时任务需要执行时，每个任务都会开启一个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题，Google提供了HandlerThread，HandlerThread是在线程中创建一个Looper循环器，让Looper轮询消息队列，当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞。</p></li><li><p>HanlderThread的优缺点</p></li></ol><ul><li>HandlerThread本质上是一个线程类，它继承了Thread；</li><li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li><li>通过获取HandlerThread的looper对象传递给Handler对象，可以在<code>handleMessage()</code>方法中执行异步任务。</li><li>创建HandlerThread后必须先调用<code>HandlerThread.start()</code>方法，Thread会先调用run方法，创建Looper对象。</li><li>HandlerThread优点是异步不会堵塞，减少对性能的消耗</li><li>HandlerThread缺点是不能同时继续进行多任务处理，需要等待进行处理，处理效率较低</li><li>HandlerThread与线程池不同，HandlerThread是一个串行队列，背后只有一个线程。</li></ul><h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><ul><li><p>它本质是一种特殊的Service,继承自Service并且本身就是一个抽象类</p></li><li><p>它可以用于在后台执行耗时的异步任务，当任务完成后会自动停止</p></li><li><p>它拥有较高的优先级，不易被系统杀死（继承自Service的缘故），因此比较适合执行一些高优先级的异步任务<br>它内部通过HandlerThread和Handler实现异步操作</p></li><li><p>创建IntentService时，只需实现onHandleIntent和构造方法，onHandleIntent为异步方法，可以执行耗时操作</p></li><li><p>即使我们多次启动IntentService，但IntentService的实例只有一个，这跟传统的Service是一样的，最终IntentService会去调用onHandleIntent执行异步任务。</p></li><li><p>当任务完成后，IntentService会自动停止，而不需要手动调用<code>stopSelf()</code>。另外，可以多次启动IntentService，每个耗时操作都会以工作队列的方式在<code>IntentService</code>中<code>onHandlerIntent()</code>回调方法中执行，并且每次只会执行一个工作线程。</p></li></ul><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>1、AsyncTask是什么</p><p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并主线程中更新UI，通过AsyncTask可以更加方便执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的后台任务，对于特别耗时的任务来说，建议使用线程池。</p><p>2、AsyncTask使用方法</p><p>三个参数<br><code>Params</code>：表示后台任务执行时的参数类型，该参数会传给AysncTask的<code>doInBackground()</code>方法<br><code>Progress</code>：表示后台任务的执行进度的参数类型，该参数会作为<code>onProgressUpdate()</code>方法的参数<br><code>Result</code>：表示后台任务的返回结果的参数类型，该参数会作为<code>onPostExecute()</code>方法的参数<br>五个方法<br><code>onPreExecute()</code>：异步任务开启之前回调，在主线程中执行<br><code>doInBackground()</code>：执行异步任务，在线程池中执行<br><code>onProgressUpdate()</code>：当doInBackground中调用publishProgress时回调，在主线程中执行<br><code>onPostExecute()</code>：在异步任务执行之后回调，在主线程中执行<br><code>onCancelled()</code>：在异步任务被取消时回调</p><p>3、AsyncTask引起的内存泄漏<br>原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放<br>解决：<br>AsyncTask内部持有外部Activity的弱引用<br>AsyncTask改为静态内部类<br>Activity的<code>onDestory()</code>中调用<code>AsyncTask.cancel()</code></p><p>4.结果丢失<br>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用<code>onPostExecute()</code>再去更新界面将不再生效。</p><p>5、AsyncTask并行or串行<br>AsyncTask在Android 2.3之前默认采用并行执行任务，AsyncTask在Android 2.3之后默认采用串行执行任务<br>如果需要在Android 2.3之后采用并行执行任务，可以调用AsyncTask的<code>executeOnExecutor()</code>;</p><p>6.AsyncTask内部的线程池<br><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</code><br><code>sDefaultExecutor</code>是<code>SerialExecutor</code>的一个实例，而且它是个静态变量。也就是说，一个进程里面所有AsyncTask对象都共享同一个<code>SerialExecutor</code>对象。</p><h2 id="一些面试心经"><a href="#一些面试心经" class="headerlink" title="一些面试心经"></a>一些面试心经</h2><p>一般情况下第一轮都是基础面试，需要扎实的基础</p><p>最常用的Android 基础知识<br>Java 基础知识<br>了解一些 常用东西的原理，例如：handler， thread 等<br>项目中的技术点</p><p>第二轮的时候需要了解更深层次的东西</p><p>Android 事件分发机制原理<br>Android 绘图机制原理<br>WindowManager 的相关知识<br>进程间传输方式<br>Java 内存管理机制<br>一些常用的 list,map 原理，以及子类之间的差别</p><p>能进入第三轮基本没什么问题，但是要注意以下问题</p><p>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度<br>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</p><p>我们的面试原则就是拿到合理薪资，得到 offer<br>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。<br>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>給你一個優雅性感的Logcat</title>
      <link href="/2018/adifficultlogcat/index/"/>
      <url>/2018/adifficultlogcat/index/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>Android Studio的<code>Logcat</code>显示，默认效果如下：</p><p><img src="https://ws2.sinaimg.cn/large/005Zbr7egy1fv23ngc2lqj30lc02y75s.jpg"></p></li><li><p>其实可以通过”Logcat配色”和”自定义Locat输出格式”这两个方面来着手，让Logcat性感起来。</p><p><img src="https://ws1.sinaimg.cn/large/005Zbr7ely1fv23qqte68j31i00qidpe.jpg"></p></li></ul><h2 id="Logcat配色"><a href="#Logcat配色" class="headerlink" title="Logcat配色"></a>Logcat配色</h2><ul><li><p>默认只有Error和Assert是红色，其他都是灰色。</p></li><li><p>设置步骤</p><ol><li>Preferences -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Android Logcat；</li><li>选择要修改的日志级别，如Warning；</li><li>Use inherited attributes去掉勾选；</li><li>勾选Foreground，并点击后面的颜色框进行选色。</li></ol></li></ul><p><img src="https://ws4.sinaimg.cn/large/005Zbr7egy1fv23t0b7s7j31kw0pm7f3.jpg"></p><ul><li>我本人的配色方案。</li></ul><table><thead><tr><th align="center">日志级别</th><th align="center">色值</th></tr></thead><tbody><tr><td align="center">Verbose</td><td align="center">BBBBBB</td></tr><tr><td align="center">Debug</td><td align="center">0070BB</td></tr><tr><td align="center">Info</td><td align="center">48BB31</td></tr><tr><td align="center">Warn</td><td align="center">BBBB23</td></tr><tr><td align="center">Error</td><td align="center">FF0006</td></tr><tr><td align="center">Assert</td><td align="center">FF6B68</td></tr></tbody></table><p><img src="https://ws1.sinaimg.cn/large/005Zbr7ely1fv2400cmctj31e807a78m.jpg"></p><h2 id="自定义Logcat输出格式"><a href="#自定义Logcat输出格式" class="headerlink" title="自定义Logcat输出格式"></a>自定义Logcat输出格式</h2><p>借助开源库logger来自定义Logcat输出格式。</p><p>先上效果图。</p><p><img src="https://ws1.sinaimg.cn/large/005Zbr7ely1fv240wwiq2j319g0rq12m.jpg"></p><p>使用方法</p><ol><li><p>添加依赖：<code>compile &#39;com.orhanobut:logger:1.8&#39;</code>。</p></li><li><p><code>Logger</code>的初始化配置，最好写在自定义<code>Application</code>类的<code>onCreate()</code>中。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger.init(<span class="string">&quot;Daking&quot;</span>) <span class="comment">// TAG</span></span><br><span class="line">.setMethodCount(<span class="number">3</span>) <span class="comment">// 打印位置显示的方法调用栈的方法数,默认为2</span></span><br><span class="line">.hideThreadInfo(); <span class="comment">// 隐藏线程信息,默认为显示.</span></span><br></pre></td></tr></table></figure><ol start="3"><li>输出日志。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Logger.v(<span class="string">&quot;Logger.v&quot;</span>); <span class="comment">// Verbose级别</span></span><br><span class="line">Logger.d(<span class="string">&quot;Logger.d&quot;</span>); <span class="comment">// Debug级别</span></span><br><span class="line">Logger.i(<span class="string">&quot;Logger.i&quot;</span>); <span class="comment">// Info级别</span></span><br><span class="line">Logger.w(<span class="string">&quot;Logger.w&quot;</span>); <span class="comment">// Warn级别</span></span><br><span class="line">Logger.e(<span class="string">&quot;Logger.e&quot;</span>); <span class="comment">// Error级别</span></span><br><span class="line">Logger.wtf(<span class="string">&quot;Logger.wtf&quot;</span>); <span class="comment">// Error级别</span></span><br><span class="line">Logger.json(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;value\&quot;&#125;&quot;</span>); <span class="comment">// 打印json，Debug级别</span></span><br></pre></td></tr></table></figure><p>本文摘自<a href="http://daking.tech/2016/09/26/%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E6%80%A7%E6%84%9F%E7%9A%84Logcat/">【给你一个优雅性感的Logcat】</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“我还在等你，做我的女朋友。”</title>
      <link href="/2018/waityoutomygirlfriend/index/"/>
      <url>/2018/waityoutomygirlfriend/index/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/640.gif"></p><span id="more"></span><blockquote><p>本文转载自<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzA2Mzc2OA==&mid=2650220889&idx=1&sn=8f97f7fd1b8f6b4a038112a4774bd796&chksm=f1d9ae6ec6ae2778bd4fe186cf138f044221b7a15cc6f8b990587ed37ab12bdb315de9a25057&mpshare=1&scene=1">概率论</a></p></blockquote><p><font color=#0099ff><strong>亲爱的未来女友：</strong></font></p><p>&amp;emsp;&amp;emsp;你好啊。</p><p>&amp;emsp;&amp;emsp;说起来有点不好意思，每次写下“未来女友”这四个字，我就忍不住笑得像个傻子。</p><p>&amp;emsp;&amp;emsp;对了，之前给你寄了封信，你收到了吗？</p><p>&amp;emsp;&amp;emsp;<strong>真想看一看，你读信时是怎样的表情啊。</strong></p><p>&amp;emsp;&amp;emsp;会很惊讶吗？还是悄悄红了脸颊？</p><p>&amp;emsp;&amp;emsp;上次给你写信，还是炎热的夏季。现在转眼已经立秋了，时间过得好快啊，我……又想给你写信了。</p><p>&amp;emsp;&amp;emsp;<font color=#0099ff><strong>没办法，对你的思念像只小怪兽，在深夜时冲撞着胸口。</strong></font></p><p>&amp;emsp;&amp;emsp;只能一笔一划写下来，寄给你，才能抚平我对你的想念。</p><p><img src="/img/641.gif"></p><p>&amp;emsp;&amp;emsp;昨天七夕，路过花店时看到一束很美的鲜花。</p><p>&amp;emsp;&amp;emsp;那一刻，真想立刻买下来，像个莽撞的毛头小子一样跑到你家门前，等你2个小时，直到你回家看到我。</p><p>&amp;emsp;&amp;emsp;<font color=#0099ff><strong>这束花被你抱在怀里，才是它最合适的位置。</strong></font></p><p>&amp;emsp;&amp;emsp;可后来想到，我还不知道你家的门牌号，没办法去你家楼下等你。</p><p>&amp;emsp;&amp;emsp;路过街边的商场时，看到很多男人聚集在口红专柜买礼物。</p><p>&amp;emsp;&amp;emsp;真羡慕他们啊。</p><p>&amp;emsp;&amp;emsp;已经遇到喜欢的人了，可以趁着七夕给女朋友送礼物。</p><p>&amp;emsp;&amp;emsp;<font color=#0099ff><strong>不过，作为你的未来男友，我也过去逛了一会，看看能不能在“适合送女友的礼物清单”上，再添加几件物品。</strong></font></p><p>&amp;emsp;&amp;emsp;各种“红色”的口红，应该都很适合你的唇。</p><p>&amp;emsp;&amp;emsp;亮晶晶的耳环，挂在你的耳朵上才最好看。</p><p>&amp;emsp;&amp;emsp;精致的珍珠项链，没有比你的脖颈更合适的位置了。</p><p>&amp;emsp;&amp;emsp;<font color=#FF69B4><strong>如果你在我身边就好了，我一定能立刻挑出你最喜欢的款式。</strong></font></p><p>&amp;emsp;&amp;emsp;不信？</p><p>&amp;emsp;&amp;emsp;<font color=#FF69B4><strong>下个七夕，请和我一起过吧。</strong></font></p><p><img src="/img/642.gif"></p><p>&amp;emsp;&amp;emsp;最近，听到首很甜的歌，叫《星球坠落》。</p><p>&amp;emsp;&amp;emsp;他们唱出了很多我想对你说的情话：</p><blockquote><p>&amp;emsp;&amp;emsp;想摘下星星给你，摘下月亮给你，摘下太阳给你，<font color=#0099ff>你想要我都给你。</font></p><p>&amp;emsp;&amp;emsp;<font color=#0099ff>我不会像任何人一样对待你，我用我自己的方式用心爱你，</font>再没有人像你一样让我动心，再没有人有你一样迷人身影。</p><p>&amp;emsp;&amp;emsp;你想要什么我都给你，<font color=#0099ff>把你整个人都装进心里</font>，让我独自承受这一场暴风雨，<font color=#0099ff>看到你就感到我的世界里全是你。</font></p></blockquote><p>&amp;emsp;&amp;emsp;每次听到情歌，总会情不自禁地记下所有美好的歌词。</p><p>&amp;emsp;&amp;emsp;<strong>以后有机会了，一定要唱给你听。</strong></p><p>&amp;emsp;&amp;emsp;不仅如此，看到好看的云朵，可爱的猫咪，奇怪的太阳雨，我都会记录起来。</p><p>&amp;emsp;&amp;emsp;等以后和你一起躺在沙发上，慢慢看。</p><p>&amp;emsp;&amp;emsp;等待你的时候，我一点都不觉得无聊。因为每度过一天，我就离你更近一点点。</p><p>&amp;emsp;&amp;emsp;<font color=#FF69B4><strong>只要能遇到你，我就觉得很欢喜。</strong></font></p><p><img src="/img/643.gif"></p><p>&amp;emsp;&amp;emsp;我常常会想，你是一个怎样的女孩呢？</p><p>&amp;emsp;&amp;emsp;会为了富察皇后跳楼的剧情哭红了眼睛吗？还是会温柔地跟全世界道晚安，但恶狠狠地强调尔晴纯妃娴妃除外？</p><p>&amp;emsp;&amp;emsp;是个喜欢八卦、追剧的可爱女孩？还是一心投入学习工作的小姐姐？</p><p>&amp;emsp;&amp;emsp;<font color=#0099ff><strong>不管怎样，希望你都能以自己是个女孩而感到自信、骄傲。</strong></font></p><p>&amp;emsp;&amp;emsp;喜欢的小裙子、吊带和人字拖你尽管穿，不用在意别人奇怪的眼光。</p><p>&amp;emsp;&amp;emsp;热爱的理科、计算机等学科、工作你尽管做，无需理会他人的偏见。</p><p>&amp;emsp;&amp;emsp;遇到喜欢的人，勇敢去追，去争取，别让“女生不该主动”这句话阻拦你的幸福。（PS：希望这个喜欢的人是我。）</p><p>&amp;emsp;&amp;emsp;如果可以，请你别害怕，别怀疑。</p><p>&amp;emsp;&amp;emsp;你一定可以自信地用行动证明——</p><p>&amp;emsp;&amp;emsp;<font color=#FF69B4><strong>做自己，就是你最好的样子。</strong></font></p><p><img src="/img/644.gif"></p><p>&amp;emsp;&amp;emsp;明天，你会出门吗？</p><p>&amp;emsp;&amp;emsp;希望你还能一开门就撞到晴朗的天空、好看的街道、散着香气的鲜花，一整天都有心情。</p><p>&amp;emsp;&amp;emsp;<font color=#0099ff>不过，我更希望，你能撞到我的怀里。</font></p><p>&amp;emsp;&amp;emsp;因为——</p><p>&amp;emsp;&amp;emsp;<strong>我和我的拥抱，都还在等你。</strong></p><p>&amp;emsp;&amp;emsp;如果你受了委屈，我会抱住你。</p><p>&amp;emsp;&amp;emsp;如果你对我撒娇，我会轻轻地抱住你。</p><p>&amp;emsp;&amp;emsp;如果你对我发小脾气，我会用力地抱住你。</p><p>&amp;emsp;&amp;emsp;<font color=#FF69B4><strong>真希望一睁开眼，你就站在我面前。</strong></font></p><p  align="right"><font color=#0099ff>还没有遇见你，但已经开始想念你的</font><br/><font color=#0099ff>未来男朋友</font></p>]]></content>
      
      
      <categories>
          
          <category> 日记心事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记心事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想我就够了，不要想别人</title>
      <link href="/2018/thinkme!/think-me-please/"/>
      <url>/2018/thinkme!/think-me-please/</url>
      
        <content type="html"><![CDATA[<center><font size=4>转眼已经到了8月</font></center><center><font size=4>感觉冰激凌还没有吃够</font></center><center><font size=4>夏天就快要过去惹</font></center><center><font size=4>而在等的人</font></center><center><font size=4>却迟迟没有等到</font></center></br><center><font size=4>好像那个人再不来</font></center><center><font size=4>心里就要下雪了</font></center></br><center><font size=4>但下雪就下雪吧</font></center><center><font size=4>就算太平洋结冰</font></center><center><font size=4>乞力马扎罗山的太阳被乌云遮起～～</font></center></br><center><font size=4>今天依然</font></center><center><font size=4>想要等你❤️</font></center>]]></content>
      
      
      <categories>
          
          <category> 日记心事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记心事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSM劫持+短信嗅探是什么，如何防范指南</title>
      <link href="/2018/1466/what-is-gms/"/>
      <url>/2018/1466/what-is-gms/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/img/gms/1533552199.jpeg"></p><blockquote><p>一夜醒来，放在枕边的手机收到几十条银行短信。银行卡，支付宝里的钱全部被人转走，甚至还替你借了网商贷，不单止辛苦多年的积蓄全都没有了，还欠了银行一屁股债，这不是小说里的情节，最近这样的手机盗刷案件在国内频繁发生… 下一个没准就是你</p></blockquote><span id="more"></span><p><em><strong>本文篇幅有点长，但如果你不想辛苦打拼几十年的财产被人一夜盗走，请耐心看下去，并按文章末尾推荐的方式赶紧做好手机和资金账户的防范措施！</strong></em></p><p>近日里，微博一位网友的真实经历引发了诸多人的担忧，在他8月4号的一篇博文《记录一下支付宝，银行app被盗刷的情况》里记录了这样一件让人匪夷所思的事。在2018年8月3日凌晨5:01-7:39分之间，该网友还在熟睡时，不法分子通过盗取它的支付宝和银行账户进行消费和贷款，总计盗刷了18696.29元。期间，该网友的手机就放在枕头边，而银行卡也在家里，银行密码什么的也没被别人知道，这到底是怎么一回事呢？</p><p><img src="/img/img/gms/044f70cf7fb1161ecf089ab785fb7651.jpeg" alt="该网友被GSM劫持+短信嗅探盗刷细节1图片"></p><p><img src="/img/img/gms/06004561aa38d79e9d17e7065c374d05.jpeg" alt="该网友被GSM劫持+短信嗅探盗刷细节2图片"></p><p>如果你本人曾经开通过支付宝或者手机网银，应该还有点印象，这些财务App的开通和登陆，都是用手机号+本人姓名+身份证号+银行卡作为验证方式的。曾几何时，这样的验证方式还算靠谱。毕竟手机是在自己手上对吧，当你接收从银行发过来只于60秒内有效的验证码，再填到验证框去，这一切看起来都哪么天衣无缝，以至于人们觉得足够安全后为了简便，很多App的登陆或绑定方式就简化为了手机号+验证码的方式。但这样一来，就给不法分子留下了可乘之机。</p><h2 id="GSM劫持-短信嗅探是什么？不法分子是怎么通过该方式盗取我们钱财的"><a href="#GSM劫持-短信嗅探是什么？不法分子是怎么通过该方式盗取我们钱财的" class="headerlink" title="GSM劫持+短信嗅探是什么？不法分子是怎么通过该方式盗取我们钱财的"></a>GSM劫持+短信嗅探是什么？不法分子是怎么通过该方式盗取我们钱财的</h2><p>我们现在用的手机，无论你是用的华为小米，还是苹果iPhone，又或是支持什么4G、4G+网络的，其实通通都是由GSM制式走过来的。手机网络的发展是从 1.0（模拟通信）-&gt; 2.0 （GSM）-&gt; 3.0 (3G) -&gt; 4.0（4G&#x2F;4G+）。在手机网络2.0，也即是我们称之为GSM制式的时代，手机语音和短信第一次以纯数字信号的方式进行传输，由于年代久远加上当时的技术限制，GSM制式下手机的短信是单向鉴权并且是以明文方式传输的，什么意思？就是说如果今天你的手机收到一条短信，并且是在GSM制式下收发的话，基站（移动运营商端）只会验证手机是不是真（该网络运营商旗下的）的，但手机不会去甄别这个基站是不是真的（是不是真的该网络运营商的）。这个漏洞就造成了伪基站（一种犯罪分子打造的小型基站用以在小范围内代替运营商真基站并实施犯罪的设备）的兴起。在最开始，不法分子的脑袋还不是太灵光，他们只利用伪基站向附近的手机发送些垃圾广告内容，到后来这种短信自动被一些短信拦截App给屏蔽了，也就没人再用了。他们就开始升级到假扮运营商或者某些大网络公司的服务，用手机短信给你发一个网址从而盗取用户的隐私信息或向用户手机植入木马。时至今天，网络金融在中国得到了长足的发展，各种网络金融App，网上银行App及各种外卖和电商平台的盛行，给这些不法分子营造了绝佳的盗取资金的机会。</p><p><img src="/img/img/gms/c15b4e4de9773756282fe2c81baba864.jpeg" alt="不法分子短信嗅探器显示的画面"></p><h2 id="不法分子使用的GSM劫持及短信嗅探设备"><a href="#不法分子使用的GSM劫持及短信嗅探设备" class="headerlink" title="不法分子使用的GSM劫持及短信嗅探设备"></a>不法分子使用的GSM劫持及短信嗅探设备</h2><p>不法分子首先会挑一个凌晨（这样你就在熟睡中，手机也可能开了静音什么的），然后先利用像是饿了x&#x2F;美x或者移动运营商服务这样的平台，输入你的手机号，让他们向你发送验证码。并用该验证码登陆你的饿了X账号或者移动网上营业厅，顺便也查一些信息，像是饿了X或者美X这种外卖平台，用手机号+验证码登陆后，能查看到你的家庭住址。如果再多过2-30分钟，仍然能用新修改的移动和通信密码登陆网上营业厅，则说明受害人熟睡或者不在手机旁，这时候犯罪分子就开始大胆操作了。他会先用“短信验证码登陆”方式登陆支付宝，然后修改支付宝支付密码，之后就先把支付宝里的余额通过转账或网上消费的方式进行盗取，这还不够可恨，由于现在支付宝属于很强势并且用户众多的手机App，很多银行都对此作了通道优化能让你比较便利的绑定名下银行卡，接下来犯罪分子会通过网上购买到你的银行卡信息，通过支付宝挂靠你的银行卡，开始用支付宝做网上购物或网银转账操作。如果银行卡里没钱，会通过支付宝开通网商贷或者借呗等先贷款到银行卡上，再进行透支消费。总之，一旦不法分子登陆了支付宝后，并且你没有做进一步的验证措施（支付宝也有增加验证强度的方式，但一般人都没有做，这个会在后文提到），那损失就会如微博那篇文章那样了。具体操作手法什么的就不便分析得太具体，以免让坏人有样学样了。</p><h2 id="那我怎么防范GSM劫持-短信嗅探？"><a href="#那我怎么防范GSM劫持-短信嗅探？" class="headerlink" title="那我怎么防范GSM劫持+短信嗅探？"></a>那我怎么防范GSM劫持+短信嗅探？</h2><p>就目前来说，其实GSM劫持已经不是新鲜事了，这事情4-5年前随着伪基站的诞生就已经存在了，问题是中国幅员辽阔，而GSM手机制式（设备）也沿用了十几年，是中国也是现今世界上最大的一张手机网络，这里涉及的设备和系统千千万万。再加上GSM（2G）模式下的短信明文传输和单向鉴权都是协议上的漏洞。只要手机运行在GSM 2G网络下就一定能被利用，说白了就是米已成炊，于事无补，在运营商那边来说只能劝用户尽快升级到4G网络上去（2G全面退网），也就是说靠移动运营商层面来解决这个GSM劫持+短信嗅探问题不现实。</p><p>在网络金融和网银App方面防范这个GSM劫持+短信嗅探是有可能的，但这需要众多手机应用增加新的验证方式，并更新他们的App，这个需要一定的时间，但我相信负责任的大厂（像是支付宝其实已经有这样的功能了，但默认是关闭的）还有本应固若金汤的手机网银App会很快跟进。方法是 1）取消单纯的手机号+接收验证码即可登录甚至还可以修改支付密码等功能 2）在最后的支付环节或修改支付密码环节增加指纹或人脸识别步骤，并且该步骤开启后，需要指纹或人脸识别才能关闭。</p><p>但远水解不了近火，如果在这些软件更新前你就中招了，那怎么办？</p><p>一、首先你们要了解到，GSM劫持是因为手机使用了GSM制式下的2G网络，目前在中国只有中国移动和中国联通2G下是GSM制式，中国电信2G下是CDMA制式，是无法被短信嗅探的。因此，如果你是中国电信用户，或者有中国电信的手机卡（我知道最近很多开了中国电信家庭光纤宽带的，是附赠了无限手机流量套餐手机卡的），可以把支付宝或网银手机号临时改成中国电信的，这样100%就能避免被短信嗅探的问题。</p><p>二、网上有人说，晚上睡觉手机关机。的确，手机关机了，由于手机不在网络下，运营商不会向你发送短信验证码，自然不法分子后续的操作都无法实施，也是100%有效。但对于工作繁忙，或者有时候怕家里出什么事的人来说，一晚上关手机造成的损失可能比银行资金被盗取更大。所以这种方法也不太可取，那有没有不换手机号为中国电信，又或是晚上睡觉不关手机又能防范GSM劫持+短信嗅探的办法呢？答案是有的</p><h2 id="中国移动和中国联通用户如何不关手机防范GSM劫持-短信嗅探"><a href="#中国移动和中国联通用户如何不关手机防范GSM劫持-短信嗅探" class="headerlink" title="中国移动和中国联通用户如何不关手机防范GSM劫持+短信嗅探"></a>中国移动和中国联通用户如何不关手机防范GSM劫持+短信嗅探</h2><ol><li>手机层面的加固。目前中国移动基本在国内全面开通了VoLTE服务，关于VoLTE（语音+短信全走4G网络）服务我们晚些会有篇文章专门说明。这里就简单说一下，当你的中国移动手机开启了VoLTE服务后，无论是语音通话还是手机短信，均会改用4G网络制式，而4G网络制式下手机短信是要双向鉴权的，也就此堵住了不法分子利用的漏洞。可问题是，VoLTE服务严重依赖4G网络，也就是你必须先给手机号开通4G服务，同时在4G网络信号不好或者没有4G网络的地方，手机仍然会自动降为2G网络（这样漏洞就会再次出现，你很难确保什么时候是什么时候不是）。此外，不法分子会利用自制的干扰器压制该区的4G信号，欺骗你的手机降级去连接2G网络，从而又落入GSM漏洞的圈套。再有，中国联通目前仅于部分省市开通了VoLTE服务（中国绝大部分城市都没开通）。所以单就手机启用VoLTE服务能起到一定的作用，但不能完全杜绝。</li></ol><p>对于持有iPhone6及以上，或者这2-3年出产的OPPO，Vivo，小米或者华为手机，也是用中国移动网络的，我们当然是建议开启VoLTE服务。开通方法也很简单，向10086发送短信“KTVOLTE”（没有另外收费，不对现行资费套餐有任何影响），几秒内就生效。之后，iPhone用户需要在设置-&gt;蜂窝移动网络-&gt;蜂窝移动数据选项-&gt;启用4G（改为语音与数据），就算完整启用了。而安卓手机由于平台众多不能一一列举，你们也只需要在语音通话设置项里找一下，什么HD通话或者高清语音通话功能的，打开便是。</p><p>VoLTE服务成功开启后，苹果手机是没有任何提示的，但安卓手机一般会于手机顶部通知栏显示HD字样，意指高清语音功能开启。而如果你想甄别一下手机是否真的开启了VOLTE功能，可以试着用你的手机拨打任意电话，如果此时手机信号从4G降为2G，则说明VoLTE模式没有开启成功。如果打电话途中还是显示4G字样并且能正常上网的，那就是VoLTE开启了。</p><p>对于某些网上用户提议的开启安卓手机上的防伪基站功能，其实在短信嗅探环节里是不起作用的，就是说该功能对本次GSM劫持+短信嗅探攻击不起防护作用。你们别听到人家说开启了防伪基站功能或用了华为带防伪基站功能的手机后就高枕无忧了。</p><p><img src="/img/img/gms/58593d2bbb358e84486aa1bf98f0ed08.jpeg" alt="iPhone开启VoLTE功能的办法"></p><p>设置-&gt;蜂窝移动网络-&gt;蜂窝移动数据选项-&gt;启用4G（改为语音与数据）</p><ol start="2"><li>支付宝开启高级验证。从上面不法分子的犯案步骤可以看到，他们都是用手机号+验证码方式登录支付宝，那有没有一种方法，能让现有的支付宝版本就能在手机号验证的时候多加一道安全验证措施呢？答案是有的。你先升级iPhone最新版的支付宝，然后找到于“我的”页面-&gt;右上“设置”-&gt;安全设置-&gt;安全中心-&gt;暗号。该功能会要求用户拍摄一张照片，或者自己画一张图片作为暗号，一旦用户于非常用设备（就是新设备）登陆支付宝，除了短信验证码外，还会要你从9个相似图片里找到这个暗号，只要你答错一次，支付宝的风控就会启动。但美中不足的是，这个暗号是把一张自己的图片+随机抽取的8张图片混在一起给你挑选，也就是说，不法分子随机挑选碰中的机会也有1&#x2F;9。这方法是给不法分子增加了难度，但还是有一定几率被撞破，无法做到100%防护。</li></ol><p><img src="/img/img/gms/3c315da501b44a6769d6f58bf360a90d.jpeg" alt="支付宝开启暗号登陆验证"></p><p><img src="/img/img/gms/a5d65cd6b8ba3c06f4270bfeaf5ba027.jpeg" alt="支付宝 暗号 登陆验证功能说明"></p><ol start="3"><li>对你的资金账户投保。在开启了VoLTE功能，并于支付宝加设了暗号后，就像上文所说的，还是不能100%防范，所以我们还要继续加强保护。现在，返回到支付宝“我的”页面，进入“总资产”项，在最顶部你的ID旁边，有一个“账户安全险保障中”的，点击进去你能看到一个“支付宝账户安全险”外加“银行卡安全险”。“支付宝安全险”就很好理解了，在支付宝余额里的钱如果被盗刷了，100万以内支付宝会赔付。另外一个“银行卡安全险”如果你之前没开通过的，可以在我的银行卡底部找到这个开通连接。该保险的协议内容是你名下所有银行卡资金被盗刷的话，就赔，几十块钱保几万就够了。</li></ol><p><img src="/img/img/gms/88c1f0f01224f060b26d10cb73d28b11.jpeg" alt="支付宝银行卡安全险"></p><p><img src="/img/img/gms/d97ad9f0283f2cfbd455fef7f0528aec.jpeg" alt="支付宝账户险和银行卡安全险双开启"></p><ol start="4"><li>睡觉时手机开飞行模式但打开wifi。如果家里人跟你同住，或者家里有座机的，在支付宝和各大网银App升级软件安全功能前，还是建议晚上睡觉时手机开飞行模式后，开wifi（这样手机信号是关闭的，但又不影响微信，iMessage或者一些网银App的通知，支付宝和网银那些一旦有资金变动现在都是第一时间有推送通知的，而推送通知只要手机能连上网便可收到）。</li></ol><blockquote><p>本文转载自 <a href="https://52huameng.com/zixun/1466">华梦博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 资讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava结合Retrofit对网络请求结果的统一处理</title>
      <link href="/2018/rxjava_retrofit_result/index/"/>
      <url>/2018/rxjava_retrofit_result/index/</url>
      
        <content type="html"><![CDATA[<p>不同的网络请求有不同的返回结果，当同时也有很多相同的地方，比如数据的整体结构可以是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 1000,</span><br><span class="line">    &quot;msg&quot;: &quot;调用权限失败&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">            ***</span><br><span class="line">            ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果接口数据的设计如上，那么每个请求都会有如下三点相同的部分</p><ol><li>状态码</li><li>网络异常</li><li>相同的网络请求策略</li></ol><p>既然有相同的部分，那么就有必要对相同的部分统一处理</p><h2 id="主要功能图解"><a href="#主要功能图解" class="headerlink" title="主要功能图解"></a>主要功能图解</h2><p>整体采用MVP设计模式，如下：</p><p><img src="https://ws1.sinaimg.cn/large/005Zbr7egy1ftwgnr2k9bj30g803675c.jpg" alt="MVP架构"></p><p>其中ModelPresenter为所有网络请求的Presenter，如下：</p><p><img src="https://ws2.sinaimg.cn/large/005Zbr7egy1ftwgp7f3ncj30h9072gnk.jpg" alt="ModelPresenter"></p><p>DataService为Retrofit请求接口，如下：</p><p><img src="https://ws1.sinaimg.cn/large/005Zbr7egy1ftwgq54wmfj30h306wac0.jpg" alt="DataService"></p><p>网络层的整体流程如下</p><p><img src="https://ws1.sinaimg.cn/large/005Zbr7egy1ftwgq54wmfj30h306wac0.jpg" alt="网络层流程"></p><p>其中第三层返回的是HttpBean<T>，第二层返回的是业务层需要的T类型</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>在和后台对接的时候，定义一个统一的数据结构，这样才好统一处理状态码，利用泛型，我们可以设计借口返回的数据模型为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的网络请求只需要传入相应的数据模型即可，那么利用Retrofit请求数据的接口如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(RequestCons.MY_BOX)</span></span><br><span class="line">    Observable&lt;HttpBean&lt;BoxData&gt;&gt; <span class="title function_">getBox</span><span class="params">(<span class="meta">@Query(&quot;client_id&quot;)</span> String client_id, <span class="meta">@Query(&quot;client_secret&quot;)</span> String secret, <span class="meta">@Query(&quot;visit_user_id&quot;)</span> <span class="type">long</span> user_id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(RequestCons.COMMENTS_LIST)</span></span><br><span class="line">    Observable&lt;HttpBean&lt;CommentData&gt;&gt; <span class="title function_">getComments</span><span class="params">(<span class="meta">@Query(&quot;client_id&quot;)</span> String client_id, <span class="meta">@Query(&quot;client_secret&quot;)</span> String secret, <span class="meta">@Query(&quot;object_id&quot;)</span> <span class="type">long</span> object_id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(RequestCons.TOPIC)</span></span><br><span class="line">    Observable&lt;HttpBean&lt;TopicData&gt;&gt; <span class="title function_">getTopic</span><span class="params">(<span class="meta">@Query(&quot;client_id&quot;)</span> String client_id, <span class="meta">@Query(&quot;client_secret&quot;)</span> String secret, <span class="meta">@Query(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层向模型层请求数据的接口如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ModelPresenter</span> &#123;</span><br><span class="line">    <span class="comment">/**     * 下载box数据接口     */</span></span><br><span class="line">    Observable&lt;BoxData&gt; <span class="title function_">loadBoxData</span><span class="params">(String client_id, String secret, <span class="type">long</span> user_id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * 下载评论数据接口     */</span></span><br><span class="line">    Observable&lt;CommentData&gt; <span class="title function_">loadCommentData</span><span class="params">(String client_id, String secret, <span class="type">long</span> object_id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * 下载Topic商品     */</span></span><br><span class="line">    Observable&lt;TopicData&gt; <span class="title function_">loadTopic</span><span class="params">(String client_id, String secret, <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对比两个接口，可以发现业务层无需关心状态码了，只会拿到Observable<T>而不是Obervable&lt;HttpBean<T>&gt;</p><h3 id="ModelPresenterImpl的实现"><a href="#ModelPresenterImpl的实现" class="headerlink" title="ModelPresenterImpl的实现"></a>ModelPresenterImpl的实现</h3><p>ModelPresenterImpl继承自BaseModelImpl，本身的实现其实很简单，主要工作就是调用DataService对应的方法，然后过滤状态码，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelPresenterImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseModelImpl</span> <span class="keyword">implements</span> <span class="title class_">ModelPresenter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;BoxData&gt; <span class="title function_">loadBoxData</span><span class="params">(String client_id, String secret, <span class="type">long</span> user_id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filterStatus(mDataService.getBox(client_id,secret,user_id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;CommentData&gt; <span class="title function_">loadCommentData</span><span class="params">(String client_id, String secret, <span class="type">long</span> object_id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filterStatus(mDataService.getComments(client_id,secret,object_id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;TopicData&gt; <span class="title function_">loadTopic</span><span class="params">(String client_id, String secret, <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filterStatus(mDataService.getTopic(client_id,secret,id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BaseModelImpl的实现"><a href="#BaseModelImpl的实现" class="headerlink" title="BaseModelImpl的实现"></a>BaseModelImpl的实现</h3><p>BaseModelImpl做了以下两点工作</p><ol><li>创建OkHttpClient、Retrofit、DataService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BaseModelImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = RequestCons.BASE_URL;</span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">            .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">            .build();</span><br><span class="line">    mRetrofit = <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">            .baseUrl(baseUrl)</span><br><span class="line">            .client(client)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line">    mDataService = mRetrofit.create(DataService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用Rxjava的map操作符过滤状态码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 给返回结果去掉状态码等属性,</span></span><br><span class="line"><span class="comment"> * 如果是查询出错,则返回状态码对应的描述给用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> observable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Observable <span class="title function_">filterStatus</span><span class="params">(Observable observable)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observable.map(<span class="keyword">new</span> <span class="title class_">ResultFilter</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ResultFilter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Func1</span>&lt;HttpBean&lt;T&gt;, T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">(HttpBean&lt;T&gt; tHttpBean)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tHttpBean.getStatus() != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApiException</span>(tHttpBean.getStatus());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tHttpBean.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处代码是一个关键点，利用操作符map给请求的数据“去壳”，只返回给业务层所需要的模型，如果当前请求的状态码不是成功的标志，那么抛出异常，交给应用层的OnError处理，确保应用层的onNext方法只处理成功的结果，纯粹专一。</p><h3 id="配置状态码过滤器"><a href="#配置状态码过滤器" class="headerlink" title="配置状态码过滤器"></a>配置状态码过滤器</h3><p>状态码过滤器一共需要两个类</p><ol><li>常量说明类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseCons</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATUS_SUCCESS</span>  <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SUCCESS_MSG</span> <span class="operator">=</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATU_1000</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FAILURE_1000</span> <span class="operator">=</span> <span class="string">&quot;调用权限失败&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>状态码匹配工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatusUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StatusResult</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> status;</span><br><span class="line">        <span class="keyword">public</span> String desc;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StatusResult</span> <span class="variable">mStatusResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatusResult</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StatusResult <span class="title function_">judgeStatus</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> ResponseCons.STATUS_SUCCESS:</span><br><span class="line">                desc = ResponseCons.SUCCESS_MSG;</span><br><span class="line">                isSuccess = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ResponseCons.STATU_1000:</span><br><span class="line">                desc = ResponseCons.FAILURE_1000;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mStatusResult.status = status;</span><br><span class="line">        mStatusResult.desc = desc;</span><br><span class="line">        mStatusResult.isSuccess = isSuccess;</span><br><span class="line">        <span class="keyword">return</span> mStatusResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BaseModelImpl中对网络请求结果的状态码进行判断，如果不是标志成功的状态码，那么就抛出一个异常，在异常中利用状态码匹配工具类找到对应错误描述并且返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiException</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(getErrorDesc(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getErrorDesc</span><span class="params">(<span class="type">int</span> status)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StatusUtils.judgeStatus(status).desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着业务的扩展，如出现新的状态码，那么只需要往常亮类和匹配工具类增加状态码和错误描述即可，不需要更改网络层其他代码，还可以拓展成将错误码和对应描述信息存储在本地，当成配置文件，那么当产品发布之后，如果后台增加错误码，只需要download新的状态码配置文件即可，不需要发布新版本应用。</p><h3 id="其他网络错误处理"><a href="#其他网络错误处理" class="headerlink" title="其他网络错误处理"></a>其他网络错误处理</h3><p>以上已经基本实现了网络层的功能，包括发起请求，解析返回结果并且统一过滤状态码，将请求成功的结果返回到Observable.onNext()，将失败结果返回到Observable.onError()。</p><p><strong>然而网络请求并不是一直稳定的，所以所有网络请求都有可能出现超时、无网络连接或者其他40x，50x错误。</strong></p><p>因此还需要再做一层错误过滤，在Retrofit中，所有的异常都会抛出，并且最终由Observable的onError接收，所以我们可以自定义一个FilterSubscriber继承自Subscriber，实现onError接口，对传入的throwable参数进行判处理，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FilterSubscriber</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Subscriber</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String error;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TimeoutException || e <span class="keyword">instanceof</span> SocketTimeoutException</span><br><span class="line">            || e <span class="keyword">instanceof</span> ConnectException)&#123;</span><br><span class="line">            error = <span class="string">&quot;超时了&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> JsonSyntaxException)&#123;</span><br><span class="line">            error = <span class="string">&quot;Json格式出错了&quot;</span>;</span><br><span class="line">            <span class="comment">//假如导致这个异常触发的原因是服务器的问题，那么应该让服务器知道，所以可以在这里</span></span><br><span class="line">            <span class="comment">//选择上传原始异常描述信息给服务器</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            error = e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们提取出异常处理类，在异常处理类的onError( )中统一对所有异常进行处理，所以当一些异常确定是或者疑似是服务器的bug，抑或是未知bug，我们应该及时上报服务器，让服务器收集错误信息，及时修复，所以在onError( )中选择上传数据请求的异常信息是一个不错的选择。当然服务器的异常也可以后台自己收集，这里只是提供一种策略而已。</p><h3 id="应用层调用"><a href="#应用层调用" class="headerlink" title="应用层调用"></a>应用层调用</h3><p>做完了发送请求，解析数据，错误处理，最后就是应用层调用了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadTopicSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">    Observable&lt;TopicData&gt; observable = mModelPresenter.loadTopic(<span class="string">&quot;bt_app_ios&quot;</span>, <span class="string">&quot;9c1e6634ce1c5098e056628cd66a17a5&quot;</span>, <span class="number">1346</span>);</span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> <span class="title class_">FilterSubscriber</span>&lt;TopicData&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">                    MLog.d(<span class="string">&quot;Topic信息下载完毕&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(TopicData data)</span> &#123;</span><br><span class="line">                    mMainView.showSuccess(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    <span class="built_in">super</span>.onError(e);</span><br><span class="line">                    mMainView.showError(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，在onError(Throwable e){ }中第一行代码需要super.onError(e),然后接下去的异常信息的描述是error字符串。</strong></p><p>做完以上工作之后，往后如果需要添加新的接口，那么只需要以下几步</p><ol><li>在requestCons添加新的接口的文件路径</li><li>增加相应的bean文件</li><li>在DataService中添加新的接口方法</li><li>在ModelPresenter添加新的接口方法并且在Impl中实现</li></ol><p>而不需要再处理以下内容</p><ol><li>客户端的创建</li><li>状态码过滤</li><li>网络异常过滤</li></ol><p><a href="https://link.jianshu.com/?t=https://github.com/LittleMango/RxJava-Retrofit-/tree/master">上传的源码</a>使用MVP设计模式的思想，如果想了解如何使用MVP的同学可以下载看看。</p><p>【<a href="https://www.jianshu.com/p/c88ebf1e0ca7">原文链接</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Retrofit </tag>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学之美番外篇：平凡而又神奇的贝叶斯方法</title>
      <link href="/2018/the-magical-bayesian-method/index/"/>
      <url>/2018/the-magical-bayesian-method/index/</url>
      
        <content type="html"><![CDATA[<p>【原文链接】:<a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/">数学之美番外篇：平凡而又神奇的贝叶斯方法</a></p><blockquote><p>概率论只不过是把常识用数学公式表达了出来。</p><p>——拉普拉斯</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>托马斯·贝叶斯（Thomas Bayes）同学的详细生平在<a href="http://en.wikipedia.org/wiki/Thomas_Bayes">这里</a>。以下摘一段 wikipedia 上的简介：</p><blockquote><p>所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。</p></blockquote><p>实际上，贝叶斯当时的论文只是对这个问题的一个直接的求解尝试，并不清楚他当时是不是已经意识到这里面包含着的深刻的思想。然而后来，贝叶斯方法席卷了概率论，并将应用延伸到各个问题领域，所有需要作出概率预测的地方都可以见到贝叶斯方法的影子，特别地，贝叶斯是机器学习的核心方法之一。这背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的（否则有很大一部分科学就没有必要做了——设想我们能够直接观察到电子的运行，还需要对原子模型争吵不休吗？），我们日常所观察到的只是事物表面上的结果，沿用刚才那个袋子里面取球的比方，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，我们就需要提供一个猜测（hypothesis，更为严格的说法是“假设”，这里用“猜测”更通俗易懂一点），所谓猜测，当然就是不确定的（很可能有好多种乃至无数种猜测都能满足目前的观测），<strong>但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。</strong></p><h3 id="一个栗子：自然语言的二义性"><a href="#一个栗子：自然语言的二义性" class="headerlink" title="一个栗子：自然语言的二义性"></a>一个栗子：自然语言的二义性</h3><p>下面举一个自然语言的不确定性的例子。当你看到这句话：</p><blockquote><p>The girl saw the boy with a telescope.</p></blockquote><p>你对这句话的含义有什么猜测？平常人肯定会说：那个女孩拿望远镜看见了那个男孩（即你对这个句子背后的实际语法结构的猜测是：The girl saw-with-a-telescope the boy ）。然而，仔细一想，你会发现这个句子完全可以解释成：那个女孩看见了那个拿着望远镜的男孩（即：The girl saw the-boy-with-a-telescope ）。那为什么平常生活中我们每个人都能够迅速地对这种二义性进行消解呢？这背后到底隐藏着什么样的思维法则？我们留到后面解释。</p><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>贝叶斯公式是怎么来的？</p><p>我们还是使用 wikipedia 上的一个例子：</p><blockquote><p>一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？</p></blockquote><p>一些认知科学的研究表明（《决策与判断》以及《<a href="http://www.douban.com/subject/3199621/">Rationality for Mortals</a>》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面<a href="http://en.wikipedia.org/wiki/Random_walk">随机游走</a>，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。</p><p>你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？</p><p>我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 U * P(Boy) * P(Pants|Boy) 个穿长裤的（男生）（其中 P(Boy) 是男生的概率 &#x3D; 60%，这里可以简单的理解为男生的比例；P(Pants|Boy) 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 U * P(Girl) * P(Pants|Girl) 个穿长裤的（女生）。加起来一共是 U * P(Boy) * P(Pants|Boy) + U * P(Girl) * P(Pants|Girl) 个穿长裤的，其中有 U * P(Girl) * P(Pants|Girl) 个女生。两者一比就是你要求的答案。</p><p>下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U * P(Girl) * P(Pants|Girl) &#x2F; [U * P(Boy) * P(Pants|Boy) + U * P(Girl) * P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到</p><p><strong>P(Girl|Pants) &#x3D; P(Girl) * P(Pants|Girl) &#x2F; [P(Boy) * P(Pants|Boy) + P(Girl) * P(Pants|Girl)]</strong></p><p>注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。</p><p>上式中的 Pants 和 Boy&#x2F;Girl 可以指代一切东西，所以其一般形式就是：</p><p><strong>P(B|A) &#x3D; P(A|B) * P(B) &#x2F; [P(A|B) * P(B) + P(A|<del>B) * P(</del>B) ]</strong></p><p>收缩起来就是：</p><p><strong>P(B|A) &#x3D; P(AB) &#x2F; P(A)</strong></p><p>其实这个就等于：</p><p><strong>P(B|A) * P(A) &#x3D; P(AB)</strong></p><p>难怪拉普拉斯说__概率论只是把常识用数学公式表达了出来__。</p><p>然而，后面我们会逐渐发现，看似这么平凡的贝叶斯公式，背后却隐含着非常深刻的原理。</p><h2 id="拼写纠正"><a href="#拼写纠正" class="headerlink" title="拼写纠正"></a>拼写纠正</h2><p>经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查&#x2F;纠正器的文章（原文在<a href="http://norvig.com/spell-correct.html">这里</a>，徐宥的翻译版在<a href="http://blog.youxu.info/spell-correct.html">这里</a>，这篇文章很深入浅出，强烈建议读一读），里面用到的就是贝叶斯方法，这里我们不打算复述他写的文章，而是简要地将其核心思想介绍一下。</p><p>首先，我们需要询问的是：“__问题是什么？__”</p><p>问题是我们看到用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用刚才我们形式化的语言来叙述就是，我们需要求：</p><p><strong>P(我们猜测他想输入的单词 | 他实际输入的单词)</strong></p><p>这个概率。并找出那个使得这个概率最大的猜测单词。显然，我们的猜测未必是唯一的，就像前面举的那个自然语言的歧义性的例子一样；这里，比如用户输入： thew ，那么他到底是想输入 the ，还是想输入 thaw ？到底哪个猜测可能性更大呢？幸运的是我们可以用贝叶斯公式来直接出它们各自的概率，我们不妨将我们的多个猜测记为 h1 h2 .. （ h 代表 hypothesis），它们都属于一个有限且离散的猜测空间 H （单词总共就那么多而已），将用户实际输入的单词记为 D （ D 代表 Data ，即观测数据），于是</p><p><strong>P(我们的猜测1 | 他实际输入的单词)</strong></p><p>可以抽象地记为：</p><p><em>P(h1 | D)</em></p><p>类似地，对于我们的猜测2，则是 _P(h2 | D)_。不妨统一记为：</p><p><em>P(h | D)</em></p><p>运用一次贝叶斯公式，我们得到：</p><p><strong>P(h | D) &#x3D; P(h) * P(D | h) &#x2F; P(D)</strong></p><p>对于不同的具体猜测 h1 h2 h3 .. ，P(D) 都是一样的，所以在比较 P(h1 | D) 和 P(h2 | D) 的时候我们可以忽略这个常数。即我们只需要知道：</p><p>P(h | D) ∝ P(h) * P(D | h) （注：那个符号的意思是“正比例于”，不是无穷大，注意符号右端是有一个小缺口的。）</p><p>这个式子的抽象含义是：对于给定观测数据，一个猜测是好是坏，取决于“这个猜测本身独立的可能性大小（先验概率，Prior ）”和“这个猜测生成我们观测到的数据的可能性大小”（似然，Likelihood ）的乘积。具体到我们的那个 thew 例子上，含义就是，用户实际是想输入 the 的可能性大小取决于 the 本身在词汇表中被使用的可能性（频繁程度）大小（先验概率）和 想打 the 却打成 thew 的可能性大小（似然）的乘积。</p><p>下面的事情就很简单了，对于我们猜测为可能的每个单词计算一下 P(h) * P(D | h) 这个值，然后取最大的，得到的就是最靠谱的猜测。</p><p>__一点注记__：Norvig 的拼写纠正器里面只提取了编辑距离为 2 以内的所有已知单词。这是为了避免去遍历字典中每个单词计算它们的 P(h) * P(D | h) ，但这种做法为了节省时间带来了一些误差。但话说回来难道我们人类真的回去遍历每个可能的单词来计算他们的后验概率吗？不可能。实际上，根据认知神经科学的观点，我们首先根据错误的单词做一个 bottom-up 的关联提取，提取出有可能是实际单词的那些候选单词，这个提取过程就是所谓的基于内容的提取，可以根据错误单词的一些模式片段提取出有限的一组候选，非常快地缩小的搜索空间（比如我输入 explaination ，单词里面就有充分的信息使得我们的大脑在常数时间内把可能性 narrow down 到 explanation 这个单词上，至于具体是根据哪些线索——如音节——来提取，又是如何在生物神经网络中实现这个提取机制的，目前还是一个没有弄清的领域）。然后，我们对这有限的几个猜测做一个 top-down 的预测，看看到底哪个对于观测数据（即错误单词）的预测效力最好，而如何衡量预测效率则就是用贝叶斯公式里面的那个 P(h) * P(D | h) 了——虽然我们很可能使用了<a href="http://www.douban.com/subject/1599035/">一些启发法来简化计算</a>。后面我们还会提到这样的 bottom-up 的关联提取。</p><h2 id="模型比较与贝叶斯奥卡姆剃刀"><a href="#模型比较与贝叶斯奥卡姆剃刀" class="headerlink" title="模型比较与贝叶斯奥卡姆剃刀"></a>模型比较与贝叶斯奥卡姆剃刀</h2><h3 id="再访拼写纠正"><a href="#再访拼写纠正" class="headerlink" title="再访拼写纠正"></a>再访拼写纠正</h3><p>介绍了贝叶斯拼写纠正之后，接下来的一个自然而然的问题就来了：“_为什么？_”为什么要用贝叶斯公式？为什么贝叶斯公式在这里可以用？我们可以很容易地领会为什么贝叶斯公式用在前面介绍的那个男生女生长裤裙子的问题里是正确的。但为什么这里？</p><p>为了回答这个问题，一个常见的思路就是想想：<em>非得这样吗？</em> 因为如果你想到了另一种做法并且证明了它也是靠谱的，那么将它与现在这个一比较，也许就能得出很有价值的信息。那么对于拼写纠错问题你能想到其他方案吗？</p><p>不管怎样，一个最常见的替代方案就是，选择离 thew 的<a href="http://en.wikipedia.org/wiki/Edit_distance">编辑距离</a>最近的。然而 the 和 thaw 离 thew 的编辑距离都是 1 。这可咋办捏？你说，不慌，那还是好办。我们就看到底哪个更可能被错打为 thew 就是了。我们注意到字母 e 和字母 w 在键盘上离得很紧，无名指一抽筋就不小心多打出一个 w 来，the 就变成 thew 了。而另一方面 thaw 被错打成 thew 的可能性就相对小一点，因为 e 和 a 离得较远而且使用的指头相差一个指头（一个是中指一个是小指，不像 e 和 w 使用的指头靠在一块——神经科学的证据表明紧邻的身体设施之间容易串位）。OK，很好，因为你现在已经是在用最大似然方法了，或者直白一点，你就是在计算那个使得 P(D | h) 最大的 h 。</p><p>而贝叶斯方法计算的是什么？是 P(h) * P(D | h) 。多出来了一个 P(h) 。我们刚才说了，这个多出来的 P(h) 是特定猜测的先验概率。为什么要掺和进一个先验概率？刚才说的那个最大似然不是挺好么？很雄辩地指出了 the 是更靠谱的猜测。有什么问题呢？既然这样，我们就从给最大似然找茬开始吧——我们假设两者的似然程度是一样或非常相近，这样不就难以区分哪个猜测更靠谱了吗？比如用户输入tlp ，那到底是 top 还是 tip ？（这个例子不怎么好，因为 top 和 tip 的词频可能仍然是接近的，但一时想不到好的英文单词的例子，我们不妨就假设 top 比 tip 常见许多吧，这个假设并不影响问题的本质。）这个时候，当最大似然不能作出决定性的判断时，先验概率就可以插手进来给出指示——“既然你无法决定，那么我告诉你，一般来说 top 出现的程度要高许多，所以更可能他想打的是 top ”）。</p><p>以上只是最大似然的一个问题，即并不能提供决策的全部信息。</p><p>最大似然还有另一个问题：即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低。比如 MacKay 在《Information Theory : Inference and Learning Algorithms》里面就举了一个很好的例子：-1 3 7 11 你说是等差数列更有可能呢？还是 -X^3 &#x2F; 11 + 9&#x2F;11*X^2 + 23&#x2F;11 每项把前项作为 X 带入后计算得到的数列？此外曲线拟合也是，平面上 N 个点总是可以用 N-1 阶多项式来完全拟合，当 N 个点近似但不精确共线的时候，用 N-1 阶多项式来拟合能够精确通过每一个点，然而用直线来做拟合&#x2F;线性回归的时候却会使得某些点不能位于直线上。你说到底哪个好呢？多项式？还是直线？一般地说肯定是越低阶的多项式越靠谱（当然前提是也不能忽视“似然”P(D | h) ，明摆着一个多项式分布您愣是去拿直线拟合也是不靠谱的，这就是为什么要把它们两者乘起来考虑。），原因之一就是低阶多项式更常见，先验概率（ P(h) ）较大（原因之二则隐藏在 P(D | h) 里面），这就是为什么我们要用<a href="http://en.wikipedia.org/wiki/Spline_interpolation">样条</a>来插值，而不是直接搞一个 N-1 阶多项式来通过任意 N 个点的原因。</p><p>以上分析当中隐含的哲学是，观测数据总是会有各种各样的误差，比如观测误差（比如你观测的时候一个 MM 经过你一不留神，手一抖就是一个误差出现了），所以如果过分去寻求能够完美解释观测数据的模型，就会落入所谓的数据<a href="http://en.wikipedia.org/wiki/Overfitting">过配（overfitting）</a>的境地，一个过配的模型试图连误差（噪音）都去解释（而实际上噪音又是不需要解释的），显然就过犹不及了。所以 P(D | h) 大不代表你的 h （猜测）就是更好的 h。还要看 P(h) 是怎样的。所谓<a href="http://en.wikipedia.org/wiki/Occam%27s_razor">奥卡姆剃刀</a>精神就是说：如果两个理论具有相似的解释力度，那么优先选择那个更简单的（往往也正是更平凡的，更少繁复的，更常见的）。</p><p>过分匹配的另一个原因在于当观测的结果并不是因为误差而显得“不精确”而是因为真实世界中对数据的结果产生贡献的因素太多太多，跟噪音不同，这些偏差是一些另外的因素集体贡献的结果，不是你的模型所能解释的——噪音那是不需要解释——一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈<a href="http://en.wikipedia.org/wiki/Normal_Distribution">正态分布</a>，于是你实际观察到的结果就是这个正态分布的<a href="http://en.wikipedia.org/wiki/Random_sample">随机取样</a>，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型，举个教科书例子：身高和体重的实际关系近似于一个二阶多项式的关系，但大家都知道并不是只有身高才会对体重产生影响，物理世界影响体重的因素太多太多了，有人身材高大却瘦得跟稻草，有人却是横长竖不长。但不可否认的是总体上来说，那些特殊情况越是特殊就越是稀少，呈围绕最普遍情况（胖瘦适中）的正态分布，这个分布就保证了我们的身高——体重相关模型能够在大多数情况下做出靠谱的预测。但是——刚才说了，特例是存在的，就算不是特例，人有胖瘦，密度也有大小，所以完美符合身高——体重的某个假想的二阶多项式关系的人是不存在的，我们又不是欧几里德几何世界当中的理想多面体，所以，当我们对人群随机抽取了 N 个样本（数据点）试图对这 N 个数据点拟合出一个多项式的话就得注意，它肯定得是二阶多项式，我们要做的只是去根据数据点计算出多项式各项的参数（一个典型的方法就是最小二乘）；它肯定不是直线（我们又不是稻草），也不是三阶多项式四阶多项式.. 如果硬要完美拟合 N 个点，你可能会整出一个 N-1 阶多项式来——设想身高和体重的关系是 5 阶多项式看看？</p><h3 id="模型比较理论-Model-Comparasion-与贝叶斯奥卡姆剃刀-Bayesian-Occam-s-Razor"><a href="#模型比较理论-Model-Comparasion-与贝叶斯奥卡姆剃刀-Bayesian-Occam-s-Razor" class="headerlink" title="模型比较理论(Model Comparasion)与贝叶斯奥卡姆剃刀(Bayesian Occam`s Razor)"></a>模型比较理论(Model Comparasion)与贝叶斯奥卡姆剃刀(Bayesian Occam`s Razor)</h3><p>实际上，模型比较就是去比较哪个模型（猜测）更可能隐藏在观察数据的背后。其基本思想前面已经用拼写纠正的例子来说明了。我们对用户实际想输入的单词的猜测就是模型，用户输错的单词就是观测数据。我们通过：</p><p>P(h | D) ∝ P(h) * P(D | h)</p><p>来比较哪个模型最为靠谱。前面提到，光靠 P(D | h) （即“似然”）是不够的，有时候还需要引入 P(h) 这个先验概率。奥卡姆剃刀就是说 P(h) 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 P(D | h) 最大的）最有优势。整个模型比较就是这两方力量的拉锯。我们不妨再举一个简单的例子来说明这一精神：你随便找枚硬币，掷一下，观察一下结果。好，你观察到的结果要么是“正”，要么是“反”（不，不是少林足球那枚硬币:P ），不妨假设你观察到的是“正”。现在你要去根据这个观测数据推断这枚硬币掷出“正”的概率是多大。根据最大似然估计的精神，我们应该猜测这枚硬币掷出“正”的概率是 1 ，因为这个才是能最大化 P(D | h) 的那个猜测。然而每个人都会大摇其头——很显然，你随机摸出一枚硬币这枚硬币居然没有反面的概率是“不存在的”，我们对一枚随机硬币是否一枚有偏硬币，偏了多少，是有着一个先验的认识的，这个认识就是绝大多数硬币都是基本公平的，偏得越多的硬币越少见（可以用一个 <a href="http://en.wikipedia.org/wiki/Beta_distribution">beta 分布</a>来表达这一先验概率）。将这个先验正态分布 p(θ) （其中 θ 表示硬币掷出正面的比例，小写的 p 代表这是<a href="http://en.wikipedia.org/wiki/Probability_density_function">概率密度函数</a>）结合到我们的问题中，我们便不是去最大化 P(D | h) ，而是去最大化 P(D | θ) * p(θ) ，显然 θ &#x3D; 1 是不行的，因为 P(θ&#x3D;1) 为 0 ，导致整个乘积也为 0 。实际上，只要对这个式子求一个导数就可以得到最值点。</p><p>以上说的是当我们知道先验概率 P(h) 的时候，光用最大似然是不靠谱的，因为最大似然的猜测可能先验概率非常小。然而，有些时候，我们对于先验概率一无所知，只能假设每种猜测的先验概率是均等的，这个时候就只有用最大似然了。实际上，统计学家和贝叶斯学家有一个有趣的争论，统计学家说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯支持者则说：数据会有各种各样的偏差，而一个靠谱的先验概率则可以对这些随机噪音做到健壮。事实证明贝叶斯派胜利了，胜利的关键在于所谓先验概率其实也是经验统计的结果，譬如为什么我们会认为绝大多数硬币是基本公平的？为什么我们认为大多数人的肥胖适中？为什么我们认为肤色是种族相关的，而体重则与种族无关？先验概率里面的“先验”并不是指先于一切经验，而是仅指先于我们“当前”给出的观测数据而已，在硬币的例子中先验指的只是先于我们知道投掷的结果这个经验，而并非“先天”。</p><p>然而，话说回来，有时候我们必须得承认，就算是基于以往的经验，我们手头的“先验”概率还是均匀分布，这个时候就必须依赖用最大似然，我们用前面留下的一个自然语言二义性问题来说明这一点：</p><blockquote><p>The girl saw the boy with a telescope.</p></blockquote><p>到底是 The girl saw-with-a-telescope the boy 这一语法结构，还是 The girl saw the-boy-with-a-telescope 呢？两种语法结构的常见程度都差不多（你可能会觉得后一种语法结构的常见程度较低，这是事后偏见，你只需想想 The girl saw the boy with a book 就知道了。当然，实际上从大规模语料统计结果来看后一种语法结构的确稍稍不常见一丁点，但是绝对不足以解释我们对第一种结构的强烈倾向）。那么到底为什么呢？</p><p>我们不妨先来看看 MacKay 在书中举的一个漂亮的例子：</p><p><img src="/img/i1-thumb.jpg"></p><p>图中有多少个箱子？特别地，那棵书后面是一个箱子？还是两个箱子？还是三个箱子？还是.. 你可能会觉得树后面肯定是一个箱子，但为什么不是两个呢？如下图：</p><p><img src="/img/i2-thumb.jpg"></p><p>用概率论的语言来说，你刚才的话就翻译为：猜测 h 不成立，因为 P(D | h) 太小（太巧合）了。我们的直觉是：巧合（小概率）事件不会发生。所以当一个猜测（假设）使得我们的观测结果成为小概率事件的时候，我们就说“才怪呢，哪能那么巧捏？！”</p><p>现在我们可以回到那个自然语言二义性的例子，并给出一个完美的解释了：如果语法结构是 The girl saw the-boy-with-a-telecope 的话，怎么那个男孩偏偏手里拿的就是望远镜——一个可以被用来 saw-with 的东东捏？这也忒小概率了吧。他咋就不会拿本书呢？拿什么都好。怎么偏偏就拿了望远镜？所以唯一的解释是，这个“巧合”背后肯定有它的必然性，这个必然性就是，如果我们将语法结构解释为 The girl saw-with-a-telescope the boy 的话，就跟数据完美吻合了——既然那个女孩是用某个东西去看这个男孩的，那么这个东西是一个望远镜就完全可以解释了（不再是小概率事件了）。</p><p>自然语言二义性很常见，譬如上文中的一句话：</p><blockquote><p>参见《决策与判断》以及《<a href="http://www.douban.com/subject/3199621/">Rationality for Mortals</a>》第12章：小孩也可以解决贝叶斯问题</p></blockquote><p>就有二义性：到底是参见这两本书的第 12 章，还是仅仅是第二本书的第 12 章呢？如果是这两本书的第 12 章那就是咄咄怪事了，怎么恰好两本书都有第 12 章，都是讲同一个问题，更诡异的是，标题还相同呢？</p><p>注意，以上做的是似然估计（即只看 P(D | h) 的大小），不含先验概率。通过这两个例子，尤其是那个树后面的箱子的例子我们可以看到，似然估计里面也蕴含着奥卡姆剃刀：树后面的箱子数目越多，这个模型就越复杂。单个箱子的模型是最简单的。似然估计选择了更简单的模型。</p><p>这个就是所谓的 <strong>贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</strong> ，因为这个剃刀工作在贝叶斯公式的似然（P(D | h) ）上，而不是模型本身（ P(h) ）的先验概率上，后者是传统的奥卡姆剃刀。关于贝叶斯奥卡姆剃刀我们再来看一个前面说到的曲线拟合的例子：如果平面上有 N 个点，近似构成一条直线，但绝不精确地位于一条直线上。这时我们既可以用直线来拟合（模型1），也可以用二阶多项式（模型2）拟合，也可以用三阶多项式（模型3），.. ，特别地，用 N-1 阶多项式便能够保证肯定能完美通过 N 个数据点。那么，这些可能的模型之中到底哪个是最靠谱的呢？前面提到，一个衡量的依据是奥卡姆剃刀：越是高阶的多项式越是繁复和不常见。然而，我们其实并不需要依赖于这个先验的奥卡姆剃刀，因为有人可能会争辩说：你怎么就能说越高阶的多项式越不常见呢？我偏偏觉得所有阶多项式都是等可能的。好吧，既然如此那我们不妨就扔掉 P(h) 项，看看 P(D | h) 能告诉我们什么。我们注意到越是高阶的多项式，它的轨迹弯曲程度越是大，到了八九阶简直就是直上直下，于是我们不仅要问：一个比如说八阶多项式在平面上随机生成的一堆 N 个点偏偏恰好近似构成一条直线的概率（即 P(D | h) ）有多大？太小太小了。反之，如果背后的模型是一条直线，那么根据该模型生成一堆近似构成直线的点的概率就大得多了。这就是贝叶斯奥卡姆剃刀。</p><p>这里只是提供一个关于贝叶斯奥卡姆剃刀的科普，强调直观解释，更多理论公式请参考 MacKay 的著作 《Information Theory : Inference and Learning Algorithms》第 28 章。</p><h3 id="最小描述长度原则"><a href="#最小描述长度原则" class="headerlink" title="最小描述长度原则"></a>最小描述长度原则</h3><p>贝叶斯模型比较理论与信息论有一个有趣的关联：</p><p>P(h | D) ∝ P(h) * P(D | h)</p><p>两边求对数，将右式的乘积变成相加：</p><p>ln P(h | D) ∝ ln P(h) + ln P(D | h)</p><p>显然，最大化 P(h | D) 也就是最大化 ln P(h | D)。而 ln P(h) + ln P(D | h) 则可以解释为模型（或者称“假设”、“猜测”）h 的编码长度加上在该模型下数据 D 的编码长度。使这个和最小的模型就是最佳模型。</p><p>而究竟如何定义一个模型的编码长度，以及数据在模型下的编码长度则是一个问题。更多可参考 Mitchell 的 《Machine Learning》的 6.6 节，或 Mackay 的 28.3 节）</p><h3 id="最优贝叶斯推理"><a href="#最优贝叶斯推理" class="headerlink" title="最优贝叶斯推理"></a>最优贝叶斯推理</h3><p>所谓的推理，分为两个过程，第一步是对观测数据建立一个模型。第二步则是使用这个模型来推测未知现象发生的概率。我们前面都是讲的对于观测数据给出最靠谱的那个模型。然而很多时候，虽然某个模型是所有模型里面最靠谱的，但是别的模型也并不是一点机会都没有。譬如第一个模型在观测数据下的概率是 0.5 。第二个模型是 0.4 ，第三个是 0.1 。如果我们只想知道对于观测数据哪个模型最可能，那么只要取第一个就行了，故事到此结束。然而很多时候我们建立模型是为了推测未知的事情的发生概率，这个时候，三个模型对未知的事情发生的概率都会有自己的预测，仅仅因为某一个模型概率稍大一点就只听他一个人的就太不民主了。所谓的最优贝叶斯推理就是将三个模型对于未知数据的预测结论加权平均起来（权值就是模型相应的概率）。显然，这个推理是理论上的制高点，无法再优了，因为它已经把所有可能性都考虑进去了。</p><p>只不过实际上我们是基本不会使用这个框架的，因为计算模型可能非常费时间，二来模型空间可能是连续的，即有无穷多个模型（这个时候需要计算模型的概率分布）。结果还是非常费时间。所以这个被看作是一个理论基准。</p><h2 id="无处不在的贝叶斯"><a href="#无处不在的贝叶斯" class="headerlink" title="无处不在的贝叶斯"></a>无处不在的贝叶斯</h2><p>以下我们再举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。</p><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><p>贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述，详细请参考吴军的文章（<a href="http://www.googlechinablog.com/2006/04/blog-post_10.html">这里</a>）。</p><p>分词问题的描述为：给定一个句子（字串），如：</p><p>南京市长江大桥</p><p>如何对这个句子进行分词（词串）才是最靠谱的。例如：</p><ol><li><p>南京市&#x2F;长江大桥</p></li><li><p>南京&#x2F;市长&#x2F;江大桥</p></li></ol><p>这两个分词，到底哪个更靠谱呢？</p><p>我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得：</p><p>P(Y|X) ∝ P(Y) * P(X|Y)</p><p>用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串：</p><p>W1, W2, W3, W4 ..</p><p>的可能性呢？我们知道，根据<a href="http://en.wikipedia.org/wiki/Joint_probability">联合概率</a>的公式展开：P(W1, W2, W3, W4 ..) &#x3D; P(W1) * P(W2|W1) * P(W3|W2, W1) * P(W4|W1,W2,W3) * .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），<a href="http://en.wikipedia.org/wiki/Curse_of_dimensionality">数据稀疏问题</a>也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元<a href="http://en.wikipedia.org/wiki/N-gram">语言模型</a>（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) * P(W2|W1) * P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长&#x2F;江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市&#x2F;长江大桥”这一分词方式胜出。</p><p><strong>一点注记</strong> ：有人可能会疑惑，难道我们人类也是基于这些天真的假设来进行推理的？不是的。事实上，统计机器学习方法所统计的东西往往处于相当表层（shallow）的层面，在这个层面机器学习只能看到一些非常表面的现象，有一点科学研究的理念的人都知道：越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的。特征一多，好了，<a href="http://en.wikipedia.org/wiki/Curse_of_dimensionality">高维诅咒</a>就产生了，数据就稀疏得要命，不够用了。而我们人类的观察水平显然比机器学习的观察水平要更深入一些，为了避免数据稀疏我们不断地发明各种装置（最典型就是显微镜），来帮助我们直接深入到更深层的事物层面去观察更本质的联系，而不是在浅层对表面现象作统计归纳。举一个简单的例子，通过对大规模语料库的统计，机器学习可能会发现这样一个规律：所有的“他”都是不会穿 bra 的，所有的“她”则都是穿的。然而，作为一个男人，却完全无需进行任何统计学习，因为深层的规律就决定了我们根本不会去穿 bra 。至于机器学习能不能完成后者（像人类那样的）这个推理，则是人工智能领域的经典问题。至少在那之前，<a href="http://www.yeeyan.com/articles/view/sylviaangel/9995">声称统计学习方法能够终结科学研究</a>（<a href="http://www.wired.com/science/discoveries/magazine/16-07/pb_theory">原文</a>）的说法<a href="http://scienceblogs.com/goodmath/2008/07/petabyte_scale_dataanalysis_an.php">是纯粹外行人说的话</a>。</p><h3 id="统计机器翻译"><a href="#统计机器翻译" class="headerlink" title="统计机器翻译"></a>统计机器翻译</h3><p>统计机器翻译因为其简单，自动（无需手动添加规则），迅速成为了机器翻译的事实标准。而统计机器翻译的核心算法也是使用的贝叶斯方法。</p><p>问题是什么？统计机器翻译的问题可以描述为：给定一个句子 e ，它的可能的外文翻译 f 中哪个是最靠谱的。即我们需要计算：P(f|e) 。一旦出现条件概率贝叶斯总是挺身而出：</p><p>P(f|e) ∝ P(f) * P(e|f)</p><p>这个式子的右端很容易解释：那些先验概率较高，并且更可能生成句子 e 的外文句子 f 将会胜出。我们只需简单统计（结合上面提到的 N-Gram 语言模型）就可以统计任意一个外文句子 f 的出现概率。然而 P(e|f) 却不是那么好求的，给定一个候选的外文局子 f ，它生成（或对应）句子 e 的概率是多大呢？我们需要定义什么叫 “对应”，这里需要用到一个分词对齐的平行语料库，有兴趣的可以参考 《Foundations of Statistical Natural Language Processing》第 13 章，这里摘选其中的一个例子：假设 e 为：John loves Mary 。我们需要考察的首选 f 是：Jean aime Marie （法文）。我们需要求出 P(e|f) 是多大，为此我们考虑 e 和 f 有多少种对齐的可能性，如：</p><p>John (Jean) loves (aime) Marie (Mary)</p><p>就是其中的一种（最靠谱的）对齐，为什么要对齐，是因为一旦对齐了之后，就可以容易地计算在这个对齐之下的 P(e|f) 是多大，只需计算：</p><p>P(John|Jean) * P(loves|aime) * P(Marie|Mary)</p><p>即可。</p><p>然后我们遍历所有的对齐方式，并将每种对齐方式之下的翻译概率 ∑ 求和。便可以获得整个的 P(e|f) 是多大。</p><p><strong>一点注记</strong> ：还是那个问题：难道我们人类真的是用这种方式进行翻译的？highly unlikely 。这种计算复杂性非常高的东西连三位数乘法都搞不定的我们才不会笨到去使用呢。根据认知神经科学的认识，很可能我们是先从句子到语义（一个逐层往上（bottom-up）抽象的 folding 过程），然后从语义根据另一门语言的语法展开为另一门语言（一个逐层往下（top-down）的具体化 unfolding 过程）。如何可计算地实现这个过程，目前仍然是个难题。（我们看到很多地方都有 bottom-up&#x2F;top-down 这样一个对称的过程，实际上有人猜测这正是生物神经网络原则上的运作方式，对视觉神经系统的研究尤其证明了这一点，Hawkins 在 《On Intelligence》 里面提出了一种<a href="http://en.wikipedia.org/wiki/Hierarchical_Temporal_Memory">HTM</a>Hierarchical Temporal Memory）模型正是使用了这个原则。）</p><h3 id="贝叶斯图像识别，Analysis-by-Synthesis"><a href="#贝叶斯图像识别，Analysis-by-Synthesis" class="headerlink" title="贝叶斯图像识别，Analysis by Synthesis"></a>贝叶斯图像识别，Analysis by Synthesis</h3><p>贝叶斯方法是一个非常 general 的推理框架。其核心理念可以描述成：Analysis by Synthesis （通过合成来分析）。06 年的认知科学新进展上有一篇 paper 就是讲用贝叶斯推理来解释视觉识别的，一图胜千言，下图就是摘自这篇 paper ：</p><p><img src="/img/i3-thumb.jpg"></p><p>首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念（比如是 E 还是 F 还是等号），然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像。</p><h3 id="EM算法与基于模型的聚类"><a href="#EM算法与基于模型的聚类" class="headerlink" title="EM算法与基于模型的聚类"></a>EM算法与基于模型的聚类</h3><p><a href="http://en.wikipedia.org/wiki/Data_clustering">聚类</a>是一种<a href="http://en.wikipedia.org/wiki/Unsupervised_learning">无指导的机器学习</a>问题，问题描述：给你一堆数据点，让你将它们最靠谱地分成一堆一堆的。聚类算法很多，不同的算法适应于不同的问题，这里仅介绍一个基于模型的聚类，该聚类算法对数据点的假设是，这些数据点分别是围绕 K 个核心的 K 个正态分布源所随机生成的，使用 Han JiaWei 的《Data Ming： Concepts and Techniques》中的图：</p><p><img src="/img/i4-thumb.jpg"></p><p>图中有两个正态分布核心，生成了大致两堆点。我们的聚类算法就是需要根据给出来的那些点，算出这两个正态分布的核心在什么位置，以及分布的参数是多少。这很明显又是一个贝叶斯问题，但这次不同的是，答案是连续的且有无穷多种可能性，更糟的是，只有当我们知道了哪些点属于同一个正态分布圈的时候才能够对这个分布的参数作出靠谱的预测，现在两堆点混在一块我们又不知道哪些点属于第一个正态分布，哪些属于第二个。反过来，只有当我们对分布的参数作出了靠谱的预测时候，才能知道到底哪些点属于第一个分布，那些点属于第二个分布。这就成了一个先有鸡还是先有蛋的问题了。为了解决这个循环依赖，总有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终收敛到一个解。这就是 EM 算法。</p><p>EM 的意思是“Expectation-Maximazation”，在这个聚类问题里面，我们是先随便猜一下这两个正态分布的参数：如核心在什么地方，方差是多少。然后计算出每个数据点更可能属于第一个还是第二个正态分布圈，这个是属于 Expectation 一步。有了每个数据点的归属，我们就可以根据属于第一个分布的数据点来重新评估第一个分布的参数（从蛋再回到鸡），这个是 Maximazation 。如此往复，直到参数基本不再发生变化为止。这个迭代收敛过程中的贝叶斯方法在第二步，根据数据点求分布的参数上面。</p><h3 id="最大似然与最小二乘"><a href="#最大似然与最小二乘" class="headerlink" title="最大似然与最小二乘"></a>最大似然与最小二乘</h3><p><img src="/img/i5-thumb.png"></p><p>学过线性代数的大概都知道经典的最小二乘方法来做线性回归。问题描述是：给定平面上 N 个点，（这里不妨假设我们想用一条直线来拟合这些点——<a href="http://en.wikipedia.org/wiki/Regression_analysis">回归</a>可以看作是<a href="http://en.wikipedia.org/wiki/Curve_fitting">拟合</a>的特例，即允许误差的拟合），找出一条最佳描述了这些点的直线。</p><p>一个接踵而来的问题就是，我们如何定义最佳？我们设每个点的坐标为 (Xi, Yi) 。如果直线为 y &#x3D; f(x) 。那么 (Xi, Yi) 跟直线对这个点的“预测”：(Xi, f(Xi)) 就相差了一个 ΔYi &#x3D; |Yi – f(Xi)| 。最小二乘就是说寻找直线使得 (ΔY1)^2 + (ΔY2)^2 + .. （即误差的平方和）最小，至于为什么是误差的平方和而不是误差的绝对值和，统计学上也没有什么好的解释。然而贝叶斯方法却能对此提供一个完美的解释。</p><p>我们假设直线对于坐标 Xi 给出的预测 f(Xi) 是最靠谱的预测，所有纵坐标偏离 f(Xi) 的那些数据点都含有噪音，是噪音使得它们偏离了完美的一条直线，一个合理的假设就是偏离路线越远的概率越小，具体小多少，可以用一个正态分布曲线来模拟，这个分布曲线以直线对 Xi 给出的预测 f(Xi) 为中心，实际纵坐标为 Yi 的点 (Xi, Yi) 发生的概率就正比于 EXP[-(ΔYi)^2]。（EXP(..) 代表以常数 e 为底的多少次方）。</p><p>现在我们回到问题的贝叶斯方面，我们要想最大化的后验概率是：</p><p>P(h|D) ∝ P(h) * P(D|h)</p><p>又见贝叶斯！这里 h 就是指一条特定的直线，D 就是指这 N 个数据点。我们需要寻找一条直线 h 使得 P(h) * P(D|h) 最大。很显然，P(h) 这个先验概率是均匀的，因为哪条直线也不比另一条更优越。所以我们只需要看 P(D|h) 这一项，这一项是指这条直线生成这些数据点的概率，刚才说过了，生成数据点 (Xi, Yi) 的概率为 EXP[-(ΔYi)^2] 乘以一个常数。而 P(D|h) &#x3D; P(d1|h) * P(d2|h) * .. 即假设各个数据点是独立生成的，所以可以把每个概率乘起来。于是生成 N 个数据点的概率为 EXP[-(ΔY1)^2] * EXP[-(ΔY2)^2] * EXP[-(ΔY3)^2] * .. &#x3D; EXP{-[(ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + ..]} 最大化这个概率就是要最小化 (ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + .. 。 熟悉这个式子吗？</p><h2 id="朴素贝叶斯方法-又名“愚蠢者的贝叶斯-idiot-s-bayes-”"><a href="#朴素贝叶斯方法-又名“愚蠢者的贝叶斯-idiot-s-bayes-”" class="headerlink" title="朴素贝叶斯方法(又名“愚蠢者的贝叶斯(idiot`s bayes)”)"></a>朴素贝叶斯方法(又名“愚蠢者的贝叶斯(idiot`s bayes)”)</h2><p>朴素贝叶斯方法是一个很特别的方法，所以值得介绍一下。我们用朴素贝叶斯在垃圾邮件过滤中的应用来举例说明。</p><h3 id="贝叶斯垃圾邮件过滤器"><a href="#贝叶斯垃圾邮件过滤器" class="headerlink" title="贝叶斯垃圾邮件过滤器"></a>贝叶斯垃圾邮件过滤器</h3><p>问题是什么？问题是，给定一封邮件，判定它是否属于垃圾邮件。按照先例，我们还是用 D 来表示这封邮件，注意 D 由 N 个单词组成。我们用 h+ 来表示垃圾邮件，h- 表示正常邮件。问题可以形式化地描述为求：</p><p>P(h+|D) &#x3D; P(h+) * P(D|h+) &#x2F; P(D)</p><p>P(h-|D) &#x3D; P(h-) * P(D|h-) &#x2F; P(D)</p><p>其中 P(h+) 和 P(h-) 这两个先验概率都是很容易求出来的，只需要计算一个邮件库里面垃圾邮件和正常邮件的比例就行了。然而 P(D|h+) 却不容易求，因为 D 里面含有 N 个单词 d1, d2, d3, .. ，所以P(D|h+) &#x3D; P(d1,d2,..,dn|h+) 。我们又一次遇到了数据稀疏性，为什么这么说呢？P(d1,d2,..,dn|h+) 就是说在垃圾邮件当中出现跟我们目前这封邮件一模一样的一封邮件的概率是多大！开玩笑，每封邮件都是不同的，世界上有无穷多封邮件。瞧，这就是数据稀疏性，因为可以肯定地说，你收集的训练数据库不管里面含了多少封邮件，也不可能找出一封跟目前这封一模一样的。结果呢？我们又该如何来计算 P(d1,d2,..,dn|h+) 呢？</p><p>我们将 P(d1,d2,..,dn|h+)  扩展为： P(d1|h+) * P(d2|d1, h+) * P(d3|d2,d1, h+) * .. 。熟悉这个式子吗？这里我们会使用一个更激进的假设，我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) * P(d2|h+) * P(d3|h+) * .. 。这个就是所谓的<a href="http://en.wikipedia.org/wiki/Conditional_independence">条件独立假设</a>，也正是朴素贝叶斯方法的朴素之处。而计算 P(d1|h+) * P(d2|h+) * P(d3|h+) * .. 就太简单了，只要统计 di 这个单词在垃圾邮件中出现的频率即可。关于贝叶斯垃圾邮件过滤更多的内容可以参考<a href="http://en.wikipedia.org/wiki/Bayesian_spam_filtering">这个条目</a>，注意其中提到的其他资料。</p><p>__一点注记__：这里，为什么有这个数据稀疏问题，还是因为统计学习方法工作在浅层面，世界上的单词就算不再变多也是非常之多的，单词之间组成的句子也是变化多端，更不用说一篇文章了，文章数目则是无穷的，所以在这个层面作统计，肯定要被数据稀疏性困扰。我们要注意，虽然句子和文章的数目是无限的，然而就拿邮件来说，如果我们只关心邮件中句子的语义（进而更高抽象层面的“意图”（语义，意图如何可计算地定义出来是一个人工智能问题），在这个层面上可能性便大大缩减了，我们关心的抽象层面越高，可能性越小。单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。神经科学的发现也表明大脑的皮层大致有一种层级结构，对应着越来越抽象的各个层面，至于如何具体实现一个可放在计算机内的大脑皮层，仍然是一个未解决问题，以上只是一个原则（principle）上的认识，只有当 computational 的 cortex 模型被建立起来了之后才可能将其放入电脑。</p><h3 id="为什么朴素贝叶斯方法令人诧异地好——一个理论解释"><a href="#为什么朴素贝叶斯方法令人诧异地好——一个理论解释" class="headerlink" title="为什么朴素贝叶斯方法令人诧异地好——一个理论解释"></a>为什么朴素贝叶斯方法令人诧异地好——一个理论解释</h3><p>朴素贝叶斯方法的条件独立假设看上去很傻很天真，为什么结果却很好很强大呢？就拿一个句子来说，我们怎么能鲁莽地声称其中任意一个单词出现的概率只受到它前面的 3 个或 4 个单词的影响呢？别说 3 个，有时候一个单词的概率受到上一句话的影响都是绝对可能的。那么为什么这个假设在实际中的表现却不比决策树差呢？有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考<a href="http://www.cs.unb.ca/profs/hzhang/publications/FLAIRS04ZhangH.pdf">这篇 paper</a>。</p><h2 id="层级贝叶斯模型"><a href="#层级贝叶斯模型" class="headerlink" title="层级贝叶斯模型"></a>层级贝叶斯模型</h2><p><img src="/img/i6-thumb.png"></p><p><a href="http://en.wikipedia.org/wiki/Hierarchical_Bayes_model">层级贝叶斯模型</a>是现代贝叶斯方法的标志性建筑之一。前面讲的贝叶斯，都是在同一个事物层次上的各个因素之间进行统计推理，然而层次贝叶斯模型在哲学上更深入了一层，将这些因素背后的因素（原因的原因，原因的原因，以此类推）囊括进来。一个教科书例子是：如果你手头有 N 枚硬币，它们是同一个工厂铸出来的，你把每一枚硬币掷出一个结果，然后基于这 N 个结果对这 N 个硬币的 θ （出现正面的比例）进行推理。如果根据最大似然，每个硬币的 θ 不是 1 就是 0 （这个前面提到过的），然而我们又知道每个硬币的 p(θ) 是有一个先验概率的，也许是一个 beta 分布。也就是说，每个硬币的实际投掷结果 Xi 服从以 θ 为中心的正态分布，而 θ 又服从另一个以 Ψ 为中心的 beta 分布。层层因果关系就体现出来了。进而 Ψ 还可能依赖于因果链上更上层的因素，以此类推。</p><h3 id="隐马可夫模型-HMM"><a href="#隐马可夫模型-HMM" class="headerlink" title="隐马可夫模型(HMM)"></a>隐马可夫模型(HMM)</h3><p><img src="/img/i7-thumb.png"></p><p>吴军在数学之美系列里面介绍的<a href="http://en.wikipedia.org/wiki/Hidden_Markov_model">隐马可夫模型</a>HMM）就是一个简单的层级贝叶斯模型：</p><blockquote><p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做“隐含马尔可夫模型”（Hidden Markov Model）来解决这些问题。以语音识别为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p></blockquote><p>吴军的文章中这里省掉没说的是，s1, s2, s3, .. 这个句子的生成概率同时又取决于一组参数，这组参数决定了 s1, s2, s3, .. 这个马可夫链的先验生成概率。如果我们将这组参数记为 λ ，我们实际上要求的是：P(S|O, λ) （其中 O 表示 o1,o2,o3,.. ，S表示 s1,s2,s3,..）</p><blockquote><p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公式并且省掉一个常数项，可以把上述公式等价变换成</p><p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…)</p><p>其中</p><p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…的可能性, 而 P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘以 s1,s2,s3.. 本身可以一个句子的可能性，得出概率。</p></blockquote><p>这里，s1,s2,s3…本身可以一个句子的可能性其实就取决于参数 λ ，也就是语言模型。所以简而言之就是发出的语音信号取决于背后实际想发出的句子，而背后实际想发出的句子本身的独立先验概率又取决于语言模型。</p><h2 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h2><p>吴军已经对贝叶斯网络作了科普，请直接跳转到<a href="http://googlechinablog.com/2007/01/bayesian-networks.html">这里</a>。更详细的理论参考所有机器学习的书上都有。</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 贝叶斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo优化-Hexo评论插件</title>
      <link href="/2018/add-valine-comments-to-your-blog/index/"/>
      <url>/2018/add-valine-comments-to-your-blog/index/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/006qRazegy1flcucgbhmuj30sf0o3mxy.jpg"></p><span id="more"></span><h2 id="写在前面的"><a href="#写在前面的" class="headerlink" title="写在前面的"></a>写在前面的</h2><p>2017年6月1日，在你等超龄儿童欢度节日的时候，多说躺下了。<br>2017年8月1日，不甘寂寞的网易云跟帖也跟多说随风而去了。</p><p>2017年8月7日，一款基于<code>Leancloud</code>的极简风评论系统诞生：<a href="https://valine.js.org/">Valine</a>。</p><h2 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h2><h3 id="获取-APP-ID-和-APP-KEY"><a href="#获取-APP-ID-和-APP-KEY" class="headerlink" title="获取 APP ID 和 APP KEY"></a>获取 <code>APP ID</code> 和 <code>APP KEY</code></h3><ol><li><a href="https://leancloud.cn/dashboard/login.html#/signup">点击这里登录或注册</a><code>Leancloud</code></li><li><a href="https://leancloud.cn/dashboard/applist.html#/newapp">点这里创建应用</a>，应用名看个人喜好。</li><li>选择刚刚创建的<code>应用</code>&gt;<code>设置</code>&gt;选择<code>应用 Key</code>，然后你就能看到你的<code>APP ID</code>和<code>APP KEY</code>了，参考下图：</li></ol><p><img src="https://ws1.sinaimg.cn/large/006qRazegy1fibactm2csj30x80f2dhn.jpg"></p><ol start="4"><li>为了您的数据安全，请填写<code>应用</code>&gt;<code>设置</code>&gt;<code>安全设置</code>中的<code>Web 安全域名</code>，如下图：</li></ol><p><img src="https://ws1.sinaimg.cn/large/006qRazegy1fiba67warvj30re0k5abv.jpg"></p><h3 id="页面中的设置"><a href="#页面中的设置" class="headerlink" title="页面中的设置"></a>页面中的设置</h3><p>页面中的食用方法炒鸡简单，来来来，我们用代码说话：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Valine - A simple comment system based on Leancloud.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Leancloud 操作库:--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Valine 的核心代码库:--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/Valine.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Valine</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">av</span>: <span class="variable constant_">AV</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;.comment&#x27;</span>, <span class="comment">//</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">app_id</span>: <span class="string">&#x27;Your APP ID&#x27;</span>, <span class="comment">// 这里填写上面得到的APP ID</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">app_key</span>: <span class="string">&#x27;Your APP KEY&#x27;</span>, <span class="comment">// 这里填写上面得到的APP KEY</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">placeholder</span>: <span class="string">&#x27;ヾﾉ≧∀≦)o来啊，快活啊!&#x27;</span> <span class="comment">// [v1.0.7 new]留言框占位提示文字</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Valine.min.js</code> 你可以使用别人的或者上传到自己的服务器或主机：<a href="https://github.com/panjunwen/Valine/releases/tag/v1.1.4.fix">Valine Ex</a></p><p>需要修改的只有：<code>el</code>、<code>app_id</code> 和 <code>app_key</code>。如果之前有用原版<code>Valine</code>，请将邮件通知和验证码关掉：<code>notify: false</code>, <code>verify: false</code>，避免重复发通知。算术验证码反人类，强烈建议停用。<br>此外，如果你的主题没有引入 <code>jQuery</code> 也请引入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cat.net/ajax/libs/jquery/3.2.1/jquery.min.js&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>至此，你的评论系统已经可以工作了！是不是很简单😉.</p><p>看吧，我是不是没说大话(<code>_(:з」∠)_一本正经的胡说八道</code>)。</p><h3 id="评论数据管理"><a href="#评论数据管理" class="headerlink" title="评论数据管理"></a>评论数据管理</h3><p>插播一下，关于评论数据管理，请自行登录<code>Leancloud</code>应用管理。<br>具体步骤：<code>登录</code>&gt;选择你创建的<code>应用</code>&gt;<code>存储</code>&gt;选择<code>ClassComment</code>，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><p><img src="https://ws1.sinaimg.cn/large/006qRazegy1fibb4pbvv4j31820iqjw0.jpg"></p><h2 id="自定义Hexo评论"><a href="#自定义Hexo评论" class="headerlink" title="自定义Hexo评论"></a>自定义Hexo评论</h2><blockquote><p>转自:<a href="http://panjunwen.com/">panjunwen.com</a></p></blockquote><h3 id="云引擎一键部署"><a href="#云引擎一键部署" class="headerlink" title="云引擎一键部署"></a>云引擎一键部署</h3><p>虽然 Valine 是无后端的，但为了实现邮件通知和垃圾评论过滤，需要部署少量的 LeanEngine 代码。不用担心，代码我都写好了，不需要本地开发环境，只要在网页点两下就能完成。关于自动休眠问题的说明。</p><ol><li>打开 <a href="https://leancloud.cn/dashboard/#/apps">LeanCloud 后台</a>，进入云引擎设置页。</li></ol><ul><li>填写代码库并保存：<code>https://github.com/panjunwen/Valine-Admin.git</code></li></ul><p><img src="/img/ping-mu-kuai-zhao-2017-11-12-xia-wu-2-45-11.png"></p><ul><li>切换到部署标签页，分支使用master，点击部署即可：</li></ul><p><img src="/img/ping-mu-kuai-zhao-2017-11-12-xia-wu-2-43-52.png"></p><ol start="2"><li>此外，你需要设置云引擎的环境变量以提供必要的信息，如下示例：</li></ol><p><img src="/img/ping-mu-kuai-zhao-2017-11-12-xia-wu-2-46-35.png"></p><p>请正确填写 SMTP 服务器信息，部分邮箱需要单独的 SMTP 密码。以QQ邮箱为例，需要在设置中开启 SMTP 并且通过发送短信来获取授权码（即密码）。注意我们使用 SSL 发件，所以端口别填错了。</p><p>如果你用过 WordPress 你应该有 Akismet Key；如果还没有，你可以去 <a href="https://akismet.com/development/">AKISMET FOR DEVELOPERS</a> 网站 免费申请一个；如果你不需要反垃圾评论，Akismet Key可以忽略。</p><ol start="3"><li>设置二级域名后你可以访问评论管理后台。</li></ol><p><img src="/img/ping-mu-kuai-zhao-2017-08-15-xia-wu-6-30-12.png"></p><p>后台管理需要登录，__使用云存储 _User 表中的用户登录即可__。特别提醒，为确保数据安全，请合理设置数据库权限。此外，请务必设置 Web 安全域名。</p><ol start="4"><li>设置完成后重启一下云引擎实例一切就正常工作啦！</li></ol><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p><a href="http://disqus.panjunwen.com/">Disqus2LeanCloud</a><br>（点击提交按钮后跳转至博客首页，大约一两分钟会自动导入完成。）</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul><li>前端效果：</li></ul><p><img src="/img/ping-mu-kuai-zhao-2017-08-14-xia-wu-5-48-25.png"></p><ul><li>后台截图：</li></ul><p><img src="/img/ping-mu-kuai-zhao-2017-11-12-xia-wu-2-57-13.png"></p><ul><li>邮件通知：</li></ul><p><img src="/img/ping-mu-kuai-zhao-2017-11-12-xia-wu-2-52-48.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Valine 『无后端』已经可以很好的运行，但反垃圾评论和邮件通知还得靠后台来做，正好 LeanCloud 提供免费的云引擎和云 Hook，得以实现上述功能。LeanCloud 实在太好用了，借助官方的示例程序，连 JavaScript 语法都不懂就硬着头皮用 Nodejs 了，代码虽然很丑还是放出来，Github：<a href="https://github.com/panjunwen/Valine-Admin">Valine-Admin</a>。另外数据迁移是用 Flask 写的，也是第一次用，所以就不放源码献丑了。</p><p>关于免费云引擎自动休眠的补充说明：<br>关于自动休眠的官方说法：<a href="https://leancloud.cn/docs/leanengine_plan.html#hash633315134">点击查看</a>；休眠后只影响邮件通知功能，可以在评论管理后台补发。<br>我的做法是在 VPS 上添加一个定时任务，每天6:00 ~ 23:00每20分钟访问一次我的leanapp网址，防止云引擎进入休眠，保证通知邮件的及时发送。cron定时任务：<code>*/20 6-23 * * * curl https://deserts.leanapp.cn</code>。薅羊毛就要薅得干干净净！</p><hr><blockquote><p>更多配置信息请移步：<a href="https://valine.js.org/">https://valine.js.org</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习基础知识概要</title>
      <link href="/2018/start_python_basics/index/"/>
      <url>/2018/start_python_basics/index/</url>
      
        <content type="html"><![CDATA[<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul><li>输出实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><ul><li>输入实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = raw_input();</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;hello,&quot;</span>,name</span><br><span class="line"></span><br><span class="line">world</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><ul><li>输入时提示实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = raw_input(<span class="string">&#x27;please enter your name:&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;hello,&quot;</span>,name</span><br><span class="line"></span><br><span class="line">please enter your name:world</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>raw_input 函数读入的是字符串，如果想要转换成int类型，就要用到int函数。</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">birth = <span class="built_in">int</span>(raw_input(<span class="string">&#x27;birth: &#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="字符表示"><a href="#字符表示" class="headerlink" title="字符表示"></a>字符表示</h2><ul><li><p>十进制正常表示，十六进制最前面加 0x，小数正常表示，科学计数法表示 1.23×109就是1.23e9，或者 12.3e8</p><p>转义符 \</p><p>转义符实例：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;\\\n\\&#x27;</span></span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure><ul><li>防止转义，可以在前面加入r</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;\\\t\\&#x27;</span></span><br><span class="line">\       \</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">r&#x27;\\\t\\&#x27;</span></span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure><ul><li>多行内容表示，用三引号包括</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;&#x27;&#x27;line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3&#x27;&#x27;&#x27;</span></span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><ul><li>布尔值的表示 True 和 False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>空值 None，相当于Java，C 中的 null</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> <span class="literal">None</span>==<span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>Unicode表示的字符串用 u’…’ 表示，转化成 UTF-8 编码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u&#x27;ABC&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>文本文件编码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><ul><li>格式化输出实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello, %s&#x27;</span> % <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="string">&#x27;Hello, world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="string">&#x27;Michael&#x27;</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="string">&#x27;Hi, Michael, you have $1000000.&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>格式化整数和小数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%2d-%02d&#x27;</span> % (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27; 3-01&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%.2f&#x27;</span> % <span class="number">3.1415926</span></span><br><span class="line"><span class="string">&#x27;3.14&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>万能格式化 %s，可以代替所有格式化</p><p>对于Unicode字符串，用法完全一样，但最好确保替换的字符串也是Unicode字符串：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u&#x27;Hi, %s&#x27;</span> % <span class="string">u&#x27;Michael&#x27;</span></span><br><span class="line"><span class="string">u&#x27;Hi, Michael&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>输出百分号 %，用双 % 即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;growth rate: %d %%&#x27;</span> % <span class="number">7</span></span><br><span class="line"><span class="string">&#x27;growth rate: 7 %&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><ul><li>列表 list ，可变的有序表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>len函数获取它的长度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>取得某个元素，可以用中括号索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Tracy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">3</span>]</span><br><span class="line">Traceback (most recent call last):</span><br></pre></td></tr></table></figure><ul><li>倒数索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Tracy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">4</span>]</span><br><span class="line">Traceback (most recent call last):</span><br></pre></td></tr></table></figure><ul><li>append 追加元素到末尾</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">&#x27;Adam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>insert 插入到指定位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt; classmates.insert(<span class="number">1</span>, <span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>pop 删除末尾元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</span><br><span class="line"><span class="string">&#x27;Adam&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>pop 加入参数删除指定元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>元素改变，直接赋值即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">&#x27;Sarah&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>list可以嵌套，可用二维索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, [<span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;php&#x27;</span>], <span class="string">&#x27;scheme&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">php</span><br></pre></td></tr></table></figure><ul><li>空列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(L)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h2><blockquote><p>不可变有序的数组</p></blockquote><ul><li>定义元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">(<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>空的元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">()</span><br></pre></td></tr></table></figure><ul><li>一个元素的元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><blockquote><p>注意不能用 t &#x3D; (1) 来定义， 因为它定义的不是tuple，是 1 这个数，这是因为括号既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p></blockquote><ul><li>表面上可变的tuple</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>])</span><br></pre></td></tr></table></figure><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向 ‘a’，就不能改成指向 ‘b’ ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><ul><li>字典 dict 即键值对组，dict的key必须是不可变对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure><ul><li>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入，在这之前，d 必须被声明，否则会报错</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>] = <span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>判断key是否在字典中</li></ul><ol><li>in 判断</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Thomas&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d.get(<span class="string">&#x27;Thomas&#x27;</span>)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d.get(<span class="string">&#x27;Thomas&#x27;</span>, -<span class="number">1</span>)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>要删除一个key，用 pop(key) 方法，对应的value也会从dict中删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h2><blockquote><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p></blockquote><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>重复元素在set中自动被过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>通过 add(key) 方法可以添加元素到set中，可以重复添加，但不会有效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>通过 remove(key) 方法可以删除元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>判断元素是否在set中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line"><span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文 Linear Algebra （线性代数） 笔记</title>
      <link href="/2018/math/index/"/>
      <url>/2018/math/index/</url>
      
        <content type="html"><![CDATA[<p><a href="https://opensource.org/licenses/mit-license.php"><img src="/img/math/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BZWZ2cGdpYUlQdzNYZ0UyeEI2WHI0YjFFYTQ1cHd1ckxGd2dDZnpya1dYTVB1dlFiMVhKNWRPdE40Z01nUUZSZUJaOFBjZERxZjUzZjNMcEhpYXBJN.png" alt="MIT Licence"></a></p><h1 id="中文-Linear-Algebra-（线性代数）-笔记"><a href="#中文-Linear-Algebra-（线性代数）-笔记" class="headerlink" title="中文 Linear Algebra （线性代数） 笔记"></a>中文 Linear Algebra （线性代数） 笔记</h1><h2 id="Overview-（概述）"><a href="#Overview-（概述）" class="headerlink" title="Overview （概述）"></a>Overview （概述）</h2><p>Most of the content comes from the web.<br><br>大部分内容来自网络。</p><p>I know my knowledge of linear algebra is not very thorough, so I re-learn linear algebra, record the corresponding notes.<br><br>由于我们对线性代数的知识了解不深，特意重新学习一次线代，记录下相应笔记。</p><p>课程顺序是按照麻省理工公开课的 <a href="http://open.163.com/special/opencourse/daishu.html">Linear Algebra</a> 记录的学习笔记。</p><hr><h2 id="Contents-（目录）"><a href="#Contents-（目录）" class="headerlink" title="Contents （目录）"></a>Contents （目录）</h2><hr><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/01-%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/01-%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A.md">01. <strong>方程组的几何解释</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/01-%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/01-%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A.md">01.01 方程组的几何解释</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/02-%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/02-%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83.md">02. <strong>矩阵消元</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/02-%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/02-%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83.md">02.01 矩阵消元</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/03-%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/03-%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5.md">03. <strong>乘法和逆矩阵</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/03-%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/03-%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5.md">03.01 矩阵乘法和逆矩阵</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/04-A%E7%9A%84LU%E5%88%86%E8%A7%A3/04-A%E7%9A%84LU%E5%88%86%E8%A7%A3.md">04. <strong>A的LU分解</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/04-A%E7%9A%84LU%E5%88%86%E8%A7%A3/04-A%E7%9A%84LU%E5%88%86%E8%A7%A3.md">04.01 A的LU分解</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R.md">05. <strong>转置-置换-向量空间R</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R.md">05.01 矩阵转置</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R.md">05.02 置换</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/05-%E8%BD%AC%E7%BD%AE-%E7%BD%AE%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R.md">05.03 向量空间 R</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/06-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/06-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4.md">06. <strong>列空间和零空间</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/06-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/06-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4.md">06.01 列空间</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/06-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/06-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4.md">06.02 零空间</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/07-%E6%B1%82%E8%A7%A3Ax=0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3/07-%E6%B1%82%E8%A7%A3Ax=0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3.md">07. <strong>求解Ax&#x3D;0:主变量,特解</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/07-%E6%B1%82%E8%A7%A3Ax=0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3/07-%E6%B1%82%E8%A7%A3Ax=0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3.md">07.01 主变量</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/07-%E6%B1%82%E8%A7%A3Ax=0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3/07-%E6%B1%82%E8%A7%A3Ax=0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3.md">07.02 特解</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/08-%E6%B1%82%E8%A7%A3Ax=b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/08-%E6%B1%82%E8%A7%A3Ax=b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84.md">08. <strong>求解Ax&#x3D;b:可解性和解的结构</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/08-%E6%B1%82%E8%A7%A3Ax=b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/08-%E6%B1%82%E8%A7%A3Ax=b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84.md">08.01 可解性</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/08-%E6%B1%82%E8%A7%A3Ax=b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/08-%E6%B1%82%E8%A7%A3Ax=b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84.md">08.02 解的结构</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0.md">09. <strong>线性相关性、基、维数</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0.md">09.01 线性相关性</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0.md">09.02 基</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0/09-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%9F%BA-%E7%BB%B4%E6%95%B0.md">09.03 维数</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/10-%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/10-%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4.md">10. <strong>四个基本子空间</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/10-%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/10-%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4.md">10.01 基本子空间</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/10-%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/10-%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4.md">10.02 四个基本子空间</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE.md">11. <strong>矩阵空间、秩1矩阵和小世界图</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE.md">11.01 矩阵空间</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE.md">11.02 秩1矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/11-%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4-%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE.md">11.03 小世界图</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/12-%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/12-%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C.md">12. <strong>图和网络</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/12-%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/12-%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C.md">12.01 图</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/12-%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/12-%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C.md">12.02 网络</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/13-%E5%A4%8D%E4%B9%A0%E4%B8%80/13-%E5%A4%8D%E4%B9%A0%E4%B8%80.md">13. <strong>复习一</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/13-%E5%A4%8D%E4%B9%A0%E4%B8%80/13-%E5%A4%8D%E4%B9%A0%E4%B8%80.md">13.01 复习一</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/14-%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/14-%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4.md">14. <strong>正交向量与子空间</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/14-%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/14-%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4.md">14.01 正交向量</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/14-%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/14-%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4.md">14.02 子空间</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/15-%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/15-%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1.md">15. <strong>子空间投影</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/15-%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/15-%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1.md">15.01 子空间投影</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/16-%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/16-%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98.md">16. <strong>投影矩阵和最小二乘</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/16-%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/16-%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98.md">16.01 投影矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/16-%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/16-%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98.md">16.02 最小二乘</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/17-%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96/17-%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96.md6">17. <strong>正交矩阵和Gram-Schmidt正交化</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/17-%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96/17-%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96.md">17.01 正交矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/17-%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96/17-%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96.md">17.02 Gram-Schmidt正交化</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/18-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/18-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8.md">18. <strong>行列式及其性质</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/18-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/18-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8.md">18.01 行列式</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/18-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/18-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8.md">18.02 行列式性质</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/19-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F%E5%92%8C%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F/19-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F%E5%92%8C%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F.md">19. <strong>行列式公式和代数余子式</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/19-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F%E5%92%8C%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F/19-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F%E5%92%8C%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F.md">19.01 行列式公式</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/19-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F%E5%92%8C%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F/19-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F%E5%92%8C%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F.md">19.02 代数余子式</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF.md">20. <strong>克拉默法则、逆矩阵、体积</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF.md">20.01 克拉默法则</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF.md">20.02 逆矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF/20-%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99-%E9%80%86%E7%9F%A9%E9%98%B5-%E4%BD%93%E7%A7%AF.md">20.03 体积</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/21-%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/21-%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F.md">21. <strong>特征值和特征向量</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/21-%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/21-%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F.md">21.01 特征值和特征向量</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/22-%E5%AF%B9%E8%A7%92%E5%8C%96%E5%92%8CA%E7%9A%84%E5%B9%82/22-%E5%AF%B9%E8%A7%92%E5%8C%96%E5%92%8CA%E7%9A%84%E5%B9%82.md">22. <strong>对角化和A的幂</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/22-%E5%AF%B9%E8%A7%92%E5%8C%96%E5%92%8CA%E7%9A%84%E5%B9%82/22-%E5%AF%B9%E8%A7%92%E5%8C%96%E5%92%8CA%E7%9A%84%E5%B9%82.md">22.01 对角化</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/22-%E5%AF%B9%E8%A7%92%E5%8C%96%E5%92%8CA%E7%9A%84%E5%B9%82/22-%E5%AF%B9%E8%A7%92%E5%8C%96%E5%92%8CA%E7%9A%84%E5%B9%82.md">22.02 A的幂</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/23-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8Cexp(At)/23-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8Cexp(At).md">23. <strong>微分方程和exp(At)</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/23-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8Cexp(At)/23-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8Cexp(At).md">23.01 微分方程</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/23-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8Cexp(At)/23-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8Cexp(At).md">23.02 exp(AT)</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/24-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0/24-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0.md">24. <strong>马尔可夫矩阵;傅立叶级数</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/24-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0/24-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0.md">24.01 马尔可夫矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/24-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0/24-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0.md">24.02 傅立叶级数</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/25-%E5%A4%8D%E4%B9%A0%E4%BA%8C/25-%E5%A4%8D%E4%B9%A0%E4%BA%8C.md">25. <strong>复习二</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/25-%E5%A4%8D%E4%B9%A0%E4%BA%8C/25-%E5%A4%8D%E4%B9%A0%E4%BA%8C.md">25.01 复习二</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/26-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%8F%8A%E6%AD%A3%E5%AE%9A%E6%80%A7/26-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%8F%8A%E6%AD%A3%E5%AE%9A%E6%80%A7.md">26. <strong>对称矩阵及正定性</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/26-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%8F%8A%E6%AD%A3%E5%AE%9A%E6%80%A7/26-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%8F%8A%E6%AD%A3%E5%AE%9A%E6%80%A7.md">26.01 对称矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/26-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%8F%8A%E6%AD%A3%E5%AE%9A%E6%80%A7/26-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%8F%8A%E6%AD%A3%E5%AE%9A%E6%80%A7.md">26.02 正定性</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/27-%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/27-%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2.md">27. <strong>复数矩阵和快速傅里叶变换</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/27-%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/27-%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2.md">27.01 复数矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/27-%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/27-%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2.md">27.02 快速傅里叶变换</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/28-%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/28-%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC.md">28. <strong>正定矩阵和最小值</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/28-%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/28-%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC.md">28.01 正定矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/28-%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/28-%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC.md">28.02 最小值</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/29-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E5%92%8C%E8%8B%A5%E5%B0%94%E5%BD%93%E5%BD%A2/29-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E5%92%8C%E8%8B%A5%E5%B0%94%E5%BD%93%E5%BD%A2.md">29. <strong>相似矩阵和若尔当形</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/29-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E5%92%8C%E8%8B%A5%E5%B0%94%E5%BD%93%E5%BD%A2/29-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E5%92%8C%E8%8B%A5%E5%B0%94%E5%BD%93%E5%BD%A2.md">29.01 相似矩阵</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/29-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E5%92%8C%E8%8B%A5%E5%B0%94%E5%BD%93%E5%BD%A2/29-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E5%92%8C%E8%8B%A5%E5%B0%94%E5%BD%93%E5%BD%A2.md">29.02 若尔当形</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/30-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/30-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3.md">30. <strong>奇异值分解</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/30-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/30-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3.md">30.01 奇异值分解</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/31-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5/31-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5.md">31. <strong>线性变换及对应矩阵</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/31-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5/31-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5.md">31.01 线性变换</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/31-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5/31-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5.md">31.02 对应矩阵</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/32-%E5%9F%BA%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/32-%E5%9F%BA%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9.md">32. <strong>基变换和图像压缩</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/32-%E5%9F%BA%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/32-%E5%9F%BA%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9.md">32.01 基变换</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/32-%E5%9F%BA%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/32-%E5%9F%BA%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9.md">32.02 图像压缩</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/33-%E5%A4%8D%E4%B9%A0%E4%B8%89/33-%E5%A4%8D%E4%B9%A0%E4%B8%89.md">33. <strong>复习三</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/33-%E5%A4%8D%E4%B9%A0%E4%B8%89/33-%E5%A4%8D%E4%B9%A0%E4%B8%89.md">33.01 复习三</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/34-%E5%B7%A6%E5%8F%B3%E9%80%86%E5%92%8C%E4%BC%AA%E9%80%86/34-%E5%B7%A6%E5%8F%B3%E9%80%86%E5%92%8C%E4%BC%AA%E9%80%86.md">34. <strong>左右逆和伪逆</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/34-%E5%B7%A6%E5%8F%B3%E9%80%86%E5%92%8C%E4%BC%AA%E9%80%86/34-%E5%B7%A6%E5%8F%B3%E9%80%86%E5%92%8C%E4%BC%AA%E9%80%86.md">34.01 左右逆</a></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/34-%E5%B7%A6%E5%8F%B3%E9%80%86%E5%92%8C%E4%BC%AA%E9%80%86/34-%E5%B7%A6%E5%8F%B3%E9%80%86%E5%92%8C%E4%BC%AA%E9%80%86.md">34.02 伪逆</a></li></ul></li><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/35-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/35-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.md">35. <strong>期末复习</strong></a><ul><li><a href="https://coding.net/u/Trover/p/math/git/blob/master/35-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/35-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.md">35.01 期末复习</a></li></ul></li></ul><hr><h2 id="对应课程"><a href="#对应课程" class="headerlink" title="对应课程"></a>对应课程</h2><p><img src="/img/math/LA_whole_1.png" alt="MIT_Linear-Algebra_1"></p><p><img src="/img/math/LA_whole_2.png" alt="MIT_Linear-Algebra_2"></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分分钟学会一门语言之Python篇</title>
      <link href="/2018/start_python/index/"/>
      <url>/2018/start_python/index/</url>
      
        <content type="html"><![CDATA[<p>Python 是 90 年代初由 Guido Van Rossum 创立的。它是当前最流行的程序语言之一。它那纯净的语法令我一见倾心，它简直就是可以运行的伪码。</p><p>请注意：本文以 Python 2.7 为基准，但也应该适用于所有 2.X 版本。还要继续学习最新的 Python 3 哦！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Single line comments start with a hash.</span></span><br><span class="line"><span class="comment"># 单行注释由一个井号开头。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; Multiline strings can be written</span></span><br><span class="line"><span class="string">    using three &quot;&#x27;s, and are often used</span></span><br><span class="line"><span class="string">    as comments</span></span><br><span class="line"><span class="string">    三个双引号（或单引号）之间可以写多行字符串，</span></span><br><span class="line"><span class="string">    通常用来写注释。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"><span class="comment">## 1. Primitive Datatypes and Operators</span></span><br><span class="line"><span class="comment">## 1. 基本数据类型和操作符</span></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You have numbers</span></span><br><span class="line"><span class="comment"># 数字就是数字</span></span><br><span class="line"><span class="number">3</span> <span class="comment">#=&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Math is what you would expect</span></span><br><span class="line"><span class="comment"># 四则运算也是你所期望的那样</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> <span class="comment">#=&gt; 2</span></span><br><span class="line"><span class="number">8</span> - <span class="number">1</span> <span class="comment">#=&gt; 7</span></span><br><span class="line"><span class="number">10</span> * <span class="number">2</span> <span class="comment">#=&gt; 20</span></span><br><span class="line"><span class="number">35</span> / <span class="number">5</span> <span class="comment">#=&gt; 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Division is a bit tricky. It is integer division and floors the results</span></span><br><span class="line"><span class="comment"># automatically.</span></span><br><span class="line"><span class="comment"># 除法有一点棘手。</span></span><br><span class="line"><span class="comment"># 对于整数除法来说，计算结果会自动取整。</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span> <span class="comment">#=&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To fix division we need to learn about floats.</span></span><br><span class="line"><span class="comment"># 为了修正除法的问题，我们需要先学习浮点数。</span></span><br><span class="line"><span class="number">2.0</span>     <span class="comment"># This is a float</span></span><br><span class="line"><span class="number">2.0</span>     <span class="comment"># 这是一个浮点数</span></span><br><span class="line"><span class="number">11.0</span> / <span class="number">4.0</span> <span class="comment">#=&gt; 2.75 ahhh...much better</span></span><br><span class="line"><span class="number">11.0</span> / <span class="number">4.0</span> <span class="comment">#=&gt; 2.75 啊……这样就好多了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enforce precedence with parentheses</span></span><br><span class="line"><span class="comment"># 使用小括号来强制计算的优先顺序</span></span><br><span class="line">(<span class="number">1</span> + <span class="number">3</span>) * <span class="number">2</span> <span class="comment">#=&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean values are primitives</span></span><br><span class="line"><span class="comment"># 布尔值也是基本数据类型</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># negate with not</span></span><br><span class="line"><span class="comment"># 使用 not 来取反</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">True</span> <span class="comment">#=&gt; False</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">False</span> <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equality is ==</span></span><br><span class="line"><span class="comment"># 等式判断用 ==</span></span><br><span class="line"><span class="number">1</span> == <span class="number">1</span> <span class="comment">#=&gt; True</span></span><br><span class="line"><span class="number">2</span> == <span class="number">1</span> <span class="comment">#=&gt; False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Inequality is !=</span></span><br><span class="line"><span class="comment"># 不等式判断是用 !=</span></span><br><span class="line"><span class="number">1</span> != <span class="number">1</span> <span class="comment">#=&gt; False</span></span><br><span class="line"><span class="number">2</span> != <span class="number">1</span> <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># More comparisons</span></span><br><span class="line"><span class="comment"># 还有更多的比较运算</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">10</span> <span class="comment">#=&gt; True</span></span><br><span class="line"><span class="number">1</span> &gt; <span class="number">10</span> <span class="comment">#=&gt; False</span></span><br><span class="line"><span class="number">2</span> &lt;= <span class="number">2</span> <span class="comment">#=&gt; True</span></span><br><span class="line"><span class="number">2</span> &gt;= <span class="number">2</span> <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Comparisons can be chained!</span></span><br><span class="line"><span class="comment"># 居然可以把比较运算串连起来！</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span> <span class="comment">#=&gt; True</span></span><br><span class="line"><span class="number">2</span> &lt; <span class="number">3</span> &lt; <span class="number">2</span> <span class="comment">#=&gt; False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Strings are created with &quot; or &#x27;</span></span><br><span class="line"><span class="comment"># 使用 &quot; 或 &#x27; 来创建字符串</span></span><br><span class="line"><span class="string">&quot;This is a string.&quot;</span></span><br><span class="line"><span class="string">&#x27;This is also a string.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Strings can be added too!</span></span><br><span class="line"><span class="comment"># 字符串也可以相加！</span></span><br><span class="line"><span class="string">&quot;Hello &quot;</span> + <span class="string">&quot;world!&quot;</span> <span class="comment">#=&gt; &quot;Hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A string can be treated like a list of characters</span></span><br><span class="line"><span class="comment"># 一个字符串可以视为一个字符的列表</span></span><br><span class="line"><span class="comment"># （译注：后面会讲到“列表”。）</span></span><br><span class="line"><span class="string">&quot;This is a string&quot;</span>[<span class="number">0</span>] <span class="comment">#=&gt; &#x27;T&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># % can be used to format strings, like this:</span></span><br><span class="line"><span class="comment"># % 可以用来格式化字符串，就像这样：</span></span><br><span class="line"><span class="string">&quot;%s can be %s&quot;</span> % (<span class="string">&quot;strings&quot;</span>, <span class="string">&quot;interpolated&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A newer way to format strings is the format method.</span></span><br><span class="line"><span class="comment"># This method is the preferred way</span></span><br><span class="line"><span class="comment"># 后来又有一种格式化字符串的新方法：format 方法。</span></span><br><span class="line"><span class="comment"># 我们推荐使用这个方法。</span></span><br><span class="line"><span class="string">&quot;&#123;0&#125; can be &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;strings&quot;</span>, <span class="string">&quot;formatted&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can use keywords if you don&#x27;t want to count.</span></span><br><span class="line"><span class="comment"># 如果你不喜欢数数的话，可以使用关键字（变量）。</span></span><br><span class="line"><span class="string">&quot;&#123;name&#125; wants to eat &#123;food&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;Bob&quot;</span>, food=<span class="string">&quot;lasagna&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># None is an object</span></span><br><span class="line"><span class="comment"># None 是一个对象</span></span><br><span class="line"><span class="literal">None</span> <span class="comment">#=&gt; None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don&#x27;t use the equality `==` symbol to compare objects to None</span></span><br><span class="line"><span class="comment"># Use `is` instead</span></span><br><span class="line"><span class="comment"># 不要使用相等符号 `==` 来把对象和 None 进行比较，</span></span><br><span class="line"><span class="comment"># 而要用 `is`。</span></span><br><span class="line"><span class="string">&quot;etc&quot;</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="comment">#=&gt; False</span></span><br><span class="line"><span class="literal">None</span> <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The &#x27;is&#x27; operator tests for object identity. This isn&#x27;t</span></span><br><span class="line"><span class="comment"># very useful when dealing with primitive values, but is</span></span><br><span class="line"><span class="comment"># very useful when dealing with objects.</span></span><br><span class="line"><span class="comment"># 这个 `is` 操作符用于比较两个对象的标识。</span></span><br><span class="line"><span class="comment"># （译注：对象一旦建立，其标识就不会改变，可以认为它就是对象的内存地址。）</span></span><br><span class="line"><span class="comment"># 在处理基本数据类型时基本用不上，</span></span><br><span class="line"><span class="comment"># 但它在处理对象时很有用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># None, 0, and empty strings/lists all evaluate to False.</span></span><br><span class="line"><span class="comment"># All other values are True</span></span><br><span class="line"><span class="comment"># None、0 以及空字符串和空列表都等于 False，</span></span><br><span class="line"><span class="comment"># 除此以外的所有值都等于 True。</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">False</span>  <span class="comment">#=&gt; True</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">False</span> <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"><span class="comment">## 2. Variables and Collections</span></span><br><span class="line"><span class="comment">## 2. 变量和集合</span></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Printing is pretty easy</span></span><br><span class="line"><span class="comment"># 打印输出很简单</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I&#x27;m Python. Nice to meet you!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># No need to declare variables before assigning to them.</span></span><br><span class="line"><span class="comment"># 在赋值给变量之前不需要声明</span></span><br><span class="line">some_var = <span class="number">5</span>    <span class="comment"># Convention is to use lower_case_with_underscores</span></span><br><span class="line">                <span class="comment"># 变量名的约定是使用下划线分隔的小写单词</span></span><br><span class="line">some_var <span class="comment">#=&gt; 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Accessing a previously unassigned variable is an exception.</span></span><br><span class="line"><span class="comment"># See Control Flow to learn more about exception handling.</span></span><br><span class="line"><span class="comment"># 访问一个未赋值的变量会产生一个异常。</span></span><br><span class="line"><span class="comment"># 进一步了解异常处理，可参见下一节《控制流》。</span></span><br><span class="line">some_other_var  <span class="comment"># Raises a name error</span></span><br><span class="line">                <span class="comment"># 会抛出一个名称错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if can be used as an expression</span></span><br><span class="line"><span class="comment"># if 可以作为表达式来使用</span></span><br><span class="line"><span class="string">&quot;yahoo!&quot;</span> <span class="keyword">if</span> <span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> <span class="comment">#=&gt; &quot;yahoo!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lists store sequences</span></span><br><span class="line"><span class="comment"># 列表用于存储序列</span></span><br><span class="line">li = []</span><br><span class="line"><span class="comment"># You can start with a prefilled list</span></span><br><span class="line"><span class="comment"># 我们先尝试一个预先填充好的列表</span></span><br><span class="line">other_li = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add stuff to the end of a list with append</span></span><br><span class="line"><span class="comment"># 使用 append 方法把元素添加到列表的尾部</span></span><br><span class="line">li.append(<span class="number">1</span>)    <span class="comment">#li is now [1]</span></span><br><span class="line">                <span class="comment">#li 现在是 [1]</span></span><br><span class="line">li.append(<span class="number">2</span>)    <span class="comment">#li is now [1, 2]</span></span><br><span class="line">                <span class="comment">#li 现在是 [1, 2]</span></span><br><span class="line">li.append(<span class="number">4</span>)    <span class="comment">#li is now [1, 2, 4]</span></span><br><span class="line">                <span class="comment">#li 现在是 [1, 2, 4]</span></span><br><span class="line">li.append(<span class="number">3</span>)    <span class="comment">#li is now [1, 2, 4, 3]</span></span><br><span class="line">                <span class="comment">#li 现在是 [1, 2, 4, 3]</span></span><br><span class="line"><span class="comment"># Remove from the end with pop</span></span><br><span class="line"><span class="comment"># 使用 pop 来移除最后一个元素</span></span><br><span class="line">li.pop()        <span class="comment">#=&gt; 3 and li is now [1, 2, 4]</span></span><br><span class="line">                <span class="comment">#=&gt; 3，然后 li 现在是 [1, 2, 4]</span></span><br><span class="line"><span class="comment"># Let&#x27;s put it back</span></span><br><span class="line"><span class="comment"># 我们再把它放回去</span></span><br><span class="line">li.append(<span class="number">3</span>)    <span class="comment"># li is now [1, 2, 4, 3] again.</span></span><br><span class="line">                <span class="comment"># li 现在又是 [1, 2, 4, 3] 了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Access a list like you would any array</span></span><br><span class="line"><span class="comment"># 像访问其它语言的数组那样访问列表</span></span><br><span class="line">li[<span class="number">0</span>] <span class="comment">#=&gt; 1</span></span><br><span class="line"><span class="comment"># Look at the last element</span></span><br><span class="line"><span class="comment"># 查询最后一个元素</span></span><br><span class="line">li[-<span class="number">1</span>] <span class="comment">#=&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Looking out of bounds is an IndexError</span></span><br><span class="line"><span class="comment"># 越界查询会产生一个索引错误</span></span><br><span class="line">li[<span class="number">4</span>] <span class="comment"># Raises an IndexError</span></span><br><span class="line">      <span class="comment"># 抛出一个索引错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can look at ranges with slice syntax.</span></span><br><span class="line"><span class="comment"># (It&#x27;s a closed/open range for you mathy types.)</span></span><br><span class="line"><span class="comment"># 你可以使用切片语法来查询列表的一个范围。</span></span><br><span class="line"><span class="comment"># （这个范围相当于数学中的左闭右开区间。）</span></span><br><span class="line">li[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#=&gt; [2, 4]</span></span><br><span class="line"><span class="comment"># Omit the beginning</span></span><br><span class="line"><span class="comment"># 省略开头</span></span><br><span class="line">li[<span class="number">2</span>:] <span class="comment">#=&gt; [4, 3]</span></span><br><span class="line"><span class="comment"># Omit the end</span></span><br><span class="line"><span class="comment"># 省略结尾</span></span><br><span class="line">li[:<span class="number">3</span>] <span class="comment">#=&gt; [1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove arbitrary elements from a list with del</span></span><br><span class="line"><span class="comment"># 使用 del 来删除列表中的任意元素</span></span><br><span class="line"><span class="keyword">del</span> li[<span class="number">2</span>] <span class="comment"># li is now [1, 2, 3]</span></span><br><span class="line">          <span class="comment"># li 现在是 [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can add lists</span></span><br><span class="line"><span class="comment"># 可以把列表相加</span></span><br><span class="line">li + other_li <span class="comment">#=&gt; [1, 2, 3, 4, 5, 6] - Note: li and other_li is left alone</span></span><br><span class="line">              <span class="comment">#=&gt; [1, 2, 3, 4, 5, 6] - 请留意 li 和 other_li 并不会被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Concatenate lists with extend</span></span><br><span class="line"><span class="comment"># 使用 extend 来合并列表</span></span><br><span class="line">li.extend(other_li) <span class="comment"># Now li is [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">                    <span class="comment"># 现在 li 是 [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for existence in a list with in</span></span><br><span class="line"><span class="comment"># 用 in 来检查是否存在于某个列表中</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> li <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Examine the length with len</span></span><br><span class="line"><span class="comment"># 用 len 来检测列表的长度</span></span><br><span class="line"><span class="built_in">len</span>(li) <span class="comment">#=&gt; 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuples are like lists but are immutable.</span></span><br><span class="line"><span class="comment"># 元组很像列表，但它是“不可变”的。</span></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tup[<span class="number">0</span>] <span class="comment">#=&gt; 1</span></span><br><span class="line">tup[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># Raises a TypeError</span></span><br><span class="line">            <span class="comment"># 抛出一个类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can do all those list thingies on tuples too</span></span><br><span class="line"><span class="comment"># 操作列表的方式通常也能用在元组身上</span></span><br><span class="line"><span class="built_in">len</span>(tup) <span class="comment">#=&gt; 3</span></span><br><span class="line">tup + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">#=&gt; (1, 2, 3, 4, 5, 6)</span></span><br><span class="line">tup[:<span class="number">2</span>] <span class="comment">#=&gt; (1, 2)</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> tup <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can unpack tuples (or lists) into variables</span></span><br><span class="line"><span class="comment"># 你可以把元组（或列表）中的元素解包赋值给多个变量</span></span><br><span class="line">a, b, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)     <span class="comment"># a is now 1, b is now 2 and c is now 3</span></span><br><span class="line">                        <span class="comment"># 现在 a 是 1，b 是 2，c 是 3</span></span><br><span class="line"><span class="comment"># Tuples are created by default if you leave out the parentheses</span></span><br><span class="line"><span class="comment"># 如果你省去了小括号，那么元组会被自动创建</span></span><br><span class="line">d, e, f = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="comment"># Now look how easy it is to swap two values</span></span><br><span class="line"><span class="comment"># 再来看看交换两个值是多么简单。</span></span><br><span class="line">e, d = d, e     <span class="comment"># d is now 5 and e is now 4</span></span><br><span class="line">                <span class="comment"># 现在 d 是 5 而 e 是 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionaries store mappings</span></span><br><span class="line"><span class="comment"># 字典用于存储映射关系</span></span><br><span class="line">empty_dict = &#123;&#125;</span><br><span class="line"><span class="comment"># Here is a prefilled dictionary</span></span><br><span class="line"><span class="comment"># 这是一个预先填充的字典</span></span><br><span class="line">filled_dict = &#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Look up values with []</span></span><br><span class="line"><span class="comment"># 使用 [] 来查询键值</span></span><br><span class="line">filled_dict[<span class="string">&quot;one&quot;</span>] <span class="comment">#=&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all keys as a list</span></span><br><span class="line"><span class="comment"># 将字典的所有键名获取为一个列表</span></span><br><span class="line">filled_dict.keys() <span class="comment">#=&gt; [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</span></span><br><span class="line"><span class="comment"># Note - Dictionary key ordering is not guaranteed.</span></span><br><span class="line"><span class="comment"># Your results might not match this exactly.</span></span><br><span class="line"><span class="comment"># 请注意：无法保证字典键名的顺序如何排列。</span></span><br><span class="line"><span class="comment"># 你得到的结果可能跟上面的示例不一致。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all values as a list</span></span><br><span class="line"><span class="comment"># 将字典的所有键值获取为一个列表</span></span><br><span class="line">filled_dict.values() <span class="comment">#=&gt; [3, 2, 1]</span></span><br><span class="line"><span class="comment"># Note - Same as above regarding key ordering.</span></span><br><span class="line"><span class="comment"># 请注意：顺序的问题和上面一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for existence of keys in a dictionary with in</span></span><br><span class="line"><span class="comment"># 使用 in 来检查一个字典是否包含某个键名</span></span><br><span class="line"><span class="string">&quot;one&quot;</span> <span class="keyword">in</span> filled_dict <span class="comment">#=&gt; True</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> filled_dict <span class="comment">#=&gt; False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Looking up a non-existing key is a KeyError</span></span><br><span class="line"><span class="comment"># 查询一个不存在的键名会产生一个键名错误</span></span><br><span class="line">filled_dict[<span class="string">&quot;four&quot;</span>] <span class="comment"># KeyError</span></span><br><span class="line">                    <span class="comment"># 键名错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use get method to avoid the KeyError</span></span><br><span class="line"><span class="comment"># 所以要使用 get 方法来避免键名错误</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;one&quot;</span>) <span class="comment">#=&gt; 1</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;four&quot;</span>) <span class="comment">#=&gt; None</span></span><br><span class="line"><span class="comment"># The get method supports a default argument when the value is missing</span></span><br><span class="line"><span class="comment"># get 方法支持传入一个默认值参数，将在取不到值时返回。</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;one&quot;</span>, <span class="number">4</span>) <span class="comment">#=&gt; 1</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>) <span class="comment">#=&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setdefault method is a safe way to add new key-value pair into dictionary</span></span><br><span class="line"><span class="comment"># Setdefault 方法可以安全地把新的名值对添加到字典里</span></span><br><span class="line">filled_dict.setdefault(<span class="string">&quot;five&quot;</span>, <span class="number">5</span>) <span class="comment">#filled_dict[&quot;five&quot;] is set to 5</span></span><br><span class="line">                                  <span class="comment">#filled_dict[&quot;five&quot;] 被设置为 5</span></span><br><span class="line">filled_dict.setdefault(<span class="string">&quot;five&quot;</span>, <span class="number">6</span>) <span class="comment">#filled_dict[&quot;five&quot;] is still 5</span></span><br><span class="line">                                  <span class="comment">#filled_dict[&quot;five&quot;] 仍然为 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets store ... well sets</span></span><br><span class="line"><span class="comment"># set 用于保存集合</span></span><br><span class="line">empty_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># Initialize a set with a bunch of values</span></span><br><span class="line"><span class="comment"># 使用一堆值来初始化一个集合</span></span><br><span class="line">some_set = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) <span class="comment"># some_set is now set([1, 2, 3, 4])</span></span><br><span class="line">                            <span class="comment"># some_set 现在是 set([1, 2, 3, 4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Since Python 2.7, &#123;&#125; can be used to declare a set</span></span><br><span class="line"><span class="comment"># 从 Python 2.7 开始，&#123;&#125; 可以用来声明一个集合</span></span><br><span class="line">filled_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment"># =&gt; &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">                             <span class="comment"># （译注：集合是种无序不重复的元素集，因此重复的 2 被滤除了。）</span></span><br><span class="line">                             <span class="comment"># （译注：&#123;&#125; 不会创建一个空集合，只会创建一个空字典。）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add more items to a set</span></span><br><span class="line"><span class="comment"># 把更多的元素添加进一个集合</span></span><br><span class="line">filled_set.add(<span class="number">5</span>) <span class="comment"># filled_set is now &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">                  <span class="comment"># filled_set 现在是 &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do set intersection with &amp;</span></span><br><span class="line"><span class="comment"># 使用 &amp; 来获取交集</span></span><br><span class="line">other_set = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">filled_set &amp; other_set <span class="comment">#=&gt; &#123;3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do set union with |</span></span><br><span class="line"><span class="comment"># 使用 | 来获取并集</span></span><br><span class="line">filled_set | other_set <span class="comment">#=&gt; &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do set difference with -</span></span><br><span class="line"><span class="comment"># 使用 - 来获取补集</span></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; - &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125; <span class="comment">#=&gt; &#123;1, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for existence in a set with in</span></span><br><span class="line"><span class="comment"># 使用 in 来检查是否存在于某个集合中</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> filled_set <span class="comment">#=&gt; True</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">in</span> filled_set <span class="comment">#=&gt; False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"><span class="comment">## 3. Control Flow</span></span><br><span class="line"><span class="comment">## 3. 控制流</span></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s just make a variable</span></span><br><span class="line"><span class="comment"># 我们先创建一个变量</span></span><br><span class="line">some_var = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Here is an if statement. Indentation is significant in python!</span></span><br><span class="line"><span class="comment"># prints &quot;some_var is smaller than 10&quot;</span></span><br><span class="line"><span class="comment"># 这里有一个条件语句。缩进在 Python 中可是很重要的哦！</span></span><br><span class="line"><span class="comment"># 程序会打印出 &quot;some_var is smaller than 10&quot;</span></span><br><span class="line"><span class="comment"># （译注：意为“some_var 比 10 小”。）</span></span><br><span class="line"><span class="keyword">if</span> some_var &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;some_var is totally bigger than 10.&quot;</span></span><br><span class="line">    <span class="comment"># （译注：意为“some_var 完全比 10 大”。）</span></span><br><span class="line"><span class="keyword">elif</span> some_var &lt; <span class="number">10</span>:    <span class="comment"># This elif clause is optional.</span></span><br><span class="line">                       <span class="comment"># 这里的 elif 子句是可选的</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;some_var is smaller than 10.&quot;</span></span><br><span class="line">    <span class="comment"># （译注：意为“some_var 比 10 小”。）</span></span><br><span class="line"><span class="keyword">else</span>:           <span class="comment"># This is optional too.</span></span><br><span class="line">                <span class="comment"># 这一句也是可选的</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;some_var is indeed 10.&quot;</span></span><br><span class="line">    <span class="comment"># （译注：意为“some_var 就是 10”。）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">For loops iterate over lists</span></span><br><span class="line"><span class="string">for 循环可以遍历列表</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">如果要打印出：</span></span><br><span class="line"><span class="string">    dog is a mammal</span></span><br><span class="line"><span class="string">    cat is a mammal</span></span><br><span class="line"><span class="string">    mouse is a mammal</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> [<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;mouse&quot;</span>]:</span><br><span class="line">    <span class="comment"># You can use % to interpolate formatted strings</span></span><br><span class="line">    <span class="comment"># 别忘了你可以使用 % 来格式化字符串</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%s is a mammal&quot;</span> % animal</span><br><span class="line">    <span class="comment"># （译注：意为“%s 是哺乳动物”。）</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">`range(number)` returns a list of numbers</span></span><br><span class="line"><span class="string">from zero to the given number</span></span><br><span class="line"><span class="string">`range(数字)` 会返回一个数字列表，</span></span><br><span class="line"><span class="string">这个列表将包含从零到给定的数字。</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">如果要打印出：</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">While loops go until a condition is no longer met.</span></span><br><span class="line"><span class="string">while 循环会一直继续，直到条件不再满足。</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">如果要打印出：</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span> x</span><br><span class="line">    x += <span class="number">1</span>  <span class="comment"># Shorthand for x = x + 1</span></span><br><span class="line">            <span class="comment"># 这是 x = x + 1 的简写方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Handle exceptions with a try/except block</span></span><br><span class="line"><span class="comment"># 使用 try/except 代码块来处理异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Works on Python 2.6 and up:</span></span><br><span class="line"><span class="comment"># 适用于 Python 2.6 及以上版本：</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Use raise to raise an error</span></span><br><span class="line">    <span class="comment"># 使用 raise 来抛出一个错误</span></span><br><span class="line">    <span class="keyword">raise</span> IndexError(<span class="string">&quot;This is an index error&quot;</span>)</span><br><span class="line">    <span class="comment"># 抛出一个索引错误：“这是一个索引错误”。</span></span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span>    <span class="comment"># Pass is just a no-op. Usually you would do recovery here.</span></span><br><span class="line">            <span class="comment"># pass 只是一个空操作。通常你应该在这里做一些恢复工作。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"><span class="comment">## 4. Functions</span></span><br><span class="line"><span class="comment">## 4. 函数</span></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use def to create new functions</span></span><br><span class="line"><span class="comment"># 使用 def 来创建新函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;x is %s and y is %s&quot;</span> % (x, y)</span><br><span class="line">    <span class="comment"># （译注：意为“x 是 %s 而且 y 是 %s”。）</span></span><br><span class="line">    <span class="keyword">return</span> x + y    <span class="comment"># Return values with a return statement</span></span><br><span class="line">                    <span class="comment"># 使用 return 语句来返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calling functions with parameters</span></span><br><span class="line"><span class="comment"># 调用函数并传入参数</span></span><br><span class="line">add(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">#=&gt; prints out &quot;x is 5 and y is 6&quot; and returns 11</span></span><br><span class="line">          <span class="comment"># （译注：意为“x 是 5 而且 y 是 6”，并返回 11）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another way to call functions is with keyword arguments</span></span><br><span class="line"><span class="comment"># 调用函数的另一种方式是传入关键字参数</span></span><br><span class="line">add(y=<span class="number">6</span>, x=<span class="number">5</span>)   <span class="comment"># Keyword arguments can arrive in any order.</span></span><br><span class="line">                <span class="comment"># 关键字参数可以以任意顺序传入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can define functions that take a variable number of</span></span><br><span class="line"><span class="comment"># positional arguments</span></span><br><span class="line"><span class="comment"># 你可以定义一个函数，并让它接受可变数量的定位参数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">varargs</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line">varargs(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">#=&gt; (1,2,3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can define functions that take a variable number of</span></span><br><span class="line"><span class="comment"># keyword arguments, as well</span></span><br><span class="line"><span class="comment"># 你也可以定义一个函数，并让它接受可变数量的关键字参数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword_args</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> kwargs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s call it to see what happens</span></span><br><span class="line"><span class="comment"># 我们试着调用它，看看会发生什么：</span></span><br><span class="line">keyword_args(big=<span class="string">&quot;foot&quot;</span>, loch=<span class="string">&quot;ness&quot;</span>) <span class="comment">#=&gt; &#123;&quot;big&quot;: &quot;foot&quot;, &quot;loch&quot;: &quot;ness&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can do both at once, if you like</span></span><br><span class="line"><span class="comment"># 你还可以同时使用这两类参数，只要你愿意：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_the_args</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span> args</span><br><span class="line">    <span class="built_in">print</span> kwargs</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">all_the_args(1, 2, a=3, b=4) prints:</span></span><br><span class="line"><span class="string">    (1, 2)</span></span><br><span class="line"><span class="string">    &#123;&quot;a&quot;: 3, &quot;b&quot;: 4&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When calling functions, you can do the opposite of varargs/kwargs!</span></span><br><span class="line"><span class="comment"># Use * to expand tuples and use ** to expand kwargs.</span></span><br><span class="line"><span class="comment"># 在调用函数时，定位参数和关键字参数还可以反过来用。</span></span><br><span class="line"><span class="comment"># 使用 * 来展开元组，使用 ** 来展开关键字参数。</span></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">3</span>, <span class="string">&quot;b&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">all_the_args(*args) <span class="comment"># equivalent to foo(1, 2, 3, 4)</span></span><br><span class="line">                    <span class="comment"># 相当于 all_the_args(1, 2, 3, 4)</span></span><br><span class="line">all_the_args(**kwargs) <span class="comment"># equivalent to foo(a=3, b=4)</span></span><br><span class="line">                       <span class="comment"># 相当于 all_the_args(a=3, b=4)</span></span><br><span class="line">all_the_args(*args, **kwargs) <span class="comment"># equivalent to foo(1, 2, 3, 4, a=3, b=4)</span></span><br><span class="line">                              <span class="comment"># 相当于 all_the_args(1, 2, 3, 4, a=3, b=4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python has first class functions</span></span><br><span class="line"><span class="comment"># 函数在 Python 中是一等公民</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_adder</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> adder</span><br><span class="line"></span><br><span class="line">add_10 = create_adder(<span class="number">10</span>)</span><br><span class="line">add_10(<span class="number">3</span>) <span class="comment">#=&gt; 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># There are also anonymous functions</span></span><br><span class="line"><span class="comment"># 还有匿名函数</span></span><br><span class="line">(<span class="keyword">lambda</span> x: x &gt; <span class="number">2</span>)(<span class="number">3</span>) <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># There are built-in higher order functions</span></span><br><span class="line"><span class="comment"># 还有一些内建的高阶函数</span></span><br><span class="line"><span class="built_in">map</span>(add_10, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#=&gt; [11, 12, 13]</span></span><br><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]) <span class="comment">#=&gt; [6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can use list comprehensions for nice maps and filters</span></span><br><span class="line"><span class="comment"># 我们可以使用列表推导式来模拟 map 和 filter</span></span><br><span class="line">[add_10(i) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]  <span class="comment">#=&gt; [11, 12, 13]</span></span><br><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] <span class="keyword">if</span> x &gt; <span class="number">5</span>] <span class="comment">#=&gt; [6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"><span class="comment">## 5. Classes</span></span><br><span class="line"><span class="comment">## 5. 类</span></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We subclass from object to get a class.</span></span><br><span class="line"><span class="comment"># 我们可以从对象中继承，来得到一个类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A class attribute. It is shared by all instances of this class</span></span><br><span class="line">    <span class="comment"># 下面是一个类属性。它将被这个类的所有实例共享。</span></span><br><span class="line">    species = <span class="string">&quot;H. sapiens&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Basic initializer</span></span><br><span class="line">    <span class="comment"># 基本的初始化函数（构造函数）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># Assign the argument to the instance&#x27;s name attribute</span></span><br><span class="line">        <span class="comment"># 把参数赋值为实例的 name 属性</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># An instance method. All methods take self as the first argument</span></span><br><span class="line">    <span class="comment"># 下面是一个实例方法。所有方法都以 self 作为第一个参数。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, msg</span>):</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;%s: %s&quot;</span> % (self.name, msg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A class method is shared among all instances</span></span><br><span class="line">    <span class="comment"># They are called with the calling class as the first argument</span></span><br><span class="line">    <span class="comment"># 类方法会被所有实例共享。</span></span><br><span class="line">    <span class="comment"># 类方法在调用时，会将类本身作为第一个函数传入。</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_species</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.species</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A static method is called without a class or instance reference</span></span><br><span class="line">    <span class="comment"># 静态方法在调用时，不会传入类或实例的引用。</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grunt</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;*grunt*&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate a class</span></span><br><span class="line"><span class="comment"># 实例化一个类</span></span><br><span class="line">i = Human(name=<span class="string">&quot;Ian&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> i.say(<span class="string">&quot;hi&quot;</span>)     <span class="comment"># prints out &quot;Ian: hi&quot;</span></span><br><span class="line">                      <span class="comment"># 打印出 &quot;Ian: hi&quot;</span></span><br><span class="line"></span><br><span class="line">j = Human(<span class="string">&quot;Joel&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> j.say(<span class="string">&quot;hello&quot;</span>)  <span class="comment"># prints out &quot;Joel: hello&quot;</span></span><br><span class="line">                      <span class="comment"># 打印出 &quot;Joel: hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Call our class method</span></span><br><span class="line"><span class="comment"># 调用我们的类方法</span></span><br><span class="line">i.get_species() <span class="comment">#=&gt; &quot;H. sapiens&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change the shared attribute</span></span><br><span class="line"><span class="comment"># 修改共享属性</span></span><br><span class="line">Human.species = <span class="string">&quot;H. neanderthalensis&quot;</span></span><br><span class="line">i.get_species() <span class="comment">#=&gt; &quot;H. neanderthalensis&quot;</span></span><br><span class="line">j.get_species() <span class="comment">#=&gt; &quot;H. neanderthalensis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Call the static method</span></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">Human.grunt() <span class="comment">#=&gt; &quot;*grunt*&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"><span class="comment">## 6. Modules</span></span><br><span class="line"><span class="comment">## 6. 模块</span></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can import modules</span></span><br><span class="line"><span class="comment"># 你可以导入模块</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span> math.sqrt(<span class="number">16</span>) <span class="comment">#=&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can get specific functions from a module</span></span><br><span class="line"><span class="comment"># 也可以从一个模块中获取指定的函数</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil, floor</span><br><span class="line"><span class="built_in">print</span> ceil(<span class="number">3.7</span>)  <span class="comment">#=&gt; 4.0</span></span><br><span class="line"><span class="built_in">print</span> floor(<span class="number">3.7</span>) <span class="comment">#=&gt; 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can import all functions from a module.</span></span><br><span class="line"><span class="comment"># Warning: this is not recommended</span></span><br><span class="line"><span class="comment"># 你可以从一个模块中导入所有函数</span></span><br><span class="line"><span class="comment"># 警告：不建议使用这种方式</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can shorten module names</span></span><br><span class="line"><span class="comment"># 你可以缩短模块的名称</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line">math.sqrt(<span class="number">16</span>) == m.sqrt(<span class="number">16</span>) <span class="comment">#=&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python modules are just ordinary python files. You</span></span><br><span class="line"><span class="comment"># can write your own, and import them. The name of the</span></span><br><span class="line"><span class="comment"># module is the same as the name of the file.</span></span><br><span class="line"><span class="comment"># Python 模块就是普通的 Python 文件。</span></span><br><span class="line"><span class="comment"># 你可以编写你自己的模块，然后导入它们。</span></span><br><span class="line"><span class="comment"># 模块的名称与文件名相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can find out which functions and attributes</span></span><br><span class="line"><span class="comment"># defines a module.</span></span><br><span class="line"><span class="comment"># 你可以查出一个模块里有哪些函数和属性</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">dir</span>(math)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/adambard/learnxinyminutes-docs/blob/master/python.html.markdown">Source File: adambard&#x2F;learnxinyminutes-docs - GitHub</a></p><p>Translated by: <a href="https://github.com/cssmagic">cssmagic</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式总览</title>
      <link href="/2018/Design-Pattern-Introduction/index/"/>
      <url>/2018/Design-Pattern-Introduction/index/</url>
      
        <content type="html"><![CDATA[<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了更好的代码<code>可重用性</code>、<code>可读性</code>、<code>可靠性</code>和<code>可维护性</code>。</p><h2 id="设计模式3大分类"><a href="#设计模式3大分类" class="headerlink" title="设计模式3大分类"></a>设计模式3大分类</h2><h3 id="创建型模式（5种）"><a href="#创建型模式（5种）" class="headerlink" title="创建型模式（5种）"></a>创建型模式（5种）</h3><ul><li>单例模式（Singleton Pattern）</li><li>工厂方法模式（Factory Method Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul><h3 id="结构型模式（7种）"><a href="#结构型模式（7种）" class="headerlink" title="结构型模式（7种）"></a>结构型模式（7种）</h3><ul><li>适配器模式（Adapter Pattern）</li><li>装饰者模式（Decorator Pattern）</li><li>代理模式（Proxy Pattern）</li><li>外观模式（Facade Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>组合模式（Composite Pattern）</li><li>享元模式（Flyweight Pattern）</li></ul><h3 id="行为型模式（11种）"><a href="#行为型模式（11种）" class="headerlink" title="行为型模式（11种）"></a>行为型模式（11种）</h3><ul><li>策略模式（Strategy Pattern）</li><li>模板方法模式（Template Method Pattern）</li><li>观察者模式（Observer Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>责任链模式（Chain Of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>状态模式（Status Pattern）</li><li>访问者模式（Visitor Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>解释器模式（Interpreter Pattern</li></ul><h2 id="设计模式6大原则"><a href="#设计模式6大原则" class="headerlink" title="设计模式6大原则"></a>设计模式6大原则</h2><h3 id="单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle, SRP）"></a>单一职责原则（Single Responsibility Principle, SRP）</h3><blockquote><p>就一个类而言，应该只有一个引起它变化的原因。</p></blockquote><ul><li>降低类的复杂度，一个类只负责一项职责；</li><li>提高类的可读性和可维护性；</li><li>降低变更引起的风险。</li></ul><h3 id="里氏替换原则（Liskov-Substitution-Principle-LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle-LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle, LSP）"></a>里氏替换原则（Liskov Substitution Principle, LSP）</h3><blockquote><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p></blockquote><ul><li>里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</li><li>任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li></ul><h3 id="依赖倒转原则（Dependence-Inversion-Principle-DIP）"><a href="#依赖倒转原则（Dependence-Inversion-Principle-DIP）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle, DIP）"></a>依赖倒转原则（Dependence Inversion Principle, DIP）</h3><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><ul><li>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入（DependencyInjection, DI）的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</li><li>常用的注入方式有三种，分别是：<code>构造注入</code>，<code>设值注入（Setter注入）</code>和<code>接口注入</code>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过 Setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</li></ul><h3 id="接口隔离原则（Interface-Segregation-Principle-ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle-ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle, ISP）"></a>接口隔离原则（Interface Segregation Principle, ISP）</h3><blockquote><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></blockquote><ul><li>每个接口中不存在子类用不到却必须实现的方法，若存在，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</li></ul><h3 id="迪米特法则（Demeter-Principle-DP"><a href="#迪米特法则（Demeter-Principle-DP" class="headerlink" title="迪米特法则（Demeter Principle, DP)"></a>迪米特法则（Demeter Principle, DP)</h3><blockquote><p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p></blockquote><ul><li>迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP）。一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</li></ul><h3 id="开闭原则（Composite-Reuse-Principle-CRP）"><a href="#开闭原则（Composite-Reuse-Principle-CRP）" class="headerlink" title="开闭原则（Composite Reuse Principle, CRP）"></a>开闭原则（Composite Reuse Principle, CRP）</h3><blockquote><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p></blockquote><ul><li>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</li></ul><h2 id="设计模式之间的关系图"><a href="#设计模式之间的关系图" class="headerlink" title="设计模式之间的关系图"></a>设计模式之间的关系图</h2><p><img src="/img/java/2h6UCe.jpg" alt="设计模式之间的关系"></p><p>【转载】原文出处：【[Mauger&#96;s Blog](<a href="https://wumaozheng.com/2018/Design-Pattern-Introduction.html)%E3%80%91">https://wumaozheng.com/2018/Design-Pattern-Introduction.html)】</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入 Java 单例模式</title>
      <link href="/2018/Singleton-Pattern/index/"/>
      <url>/2018/Singleton-Pattern/index/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/java/2h6EI6.jpg"></p><p>在 GoF 的23种设计模式中，单例模式是比较简单的一种。然而，有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。</p><p>所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。就像是 Java Web 中的 application，也就是提供了一个全局变量，用处相当广泛，比如：保存全局数据，实现全局性的操作等。</p><span id="more"></span><h2 id="最简单的实现"><a href="#最简单的实现" class="headerlink" title="最简单的实现"></a>最简单的实现</h2><p>首先，能够想到的最简单的实现是，把类的构造函数写成<code>private</code>的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给使用者。这样，使用者就可以通过这个引用使用到这个类的实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例，外部使用者如果需要使用<code>SingletonClass</code>的实例，只能通过<code>getInstance()</code>方法，并且它的构造方法是<code>private</code>的，这样就保证了只能有一个对象存在。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="Lazy-Loaded"><a href="#Lazy-Loaded" class="headerlink" title="Lazy Loaded"></a>Lazy Loaded</h3><p>上面的代码虽然简单，但是有一个问题——无论这个类是否被使用，都会创建一个 instance 对象。如果这个创建过程很耗时，比如需要连接 10000 次数据库(夸张了…:-))，并且这个类还并不一定会被使用，那么这个创建过程就是无用的。怎么办呢？为了解决这个问题，我们想到了新的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的变化有两处 — 首先，把 instance 初始化为 null，直到第一次使用的时候通过判断是否为 null 来创建对象。因为创建过程不在声明处，所以那个<code>final</code>的修饰必须去掉。</p><p>我们来想象一下这个过程。要使用 SingletonClass，调用 getInstance() 方法。第一次的时候发现 instance 是 null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个 instance 是 static 的，所以已经不是 null 了，因此不会再创建对象，直接将其返回。</p><p>  这个过程就称为<code>Lazy Loaded</code>，也就是迟加载 — 直到使用的时候才进行加载。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>上面的代码很清楚，也很简单。然而就像那句名言：“80% 的错误都是由 20% 代码优化引起的”。单线程下，这段代码没有什么问题，可是如果是多线程，麻烦就来了。我们来分析一下：</p><p>线程 A 希望使用 SingletonClass，调用 getInstance() 方法。因为是第一次调用，A 就发现 instance 是 null 的，于是它开始创建实例，就在这个时候，CPU 发生时间片切换，线程 B 开始执行，它要使用 SingletonClass，调用 getInstance() 方法，同样检测到 instance 是 null — 注意，这是在 A 检测完之后切换的，也就是说A并没有来得及创建对象——因此 B 开始创建。B 创建完成后，切换到 A 继续执行，因为它已经检测完了，所以 A 不会再检测一遍，它会直接创建对象。这样，线程 A 和 B 各自拥有一个 SingletonClass 的对象 — 单例失败！解决的方法也很简单，那就是加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在 getInstance() 加上同步锁，一个线程必须等待另外一个线程创建完成后才能使用这个方法，这就保证了单例的唯一性。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>上面的代码又是很清楚很简单的，然而，简单的东西往往不够理想。这段代码毫无疑问存在性能的问题 — <code>synchronized</code>修饰的同步块可是要比一般的代码段慢上几倍的！如果存在很多次<code>getInstance()</code>的调用，那性能问题就不得不考虑了！</p><p>  让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现<code>Lazy Loaded</code>的那种情形的原因。原因就是检测<code>null</code>的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SingletonClass.class) &#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先去掉 <code>getInstance()</code> 的同步操作，然后把同步锁加载<code>if</code>语句上。但是这样的修改起不到任何作用：因为每次调用 <code>getInstance()</code> 的时候必然要同步，性能问题还是存在。如果我们事先判断一下是不是为 <code>null</code> 再去同步呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (SingletonClass.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有问题吗？首先判断 <code>instance</code> 是不是为 <code>null</code>，如果为 <code>null</code>，加锁初始化；如果不为 <code>null</code>，直接返回 <code>instance</code>。这就是<code>double-checked locking</code>设计实现单例模式。到此为止，一切都很完美。我们用一种很聪明的方式实现了单例模式。</p><h2 id="从源头检查"><a href="#从源头检查" class="headerlink" title="从源头检查"></a>从源头检查</h2><p>代码。编译原理里面有一个很重要的内容是编译器优化。所谓编译器优化是指，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。这个过程称为<code>reorder</code>。</p><p>  要知道，JVM 只是一个标准，并不是实现。JVM 中并没有规定有关编译器优化的内容，也就是说，JVM 实现可以自由的进行编译器优化。</p><p>  下面来想一下，创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JVM 规范并没有规定。那么就存在这么一种情况，JVM 是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。</p><p>  下面我们来考虑这么一种情况：线程 A 开始创建 SingletonClass 的实例，此时线程 B 调用了 getInstance() 方法，首先判断 instance 是否为 null。按照我们上面所说的内存模型，A 已经把 instance 指向了那块内存，只是还没有调用构造方法，因此B检测到 instance 不为 null，于是直接把 instance 返回了 — 问题出现了，尽管 instance 不为 null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还没有收拾。此时，如果 B 在 A 将 instance 构造完成之前就是用了这个实例，程序就会出现错误了！于是，我们想到了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      SingletonClass sc;</span><br><span class="line">      <span class="keyword">synchronized</span> (SingletonClass.class) &#123;</span><br><span class="line">        sc = instance;</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (SingletonClass.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sc == <span class="literal">null</span>) &#123;</span><br><span class="line">              sc = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          instance = sc;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在第一个同步块里面创建一个临时变量，然后使用这个临时变量进行对象的创建，并且在最后把<code>instance</code>指针临时变量的内存空间。写出这种代码基于以下思想，即<code>synchronized</code>会起到一个代码屏蔽的作用，同步块里面的代码和外部的代码没有联系。因此，在外部的同步块里面对临时变量sc进行操作并不影响 <code>instance</code>，所以外部类在<code>instance = sc;</code>之前检测 <code>instance</code> 的时候，结果 <code>instance</code> 依然是 <code>null</code>。</p><p>  不过，这种想法完全是错误的！同步块的释放保证在此之前 — 也就是同步块里面 — 的操作必须完成，但是并不保证同步块之后的操作不能因编译器优化而调换到同步块结束之前进行。因此，编译器完全可以把<code>instance = sc;</code> 这句移到内部同步块里面执行。这样，程序又是错误的了！</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>说了这么多，难道单例没有办法在 Java 中实现吗？其实不然！<br>在 JDK5 之后，Java 使用了新的内存模型。<code>volatile</code>关键字有了明确的语义 — 在 JDK1.5 之前，<code>volatile</code>是个关键字，但是并没有明确的规定其用途 — 被 <code>volatile</code> 修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把 <code>instance</code> 加上 <code>volatile</code> 关键字就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (SingletonClass.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>But，这只是 JDK1.5 之后的 Java 的解决方案，那之前版本呢？其实，还有另外的一种解决方案，并不会受到 Java 版本的影响：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonClassInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonClass</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonClassInstance.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一版本的单例模式实现代码中，我们使用了 Java 的静态内部类。这一技术是被 JVM 明确说明了的，因此不存在任何二义性。在这段代码中，因为 SingletonClass 没有 static 的属性，因此并不会被初始化。直到调用 getInstance() 的时候，会首先加载 SingletonClassInstance 类，这个类有一个 static 的 SingletonClass 实例，因此需要调用 SingletonClass 的构造方法，然后 getInstance() 将把这个内部类的 instance 返回给使用者。由于这个 instance 是 static 的，因此并不会构造多次。</p><p>由于 SingletonClassInstance 是私有静态内部类，所以不会被其他类知道，同样， static 语义也要求不会有多个实例存在。并且，JSL 规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是并发的，所以 getInstance() 也并不需要加同步。</p><p>  至此，我们完整的了解了单例模式在 Java 语言中的时候，提出了两种解决方案。个人偏向于第二种，并且 Effiective Java 也推荐的这种方式。</p><p>【转载】原文出处：【<a href="http://devbean.blog.51cto.com/448512/203501">豆子空间</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】手把手教你写网络爬虫（2）：迷你爬虫架构</title>
      <link href="/2018/python_pachong2/index/"/>
      <url>/2018/python_pachong2/index/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大家好！回顾上一期，我们在介绍了爬虫的基本概念之后，就利用各种工具横冲直撞的完成了一个小爬虫，目的就是猛、糙、快，方便初学者上手，建立信心。对于有一定基础的读者，请不要着急，以后我们会学习主流的开源框架，打造出一个强大专业的爬虫系统！不过在此之前，要继续打好基础，本期我们先介绍爬虫的种类，然后选取最典型的通用网络爬虫，为其设计一个迷你框架。有了自己对框架的思考后，再学习复杂的开源框架就有头绪了。</p><p>今天我们会把更多的时间用在思考上，而不是一根筋的coding。用80%的时间思考，20%的时间敲键盘，这样更有利于进步。</p><p><img src="/img/pachong/1368640-20180416081838994-1911527063.jpg"></p><h2 id="语言-amp-环境"><a href="#语言-amp-环境" class="headerlink" title="语言&amp;环境"></a>语言&amp;环境</h2><p><strong>语言</strong>: 带足弹药，继续用Python开路！</p><p><img src="/img/pachong/1368640-20180416083222700-1608754881.jpg"></p><p>__threading__：threading库可以在单独的线程中执行任何的在Python中可以调用的对象。Python 2.x中的thread模块已被废弃，用户可以使用threading模块代替。在Python 3中不能再使用thread模块。为了兼容性，Python 3将thread重命名为_thread。</p><p>__queue__：queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。</p><p>__re__：Python 自1.5版本起增加了re模块，它提供Perl风格的正则表达式模式。re模块使 Python语言拥有全部的正则表达式功能。</p><p>__argparse__：Python用于解析命令行参数和选项的标准模块，用于代替已经过时的optparse模块。argparse模块的作用是用于解析命令行参数。</p><p>__configparser__：读取配置文件的模块。</p><h2 id="爬虫的种类"><a href="#爬虫的种类" class="headerlink" title="爬虫的种类"></a>爬虫的种类</h2><p><img src="/img/pachong/1368640-20180416082007879-529145611.jpg"></p><p>网络爬虫按照系统结构和实现技术，大致可以分为以下几种类型：通用网络爬虫（General Purpose Web Crawler）、聚焦网络爬虫（Focused Web Crawler）、增量式网络爬虫（Incremental Web Crawler）、深层网络爬虫（Deep Web Crawler）。实际的网络爬虫系统通常是几种爬虫技术相结合实现的。</p><h3 id="通用网络爬虫"><a href="#通用网络爬虫" class="headerlink" title="通用网络爬虫"></a>通用网络爬虫</h3><p>通用网络爬虫又称全网爬虫（Scalable Web Crawler），爬取对象从一些种子 URL 扩充到整个 Web。主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。</p><p>通用网络爬虫的结构大致可以分为页面爬取模块 、页面分析模块、链接过滤模块、页面存储模块、URL 队列、初始 URL 集合几个部分。为提高工作效率，通用网络爬虫会采取一定的爬取策略。 常用的爬取策略有：深度优先策略、广度优先策略。</p><ul><li><ol><li>深度优先策略（DFS）：其基本方法是按照深度由低到高的顺序，依次访问下一级网页链接，直到不能再深入为止。</li></ol></li><li><ol start="2"><li>广度优先策略（BFS）：此策略按照网页内容目录层次深浅来爬取页面，处于较浅目录层次的页面首先被爬取。 当同一层次中的页面爬取完毕后，爬虫再深入下一层继续爬取。</li></ol></li></ul><h3 id="聚焦网络爬虫"><a href="#聚焦网络爬虫" class="headerlink" title="聚焦网络爬虫"></a>聚焦网络爬虫</h3><p>聚焦网络爬虫（Focused Crawler），又称主题网络爬虫（Topical Crawler），是指选择性地爬取那些与预先定义好的主题相关页面的网络爬虫。 和通用网络爬虫相比，聚焦爬虫只需要爬取与主题相关的页面，极大地节省了硬件和网络资源，保存的页面也由于数量少而更新快，还可以很好地满足一些特定人群对特定领域信息的需求。我们之前爬的歌单就属于这一种。</p><h3 id="增量式网络爬虫"><a href="#增量式网络爬虫" class="headerlink" title="增量式网络爬虫"></a>增量式网络爬虫</h3><p>增量式网络爬虫（Incremental Web Crawler）是 指 对 已 下 载 网 页 采 取 增 量式更新和只爬取新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬取的页面是尽可能新的页面。 和周期性爬取和刷新页面的网络爬虫相比，增量式爬虫只会在需要的时候爬取新产生或发生更新的页面 ，并不重新下载没有发生变化的页面，可有效减少数据下载量，及时更新已爬取的网页，减小时间和空间上的耗费，但是增加了爬取算法的复杂度和实现难度。现在比较火的舆情爬虫一般都是增量式网络爬虫。</p><h3 id="深网爬虫"><a href="#深网爬虫" class="headerlink" title="深网爬虫"></a>深网爬虫</h3><p>Web 页面按存在方式可以分为表层网页（Surface Web）和深层网页（Deep Web，也称 Invisible Web Pages 或 Hidden Web）。 表层网页是指传统搜索引擎可以索引的页面，以超链接可以到达的静态网页为主构成的 Web 页面。Deep Web 是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获得的 Web 页面。例如那些用户注册后内容才可见的网页就属于 Deep Web。</p><h2 id="一个迷你框架"><a href="#一个迷你框架" class="headerlink" title="一个迷你框架"></a>一个迷你框架</h2><p>下面以比较典型的通用爬虫为例，分析其工程要点，设计并实现一个迷你框架。架构图如下：</p><p><img src="/img/pachong/1368640-20180416082035382-423718508.jpg"></p><blockquote><p>代码结构：</p></blockquote><p><img src="/img/pachong/1368640-20180416082132163-615577276.png" alt="代码结构"></p><blockquote><p>config_load.py    配置文件加载</p></blockquote><blockquote><p>crawl_thread.py    爬取线程</p></blockquote><blockquote><p>mini_spider.py    主线程</p></blockquote><blockquote><p>spider.conf    配置文件</p></blockquote><blockquote><p>url_table.py    url队列、url表</p></blockquote><blockquote><p>urls.txt    种子url集合</p></blockquote><blockquote><p>webpage_parse.py    网页分析</p></blockquote><blockquote><p>webpage_save.py    网页存储</p></blockquote><p>看看配置文件里有什么内容：</p><p>spider.conf</p><p><img src="/img/pachong/1368640-20180416082154323-1329701082.png" alt="spider.conf"></p><h3 id="Step-1-采用BFS还是DFS？"><a href="#Step-1-采用BFS还是DFS？" class="headerlink" title="Step 1. 采用BFS还是DFS？"></a>Step 1. 采用BFS还是DFS？</h3><p>理论上，这两个算法都能够在大致相同的时间里爬取整个互联网上的内容。但显然各个网站最重要的网页应该是它的首页。在极端情况下，如果只能下载非常有限的网页，那么应该下载的所有网站的首页，如果把爬虫再扩大些，应该爬取从首页直接链接的网页，因为这些网页是网站设计者自己认为相当重要的网页。在这个前提下，显然BFS明显优于DFS。事实上在搜索引擎的爬虫里，主要采用的就是BFS。我们的框架采取这种策略。</p><p>抓取深度可以通过配置文件中的max_depth设置，只要没到达指定深度，程序就会不停的将解析出的url放入队列中：</p><p>mini_spider.py</p><p><img src="/img/pachong/1368640-20180416082218282-399713427.png"></p><h3 id="Step-2-初始URL集合、URL队列"><a href="#Step-2-初始URL集合、URL队列" class="headerlink" title="Step 2. 初始URL集合、URL队列"></a>Step 2. 初始URL集合、URL队列</h3><p>我们来看看通用爬虫如何下载整个互联网。假设从一家门户网站的首页出发，先下载这个网页（深度&#x3D;0），然后通过分析这个网页，可以找到页面里的所有超链接，也就等于知道了这家门户网站首页所直接连接的全部网页，诸如京东理财、京东白条，京东众筹等（深度&#x3D;1）。接下来访问、下载并分析京东理财等网页，又能找到其他相连的网页（深度&#x3D;2）。让计算机不停的做下去，就能下载整个网站。</p><p>在这个过程中，我们需要一个“初始URL集合”保存门户的首页，还需要一个“URL队列”保存分析网页得到的超链接。</p><p>mini_spider.py</p><p><img src="/img/pachong/1368640-20180416082256564-139344406.png"></p><p>url_table.py</p><p><img src="/img/pachong/1368640-20180416082310759-1967553333.png"></p><h3 id="Step-3-记录哪些网页已经下载过的小本本——URL表。"><a href="#Step-3-记录哪些网页已经下载过的小本本——URL表。" class="headerlink" title="Step 3. 记录哪些网页已经下载过的小本本——URL表。"></a>Step 3. 记录哪些网页已经下载过的小本本——URL表。</h3><p>在互联网上，一个网页可能被多个网页中的超链接所指向。这样在遍历互联网这张图的时候，这个网页可能被多次访问到。为了防止一个网页被下载和解析多次，需要一个URL表记录哪些网页已经下载过。再遇到这个网页的时候，我们就可以跳过它。</p><p>crawl_thread.py</p><p><img src="/img/pachong/1368640-20180416082342842-1602595397.png"></p><h3 id="Step-4-多个抓取线程"><a href="#Step-4-多个抓取线程" class="headerlink" title="Step 4. 多个抓取线程"></a>Step 4. 多个抓取线程</h3><p>为了提升爬虫性能，需要多个抓取线程，从URL队列获取链接进行处理。多线程并没什么毛病，但Python的多线程可能会引起很多人的质疑，这源于Python设计之初的考虑：GIL。GIL的全称是Global Interpreter Lock(全局解释器锁)，某个线程想要执行，必须先拿到GIL，并且在一个Python进程中，GIL只有一个。结果就是Python里一个进程永远只能同时执行一个线程，这就是为什么在多核CPU上，Python的多线程效率并不高。那么我们为什么还要用Python多线程呢？</p><p>CPU密集型代码(各种循环处理、编解码等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），Python下的多线程对CPU密集型代码并不友好。</p><p>IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。Python的多线程对IO密集型代码比较友好。</p><p>所以，对于IO密集的爬虫程序，使用Python多线程是没问题的。</p><p>crawl_thread.py</p><p><img src="/img/pachong/1368640-20180416082450637-490594068.png"></p><h3 id="Step-5-页面分析模块"><a href="#Step-5-页面分析模块" class="headerlink" title="Step 5. 页面分析模块"></a>Step 5. 页面分析模块</h3><p>从网页中解析出URLs或者其他有用的数据。这个是上期重点介绍的，可以参考之前的代码。</p><h3 id="Step-6-页面存储模块"><a href="#Step-6-页面存储模块" class="headerlink" title="Step 6. 页面存储模块"></a>Step 6. 页面存储模块</h3><p>保存页面的模块，目前将文件保存为文件，以后可以扩展出多种存储方式，如mysql，mongodb，hbase等等。</p><p>webpage_save.py</p><p><img src="/img/pachong/1368640-20180416082516271-957170703.png"></p><p>写到这里，整个框架已经清晰的呈现在大家眼前了，千万不要小看它，不管多么复杂的框架都是在这些基本要素上扩展出来的。</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>基础知识的学习暂时告一段落，希望能够帮助大家打下一定的基础。下期开始为大家介绍强大成熟的爬虫框架Scrapy，它提供了很多强大的特性来使得爬取更为简单高效，更多精彩，敬请期待！</p><p><em>转自</em> <a href="http://www.cnblogs.com/tuohai666/p/8853601.html">[原创]手把手教你写网络爬虫（2）：迷你爬虫架构</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列10 - 完全理解函数修改器</title>
      <link href="/2018/solidity-modify/index/"/>
      <url>/2018/solidity-modify/index/</url>
      
        <content type="html"><![CDATA[<p>智能合约语言 Solidity 教程系列10 - 完全理解函数修改器<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="函数修改器-Function-Modifiers"><a href="#函数修改器-Function-Modifiers" class="headerlink" title="函数修改器(Function Modifiers)"></a>函数修改器(Function Modifiers)</h2><p>函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。</p><blockquote><p>如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。</p></blockquote><p>修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。下面我们来看一段示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // 定义了一个函数修改器，可被继承</span><br><span class="line">    //  修饰时，函数体被插入到 “_;” 处</span><br><span class="line">    // 不符合条件时，将抛出异常</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    //  使用继承的`onlyOwner`</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // 函数修改器可接收参数</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    // 需要提供payable 以接受以太</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面onlyOwner就是定义的一个函数修改器，当用这个修改器区修饰一个函数时，则函数必须满足onlyOwner的条件才能运行，这里的条件是：必须是合约的创建这才能调用函数，否则抛出异常。<br>我们在<a href="/2018/03/10/create-token2/">实现一个可管理、增发、兑换、冻结等高级功能的代币</a>文章中就使用了这个函数修改器。</p><h3 id="多个修改器"><a href="#多个修改器" class="headerlink" title="多个修改器"></a>多个修改器</h3><p>如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。</p><p>在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的”_”后继续执行， 如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 防止递归调用</span><br><span class="line">    // return 7 之后，locked = false 依然会执行</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。</p><h3 id="深入理解修改器的执行次序"><a href="#深入理解修改器的执行次序" class="headerlink" title="深入理解修改器的执行次序"></a>深入理解修改器的执行次序</h3><p>再来看一个复杂一点的例子，来深入理解修改器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract modifysample &#123;</span><br><span class="line"></span><br><span class="line">    uint a = 10;</span><br><span class="line"></span><br><span class="line">    modifier mf1 (uint b) &#123;</span><br><span class="line">        uint c = b;</span><br><span class="line">        _;</span><br><span class="line">        c = a;</span><br><span class="line">        a = 11;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     modifier mf2 () &#123;</span><br><span class="line">        uint c = a;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier mf3() &#123;</span><br><span class="line">        a = 12;</span><br><span class="line">        return ;</span><br><span class="line">        _;</span><br><span class="line">        a = 13;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test1() mf1(a) mf2 mf3 public   &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function test2() public constant returns (uint)   &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的智能合约运行test1()之后，状态变量a的值是多少， 是1， 11， 12，还是13呢？<br>答案是 11, 大家可以运行下test2获取下a值。</p><p>我们来分析一下 test1， 它扩展之后是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint c = b;</span><br><span class="line">        uint c = a;</span><br><span class="line">            a = 12;</span><br><span class="line">            return ;</span><br><span class="line">            _;</span><br><span class="line">            a = 13;</span><br><span class="line">c = a;</span><br><span class="line">a = 11;</span><br></pre></td></tr></table></figure><p>这个时候就一目了然了，最后a 为11， 注意第5及第6行是不是执行的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers">官方文档-Function Modifiers</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列9 - 错误处理</title>
      <link href="/2018/solidity-errorhandler/index/"/>
      <url>/2018/solidity-errorhandler/index/</url>
      
        <content type="html"><![CDATA[<p>智能合约语言 Solidity 教程系列9 - 错误处理<br>这是Solidity教程系列文章第9篇介绍Solidity 错误处理。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="什么是错误处理"><a href="#什么是错误处理" class="headerlink" title="什么是错误处理"></a>什么是错误处理</h2><p>错误处理是指在程序发生错误时的处理方式，Solidity处理错误和我们常见的语言不一样，Solidity是通过回退状态的方式来处理错误。发生异常时会撤消当前调用（及其所有子调用）所改变的状态，同时给调用者返回一个错误标识。注意_捕捉异常是不可能的_ ，因此没有try … catch…。</p><p>为什么Solidity处理错误要这样设计呢？<br>我们可以把区块链理解为是全球共享的分布式事务性数据库。<em>全球共享</em> 意味着参与这个网络的每一个人都可以读写其中的记录。如果想修改这个数据库中的内容，就必须创建一个事务，<em>事务</em> 意味着要做的修改（假如我们想同时修改两个值）只能被完全的应用或者一点都没有进行。<br>学习过数据库的同学，应该理解事务的含义，如果你对事务一词不是很理解，建议你搜索一下“数据库事务“。<br>Solidity错误处理就是要保证每次调用都是事务性的。</p><h2 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h2><p>Solidity提供了两个函数assert和require来进行条件检查，如果条件不满足则抛出异常。assert函数通常用来检查（测试）内部错误，而require函数来检查输入变量或合同状态变量是否满足条件以及验证调用外部合约返回值。<br>另外，如果我们正确使用assert，有一个Solidity分析工具就可以帮我们分析出智能合约中的错误，帮助我们发现合约中有逻辑错误的bug。</p><p>除了可以两个函数assert和require来进行条件检查，另外还有两种方式来触发异常：</p><ol><li>revert函数可以用来标记错误并回退当前调用</li><li>使用throw关键字抛出异常（从0.4.13版本，throw关键字已被弃用，将来会被淘汰。）</li></ol><p>当子调用中发生异常时，异常会自动向上“冒泡”。 不过也有一些例外：send，和底层的函数调用call, delegatecall，callcode，当发生异常时，这些函数返回false。</p><p>注意：在一个不存在的地址上调用底层的函数call，delegatecall，callcode 也会返回成功，所以我们在进行调用时，应该总是优先进行函数存在性检查。</p><p>在下面通过一个示例来说明如何使用require来检查输入条件，以及assert用于内部错误检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    function sendHalf(address addr) public payable returns (uint balance) &#123;</span><br><span class="line">        require(msg.value % 2 == 0); // 仅允许偶数</span><br><span class="line">        uint balanceBeforeTransfer = this.balance;</span><br><span class="line">        addr.transfer(msg.value / 2);  // 如果失败，会抛出异常，下面的代码就不是执行</span><br><span class="line">        assert(this.balance == balanceBeforeTransfer - msg.value / 2);</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际运行下，看看异常是如何发生的：</p><ol><li><p>首先打开<a href="https://remix.ethereum.org/">Remix</a>，贴入代码，点击创建合约。如下图：<br>  <img src="/img/solidity_error1.jpg"></p></li><li><p>运行测试1：附加1wei (奇数)去调用sendHalf，这时会发生异常，如下图:<br>  <img src="/img/solidity_error2.jpg"></p></li><li><p>运行测试2：附加2wei 去调用sendHalf，运行正常。</p></li><li><p>运行测试3：附加2wei以及sendHalf参数为当前合约本身，在转账是发生异常，因为合约无法接收转账，错误提示上图类似。</p></li></ol><h2 id="assert类型异常"><a href="#assert类型异常" class="headerlink" title="assert类型异常"></a>assert类型异常</h2><p>在下述场景中自动产生assert类型的异常:</p><ol><li>如果越界，或负的序号值访问数组，如i &gt;&#x3D; x.length 或 i &lt; 0时访问x[i]</li><li>如果序号越界，或负的序号值时访问一个定长的bytesN。</li><li>被除数为0， 如5&#x2F;0 或 23 % 0。</li><li>对一个二进制移动一个负的值。如:5&lt;&lt;i; i为-1时。</li><li>整数进行可以显式转换为枚举时，如果将过大值，负值转为枚举类型则抛出异常</li><li>如果调用未初始化内部<a href="https://learnblockchain.cn/2017/12/12/solidity_func/">函数类型</a>的变量。</li><li>如果调用assert的参数为false</li></ol><h2 id="require类型异常"><a href="#require类型异常" class="headerlink" title="require类型异常"></a>require类型异常</h2><p>在下述场景中自动产生require类型的异常:</p><ol><li>调用_throw_</li><li>如果调用_require_ 的参数为false</li><li>如果你通过消息调用一个函数，但在调用的过程中，并没有正确结束(gas不足，没有匹配到对应的函数，或被调用的函数出现异常)。底层操作如call,send,delegatecall或callcode除外，它们不会抛出异常，但它们会通过返回false来表示失败。</li><li>如果在使用new创建一个新合约时出现第3条的原因没有正常完成。</li><li>如果调用外部函数调用时，被调用的对象不包含代码。</li><li>如果合约没有payable修饰符的public的函数在接收以太币时（包括构造函数，和回退函数）。</li><li>如果合约通过一个public的getter函数（public getter funciton）接收以太币。</li><li>如果_.transfer()_ 执行失败</li></ol><p>当发生require类型的异常时，Solidity会执行一个回退操作（指令0xfd）。<br>当发生assert类型的异常时，Solidity会执行一个无效操作（指令0xfe）。<br>在上述的两种情况下，EVM都会撤回所有的状态改变。是因为期望的结果没有发生，就没法继续安全执行。必须保证交易的原子性（一致性，要么全部执行，要么一点改变都没有，不能只改变一部分），所以需要撤销所有操作，让整个交易没有任何影响。</p><p>注意assert类型的异常会消耗掉所有的gas, 而require从大都会版本（Metropolis， 即目前主网所在的版本）起不会消耗gas。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#error-handling-assert-require-revert-and-exceptions">Solidity错误处理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】[BetterExplained]书写是为了更好的思考</title>
      <link href="/2018/writing-is-better-thinking/index/"/>
      <url>/2018/writing-is-better-thinking/index/</url>
      
        <content type="html"><![CDATA[<p><em>转自</em>:<a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/">[BetterExplained]书写是为了更好的思考</a></p><p>我经常在走路和睡前总结所学过的内容，思考遗留的问题，一段时间的阅读和思考之后，一个总体的知识框架就会逐渐浮现在脑海中。然后我会将它书写下来，<strong>然而，我往往非常惊讶地发现，当我书写的时候，新的内容仍然源源不断的冒出来，就像我的键盘自己也会思考一样。</strong></p><p>大半年前的时候，我曾在一篇文章<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/">《跟波利亚学解题》</a>中写到将问题求解的思维过程记录下来的好处，现在再次回忆起来，当时列出的几点其实不仅对于问题求解是大有好处，对于平时的思考也是同样的道理。</p><p>书写的好处有以下几点：</p><ul><li><strong>书写是对思维的备忘</strong>: 人在思考一个问题的时候，就像是在黑暗中打着电筒往前走（事实上，我们的工作记忆资源是有限的，有研究证明我们只能在工作记忆里面持有7加减2个项目；此外认知负荷也是有极限的），每一步推导都将我们往前挪一小步，然而电筒的光亮能照到的范围是有限的，我们走了几步发现后面又黑了，想到后面就忘了前面的，想到某个分支上去就忘了另一个分支，我们常常想着想着就想岔了，想岔了也就罢了，问题是一旦想岔了太远，就很难回到当初岔开的地方了。有时候，我们是如此努力地试图一下就走出很远，同时又老是怕忘记目前已经取得的进展和重要结论，结果意识的微光就在一个很小的范围内打转，始终无法往前走出很远。而将思维过程记录下来，则给了我们完全的回溯自己的思维轨迹的可能。举个具体的例子，平时面对一个问题我们常常首先会想出几个主要的、关键的思考方向，但是这个时候如果没有笔记，就只能一个一个展开思考，结果展开思考了一个，却忘掉了第二点是什么了。如果记笔记，我就会先一二三的罗列出思考的关键方向，然后逐一展开。思考任何一个分支的过程中有新的发现，但一时间没有剩余的思维去细想的话，就先用关键字记在一旁，一会回头再仔细思考。某种程度上这里笔记起到了备忘的作用。</li><li><strong>书写是对思维的缓存</strong>:正因为我们的工作记忆有限，所以我们在头脑中思考问题的时候就往往只能将几个最重要的核心概念保持在工作记忆中，导致想来想去在一个有限的范围内打转，思维总是走不太远。这方面我就有强烈的感觉，平时在走路的时候虽然也思考问题，但总是觉得思维的广度很有限。我们不妨设想数学家如果没有纸和笔的话，数学的发展会遭受到多大的阻碍，也许爱因斯坦能够在大脑中构思一个证明的最关键环节，但是你是否能够设想不用纸笔来“缓存”思维的中间步骤，而完全在大脑中证明费马大定理呢？有时候我甚至觉得能够用纸笔缓存思考的中间结果正是人类的理性之光能够走得如此之远的最重要条件。<a href="http://mindhacks.cn/2009/02/07/better-explained-conflicts-in-intimate-relationship/">上一篇文章</a>其实我原本的简记只有一半，另一半（更重要的那部分）却是在写成文章的时候自己冒出来的。</li><li><strong>书写是与自己的对话</strong>: 在书写的时候，你不断地观察自笔端流出的信息，一行文字被你写下来之后，你就不用再将其费力地保持在大脑的临时记忆中，因为这行黑底白字会不断主动地通过视觉刺激来提醒你它的存在，于是你就可以将空出来的思维精力用于反思你自己的观点。不信你可以自己观察一下，如果不用纸笔，仅用大脑，是否很难在思考一个问题的同时对自己的思考进行反思呢？</li><li><strong>书写是与别人的交流</strong>: 每个人的思维都有一些盲点，盲点之所以为盲点就是自己很难觉察得到，虽然我用了很长的时间来训练思维的客观和清晰，但总是不断发现自己的思维仍然还是时不时不自觉地陷入某个盲区，当我<a href="http://mindhacks.cn/2008/12/18/how-to-think-straight/">对人类思维的特点了解的越多</a>，我就越是从心底里谦卑地认识到与人讨论是多么重要的一件事情，每个人的盲点不一样，你的盲点可以在别人那里得到补充，别人的盲点也可以被你纠正。三个臭皮匠顶一个诸葛亮的含义便在于此。写下来，与别人交流，最重要的价值就在于此。除了盲点之外，我们对于自己的知识体系中的缺口一般是很难觉知的，如果自己的思考因为对某个重要知识的无知，犯了严重的错误，一般自己是难以反省出来的——如果你不知道一个东西，很大的可能性是你也不知道你自己不知道它。而把自己的思考写出来让别人发现漏洞，则是对自己知识体系的善莫大焉。</li><li><strong>有时候，语言自己也会思考</strong>: 在没有付诸笔端的时候，思想在脑海中的存在形式往往较为模糊、抽象，有时甚至是图像的形式，然而，如果需要写出来，甚至写出来给别人看和别人交流的话，就必须使用文字符号，文字符号其实有自己的一套系统，计算语言学上称为语义网络，同一个概念，在大脑中模糊的感觉，和明确地表达成某个特定的词语，是不一样的。你会因为用了某个特定的词语从而想到另一个词语，你写着写着就会发现一些词语就像本身有灵性一样，将其他的词语都带出来了。有时候，这种效应会导致书写变成一场文字游戏，但好的一面是有些时候也是有益于拓宽或启发思维的。</li></ul><p>在开始书写你的想法之前，我知道很多人不书写的原因是因为觉得没有什么可写的，其实这是一个怪圈，你越是不开始书写，总是拿有限的思维缓存去默想一个问题，就越是没有内容可以写，<strong>如果你逼着自己将一些不成熟的想法写下来，看着自己写的内容，试着进一步拓展它们，就有可能在理性的道路上走得很远，很远。</strong></p><p>祝大家书写快乐！</p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】手把手教你写网络爬虫（1）：网易云音乐歌单</title>
      <link href="/2018/python_pachong1/index/"/>
      <url>/2018/python_pachong1/index/</url>
      
        <content type="html"><![CDATA[<p>大家好，《手把手教你写网络爬虫》连载开始了！在笔者的职业生涯中，几乎没有发现像网络爬虫这样的编程实践，可以同时吸引程序员和门外汉的注意。本文由浅入深的把爬虫技术和盘托出，为初学者提供一种轻松的入门方式。请跟随我们一起踏上爬虫学习的打怪升级之路吧！</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h3><p>先看看百度百科的定义:</p><p><img src="/img/pachong/1368640-20180404162142662-477481119.png"></p><p>简单的说网络爬虫（Web crawler）也叫做网络铲（Web scraper）、网络蜘蛛（Web spider），其行为一般是先“爬”到对应的网页上，再把需要的信息“铲”下来。</p><h3 id="为什么学习爬虫"><a href="#为什么学习爬虫" class="headerlink" title="为什么学习爬虫"></a>为什么学习爬虫</h3><p>看到这里，有人就要问了：google、百度等搜索引擎已经帮我们抓取了互联网上的大部分信息了，为什么还要自己写爬虫呢？这是因为，需求是多样的。比如在企业中，爬取下来的数据可以作为数据挖掘的数据源。甚至有人为了炒股，专门抓取股票信息。笔者就见过有人为了分析房价，自学编程，爬了绿中介的数据。</p><p>在大数据深入人心的时代，网络爬虫作为网络、存储与机器学习等领域的交汇点，已经成为满足个性化网络数据需求的最佳实践。还犹豫什么？让我们开始学习吧</p><h2 id="语言-amp-环境"><a href="#语言-amp-环境" class="headerlink" title="语言&amp;环境"></a>语言&amp;环境</h2><p><strong>语言</strong>: 人生苦短，我用Python。让Python带我们飞！</p><p><img src="/img/pachong/1368640-20180404162237820-1903907878.png"></p><p>__urllib.request__：这是Python自带的库，不需要单独安装，它的作用是为我们打开url获取html的内容。Python官方文档的介绍：The urllib.request module defines functions and classes which help in opening URLs (mostly HTTP) in a complex world — basic and digest authentication, redirections, cookies and more.</p><p>__BeautifulSoup__：是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。安装比较简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p>验证的方法，进入Python直接import一下，如果没有异常，那就说明安装成功了！</p><p><img src="/img/pachong/1368640-20180404162414327-1058079444.png"></p><blockquote><p><strong>“美味的汤，绿色的浓汤，</strong></p></blockquote><blockquote><p><strong>在热气腾腾的盖碗里装！</strong></p></blockquote><blockquote><p><strong>谁不愿意尝一尝，这样的好汤？</strong></p></blockquote><blockquote><p><strong>晚餐用的汤，美味的汤！”</strong></p></blockquote><h2 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a>爬取数据</h2><p>接下来，我们就用urllib.request获取html内容，再用BeautifulSoup提取其中的数据，完成一次简单的爬取。</p><p><img src="/img/pachong/1368640-20180404162516169-1792924334.png"></p><p>把这段代码保存为get_html.py，然后运行，看看输出了什么：</p><p><img src="/img/pachong/1368640-20180404162535105-1267659430.png"></p><p>果然，输出了<a href="http://jr.jd.com/">http://jr.jd.com</a> 这个网页的全部HTML代码。</p><p>输出的代码简直无法直视，如何方便的找到我们想抓取数据呢？用Chrome打开url，然后按F12，再按Ctrl + Shift + C。如果我们要抓导航栏，就用鼠标点击任意一个导航栏的项目，浏览器就在html中找到了它的位置。效果如下：</p><p><img src="/img/pachong/1368640-20180404162555206-808125581.png"></p><p>定位到的html代码：</p><p><img src="/img/pachong/1368640-20180404162608114-617204405.png"></p><p>有了这些信息，就可以用BeautifulSoup提取数据了。升级一下代码：</p><p><img src="/img/pachong/1368640-20180404162615591-1734531884.png"></p><p>把这段代码保存为get_data.py，然后运行，看看输出了什么：</p><p><img src="/img/pachong/1368640-20180404162621632-77759488.png"></p><p>没错，得到了我们想要的数据！</p><p>BeautifulSoup提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。怎么样，是不是觉得只要复制粘贴就可以写爬虫了？简单的爬虫确实是可以的！</p><h2 id="一个迷你爬虫"><a href="#一个迷你爬虫" class="headerlink" title="一个迷你爬虫"></a>一个迷你爬虫</h2><p>我们先定一个小目标：爬取网易云音乐播放数大于500万的歌单。</p><p>打开歌单的url: <a href="http://music.163.com/#/discover/playlist">全部歌单 - 歌单 - 网易云音乐</a>，然后用BeautifulSoup提取播放数<span class="nb">3715</span>。结果表明，我们什么也没提取到。难道我们打开了一个假的网页？</p><p>__动态网页__：所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。</p><p>值得强调的是，不要将动态网页和页面内容是否有动感混为一谈。这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的动态效果没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，只要是采用了动态网站技术生成的网页都可以称为动态网页。</p><p>现在我们明白了，这是一个动态网页，我们得到它的时候，歌单还没请求到呢，当然什么都提取不出来！</p><p>我们之前的技术不能执行那些让页面产生各种神奇效果的JavaScript 代码。如果网站的HTML页面没有运行JavaScript，就可能和你在浏览器里看到的样子完全不同，因为浏览器可以正确地执行JavaScript。用Python 解决这个问题只有两种途径：直接从JavaScript 代码里采集内容，或者用Python 的第三方库运行JavaScript，直接采集你在浏览器里看到的页面。我们当然选择后者。今天第一课，不深究原理，先简单粗暴的实现我们的小目标。</p><p><img src="/img/pachong/1368640-20180404162658940-871877446.png"></p><p>__Selenium__：是一个强大的网络数据采集工具，其最初是为网站自动化测试而开发的。近几年，它还被广泛用于获取精确的网站快照，因为它们可以直接运行在浏览器上。Selenium 库是一个在WebDriver 上调用的API。WebDriver 有点儿像可以加载网站的浏览器，但是它也可以像BeautifulSoup对象一样用来查找页面元素，与页面上的元素进行交互（发送文本、点击等），以及执行其他动作来运行网络爬虫。安装方式与其他Python第三方库一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pip install Selenium</span><br></pre></td></tr></table></figure><p>验证下:</p><p><img src="/img/pachong/1368640-20180404162722805-1802992890.png"></p><p>Selenium 自己不带浏览器，它需要与第三方浏览器结合在一起使用。例如，如果你在Firefox 上运行Selenium，可以直接看到一个Firefox 窗口被打开，进入网站，然后执行你在代码中设置的动作。虽然这样可以看得更清楚，但不适用于我们的爬虫程序，爬一页就打开一页效率太低，所以我们用一个叫PhantomJS的工具代替真实的浏览器。</p><p>__PhantomJS__：是一个“无头”（headless）浏览器。它会把网站加载到内存并执行页面上的JavaScript，但是它不会向用户展示网页的图形界面。把Selenium和PhantomJS 结合在一起，就可以运行一个非常强大的网络爬虫了，可以处理cookie、JavaScript、header，以及任何你需要做的事情。</p><p>PhantomJS并不是Python的第三方库，不能用pip安装。它是一个完善的浏览器，所以你需要去它的官方网站下载，然后把可执行文件拷贝到Python安装目录的Scripts文件夹，像这样：</p><p><img src="/img/pachong/1368640-20180404162749600-1324637495.png"></p><p>开始干活！</p><p>打开歌单的第一页：</p><p><a href="http://music.163.com/#/discover/playlist/?order=hot&cat=%E5%85%A8%E9%83%A8&limit=35&offset=0">http://music.163.com/#/discover/playlist/?order=hot&amp;cat=%E5%85%A8%E9%83%A8&amp;limit=35&amp;offset=0</a></p><p>用Chrome的“开发者工具”F12先分析一下，很容易就看穿了一切。</p><p><img src="/img/pachong/1368640-20180404162809032-17850140.png"></p><blockquote><p>播放数nb (number broadcast)：29915</p></blockquote><blockquote><p>封面 msk (mask)：有标题和url</p></blockquote><p>同理，可以找到“下一页”的url，最后一页的url是“javascript:void(0)”。</p><p>最后，用18行代码即可完成我们的工作。</p><p><img src="/img/pachong/1368640-20180404162829239-477020844.png"></p><p>把这段代码保存为get_data.py，然后运行。运行结束后，在程序的目录里生成了一个playlist.csv文件。</p><p><img src="/img/pachong/1368640-20180404162845951-698800301.png"></p><p>看到成果后是不是很有成就感？如果你感兴趣，还可以按照这个思路，找找评论数最多的单曲，再也不用担心没歌听了！</p><p>今天的内容比较浅显，希望对你有用。就先介绍到这里，我们下期再见！</p><p><em>转</em> : <a href="http://www.cnblogs.com/tuohai666/p/8718107.html">[原创]手把手教你写网络爬虫（1）：网易云音乐歌单</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析非同质化代币ERC721-全面解析ERC721标准</title>
      <link href="/2018/token-erc721/index/"/>
      <url>/2018/token-erc721/index/</url>
      
        <content type="html"><![CDATA[<p>什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.</p><h2 id="ERC721是什么"><a href="#ERC721是什么" class="headerlink" title="ERC721是什么"></a>ERC721是什么</h2><p>在<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html">创建代币</a>一篇，我们讲到过ERC20代币，<br>和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。</p><blockquote><p>ERC721 是由Dieter Shirley 在2017年9月提出。Dieter Shirley 正是谜恋猫CryptoKitties背后的公司Axiom Zen的技术总监。因此谜恋猫也是第一个实现了ERC721 标准的去中心化应用。ERC721号提议已经被以太坊作为标准接受，但该标准仍处于草稿阶段。本文介绍的ERC721标准基于最新(2018&#x2F;03&#x2F;23官方提议。</p></blockquote><p>那怎么理解__非同质__ 代币呢?</p><p>非同质代表独一无二，谜恋猫为例，每只猫都被赋予拥有基因，是独一无二的（一只猫就是一个NFTs），猫之间是不能置换的。这种独特性使得某些稀有猫具有收藏价值，也因此受到追捧。</p><p>ERC20代币是可置换的，且可细分为N份（1 &#x3D; 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。</p><blockquote><p>如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。</p></blockquote><p>非同质性其实广泛存在于我们的生活中，如图书馆的每一本，宠物商店的每一只宠物，歌手所演唱的歌曲，花店里不同的花等等，因此ERC721合约必定有广泛的应用场景。通过这样一个标准，也可建立跨功能的NFTs管理和销售平台（就像有支持ERC20的交易所和钱包一样），使生态更加强大。</p><h2 id="ERC721标准"><a href="#ERC721标准" class="headerlink" title="ERC721标准"></a>ERC721标准</h2><p>ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20;</span><br><span class="line"></span><br><span class="line">interface ERC721 /* is ERC165 */ &#123;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line">    function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line">    function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口说明：</p><ul><li><p>balanceOf(): 返回由_owner 持有的NFTs的数量。</p></li><li><p>ownerOf(): 返回tokenId代币持有者的地址。</p></li><li><p>approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。</p></li><li><p>setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。</p></li><li><p>getApproved()、isApprovedForAll(): 用来查询授权。</p></li><li><p>safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：</p></li></ul><ol><li>调用者msg.sender应该是当前tokenId的所有者或被授权的地址</li><li>_from 必须是 _tokenId的所有者</li><li>_tokenId 应该是当前合约正在监测的NFTs 中的任何一个</li><li>_to 地址不应该为 0</li><li>如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为<code>bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))</code>抛出异常。</li></ol><pre><code>一个可接收NFT的合约必须实现ERC721TokenReceiver接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721TokenReceiver &#123;</span><br><span class="line">/// @return `bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))`</span><br><span class="line">  function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</li></ul><h2 id="ERC165标准"><a href="#ERC165标准" class="headerlink" title="ERC165标准"></a>ERC165标准</h2><p>ERC721标准同时要求必须符合ERC165标准 ，其接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ERC165 &#123;</span><br><span class="line">    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md">ERC165</a>同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。<br>interfaceID为函数选择器，计算方式有两种，如：<code>bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));</code>或<code>ERC165.supportsInterface.selector</code>，多个函数的接口ID为函数选择器的异或值。<br>关于ERC165，这里不深入介绍，有兴趣的同学可以阅读<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md">官方提案</a>。</p><h3 id="可选实现接口：ERC721Metadata"><a href="#可选实现接口：ERC721Metadata" class="headerlink" title="可选实现接口：ERC721Metadata"></a>可选实现接口：ERC721Metadata</h3><p>ERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。<br>其接口定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Metadata /* is ERC721 */ &#123;</span><br><span class="line">    function name() external pure returns (string _name);</span><br><span class="line">    function symbol() external pure returns (string _symbol);</span><br><span class="line">    function tokenURI(uint256 _tokenId) external view returns (string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口说明:</strong></p><ul><li><p>name(): 返回合约的名字，尽管是可选，但强烈建议实现，即便是返回空字符串。</p></li><li><p>symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。</p></li><li><p>tokenURI(): 返回_tokenId所对应的外部资源文件的URI(通常是IPFS或HTTP(S)路径)。外部资源文件需要包含名字、描述、图片，其格式的要求如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Asset Metadata&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Identifies the asset to which this NFT represents&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Describes the asset to which this NFT represents&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>  tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。</p><h3 id="可选实现接口：ERC721Enumerable"><a href="#可选实现接口：ERC721Enumerable" class="headerlink" title="可选实现接口：ERC721Enumerable"></a>可选实现接口：ERC721Enumerable</h3><p>ERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Enumerable /* is ERC721 */ &#123;</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line">    function tokenByIndex(uint256 _index) external view returns (uint256);</span><br><span class="line">    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口说明:</strong></p><ul><li>totalSupply(): 返回NFT总量</li><li>tokenByIndex(): 通过索引返回对应的tokenId。</li><li>tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。</li></ul><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="NTF-IDs"><a href="#NTF-IDs" class="headerlink" title="NTF IDs"></a>NTF IDs</h3><p>NTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有：</p><ol><li>从0开始，每新加一个NFT，NTF ID加1</li><li>使用sha3后uuid转换为NTF ID</li></ol><h3 id="与ERC-20的兼容性"><a href="#与ERC-20的兼容性" class="headerlink" title="与ERC-20的兼容性"></a>与ERC-20的兼容性</h3><p>ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。</p><h3 id="交易、挖矿、销毁"><a href="#交易、挖矿、销毁" class="headerlink" title="交易、挖矿、销毁"></a>交易、挖矿、销毁</h3><p>在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。<br>同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md">EIPS-165</a></li><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md">EIPS-721</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
            <tag> ERC721 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建以太坊私有链</title>
      <link href="/2018/create_private_blockchain/index/"/>
      <url>/2018/create_private_blockchain/index/</url>
      
        <content type="html"><![CDATA[<p>在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊语言有所了解，如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><h2 id="go-ethereum客户端安装"><a href="#go-ethereum客户端安装" class="headerlink" title="go-ethereum客户端安装"></a>go-ethereum客户端安装</h2><p>Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择geth工具来进行开发。由于本人是mac，所以优先使用mac进行开发啦。mac中geth安装如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap ethereum/ethereum</span><br><span class="line">brew install ethereum</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --help</span><br></pre></td></tr></table></figure><p>如果输出一些帮助提示命令，则说明安装成功。<br>其他平台可参考<a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum">Geth 安装</a></p><h2 id="搭建私有链"><a href="#搭建私有链" class="headerlink" title="搭建私有链"></a>搭建私有链</h2><p>以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如genesis.json。<br>json文件内容如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;chainId&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;homesteadBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eip155Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eip158Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alloc&quot;</span>      <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coinbase&quot;</span>   <span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;difficulty&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0x20000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extraData&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gasLimit&quot;</span>   <span class="punctuation">:</span> <span class="string">&quot;0x2fefd8&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span>      <span class="punctuation">:</span> <span class="string">&quot;0x0000000000000042&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mixhash&quot;</span>    <span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parentHash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;0x00&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="初始化-写入创世区块"><a href="#初始化-写入创世区块" class="headerlink" title="初始化:写入创世区块"></a>初始化:写入创世区块</h2><p>准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示：</p><p><img src="/img/create_private_blockchain_1.png"></p><p>接下来进入privatechain目录中，执行初始化命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd privatechain</span><br><span class="line">geth --datadir data0 init genesis.json</span><br></pre></td></tr></table></figure><p>上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。</p><p>运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有_Successfully wrote genesis state_ 字样，说明初始化成功。</p><p>初始化成功后的目录如下：</p><p><img src="/img/create_private_blockchain_2.png"></p><p>其中geth&#x2F;chaindata中存放的是区块数据，keystore中存放的是账户数据。</p><h2 id="启动私有链节点"><a href="#启动私有链节点" class="headerlink" title="启动私有链节点"></a>启动私有链节点</h2><p>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir data0 --networkid 1108 console</span><br></pre></td></tr></table></figure><p>上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，我直接重启mac，再进入到privateChain目录中，简单粗暴)。</p><p>运行上面的命令后，就启动了区块链节点并进入了Javascript Console：</p><p><img src="/img/create_private_blockchain_3.png"></p><p>这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：</p><p><strong>eth</strong> ：包含一些跟操作区块链相关的方法<br><strong>net</strong> ：包含以下查看p2p网络状态的方法<br><strong>admin</strong> ：包含一些与管理节点相关的方法<br><strong>miner</strong> ：包含启动&amp;停止挖矿的一些方法<br><strong>personal</strong> ：主要包含一些管理账户的方法<br><strong>txpool</strong> ：包含一些查看交易内存池的方法<br><strong>web3</strong> ：包含了以上对象，还包含一些单位换算的方法</p><h2 id="玩转Javascript-Console"><a href="#玩转Javascript-Console" class="headerlink" title="玩转Javascript Console"></a>玩转Javascript Console</h2><p>进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。</p><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>此时没有账户，接下来使用personal对象来创建一个账户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>这时候再去看账户，就有两个了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;]</span><br></pre></td></tr></table></figure><p>账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0&#x2F;keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。</p><p><img src="/img/create_private_blockchain_4.png"></p><p>json文件中信息格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;crypto&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cipher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aes-128-ctr&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ciphertext&quot;</span><span class="punctuation">:</span> <span class="string">&quot;238d6d48126b762c8f13e84622b1bbb7713f7244c2f24555c99b76396fae8355&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cipherparams&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;iv&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d0f5a3d3e6c1eeec77bf631bc938725d&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;kdf&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scrypt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;kdfparams&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;dklen&quot;</span><span class="punctuation">:</span> <span class="number">32</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;n&quot;</span><span class="punctuation">:</span> <span class="number">262144</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;p&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;r&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;salt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;70dc72c4eb63bea50f7637d9ff85bb53f6ca8ace17f4245feae9c0bc9abaad82&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bd7fc0c937c39f1cbbf1ca654c33b53d7f9c644c6dacfeefe1641d2f3decea04&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;57803d82-0cd4-4a78-9c29-9f9252fdcf60&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查看账户余额"><a href="#查看账户余额" class="headerlink" title="查看账户余额"></a>查看账户余额</h3><p>eth对象提供了查看账户余额的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">0</span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。</p><h3 id="启动＆停止挖矿"><a href="#启动＆停止挖矿" class="headerlink" title="启动＆停止挖矿"></a>启动＆停止挖矿</h3><p>通过miner.start()来启动挖矿：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(10)</span><br></pre></td></tr></table></figure><p>其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p><p>如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miner.stop()：</span><br></pre></td></tr></table></figure><p>注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。</p><p>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.setEtherbase(eth.accounts[1])</span><br><span class="line">true</span><br><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>挖到区块以后，账户0里面应该就有余额了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">2.31e+21</span><br></pre></td></tr></table></figure><p>getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币&#x3D;10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&#x27;ether&#x27;)</span><br><span class="line">2310</span><br></pre></td></tr></table></figure><h3 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h3><p>截止目前，账户一的余额还是0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>可以通过发送一笔交易，从账户0转移10个以太币到账户1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&#x27;ether&#x27;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">Error: authentication needed: password or unlock</span><br><span class="line">    at web3.js:3143:20</span><br><span class="line">    at web3.js:6347:15</span><br><span class="line">    at web3.js:5081:36</span><br><span class="line">    at &lt;anonymous&gt;:1:1</span><br></pre></td></tr></table></figure><p>这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[0])</span><br><span class="line">Unlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f</span><br><span class="line">Passphrase:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&#x27;ether&#x27;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">INFO [03-07|11:13:11] Submitted transaction                    fullhash=0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6 recipient=0x46B24d04105551498587e3C6CE2c3341d5988938</span><br><span class="line">&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;</span><br></pre></td></tr></table></figure><p>我们去查看账户1中的余额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; txpool.status</span><br><span class="line">&#123;</span><br><span class="line">  pending: 1,</span><br><span class="line">  queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一条pending的交易，pending表示已提交但还未被处理的交易。</p><p>要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();</span><br></pre></td></tr></table></figure><p>当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&#x27;ether&#x27;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="查看交易和区块"><a href="#查看交易和区块" class="headerlink" title="查看交易和区块"></a>查看交易和区块</h3><p>eth对象封装了查看交易和区块信息的方法。</p><p>查看当前区块总数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.blockNumber</span><br><span class="line">463</span><br></pre></td></tr></table></figure><p>通过区块号查看区块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBlock(66)</span><br><span class="line">&#123;</span><br><span class="line">  difficulty: 135266,</span><br><span class="line">  extraData: &quot;0xd783010802846765746886676f312e31308664617277696e&quot;,</span><br><span class="line">  gasLimit: 3350537,</span><br><span class="line">  gasUsed: 0,</span><br><span class="line">  hash: &quot;0x265dfcc0649bf6240812256b2b9b4e3ae48d51fd8e43e25329ac111556eacdc8&quot;,</span><br><span class="line">  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  miner: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  mixHash: &quot;0xaf755722f62cac9b483d3437dbc795f2d3a02e28ec03d39d8ecbb6012906263c&quot;,</span><br><span class="line">  nonce: &quot;0x3cd80f6ec5c2f3e9&quot;,</span><br><span class="line">  number: 66,</span><br><span class="line">  parentHash: &quot;0x099776a52223b892d13266bb3aec3cc04c455dc797185f0b3300d39f9fc0a8ec&quot;,</span><br><span class="line">  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</span><br><span class="line">  size: 535,</span><br><span class="line">  stateRoot: &quot;0x0c9feec5a201c8c98618331aecbfd2d4d93da1c6064abd0c41ae649fc08d8d06&quot;,</span><br><span class="line">  timestamp: 1520391527,</span><br><span class="line">  totalDifficulty: 8919666,</span><br><span class="line">  transactions: [],</span><br><span class="line">  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  uncles: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过交易hash查看交易：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getTransaction(&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  blockHash: &quot;0x1cb368a27cc23c786ff5cdf7cd4351d48f4c8e8aea2e084a5e9d7c480449c79a&quot;,</span><br><span class="line">  blockNumber: 463,</span><br><span class="line">  from: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  gas: 90000,</span><br><span class="line">  gasPrice: 18000000000,</span><br><span class="line">  hash: &quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;,</span><br><span class="line">  input: &quot;0x&quot;,</span><br><span class="line">  nonce: 0,</span><br><span class="line">  r: &quot;0x31d22686e0d408a16497becf6d47fbfdffe6692d91727e5b7ed3d73ede9e66ea&quot;,</span><br><span class="line">  s: &quot;0x7ff7c14a20991e2dfdb813c2237b08a5611c8c8cb3c2dcb03a55ed282ce4d9c3&quot;,</span><br><span class="line">  to: &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;,</span><br><span class="line">  transactionIndex: 0,</span><br><span class="line">  v: &quot;0x38&quot;,</span><br><span class="line">  value: 10000000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列8 - Solidity API</title>
      <link href="/2018/solidity-api/solidity-api/"/>
      <url>/2018/solidity-api/solidity-api/</url>
      
        <content type="html"><![CDATA[<p>智能合约语言 Solidity 教程系列8 - Solidity API<br>这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><p>Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类：</p><ol><li>有关区块和交易的属性</li><li>有关错误处理</li><li>有关数学及加密功能</li><li>地址相关</li><li>合约相关</li></ol><p>下面详细讲解下</p><h2 id="区块和交易的属性（Block-And-Transaction-Properties）"><a href="#区块和交易的属性（Block-And-Transaction-Properties）" class="headerlink" title="区块和交易的属性（Block And Transaction Properties）"></a>区块和交易的属性（Block And Transaction Properties）</h2><p>用来提供一些区块链当前的信息。</p><ul><li>block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。</li><li>block.coinbase (address): 当前块矿工的地址。</li><li>block.difficulty (uint):当前块的难度。</li><li>block.gaslimit (uint):当前块的gaslimit。</li><li>block.number (uint):当前区块的块号。</li><li>block.timestamp (uint): 当前块的Unix时间戳（从1970&#x2F;1&#x2F;1 00:00:00 UTC开始所经过的秒数）</li><li>msg.data (bytes): 完整的调用数据（calldata）。</li><li>msg.gas (uint): 当前还剩的gas。</li><li>msg.sender (address): 当前调用发起人的地址。</li><li>msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。</li><li>msg.value (uint): 这个消息所附带的以太币，单位为wei。</li><li>now (uint): 当前块的时间戳(block.timestamp的别名)</li><li>tx.gasprice (uint) : 交易的gas价格。</li><li>tx.origin (address): 交易的发送者（全调用链）</li></ul><p>注意：</p><p>msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。</p><p>不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。</p><p>对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。</p><p>为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0.</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>assert(bool condition)<br>用于判断内部错误，条件不满足时抛出异常</li><li>require(bool condition):<br>用于判断输入或外部组件错误，条件不满足时抛出异常</li><li>revert():<br>终止执行并还原改变的状态</li></ul><h2 id="数学及加密功能"><a href="#数学及加密功能" class="headerlink" title="数学及加密功能"></a>数学及加密功能</h2><ul><li><p>addmod(uint x, uint y, uint k) returns (uint):<br>计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k !&#x3D; 0。</p></li><li><p>mulmod(uint x, uint y, uint k) returns (uint):<br>计算 (x y) % k， 乘法支持任意的精度且不会在2*256处溢出， 从0.5.0版本开始断言k !&#x3D; 0。</p></li><li><p>keccak256(…) returns (bytes32):<br>使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。</p></li><li><p>sha256(…) returns (bytes32):<br>使用SHA-256计算hash值，紧密打包参数。</p></li><li><p>sha3(…) returns (bytes32):<br>keccak256的别名</p></li><li><p>ripemd160(…) returns (bytes20):<br>使用RIPEMD-160计算HASH值。紧密打包参数。</p></li><li><p>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。</p><blockquote><p>ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。<br>r &#x3D; signature[0:64]<br>s &#x3D; signature[64:128]<br>v &#x3D; signature[128:130]<br>其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。</p></blockquote></li></ul><p>用javascript表达如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">&#x27;0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hash = web3.<span class="title function_">sha3</span>(msg)</span><br><span class="line"><span class="keyword">var</span> sig = web3.<span class="property">eth</span>.<span class="title function_">sign</span>(address, h).<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> r = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">0</span>, <span class="number">64</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">64</span>, <span class="number">128</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> v = web3.<span class="title function_">toDecimal</span>(sig.<span class="title function_">slice</span>(<span class="number">128</span>, <span class="number">130</span>)) + <span class="number">27</span></span><br></pre></td></tr></table></figure><p>紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line"></span><br><span class="line">keccak256(0x616263)  // hex</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)   //ascii</span><br></pre></td></tr></table></figure><p>如果需要填充，可以使用显式类型转换：keccak256(“\x00\x12”) 与keccak256(uint16(0x12))相同。</p><p>注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) &#x3D;&#x3D; keccak256(uint8(0))和keccak256(0x12345678) &#x3D;&#x3D; keccak256(uint32(0x12345678))</p><p>在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。</p><h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><ul><li>.balance (uint256):<br>  Address的余额，以wei为单位。</li><li>.transfer(uint256 amount):<br>  发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。</li><li>.send(uint256 amount) returns (bool):<br>  发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。</li><li>.call(…) returns (bool):<br>  发起底层的call调用。失败时返回false。</li><li>.callcode(…) returns (bool):<br>  发起底层的callcode调用，失败时返回false。<br>  不鼓励使用，未来可能会移除。</li><li>.delegatecall(…) returns (bool):<br>  发起底层的delegatecall调用，失败时返回false</li></ul><p>警告：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p><h2 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h2><ul><li>this（当前合约的类型）:<br>表示当前合约，可以显式的转换为Address</li><li>selfdestruct(address recipient):<br>销毁当前合约，并把它所有资金发送到给定的地址。</li><li>suicide(address recipient):<br>selfdestruct的别名</li></ul><p>另外，当前合约里的所有函数均可支持调用，包括当前函数本身。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables">Special Variables and Functions</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列7 - 以太单位及时间单位</title>
      <link href="/2018/solidity-unit/solidity-unit/"/>
      <url>/2018/solidity-unit/solidity-unit/</url>
      
        <content type="html"><![CDATA[<p>智能合约语言 Solidity 教程系列7 - 以太单位及时间单位<br>这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="货币单位-Ether-Units"><a href="#货币单位-Ether-Units" class="headerlink" title="货币单位(Ether Units)"></a>货币单位(Ether Units)</h2><p>一个数字常量（字面量）后面跟随一个后缀wei, finney,szabo或ether，这个后缀就是货币单位。不同的单位可以转换。不含任何后缀的默认单位是wei。<br>不同的以太币单位转换关系如下：</p><ul><li>1 ether &#x3D;&#x3D; 10^3 finney &#x3D;&#x3D; 1000 finney</li><li>1 ether &#x3D;&#x3D; 10^6 szabo</li><li>1 ether &#x3D;&#x3D; 10^18 wei</li></ul><blockquote><p>插曲：以太币单位其实是密码学家的名字，是以太坊创始人为了纪念他们在数字货币的领域的贡献。他们分别是：<br>wei: Wei Dai 戴伟 密码学家 ，发表 B-money<br>finney: Hal Finney 芬尼 密码学家、工作量证明机制（POW）提出<br>szabo: Nick Szabo 尼克萨博 密码学家、智能合约的提出者</p></blockquote><p>我们可以使用一下代码验证一个转换关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract testUnit &#123;</span><br><span class="line">    function tf() public pure returns (bool) &#123;</span><br><span class="line">      if (1 ether == 1000 finney)&#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ts() public pure returns (bool) &#123;</span><br><span class="line">      if (1 ether == 1000000 szabo)&#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tgw() public pure returns (bool) &#123;</span><br><span class="line">      if (1 ether == 1000000000000000000 wei)&#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间单位-Time-Units"><a href="#时间单位-Time-Units" class="headerlink" title="时间单位(Time Units)"></a>时间单位(Time Units)</h2><p>时间单位: seconds, minutes, hours, days, weeks, years均可做为后缀，并进行相互转换，规则如下：</p><ul><li>1 &#x3D;&#x3D; 1 seconds (默认是seconds为单位)</li><li>1 minutes &#x3D;&#x3D; 60 seconds</li><li>1 hours &#x3D;&#x3D; 60 minutes</li><li>1 days &#x3D;&#x3D; 24 hours</li><li>1 weeks &#x3D; 7 days</li><li>1 years &#x3D; 365 days</li></ul><p>使用这些单位进行日期计算需要特别小心，因为不是每年都是365天，且并不是每天都有24小时，因为还有闰秒。由于无法预测闰秒，必须由外部的预言（oracle）来更新从而得到一个精确的日历库。</p><p>这些后缀不能用于变量。如果想对输入的变量说明其不同的单位，可以使用下面的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract testTUnit &#123;</span><br><span class="line"></span><br><span class="line">    function currTimeInSeconds() public pure returns (uint256)&#123;</span><br><span class="line">        return now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint start, uint daysAfter) public &#123;</span><br><span class="line">        if (now &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables">units</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过以太坊智能合约来进行众筹（ICO）</title>
      <link href="/2018/ico-crowdsale/index/"/>
      <url>/2018/ico-crowdsale/index/</url>
      
        <content type="html"><![CDATA[<p>前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><h2 id="众筹"><a href="#众筹" class="headerlink" title="众筹"></a>众筹</h2><p>先简单说下众筹的概念：一般是这样的，我一个非常好的想法，但是我没有钱来做这事，于是我把这个想法发给大家看，说：我做这件事需要5百万，大家有没有兴趣投些钱，如果大家在30天内投够了5百万我就开始做，到时大家都是原始股东，如果募资额不到5百万，大家投的钱就还给大家。</p><p>现在ICO众筹已经被各路大佬拿来割韭菜而被玩坏了（不管有无达标，都把钱卷走）。</p><p>其实区块链技术本事非常适合解决众筹的信任问题，借助于智能合约，可以实现当募资额完成时，募资款自动打到指定账户，当募资额未完成时，可退款。这个过程不需要看众筹大佬的人品，不用依靠第三方平台信用担保。</p><h2 id="代币"><a href="#代币" class="headerlink" title="代币"></a>代币</h2><p>传统的众筹在参与之后通常不容易交易（参与之后无法转给其他人），而通过用代币来参与众筹，则很容易进行交易，众筹的参与人可随时进行买卖，待众筹项目实施完成的时候，完全根据代币持有量进行回馈。</p><p>举个例子说明下，大家会更容易理解，有这一个众筹：A有技术做一个能监测健康的指环，为此向公众募资200百万，募资时100块对应一个代币，约定在指环上市之后，代币的持有人可以用一个代币来兑换一个指环。而指环的研发周期是一年，因此在指环还未上市的一年里，众筹的参与人可以随时交易所持有的代币。</p><h2 id="众筹智能合约代码"><a href="#众筹智能合约代码" class="headerlink" title="众筹智能合约代码"></a>众筹智能合约代码</h2><p>接下来就看看如何实现一个众筹智能合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">interface token &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transfer</span>(<span class="params">address receiver, uint amount</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Crowdsale</span> &#123;</span><br><span class="line">    address public beneficiary;  <span class="comment">// 募资成功后的收款方</span></span><br><span class="line">    uint public fundingGoal;   <span class="comment">// 募资额度</span></span><br><span class="line">    uint public amountRaised;   <span class="comment">// 参与数量</span></span><br><span class="line">    uint public deadline;      <span class="comment">// 募资截止期</span></span><br><span class="line"></span><br><span class="line">    uint public price;    <span class="comment">//  token 与以太坊的汇率 , token卖多少钱</span></span><br><span class="line">    token public tokenReward;   <span class="comment">// 要卖的token</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    bool fundingGoalReached = <span class="literal">false</span>;  <span class="comment">// 众筹是否达到目标</span></span><br><span class="line">    bool crowdsaleClosed = <span class="literal">false</span>;   <span class="comment">//  众筹是否结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件可以用来跟踪信息</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    event <span class="title class_">GoalReached</span>(address recipient, uint totalAmountRaised);</span><br><span class="line">    event <span class="title class_">FundTransfer</span>(address backer, uint amount, bool isContribution);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数, 设置相关属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Crowdsale</span>(<span class="params"></span></span><br><span class="line"><span class="params">        address ifSuccessfulSendTo,</span></span><br><span class="line"><span class="params">        uint fundingGoalInEthers,</span></span><br><span class="line"><span class="params">        uint durationInMinutes,</span></span><br><span class="line"><span class="params">        uint finneyCostOfEachToken,</span></span><br><span class="line"><span class="params">        address addressOfTokenUsedAsReward</span>) &#123;</span><br><span class="line">            beneficiary = ifSuccessfulSendTo;</span><br><span class="line">            fundingGoal = fundingGoalInEthers * <span class="number">1</span> ether;</span><br><span class="line">            deadline = now + durationInMinutes * <span class="number">1</span> minutes;</span><br><span class="line">            price = finneyCostOfEachToken * <span class="number">1</span> finney;</span><br><span class="line">            tokenReward = <span class="title function_">token</span>(addressOfTokenUsedAsReward);   <span class="comment">// 传入已发布的 token 合约的地址来创建实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无函数名的Fallback函数，</span></span><br><span class="line"><span class="comment">     * 在向合约转账时，这个函数会被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) payable &#123;</span><br><span class="line">        <span class="built_in">require</span>(!crowdsaleClosed);</span><br><span class="line">        uint amount = msg.<span class="property">value</span>;</span><br><span class="line">        balanceOf[msg.<span class="property">sender</span>] += amount;</span><br><span class="line">        amountRaised += amount;</span><br><span class="line">        tokenReward.<span class="title function_">transfer</span>(msg.<span class="property">sender</span>, amount / price);</span><br><span class="line">        <span class="title class_">FundTransfer</span>(msg.<span class="property">sender</span>, amount, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  定义函数修改器modifier（作用和Python的装饰器很相似）</span></span><br><span class="line"><span class="comment">    * 用于在函数执行前检查某种前置条件（判断通过之后才会继续执行该方法）</span></span><br><span class="line"><span class="comment">    * _ 表示继续执行之后的代码</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    modifier <span class="title function_">afterDeadline</span>(<span class="params"></span>) &#123; <span class="keyword">if</span> (now &gt;= deadline) _; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断众筹是否完成融资目标， 这个方法使用了afterDeadline函数修改器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">checkGoalReached</span>(<span class="params"></span>) afterDeadline &#123;</span><br><span class="line">        <span class="keyword">if</span> (amountRaised &gt;= fundingGoal) &#123;</span><br><span class="line">            fundingGoalReached = <span class="literal">true</span>;</span><br><span class="line">            <span class="title class_">GoalReached</span>(beneficiary, amountRaised);</span><br><span class="line">        &#125;</span><br><span class="line">        crowdsaleClosed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成融资目标时，融资款发送到收款方</span></span><br><span class="line"><span class="comment">     * 未完成融资目标时，执行退款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">safeWithdrawal</span>(<span class="params"></span>) afterDeadline &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fundingGoalReached) &#123;</span><br><span class="line">            uint amount = balanceOf[msg.<span class="property">sender</span>];</span><br><span class="line">            balanceOf[msg.<span class="property">sender</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.<span class="property">sender</span>.<span class="title function_">send</span>(amount)) &#123;</span><br><span class="line">                    <span class="title class_">FundTransfer</span>(msg.<span class="property">sender</span>, amount, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    balanceOf[msg.<span class="property">sender</span>] = amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fundingGoalReached &amp;&amp; beneficiary == msg.<span class="property">sender</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beneficiary.<span class="title function_">send</span>(amountRaised)) &#123;</span><br><span class="line">                <span class="title class_">FundTransfer</span>(beneficiary, amountRaised, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//If we fail to send the funds to beneficiary, unlock funders balance</span></span><br><span class="line">                fundingGoalReached = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署及说明"><a href="#部署及说明" class="headerlink" title="部署及说明"></a>部署及说明</h2><p>在部署这个合约之前，我们需要先部署一个代币合约，请参考一步步教你创建自己的数字货币。</p><ol><li>创建众筹合约我们需要提供一下几个参数：<br>ifSuccessfulSendTo： 募资成功后的收款方（其实这里可以默认为合约创建者）<br>fundingGoalInEthers： 募资额度， 为了方便我们仅募3个ether<br>durationInMinutes： 募资时间<br>finneyCostOfEachToken 每个代币的价格, 这里为了方便使用了单位finney及值为：1 （1 ether &#x3D; 1000 finney）<br>addressOfTokenUsedAsReward： 代币合约地址。<br>如：</li></ol><p>  <img src="/img/crowdsale_create.jpeg"></p><pre><code> 本文使用的参数为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;0xc6f9ea59d424733e8e1902c7837ea75e20abfb49&quot;,3, 100, 1,&quot;0xad8972e2b583f580fc52f737b98327eb65d08f8c&quot;</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li>参与人投资的时候实际购买众筹合约代币，所有需要先向合约预存代币，代币的数量为：募资额度 &#x2F; 代币的价格 ， 这里为：3 * 1000&#x2F;1 &#x3D; 3000 （当能也可以大于3000）。<br>向合约预存代币可以使用<a href="https://www.myetherwallet.com/#send-transaction">myetherwallet</a>钱包，或在remix中重新加载代币合约，执行代币合约tranfer()函数进行代币转账。如使用myetherwallet转账如图：</li></ol><p>  <img src="/img/crowdsale_send_token.jpeg"></p><ol start="3"><li><p>参参与人投资行为即是向买众筹合约转账，转账时，会执行Fallback回退函数（即无名函数）向其账户打回相应的代币。</p></li><li><p>safeWithdrawl() 可以被参与人或收益人执行，如果融资不达标参与人可收回之前投资款，如果融资达标收益人可以拿到所有的融资款。</p></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://ethereum.org/crowdsale">Create a crowdsale</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列6 - 结构体与映射</title>
      <link href="/2018/solidity-structs/solidity-structs/"/>
      <url>/2018/solidity-structs/solidity-structs/</url>
      
        <content type="html"><![CDATA[<p>Solidity 教程系列第6篇 - Solidity 结构体与映射。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="结构体-Structs"><a href="#结构体-Structs" class="headerlink" title="结构体(Structs)"></a>结构体(Structs)</h2><p>Solidity提供__struct__ 来定义自定义类型，自定义的类型是引用类型。<br>我们看看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    // 定义一个包含两个成员的新类型</span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (uint =&gt; Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (uint =&gt; Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) &#123;</span><br><span class="line">        campaignID = numCampaigns++; // campaignID 作为一个变量返回</span><br><span class="line">        // 创建一个结构体实例，存储在storage ，放入mapping里</span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute(uint campaignID) public payable &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        // 用mapping对应项创建一个结构体引用</span><br><span class="line">        // 也可以用 Funder(msg.sender, msg.value) 来初始化.</span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkGoalReached(uint campaignID) public returns (bool reached) &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        if (c.amount &lt; c.fundingGoal)</span><br><span class="line">            return false;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = 0;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个简化版的众筹合约，但它可以让我们理解__structs__ 的基础概念，<strong>struct</strong> 可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。</p><p>不能声明一个__struct__ 同时将自身__struct__ 作为成员，这个限制是基于结构体的大小必须是有限的。<br>但__struct__ 可以作为__mapping__ 的值类型成员。</p><p>注意在函数中，将一个__struct__ 赋值给一个局部变量（默认是__storage__ 类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。</p><p>当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如__campaigns[campaignID].amount &#x3D; 0__</p><h2 id="映射-Mappings"><a href="#映射-Mappings" class="headerlink" title="映射(Mappings)"></a>映射(Mappings)</h2><p>映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType &#x3D;&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。</p><p><strong>映射</strong> 可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。<br>正因为此，<strong>映射</strong> 是没有长度的，也没有键集合或值集合的概念。</p><p><strong>映射类型</strong> ，仅能用来作为状态变量，或在内部函数中作为__storage__ 类型的引用。</p><p>可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。<br>映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。<br>来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint newBalance) public &#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    function f() public returns (uint) &#123;</span><br><span class="line">        MappingExample m = new MappingExample();</span><br><span class="line">        m.update(100);</span><br><span class="line">        return m.balances(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考<a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">iterable mapping</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#mappings">Solidity官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列5 - 数组介绍</title>
      <link href="/2018/solidity-arrays/solidity-arrays/"/>
      <url>/2018/solidity-arrays/solidity-arrays/</url>
      
        <content type="html"><![CDATA[<p>Solidity 教程系列第5篇 - Solidity 数组介绍。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><p>数组可以声明时指定长度，也可以是动态变长。对storage存储的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，结构体等。但对于memory的数组来说。如果作为public函数的参数，它不能是映射类型的数组，只能是支持<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#types">ABI的类型</a>。</p><p>一个元素类型为__T__ ，固定长度为__k__ 的数组，可以声明为__T[k]__ ，而一个动态大小（变长）的数组则声明为__T[]__ 。<br>还可以声明一个多维数组，如声明一个类型为uint的数组长度为5的变长数组（5个元素都是变长数组），可以声明为uint[][5]。（注意，相比非区块链语言，多维数组的长度声明是反的。）</p><p>要访问第三个动态数组的第二个元素，使用x[2][1]。数组的序号是从0开始的，序号顺序与定义相反。</p><p><strong>bytes</strong> 和__string__ 是一种特殊的数组。<strong>bytes</strong> 类似__byte[]__ ，但在外部函数作为参数调用中，<strong>bytes</strong> 会进行压缩打包。<strong>string</strong> 类似__bytes__ ，但不提供长度和按序号的访问方式（目前）。<br>所以应该尽量使用__bytes__ 而不是__byte[]__ 。</p><blockquote><p>可以将字符串s通过bytes(s)转为一个bytes，可以通过bytes(s).length获取长度，bytes(s)[n]获取对应的UTF-8编码。通过下标访问获取到的不是对应字符，而是UTF-8编码，比如中文编码是多字节，变长的，所以下标访问到的只是其中的一个编码。<br>类型为数组的状态变量，可以标记为public，从而让Solidity创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。（稍后代码示例）</p></blockquote><h2 id="创建内存数组"><a href="#创建内存数组" class="headerlink" title="创建内存数组"></a>创建内存数组</h2><p>可使用new关键字创建一个memory的数组。与stroage数组不同的是，你不能通过.length的长度来修改数组大小属性。我们来看看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint len) public pure &#123;</span><br><span class="line">        uint[] memory a = new uint[](7);</span><br><span class="line"></span><br><span class="line">        //a.length = 100;  // 错误</span><br><span class="line">        bytes memory b = new bytes(len);</span><br><span class="line">        // Here we have a.length == 7 and b.length == len</span><br><span class="line">        a[6] = 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组常量以及内联数组"><a href="#数组常量以及内联数组" class="headerlink" title="数组常量以及内联数组"></a>数组常量以及内联数组</h2><p>数组常量，是一个数组表达式（还没有赋值到变量）。下面是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] _data) public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过数组常量，创建的数组是memory的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如[1, 2, 3]，只需要uint8即可存储，它的类型是__uint8[3] memory__ 。</p><p>由于g()方法的参数需要的是uint（默认的uint表示的其实是uint256），所以需要对第一个元素进行类型转换，使用uint(1)来进行这个转换。</p><p>还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//  无法编译</span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        // The next line creates a type error because uint[3] memory</span><br><span class="line">        // cannot be converted to uint[] memory.</span><br><span class="line">        uint[] x = [uint(1), 3, 4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经计划在未来移除这样的限制。当前因为ABI传递数组还有些问题。</p><h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。<br>不能通过访问超出当前数组的长度的方式，来自动实现改变数组长度。memory数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整。</p><h3 id="push方法"><a href="#push方法" class="headerlink" title="push方法"></a>push方法</h3><p>storage的变长数组和bytes都有一个push方法（string没有），用于附加新元素到数据末端，返回值为新的长度。</p><h2 id="限制情况"><a href="#限制情况" class="headerlink" title="限制情况"></a>限制情况</h2><p>当前在external函数中，不能使用多维数组。</p><p>另外，基于EVM的限制，不能通过外部函数返回动态的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">     function f() returns (uint[]) &#123; ... &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>在这个的例子中，如果通过web.js调用能返回数据，但从Solidity中调用不能返回数据。一种绕过这个问题的办法是使用一个非常大的静态数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[2**20] m_aLotOfIntegers;</span><br><span class="line">    // 这里不是两个动态数组的数组，而是一个动态数组里，每个元素是长度为二的数组。</span><br><span class="line">    bool[2][] m_pairsOfFlags;</span><br><span class="line">    // newPairs 存在 memory里，因为是函数参数</span><br><span class="line">    function setAllFlagPairs(bool[2][] newPairs) public &#123;</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFlagPair(uint index, bool flagA, bool flagB) public &#123;</span><br><span class="line">        // 访问不存在的index会抛出异常</span><br><span class="line">        m_pairsOfFlags[index][0] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][1] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeFlagArraySize(uint newSize) public &#123;</span><br><span class="line">        // 如果新size更小, 移除的元素会被销毁</span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function clear() public &#123;</span><br><span class="line">        // 销毁</span><br><span class="line">        delete m_pairsOfFlags;</span><br><span class="line">        delete m_aLotOfIntegers;</span><br><span class="line">        // 同销毁一样的效果</span><br><span class="line">        m_pairsOfFlags.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    function byteArrays(bytes data) public &#123;</span><br><span class="line">        // byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br><span class="line">        // but can be treated identical to &quot;uint8[]&quot;</span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += 7;</span><br><span class="line">        m_byteData[3] = byte(8);</span><br><span class="line">        delete m_byteData[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addFlag(bool[2] flag) public returns (uint) &#123;</span><br><span class="line">        return m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createMemoryArray(uint size) public pure returns (bytes) &#123;</span><br><span class="line">        // Dynamic memory arrays are created using `new`:</span><br><span class="line">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class="line">        // Create a dynamic byte array:</span><br><span class="line">        bytes memory b = new bytes(200);</span><br><span class="line">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#arrays">Solidity官方文档-数组</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列4 - 数据存储位置分析</title>
      <link href="/2018/solidity_reftype_datalocation/index/"/>
      <url>/2018/solidity_reftype_datalocation/index/</url>
      
        <content type="html"><![CDATA[<p>Solidity教程系列第4篇 - Solidity数据位置分析。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="数据位置-Data-location"><a href="#数据位置-Data-location" class="headerlink" title="数据位置(Data location)"></a>数据位置(Data location)</h2><p>在系列第一篇，我们提到 Solidity 类型分为两类：<br>值类型(Value Type) 及 引用类型(Reference Types)，<br>前面我们已经介绍完了值类型，接下来会介绍引用类型。</p><p>引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存储在区块链中）<br>所有的复杂类型如数组(arrays)和结构体(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。</p><p>根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。</p><p>函数参数（包含返回的参数）默认是memory。<br>局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。</p><blockquote><p>局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。<br>状态变量：合约内声明的公有变量</p></blockquote><p>还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。</p><p>数据位置指定非常重要，因为他们影响着赋值行为。<br>在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。<br>而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。<br>另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。</p><blockquote><ol><li>注意：不能将memory赋值给局部变量。</li><li>对于值类型，总是会进行拷贝。</li></ol></blockquote><p>下面看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; //  x的存储位置是storage</span><br><span class="line"></span><br><span class="line">    // memoryArray的存储位置是 memory</span><br><span class="line">    function f(uint[] memoryArray) public &#123;</span><br><span class="line">        x = memoryArray;    // 从 memory 复制到 storage</span><br><span class="line">        var y = x;          // storage 引用传递局部变量y（y 是一个 storage 引用）</span><br><span class="line">        y[7];               // 返回第8个元素</span><br><span class="line">        y.length = 2;       // x同样会被修改</span><br><span class="line">        delete x;           // y同样会被修改</span><br><span class="line"></span><br><span class="line">        // 错误， 不能将memory赋值给局部变量</span><br><span class="line">        // y = memoryArray;</span><br><span class="line"></span><br><span class="line">        // 错误，不能通过引用销毁storage</span><br><span class="line">        // delete y;</span><br><span class="line"></span><br><span class="line">        g(x);               // 引用传递， g可以改变x的内容</span><br><span class="line">        h(x);               // 拷贝到memory， h无法改变x的内容</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="强制的数据位置-Forced-data-location"><a href="#强制的数据位置-Forced-data-location" class="headerlink" title="强制的数据位置(Forced data location)"></a>强制的数据位置(Forced data location)</h4><ul><li>外部函数(External function)的参数(不包括返回参数)强制为：calldata</li><li>状态变量(State variables)强制为: storage</li></ul><h4 id="默认数据位置（Default-data-location）"><a href="#默认数据位置（Default-data-location）" class="headerlink" title="默认数据位置（Default data location）"></a>默认数据位置（Default data location）</h4><ul><li>函数参数及返回参数：memory</li><li>复杂类型的局部变量：storage</li></ul><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。</p><blockquote><p>Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。</p></blockquote><p>memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。</p><blockquote><p>storage 在区块链中是用key&#x2F;value的形式存储，而memory则表现为字节数组</p></blockquote><h3 id="关于栈"><a href="#关于栈" class="headerlink" title="关于栈"></a>关于栈</h3><p>EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。<br>值类型的局部变量是存储在栈上。</p><h3 id="不同存储的消耗（gas消耗）"><a href="#不同存储的消耗（gas消耗）" class="headerlink" title="不同存储的消耗（gas消耗）"></a>不同存储的消耗（gas消耗）</h3><ul><li>storage 会永久保存合约状态变量，开销最大</li><li>memory 仅保存临时变量，函数调用之后释放，开销很小</li><li>stack 保存很小的局部变量，几乎免费使用，但有数量限制。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#data-location">Solidity官方文档-类型</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个可管理、增发、兑换、冻结等高级功能的代币</title>
      <link href="/2018/create-token2/index/"/>
      <url>/2018/create-token2/index/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇：<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html">一步步教你创建自己的数字货币（代币）进行ICO</a>中我们实现一个最基本功能的代币，本文将在上一遍文章的基础上，讲解如果添加更多的高级功能。</p><h2 id="实现代币的管理者"><a href="#实现代币的管理者" class="headerlink" title="实现代币的管理者"></a>实现代币的管理者</h2><p>虽然区块链是去中心化的，但是实现对代币（合约）的管理，也在许多应用中有需求，为了对代币进行管理，首先需要给合约添加一个管理者。</p><p>我们来看看如果实现，先创建一个_owned_ 合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract owned &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function owned() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现所有权转移</span><br><span class="line">    function transferOwnership(address newOwner) onlyOwner &#123;</span><br><span class="line">        owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约重要的是加入了一个函数修改器（Function Modifiers）onlyOwner，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract MyToken is owned &#123;</span><br><span class="line">    function MyToken(</span><br><span class="line">        uint256 initialSupply,</span><br><span class="line">        string tokenName,</span><br><span class="line">        uint8 decimalUnits,</span><br><span class="line">        string tokenSymbol,</span><br><span class="line">        address centralMinter</span><br><span class="line">        ) &#123;</span><br><span class="line">        if(centralMinter != 0 ) owner = centralMinter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代币增发"><a href="#代币增发" class="headerlink" title="代币增发"></a>代币增发</h2><p>实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。</p><p>给合约添加以下的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mintToken(address target, uint256 mintedAmount) onlyOwner &#123;</span><br><span class="line">        balanceOf[target] += mintedAmount;</span><br><span class="line">        totalSupply += mintedAmount;</span><br><span class="line">        Transfer(0, owner, mintedAmount);</span><br><span class="line">        Transfer(owner, target, mintedAmount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意onlyOwner修改器添加在函数末尾，这表示只有ower才能调用这用函数。<br>他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。</p><h2 id="资产冻结"><a href="#资产冻结" class="headerlink" title="资产冻结"></a>资产冻结</h2><p>有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。<br>给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把mapping加到和其他mapping一起，event也是如此）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; bool) public frozenAccount;</span><br><span class="line">event FrozenFunds(address target, bool frozen);</span><br><span class="line"></span><br><span class="line">function freezeAccount(address target, bool freeze) onlyOwner &#123;</span><br><span class="line">    frozenAccount[target] = freeze;</span><br><span class="line">    FrozenFunds(target, freeze);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单单以上的代码还无法冻结，需要把他加入到transfer函数中才能真正生效，因此修改transfer函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint256 _value) &#123;</span><br><span class="line">        require(!frozenAccount[msg.sender]);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。</p><h2 id="代币买卖（兑换）"><a href="#代币买卖（兑换）" class="headerlink" title="代币买卖（兑换）"></a>代币买卖（兑换）</h2><p>可以自己的货币中实现代币与其他数字货币（ether 或其他tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。</p><p>先来设置下买卖价格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint256 public sellPrice;</span><br><span class="line">uint256 public buyPrice;</span><br><span class="line"></span><br><span class="line">function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner &#123;</span><br><span class="line">    sellPrice = newSellPrice;</span><br><span class="line">    buyPrice = newBuyPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setPrices()添加了onlyOwner修改器，注意买卖的价格单位是wei（最小的货币单位： 1 eth &#x3D; 1000000000000000000 wei)</p><p>现在来添加买卖函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function buy() payable returns (uint amount)&#123;</span><br><span class="line">    amount = msg.value / buyPrice;                    // calculates the amount</span><br><span class="line">    require(balanceOf[this] &gt;= amount);               // checks if it has enough to sell</span><br><span class="line">    balanceOf[msg.sender] += amount;                  // adds the amount to buyer&#x27;s balance</span><br><span class="line">    balanceOf[this] -= amount;                        // subtracts amount from seller&#x27;s balance</span><br><span class="line">    Transfer(this, msg.sender, amount);               // execute an event reflecting the change</span><br><span class="line">    return amount;                                    // ends function and returns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sell(uint amount) returns (uint revenue)&#123;</span><br><span class="line">    require(balanceOf[msg.sender] &gt;= amount);         // checks if the sender has enough to sell</span><br><span class="line">    balanceOf[this] += amount;                        // adds the amount to owner&#x27;s balance</span><br><span class="line">    balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller&#x27;s balance</span><br><span class="line">    revenue = amount * sellPrice;</span><br><span class="line">    msg.sender.transfer(revenue);                     // sends ether to the seller: it&#x27;s important to do this last to prevent recursion attacks</span><br><span class="line">    Transfer(msg.sender, this, amount);               // executes an event reflecting on the change</span><br><span class="line">    return revenue;                                   // ends function and returns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。</p><h2 id="实现Gas的自动补充"><a href="#实现Gas的自动补充" class="headerlink" title="实现Gas的自动补充"></a>实现Gas的自动补充</h2><p>以太坊中的交易时需要gas（支付给矿工的费用，费用以ether来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充gas的功能。这个功能将使我们代币更加好用。</p><p>自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。</p><p>先来设定余额阈值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint minBalanceForAccounts;</span><br><span class="line"></span><br><span class="line">    function setMinBalance(uint minimumBalanceInFinney) onlyOwner &#123;</span><br><span class="line">         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>finney 是货币单位<br>1 finney &#x3D; 0.001eth<br>然后交易中加入对用户的余额的判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint256 _value) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if(msg.sender.balance &lt; minBalanceForAccounts)</span><br><span class="line">        sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);</span><br><span class="line">    if(_to.balance&lt;minBalanceForAccounts)   // 可选，让接受者也补充余额，以便接受者使用代币。</span><br><span class="line">        _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码部署"><a href="#代码部署" class="headerlink" title="代码部署"></a>代码部署</h2><p>项目的完整的部署方法参考<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html">上一篇</a>，不同的是创建合约时需要预存余额，如图：</p><p><img src="/img/create_adv_token.jpg"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列3 - 类型介绍</title>
      <link href="/2018/solidity_func/index/"/>
      <url>/2018/solidity_func/index/</url>
      
        <content type="html"><![CDATA[<p>Solidity 教程系列第三篇 - Solidity 函数类型介绍。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="函数类型-Function-Types"><a href="#函数类型-Function-Types" class="headerlink" title="函数类型(Function Types)"></a>函数类型(Function Types)</h2><p>函数也是一种类型，且属于值类型。<br>可以将一个函数赋值给一个函数类型的变量。还可以将一个函数作为参数进行传递。也可以在函数调用中返回一个函数。<br>函数类型有两类:内部(internal)和外部(external)函数</p><p><strong>内部(internal)</strong> 函数只能在当前合约内被调用（在当前的代码块内，包括内部库函数，和继承的函数中）。<br><strong>外部(external)</strong> 函数由地址和函数方法签名两部分组成，可作为外部函数调用的参数，或返回值。</p><p>函数类型定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><p>如果函数不需要返回，则省去returns ()<br>函数类型默认是internal， 因此internal可以省去。但以此相反，合约中函数本身默认是public的， 仅仅是当作类型名使用时默认是internal的。</p><p>有两个方式访问函数，一种是直接用函数名f, 一种是this.f， 前者用于内部函数，后者用于外部函数。</p><p>如果一个函数变量没有初始化，直接调用它将会产生异常。如果delete了一个函数后调用，也会发生同样的异常。</p><p>如果外部函数类型在Solidity的上下文环境以外的地方使用，他们会被视为function类型。它会编码为20字节的函数所在地址，和在它之前的4字节的函数方法签名一起作为bytes24类型。<br>合约中的public的函数，可以使用internal和external两种方式来调用。<br>internal访问形式为f, external访问形式为this.f</p><h3 id="成员：属性-selector"><a href="#成员：属性-selector" class="headerlink" title="成员：属性 selector"></a>成员：属性 selector</h3><p>public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Selector &#123;</span><br><span class="line">  function f() public view returns (bytes4) &#123;</span><br><span class="line">      return this.f.selector;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码显示内部（internal）函数类型的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  // internal functions can be used in internal library functions because</span><br><span class="line">  // they will be part of the same code context</span><br><span class="line">  function map(uint[] memory self, function (uint) pure returns (uint) f)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint[] memory r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = new uint[](self.length);</span><br><span class="line">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reduce(</span><br><span class="line">    uint[] memory self,</span><br><span class="line">    function (uint, uint) pure returns (uint) f</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = self[0];</span><br><span class="line">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function range(uint length) internal pure returns (uint[] memory r) &#123;</span><br><span class="line">    r = new uint[](length);</span><br><span class="line">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils for *;</span><br><span class="line">  function pyramid(uint l) public pure returns (uint) &#123;</span><br><span class="line">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  function square(uint x) internal pure returns (uint) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  function sum(uint x, uint y) internal pure returns (uint) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码显示外部（external）函数类型的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    function(bytes memory) external callback;</span><br><span class="line">  &#125;</span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  function query(bytes data, function(bytes memory) external callback) public &#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  function reply(uint requestID, bytes response) public &#123;</span><br><span class="line">    // Here goes the check that the reply comes from a trusted source</span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class="line">  function buySomething() &#123;</span><br><span class="line">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  function oracleResponse(bytes response) public &#123;</span><br><span class="line">    require(msg.sender == address(oracle));</span><br><span class="line">    // Use the data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数可见性分析"><a href="#函数可见性分析" class="headerlink" title="函数可见性分析"></a>函数可见性分析</h2><ul><li>public - 任意访问</li><li>private - 仅当前合约内</li><li>internal - 仅当前合约及所继承的合约</li><li>external - 仅外部访问（在内部也只能用外部访问方式访问）</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html">Solidity官方文档-类型</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步步教你创建自己的数字货币（代币）进行ICO</title>
      <link href="/2018/create_token/index/"/>
      <url>/2018/create_token/index/</url>
      
        <content type="html"><![CDATA[<p>本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><h2 id="代币Token"><a href="#代币Token" class="headerlink" title="代币Token"></a>代币Token</h2><p>如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。<br>利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。<br>因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。</p><p><img src="/img/token_info.jpeg"></p><p>今天我们就来详细讲一讲怎样创建一个这样的代币。</p><h3 id="ERC20-Token"><a href="#ERC20-Token" class="headerlink" title="ERC20 Token"></a>ERC20 Token</h3><p>也许你经常看到ERC20和代币一同出现， ERC20是以太坊定义的一个代币标准。<br>要求我们在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>其接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = &quot;Token Name&quot;;</span><br><span class="line">    string public constant symbol = &quot;SYM&quot;;</span><br><span class="line">    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places</span><br><span class="line"></span><br><span class="line">    function totalSupply() public constant returns (uint);</span><br><span class="line">    function balanceOf(address tokenOwner) public constant returns (uint balance);</span><br><span class="line">    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);</span><br><span class="line">    function transfer(address to, uint tokens) public returns (bool success);</span><br><span class="line">    function approve(address spender, uint tokens) public returns (bool success);</span><br><span class="line">    function transferFrom(address from, address to, uint tokens) public returns (bool success);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint tokens);</span><br><span class="line">    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说明一下：<br>name ： 代币名称<br>symbol： 代币符号<br>decimals： 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。<br>totalSupply() : 发行代币总量。<br>balanceOf(): 查看对应账号的代币余额。<br>transfer(): 实现代币交易，用于给用户发送代币（从我们的账户里）。<br>transferFrom(): 实现代币用户之间的交易。<br>allowance(): 控制代币的交易，如可交易账号及资产。<br>approve(): 允许用户可花费的代币数。</p><h2 id="编写代币合约代码"><a href="#编写代币合约代码" class="headerlink" title="编写代币合约代码"></a>编写代币合约代码</h2><p>代币合约代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">interface tokenRecipient &#123; function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; &#125;</span><br><span class="line"></span><br><span class="line">contract TokenERC20 &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = 18;  // 18 是建议的默认值</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;  //</span><br><span class="line">    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    event Burn(address indexed from, uint256 value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public &#123;</span><br><span class="line">        totalSupply = initialSupply * 10 ** uint256(decimals);</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        name = tokenName;</span><br><span class="line">        symbol = tokenSymbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">        require(_to != 0x0);</span><br><span class="line">        require(balanceOf[_from] &gt;= _value);</span><br><span class="line">        require(balanceOf[_to] + _value &gt; balanceOf[_to]);</span><br><span class="line">        uint previousBalances = balanceOf[_from] + balanceOf[_to];</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        Transfer(_from, _to, _value);</span><br><span class="line">        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 _value) public &#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        require(_value &lt;= allowance[_from][msg.sender]);     // Check allowance</span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        _transfer(_from, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address _spender, uint256 _value) public</span><br><span class="line">        returns (bool success) &#123;</span><br><span class="line">        allowance[msg.sender][_spender] = _value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) &#123;</span><br><span class="line">        tokenRecipient spender = tokenRecipient(_spender);</span><br><span class="line">        if (approve(_spender, _value)) &#123;</span><br><span class="line">            spender.receiveApproval(msg.sender, _value, this, _extraData);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _value);</span><br><span class="line">        balanceOf[msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(msg.sender, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burnFrom(address _from, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        require(balanceOf[_from] &gt;= _value);</span><br><span class="line">        require(_value &lt;= allowance[_from][msg.sender]);</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(_from, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在开发测试智能合约时，<a href="https://metamask.io/">MetaMask</a>和<a href="https://remix.ethereum.org/">Remix Solidity IDE</a>是两个非常好用的工具，今天就用他们来完成部署。</p><ol><li>安装和配置MetaMask请参考<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Dapp/2018-02-25-first-dapp.html">开发、部署第一个去中心化应用</a>，不同的上本文选择了以太坊的测试网络Ropsten，如果你没有余额请点击购买buy，进入的网站可以送一些测试以太币给你，配置好之后，界面应该如下：</li></ol><p>  <img src="/img/metamask_main.png"></p><ol start="2"><li>浏览器打开Remix Solidity IDE，复制以上源码粘贴上，在右侧选项参考如图的设置：</li></ol><p>  <img src="/img/token_create_remix.jpeg"></p><p>  注意Environment和Account和MetaMask保持一致，然后选择合约TokenERC20，填入你想要的发行量，名称及代号，就可以创建合约了。<br>  这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。</p><ol start="3"><li>打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框：</li></ol><p>  <img src="/img/metamask_add_token.png"></p><p>  填入刚刚复制的地址，点击ADD，这时你就可以看到你创建的代币了，如图：</p><p>  <img src="/img/metamask_token_added.png"></p><p>哈哈，你已经完成了代币的创建和部署(正式网络和测试网络部署方法一样)，可以在<a href="https://ropsten.etherscan.io/token/0x1f0c085ad323bb69758111cf9ecdc32a32d9a5bb">Etherscan</a>查询到我们刚刚部署的代币。可以用它进行ICO了，从此走上人生巅峰（玩笑话，不鼓励大家发行无意义的代币）。</p><h2 id="代币交易"><a href="#代币交易" class="headerlink" title="代币交易"></a>代币交易</h2><p>由于MetaMask插件没有提供代币交易功能，同时考虑到很多人并没有以太坊钱包或是被以太坊钱包网络同步问题折磨，今天我用<a href="https://www.myetherwallet.com/">网页钱包</a>来讲解代币交易。</p><ol><li>进入<a href="https://www.myetherwallet.com/#send-transaction">网页钱包地址</a>，第一次进入有一些安全提示需要用户确认。</li><li>进入之后，按照下图进行设置：</li></ol><p>  <img src="/img/myetherwaller.jpeg"></p><ol start="3"><li>连接上之后，如图</li></ol><p>  <img src="/img/myetherwaller_connected.jpeg"></p><p>  需要添加代币，填入代币合约地址</p><ol start="4"><li>进行代币转账交易</li></ol><p>  <img src="/img/myetherwaller_transfer.jpeg"></p><p>  接下来的交易确认也点击确认即可。</p><ol start="5"><li>交易完成后，可以看到MetaMask中代币余额减少了，如图：</li></ol><p>  <img src="/img/metamask_token_tansfered.png"></p><p>代币交易是不是很简单，只要明白了交易流程，使用其他的钱包也是一样的道理。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard">代币标准</a></li><li><a href="https://ethereum.org/token">Create your own crypto-currency with ethereum</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>startService 和 bindService的区别</title>
      <link href="/2018/services/index/"/>
      <url>/2018/services/index/</url>
      
        <content type="html"><![CDATA[<h2 id="Service的简介"><a href="#Service的简介" class="headerlink" title="Service的简介"></a>Service的简介</h2><p>Service是Android系统中的四大组件之一，它是一种长生命周期的，没有可视化界面，运行于后台的一种服务程序。比如我们播放音乐的时候，有可能想边听音乐边干些其他事情，当退出播放音乐的应用，如果不用Service，我 们就听不到歌了，所以这时候就得用到Service了。</p><h3 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h3><p>Service的生命周期并不像Activity那么复杂，它只继承了onCreate(),onStart(),onDestroy()三个方法，当第一次启动Service时，先后调用了onCreate(),onStart()这两个方法，当停止Service时，则执行onDestroy()方法，这里需要注意的是，如果Service已经启动了，当我们再次启动Service时，不会在执行onCreate()方法，而是直接执行onStart()方法。</p><h2 id="Service的启动方式"><a href="#Service的启动方式" class="headerlink" title="Service的启动方式"></a>Service的启动方式</h2><p>Service的有两种启动方式：Context.startService()和Context.bindService()，这两种方式对Service生命周期的影响是不同的。</p><h3 id="Context-startService-方式启动"><a href="#Context-startService-方式启动" class="headerlink" title="Context.startService()方式启动"></a>Context.startService()方式启动</h3><ol><li>Context.startService()方式的生命周期：</li></ol><p>启动时，startService –&gt; onCreate() –&gt; onStart()<br>停止时，stopService –&gt; onDestroy()<br>如果调用者直接退出而没有停止Service，则Service 会一直在后台运行</p><p>Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p><h3 id="Context-bindService-方式启动："><a href="#Context-bindService-方式启动：" class="headerlink" title="Context.bindService()方式启动："></a>Context.bindService()方式启动：</h3><ol><li>Context.bindService()方式的生命周期：</li></ol><p>绑定时,bindService -&gt; onCreate() –&gt; onBind()<br>调用者退出了，即解绑定时,Srevice就会unbindService –&gt;onUnbind() –&gt; onDestory()</p><p>用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。</p><ol start="2"><li>Context.bindService()方式启动 Service的方法：</li></ol><p>绑定Service需要三个参数：bindService(intent, conn, Service.BIND_AUTO_CREATE);<br>第一个：Intent对象<br>第二个：ServiceConnection对象，创建该对象要实现它的onServiceConnected()和 onServiceDisconnected()来判断连接成功或者是断开连接<br>第三个：如何创建Service，一般指定绑定的时候自动创建</p><h2 id="startService-和-bindService的区别"><a href="#startService-和-bindService的区别" class="headerlink" title="startService 和 bindService的区别"></a>startService 和 bindService的区别</h2><p>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。</p><p>使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</p><p>如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p><p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列2 - 类型介绍</title>
      <link href="/2018/solidity2/index/"/>
      <url>/2018/solidity2/index/</url>
      
        <content type="html"><![CDATA[<p>Solidity教程系列第二篇 - Solidity地址类型介绍.<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="地址类型（Address）"><a href="#地址类型（Address）" class="headerlink" title="地址类型（Address）"></a>地址类型（Address）</h2><p>地址类型address是一个值类型，</p><p><strong>地址</strong> ： 20字节（一个以太坊地址的长度），地址类型也有成员，地址是所有合约的基础<br>支持的运算符：</p><pre><code>&lt;=, &lt;, ==, !=, &gt;= 和 &gt;&gt; 注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址。</code></pre><h3 id="地址类型的成员"><a href="#地址类型的成员" class="headerlink" title="地址类型的成员"></a>地址类型的成员</h3><ul><li><p>balance 属性及transfer() 函数<br>这里是地址类型相关成员的快速索引<br>balance用来查询账户余额，transfer()用来发送以太币（以wei为单位）。<br>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure><p><strong>注解</strong> ：如果x是合约地址，合约的回退函数（fallback 函数）会随transfer调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。</p><blockquote><p>关于回退函数（fallback 函数），简单来说它是合约中无函数名函数，下面代码事例中，进进一步讲解回退函数（fallback） 的使用。</p></blockquote></li><li><p>send() 函数<br>send 与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。</p><blockquote><p><strong>警告</strong> ：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p></blockquote></li><li><p>call(), callcode() 和 delegatecall() 函数<br>为了和非ABI协议的合约进行交互，可以使用call() 函数, 它用来向另一个合约发送原始数据，支持任何类型任意数量的参数，每个参数会按规则(ABI协议)打包成32字节并一一拼接到一起。一个例外是：如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名而直接使用。如果仅想发送消息体，需要避免第一个参数是4个字节。如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class="line">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class="line">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure><p>call函数返回一个bool值，以表明执行成功与否。正常结束返回true，异常终止返回false。但无法获取到结果数据，因为需要提前知道返回的数据的编码和数据大小（因不知道对方使用的协议格式，所以也不会知道返回的结果如何解析）。<br>还可以提供.gas()修饰器进行调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p>类似还可以提供附带以太币：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p>修饰器可以混合使用，修饰器调用顺序无所谓。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>注解：目前还不能在重载函数上使用gas或value修饰符，A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.（这句我怕翻译的不准确，引用原文）</p></blockquote><p>同样我们也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的库代码。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。在homestead阶段之前，仅有一个受限的callcode()方法可用，但callcode未提供对msg.sender，msg.value的访问权限。</p><p>上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。<br>.gas() 在call(), callcode() 和 delegatecall() 函数下都可以使用， delegatecall()不支持.value()</p><blockquote><p>注解：所有合约都继承了address的成员，因此可以使用this.balance查询余额。<br>callcode不鼓励使用，以后会移除。</p></blockquote><blockquote><p>警告：上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。</p></blockquote></li></ul><h2 id="地址常量（Address-Literals）"><a href="#地址常量（Address-Literals）" class="headerlink" title="地址常量（Address Literals）"></a>地址常量（Address Literals）</h2><p>一个能通过地址合法性检查（address checksum test）十六进制常量就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。而不能通过地址合法性检查的39到41位长的十六进制常量，会提示一个警告，被视为普通的有理数常量。</p><blockquote><p>地址合法性检查定义在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a></p></blockquote><h2 id="合约事例讲解"><a href="#合约事例讲解" class="headerlink" title="合约事例讲解"></a>合约事例讲解</h2><h3 id="合约事例代码"><a href="#合约事例代码" class="headerlink" title="合约事例代码"></a>合约事例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract AddrTest&#123;</span><br><span class="line">    event logdata(bytes data);</span><br><span class="line">    function() payable &#123;</span><br><span class="line">        logdata(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() returns (uint) &#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint score = 0;</span><br><span class="line">    function setScore(uint s) public &#123;</span><br><span class="line">        score = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getScore() returns ( uint)&#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest&#123;</span><br><span class="line">    function deposit() payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event logSendEvent(address to, uint value);</span><br><span class="line">    function transferEther(address towho) payable &#123;</span><br><span class="line">        towho.transfer(10);</span><br><span class="line">        logSendEvent(towho, 10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function callNoFunc(address addr) returns (bool)&#123;</span><br><span class="line">        return addr.call(&quot;tinyxiong&quot;, 1234);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function callfunc(address addr) returns (bool)&#123;</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(&quot;setScore(uint256)&quot;));</span><br><span class="line">        return addr.call(methodId, 100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() returns (uint) &#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码运行及讲解"><a href="#代码运行及讲解" class="headerlink" title="代码运行及讲解"></a>代码运行及讲解</h3><p>代码运行及讲解，请订阅<a href="https://xiaozhuanlan.com/blockchaincore">区块链技术</a>查看</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html">Solidity官方文档-类型</a></p><p>s</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币如何达成共识 - 最长链的选择</title>
      <link href="/2018/bitcoin-sonsensus/index/"/>
      <url>/2018/bitcoin-sonsensus/index/</url>
      
        <content type="html"><![CDATA[<p>比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？</p><h2 id="为什么要遵守协议"><a href="#为什么要遵守协议" class="headerlink" title="为什么要遵守协议"></a>为什么要遵守协议</h2><p>这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，<br>而只有遵守规则才会得到其他的节点认同。<br>因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。</p><blockquote><p>共识：共同遵守的协议规范</p></blockquote><h2 id="去中心化共识"><a href="#去中心化共识" class="headerlink" title="去中心化共识"></a>去中心化共识</h2><p>在<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-24-init-env.html">工作量证明</a>一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，<br>实际上，比特币的共识由所有节点的4个__独立过程__ 相互作用而产生：</p><ol><li>每个节点（挖矿节点）依据标准对每个交易进行独立验证</li><li>挖矿节点通过完成工作量证明，将交易记录独立打包进新区块</li><li>每个节点独立的对新区块进行校验并组装进区块链</li><li>每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链</li></ol><p>共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。</p><p>第1 2 3步在<a href="">比特币如何挖矿-工作量证明</a>一篇有提到过，下面着重讲第4步。</p><h2 id="最长链的选择"><a href="#最长链的选择" class="headerlink" title="最长链的选择"></a>最长链的选择</h2><p>先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为主链<br>每一个（挖矿）节点总是选择并尝试延长主链。</p><h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><p>当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的“获胜”区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。<br>当这个两个区块传播时，一些节点首先收到#3458A, 一些节点首先收到#3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：</p><p><img src="/img/block_branch.jpg"></p><p>两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为__备用链__ 保存（保存是因为备用链将来可能会超过主链难度称为新主链）。</p><h3 id="分叉解决"><a href="#分叉解决" class="headerlink" title="分叉解决"></a>分叉解决</h3><p>收到#3458A的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受#3458B区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为B链）。<br>这时总会有一方抢先发现工作量证明解并将其传播出去，假设以#3458B为父区块的工作量证明首先解出，如图：</p><p><img src="/img/block_branch2.jpg"></p><p>当原本以#3458A为父区块求解的节点在收到#3458B, #3459B之后，会立刻将B链作为主链（因为#3458A为顶点的链已经不是最长链了）继续挖矿。</p><blockquote><p>节点也有可能先收到#3459B，再收到#3458B，收到#3459B时，会被认为是“孤块“（因为还找不到#3459B的父块#3458B）保存在孤块池中，一旦收到父块#3458B时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</p></blockquote><p>比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 共识协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约语言 Solidity 教程系列1 - 类型介绍</title>
      <link href="/2018/solidity1/index/"/>
      <url>/2018/solidity1/index/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊是什么</a><br>Solidity教程会是一系列文章，本文是第一篇：介绍Solidity的变量类型。<br>Solidity 系列完整的文章列表请查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">分类-Solidity</a>。</p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Solidity是一种静态类型语言，意味着每个变量（本地或状态变量）需要在编译时指定变量的类型（或至少可以推倒出类型）。Solidity提供了一些基本类型可以用来组合成复杂类型。</p><p>Solidity类型分为两类：</p><ul><li>值类型(Value Type) - 变量在赋值或传参时，总是进行值拷贝。</li><li>引用类型(Reference Types)</li></ul><h3 id="值类型-Value-Type"><a href="#值类型-Value-Type" class="headerlink" title="值类型(Value Type)"></a>值类型(Value Type)</h3><p>值类型包含:</p><ul><li>布尔类型(Booleans)</li><li>整型(Integers)</li><li>定长浮点型(Fixed Point Numbers)</li><li>定长字节数组(Fixed-size byte arrays)</li><li>有理数和整型常量(Rational and Integer Literals)</li><li>字符串常量（String literals）</li><li>十六进制常量（Hexadecimal literals）</li><li>枚举(Enums)</li><li><a href="">函数类型(Function Types)</a></li><li><a href="">地址类型(Address)</a></li><li>地址常量(Address Literals)<blockquote><p><a href="">函数类型</a>及<a href="">地址类型(Address)</a>有单独的博文，请点击查看。</p></blockquote></li></ul><h2 id="布尔类型-Boolean"><a href="#布尔类型-Boolean" class="headerlink" title="布尔类型(Boolean)"></a>布尔类型(Boolean)</h2><p>布尔(bool):可能的取值为常量值true和false。</p><p>布尔类型支持的运算符有：</p><ul><li>！逻辑非</li><li>&amp;&amp; 逻辑与</li><li>|| 逻辑或</li><li>&#x3D;&#x3D; 等于</li><li>!&#x3D; 不等于</li></ul><p>注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。</p><h2 id="整型-Integers"><a href="#整型-Integers" class="headerlink" title="整型(Integers)"></a>整型(Integers)</h2><p>int&#x2F;uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)，<br>uint 和 int 默认对应的是 uint256 和 int256。</p><p>支持的运算符：</p><ul><li>比较运算符： &lt;&#x3D;, &lt; , &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回布尔值：true 或 false)</li><li>位操作符： &amp;，|，^(异或)，~（位取反）</li><li>算术操作符：+，-，一元运算-，一元运算+，，&#x2F;, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li></ul><p>说明：</p><ol><li>整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。</li><li>整数除0会抛异常。</li><li>移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x  2**y 是相等， x &gt;&gt; y 和 x &#x2F; 2**y 是相等的。</li><li>不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。</li></ol><p>注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。</p><h2 id="定长浮点型（Fixed-Point-Numbers）"><a href="#定长浮点型（Fixed-Point-Numbers）" class="headerlink" title="定长浮点型（Fixed Point Numbers）"></a>定长浮点型（Fixed Point Numbers）</h2><p>fixed&#x2F;ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。<br>M表示这个类型要占用的位数，以8步进，可为8到256位。<br>N表示小数点的个数，可为0到80之前</p><p>支持的运算符：</p><ul><li>比较运算符： &lt;&#x3D;, &lt; , &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回布尔值：true 或 false)</li><li>算术操作符：+，-，一元运算-，一元运算+，，&#x2F;, %(取余数)<br>注意：它和大多数语言的float和double不一样，*M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。</li></ul><h2 id="定长字节数组-Fixed-size-byte-arrays"><a href="#定长字节数组-Fixed-size-byte-arrays" class="headerlink" title="定长字节数组(Fixed-size byte arrays)"></a>定长字节数组(Fixed-size byte arrays)</h2><p>关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增）<br>byte代表bytes1。</p><p>支持的运算符：</p><ul><li>比较符: &lt;&#x3D;, &lt;, &#x3D;&#x3D;, !&#x3D;, &gt;&#x3D;, &gt; (返回bool）</li><li>位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li><li>索引（下标）访问: 如果x是bytesI，当0 &lt;&#x3D; k &lt; I ，则x[k]返回第k个字节（只读）。</li></ul><p>移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。<br>如可以-5&lt;&lt;1, 不可以5&lt;&lt;-1</p><p>成员变量：<br>.length：表示这个字节数组的长度（只读）。</p><h2 id="变长（动态分配大小）字节数组（Dynamically-sized-byte-array）"><a href="#变长（动态分配大小）字节数组（Dynamically-sized-byte-array）" class="headerlink" title="变长（动态分配大小）字节数组（Dynamically-sized byte array）"></a>变长（动态分配大小）字节数组（Dynamically-sized byte array）</h2><ul><li>bytes:动态分配大小字节数组, 参见Arrays,不是值类型!</li><li>string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型!</li></ul><p>根据经验：<br>bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。<br>如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。</p><h2 id="有理数和整型常量-Rational-and-Integer-Literals"><a href="#有理数和整型常量-Rational-and-Integer-Literals" class="headerlink" title="有理数和整型常量(Rational and Integer Literals)"></a>有理数和整型常量(Rational and Integer Literals)</h2><blockquote><p>也有人把Literals翻译为字面量</p></blockquote><p>整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。</p><p>10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3.</p><p>科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。</p><p>数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。<br>如：(2<em>800 + 1) - 2</em>800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。</p><p>只要操作数是整形，整型支持的运算符都适用于整型常量表达式。<br>如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。</p><p>注意：<br>Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3</p><p>警告：<br>整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5&#x2F;2的值为 2.5</p><p>注意：<br>数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure><p>上述代码编译不能通过，因为b会被编译器认为是小数型。</p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。</p><p>字符串常量支持转义字符，比如\n，\xNN，\uNNNN。其中\xNN表示16进制值，最终转换合适的字节。而\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。</p><h2 id="十六进制常量（Hexadecimal-literals）"><a href="#十六进制常量（Hexadecimal-literals）" class="headerlink" title="十六进制常量（Hexadecimal literals）"></a>十六进制常量（Hexadecimal literals）</h2><p>十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。<br>它的值会用二进制来表示。</p><p>十六进制常量和字符串常量类似，也可以转换为字节数组。</p><h2 id="枚举（Enums）"><a href="#枚举（Enums）" class="headerlink" title="枚举（Enums）"></a>枚举（Enums）</h2><p>在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class="line">    // for all matters external to Solidity. The integer type used is just</span><br><span class="line">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class="line">    // `uint16` will be used and so on.</span><br><span class="line">    function getChoice() returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>通过合约代码实例说明类型的使用，请订阅<a href="https://xiaozhuanlan.com/blockchaincore">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html">Solidity官方文档-类型</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步步教你开发、部署第一个去中心化应用(Dapp) - 宠物商店</title>
      <link href="/2018/first-dapp/first-dapp/"/>
      <url>/2018/first-dapp/first-dapp/</url>
      
        <content type="html"><![CDATA[<p>今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和编写智能合约结合起来看。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么<br>除此之外，你最好还了解一些HTML及JavaScript知识。</p><p>本文通过实例教大家来开发去中心化应用，应用效果如图：</p><p><img src="/img/Petshop.jpg"></p><p>从本文，你可以学习到：</p><ul><li>搭建智能合约开发环境</li><li>创建Truffle项目</li><li>编写智能合约</li><li>编译和部署智能合约到区块链</li><li>如何通过Web3和智能合约交互</li><li>MetaMask的使用</li></ul><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>Pete有一个宠物店，有16只宠物，他想开发一个去中心化应用，让大家来领养宠物。<br>在truffle box中，已经提供了pet-shop的网站部分代码，我们只需要编写合约及交互部分。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>安装<a href="https://nodejs.org/en/download/">Node</a></li><li>安装Truffle: <code>npm install -g truffle</code></li><li>安装<a href="http://truffleframework.com/ganache/">Ganache</a></li></ol><blockquote><p>Ganache(或Ganache CLI) 已经取代了testrpc</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol><li>创建项目目录并进入</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir pet-shop-tutorial</span><br><span class="line">&gt; cd pet-shop-tutorial</span><br></pre></td></tr></table></figure><ol start="2"><li>使用truffle unbox 创建项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &gt; truffle unbox pet-shop</span><br><span class="line"> Downloading...</span><br><span class="line"> Unpacking...</span><br><span class="line"> Setting up...</span><br><span class="line"> Unbox successful. Sweet!</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  Compile:        truffle compile</span><br><span class="line">  Migrate:        truffle migrate</span><br><span class="line">  Test contracts: truffle test</span><br><span class="line">  Run dev server: npm run dev</span><br></pre></td></tr></table></figure><p>这一步需要等待一会</p><blockquote><p>也可以使用truffle init 来创建一个全新的项目。</p></blockquote><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><em>contracts&#x2F;</em> 智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol（稍后再讲）<br><em>migrations&#x2F;</em> 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。<br><em>test&#x2F;</em> 智能合约测试用例文件夹<br><em>truffle.js&#x2F;</em> 配置文件</p><p>其他代码可以暂时不用管</p><h2 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h2><p>智能合约承担着分布式应用的后台逻辑和存储。智能合约使用solidity编写，可阅读<br><a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/">solidity系列文章</a></p><p>在contracts目录下，添加合约文件Adoption.sol</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract Adoption &#123;</span><br><span class="line"></span><br><span class="line">  address[16] public adopters;  // 保存领养者的地址</span><br><span class="line"></span><br><span class="line">    // 领养宠物</span><br><span class="line">  function adopt(uint petId) public returns (uint) &#123;</span><br><span class="line">    require(petId &gt;= 0 &amp;&amp; petId &lt;= 15);  // 确保id在数组长度内</span><br><span class="line"></span><br><span class="line">    adopters[petId] = msg.sender;        // 保存调用这地址</span><br><span class="line">    return petId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回领养者</span><br><span class="line">  function getAdopters() public view returns (address[16]) &#123;</span><br><span class="line">    return adopters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译部署智能合约"><a href="#编译部署智能合约" class="headerlink" title="编译部署智能合约"></a>编译部署智能合约</h2><p>Truffle集成了一个开发者控制台，可用来生成一个开发链用来测试和部署智能合约。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Solidity是编译型语言，需要把可读的Solidity代码编译为EVM字节码才能运行。<br>dapp的根目录pet-shop-tutorial下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; truffle compile</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Writing artifacts to ./build/contracts</span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>编译之后，就可以部署到区块链上。<br>在migrations文件夹下已经有一个1_initial_migration.js部署脚本，用来部署Migrations.sol合约。<br>Migrations.sol 用来确保不会部署相同的合约。</p><p>现在我们来创建一个自己的部署脚本<code>2_deploy_contracts.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Adoption = artifacts.require(&quot;Adoption&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(Adoption);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在执行部署之前，需要确保有一个区块链运行, 可以使用<br><a href="http://truffleframework.com/ganache/">Ganache</a>来开启一个私链来进行开发测试，默认会在7545端口上运行一个开发链。<br>Ganache 启动之后是这样：</p><p><img src="/img/ganache-initial.png"></p><p>接下来执行部署命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; truffle  migrate</span><br></pre></td></tr></table></figure><p>执行后，有以下类似输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Using network &#x27;develop&#x27;.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Deploying Migrations...</span><br><span class="line">  ... 0x3076b7dac65afc44ec51508bf6f2b6894f833f0f9560ecad2d6d41ed98a4679f</span><br><span class="line">  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Deploying Adoption...</span><br><span class="line">  ... 0x2c6ab4471c225b5473f2079ee42ca1356007e51d5bb57eb80bfeb406acc35cd4</span><br><span class="line">  Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><p>在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。</p><p><img src="/img/ganache-migrated.png"></p><p>这时说明已经智能合约已经部署好了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们来测试一下智能合约，测试用例可以用 JavaScript or Solidity来编写，这里使用Solidity。</p><p>在<code>test</code>目录下新建一个<code>TestAdoption.sol</code>，编写测试合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">import &quot;truffle/Assert.sol&quot;;   // 引入的断言</span><br><span class="line">import &quot;truffle/DeployedAddresses.sol&quot;;  // 用来获取被测试合约的地址</span><br><span class="line">import &quot;../contracts/Adoption.sol&quot;;      // 被测试合约</span><br><span class="line"></span><br><span class="line">contract TestAdoption &#123;</span><br><span class="line">  Adoption adoption = Adoption(DeployedAddresses.Adoption());</span><br><span class="line"></span><br><span class="line">  // 领养测试用例</span><br><span class="line">  function testUserCanAdoptPet() public &#123;</span><br><span class="line">    uint returnedId = adoption.adopt(8);</span><br><span class="line"></span><br><span class="line">    uint expected = 8;</span><br><span class="line">    Assert.equal(returnedId, expected, &quot;Adoption of pet ID 8 should be recorded.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 宠物所有者测试用例</span><br><span class="line">  function testGetAdopterAddressByPetId() public &#123;</span><br><span class="line">    // 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易，</span><br><span class="line">    address expected = this;</span><br><span class="line">    address adopter = adoption.adopters(8);</span><br><span class="line">    Assert.equal(adopter, expected, &quot;Owner of pet ID 8 should be recorded.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    // 测试所有领养者</span><br><span class="line">  function testGetAdopterAddressByPetIdInArray() public &#123;</span><br><span class="line">  // 领养者的地址就是本合约地址</span><br><span class="line">    address expected = this;</span><br><span class="line">    address[16] memory adopters = adoption.getAdopters();</span><br><span class="line">    Assert.equal(adopters[8], expected, &quot;Owner of pet ID 8 should be recorded.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Assert.sol 及 DeployedAddresses.sol是Truffle框架提供，在test目录下并不提供truffle目录。</p><p>TestAdoption合约中添加adopt的测试用例</p><h3 id="运行测试用例"><a href="#运行测试用例" class="headerlink" title="运行测试用例"></a>运行测试用例</h3><p>在终端中，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle test</span><br></pre></td></tr></table></figure><p>如果测试通过，则终端输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Using network &#x27;develop&#x27;.</span><br><span class="line"></span><br><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Compiling ./test/TestAdoption.sol...</span><br><span class="line">Compiling truffle/Assert.sol...</span><br><span class="line">Compiling truffle/DeployedAddresses.sol...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  TestAdoption</span><br><span class="line">    ✓ testUserCanAdoptPet (62ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetId (53ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetIdInArray (73ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (554ms)</span><br></pre></td></tr></table></figure><h2 id="创建用户接口和智能合约交互"><a href="#创建用户接口和智能合约交互" class="headerlink" title="创建用户接口和智能合约交互"></a>创建用户接口和智能合约交互</h2><p>我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。</p><p>在Truffle Box <code>pet-shop</code>里，已经包含了应用的前端代码，代码在<code>src/</code>文件夹下。</p><p>在编辑器中打开<code>src/js/app.js</code><br>可以看到用来管理整个应用的App对象，init函数加载宠物信息，就初始化<a href="https://github.com/ethereum/web3.js/">web3</a>.<br>web3是一个实现了与以太坊节点通信的库，我们利用web3来和合约进行交互。</p><h3 id="初始化web3"><a href="#初始化web3" class="headerlink" title="初始化web3"></a>初始化web3</h3><p>接下来，我们来编辑app.js修改initWeb3():<br>删除注释，修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">initWeb3: function() &#123;</span><br><span class="line">  // Is there an injected web3 instance?</span><br><span class="line">  if (typeof web3 !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">    App.web3Provider = web3.currentProvider;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // If no injected web3 instance is detected, fall back to Ganache</span><br><span class="line">    App.web3Provider = new Web3.providers.HttpProvider(&#x27;http://localhost:7545&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  web3 = new Web3(App.web3Provider);</span><br><span class="line"></span><br><span class="line">  return App.initContract();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中优先使用<a href="https://github.com/ethereum/mist">Mist</a>或<a href="https://metamask.io/">MetaMask</a>提供的web3实例，如果没有则从本地环境创建一个。</p><h3 id="实例化合约"><a href="#实例化合约" class="headerlink" title="实例化合约"></a>实例化合约</h3><p>使用truffle-contract会帮我们保存合约部署的信息，就不需要我们手动修改合约地址，修改initContract()代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initContract: function() &#123;</span><br><span class="line">  // 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息</span><br><span class="line">  $.getJSON(&#x27;Adoption.json&#x27;, function(data) &#123;</span><br><span class="line">    // 用Adoption.json数据创建一个可交互的TruffleContract合约实例。</span><br><span class="line">    var AdoptionArtifact = data;</span><br><span class="line">    App.contracts.Adoption = TruffleContract(AdoptionArtifact);</span><br><span class="line"></span><br><span class="line">    // Set the provider for our contract</span><br><span class="line">    App.contracts.Adoption.setProvider(App.web3Provider);</span><br><span class="line"></span><br><span class="line">    // Use our contract to retrieve and mark the adopted pets</span><br><span class="line">    return App.markAdopted();</span><br><span class="line">  &#125;);</span><br><span class="line">  return App.bindEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理领养"><a href="#处理领养" class="headerlink" title="处理领养"></a>处理领养</h3><p>修改markAdopted()代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">markAdopted: function(adopters, account) &#123;</span><br><span class="line">  var adoptionInstance;</span><br><span class="line"></span><br><span class="line">  App.contracts.Adoption.deployed().then(function(instance) &#123;</span><br><span class="line">    adoptionInstance = instance;</span><br><span class="line"></span><br><span class="line">    // 调用合约的getAdopters(), 用call读取信息不用消耗gas</span><br><span class="line">    return adoptionInstance.getAdopters.call();</span><br><span class="line">  &#125;).then(function(adopters) &#123;</span><br><span class="line">    for (i = 0; i &lt; adopters.length; i++) &#123;</span><br><span class="line">      if (adopters[i] !== &#x27;0x0000000000000000000000000000000000000000&#x27;) &#123;</span><br><span class="line">        $(&#x27;.panel-pet&#x27;).eq(i).find(&#x27;button&#x27;).text(&#x27;Success&#x27;).attr(&#x27;disabled&#x27;, true);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(function(err) &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改handleAdopt()代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">handleAdopt: function(event) &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"></span><br><span class="line">  var petId = parseInt($(event.target).data(&#x27;id&#x27;));</span><br><span class="line"></span><br><span class="line">  var adoptionInstance;</span><br><span class="line"></span><br><span class="line">  // 获取用户账号</span><br><span class="line">  web3.eth.getAccounts(function(error, accounts) &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var account = accounts[0];</span><br><span class="line"></span><br><span class="line">    App.contracts.Adoption.deployed().then(function(instance) &#123;</span><br><span class="line">      adoptionInstance = instance;</span><br><span class="line"></span><br><span class="line">      // 发送交易领养宠物</span><br><span class="line">      return adoptionInstance.adopt(petId, &#123;from: account&#125;);</span><br><span class="line">    &#125;).then(function(result) &#123;</span><br><span class="line">      return App.markAdopted();</span><br><span class="line">    &#125;).catch(function(err) &#123;</span><br><span class="line">      console.log(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在浏览器里运行"><a href="#在浏览器里运行" class="headerlink" title="在浏览器里运行"></a>在浏览器里运行</h2><h3 id="安装-MetaMask"><a href="#安装-MetaMask" class="headerlink" title="安装 MetaMask"></a>安装 MetaMask</h3><p>MetaMask 是一款插件形式的以太坊轻客户端，开发过程中使用MetaMask和我们的dapp进行交互是个很好的选择，通过此链接安装，安装完成后，浏览器工具条会显示一个小狐狸图标。</p><h3 id="配置钱包"><a href="#配置钱包" class="headerlink" title="配置钱包"></a>配置钱包</h3><p>在接受隐私说明后，会出现页面如下：</p><p><img src="/img/metamask-initial.png"></p><p>这里我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。点击页面的_Import Existing DEN_ ，输入Ganache显示的助记词。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure><p>然后自己想要的密码，点击OK。<br>如图：</p><p><img src="/img/metamask-seed.png"></p><h3 id="链接开发区块链网络"><a href="#链接开发区块链网络" class="headerlink" title="链接开发区块链网络"></a>链接开发区块链网络</h3><p>默认连接的是以太坊主网（左上角显示），选择Custom RPC，添加一个网络：<a href="http://127.0.0.1:7545/">http://127.0.0.1:7545</a> ，点返回后，显示如下：</p><p><img src="/img/metamask-account1.png"></p><p>这是左上角显示为_Private Network_ ，账号是Ganache中默认的第一个账号。</p><p>至此MetaMask的安装，配置已经完成。</p><h3 id="安装和配置lite-server"><a href="#安装和配置lite-server" class="headerlink" title="安装和配置lite-server"></a>安装和配置lite-server</h3><p>接下来需要本地的web 服务器提供服务的访问， Truffle Box pet-shop里提供了一个lite-server可以直接使用，我们看看它是如何工作的。<br>bs-config.json指示了lite-server的工作目录。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseDir&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./src&quot;</span><span class="punctuation">,</span> <span class="string">&quot;./build/contracts&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>.&#x2F;src 是网站文件目录<br>.&#x2F;build&#x2F;contracts 是合约输出目录</p><p>以此同时，在package.json文件的scripts中添加了dev命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;lite-server&quot;</span>,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>当运行npm run dev的时候，就会启动lite-server</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run dev</span><br></pre></td></tr></table></figure><p>会自动打开浏览器显示我们的dapp，如本文的第一张图。<br>现在领养一直宠物看看，当我们点击_Adopt时，MetaMask_ 会提示我们交易的确认，如图：</p><p><img src="/img/metamask-transactionconfirm.png"></p><p>点击Submit确认后，就可以看到成功领养了这次宠物。</p><p>在MetaMask中，也可以看到交易的清单：</p><p><img src="/img/metamask-transactionsuccess.png"></p><p>好了，恭喜你，即将成为一名去中心化式应用开发者的你已经成为迈出了坚实的一步。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://truffleframework.com/tutorials/pet-shop">Truffle手册</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Geth 控制台使用及 Web3.js 使用实战</title>
      <link href="/2018/geth_cmd_short/geth-cmd-short/"/>
      <url>/2018/geth_cmd_short/geth-cmd-short/</url>
      
        <content type="html"><![CDATA[<p>在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。<br>Geth 控制台（REPL）实现了所有的<a href="http://web3js.readthedocs.io/en/1.0/index.html">web3 API</a>及<a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs#admin">Admin API</a>，<br>使用好 Geth 就是必修课。结合<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/geth/2018-02-24-geth_cmd_options.html">Geth命令用法</a>阅读效果更佳。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文之前，你需要对以太坊（区块链）有初步的了解，如果你不知道以太坊是什么，请先阅读<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/geth/2018-02-25-geth_cmd_short.html">以太坊是什么</a>。<br>如果你在我的小专栏之外的地方阅读到本文，你可能只能阅读本文的节选，阅读完整全文请订阅小专栏<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链技术</a></p><h2 id="geth控制带初探-启动、退出"><a href="#geth控制带初探-启动、退出" class="headerlink" title="geth控制带初探-启动、退出"></a>geth控制带初探-启动、退出</h2><p>安装参考<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-24-init-env.html">智能合约开发环境搭建</a><br>最简单启动方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console</span><br></pre></td></tr></table></figure><p>geth控制台启动成功之后，可以看到&gt;提示符。<br>退出输入exit</p><h2 id="geth日志控制"><a href="#geth日志控制" class="headerlink" title="geth日志控制"></a>geth日志控制</h2><h3 id="重定向日志到文件"><a href="#重定向日志到文件" class="headerlink" title="重定向日志到文件"></a>重定向日志到文件</h3><p>使用geth console启动时，会在当前交互界面下时不时出现日志。<br>可以使用以下方式把日志输出到文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt;geth.log</span><br></pre></td></tr></table></figure><p>可以新开一个命令行终端输入以下命令查看日志:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f geth.log</span><br></pre></td></tr></table></figure><h3 id="重定向另一个终端"><a href="#重定向另一个终端" class="headerlink" title="重定向另一个终端"></a>重定向另一个终端</h3><p>也可以把日志重定向到另一个终端，先在想要看日志的终端输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br></pre></td></tr></table></figure><p>就可以获取到终端编号，如: &#x2F;dev&#x2F;ttys003<br>然后另一个终端使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt; /dev/ttys003</span><br></pre></td></tr></table></figure><p>启动geth,这时日志就输出到另一个终端。<br>如果不想看到日志还可以重定向到空终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="日志级别控制"><a href="#日志级别控制" class="headerlink" title="日志级别控制"></a>日志级别控制</h3><p>使用__–verbosity__ 可以控制日志级别，如不想看到日志还可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth --verbosity 0 console</span><br></pre></td></tr></table></figure><h2 id="启动一个开发模式测试节点"><a href="#启动一个开发模式测试节点" class="headerlink" title="启动一个开发模式测试节点"></a>启动一个开发模式测试节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir /home/xxx/testNet --dev console</span><br></pre></td></tr></table></figure><blockquote><p>技巧：如果我们经常使用一个方式来启动，可以把命令存为一个bash脚本。<br><del>&#x2F;bin你可以放一些常用的脚本，并把</del>&#x2F;bin加入到环境变量PATH里。</p></blockquote><h2 id="连接geth节点"><a href="#连接geth节点" class="headerlink" title="连接geth节点"></a>连接geth节点</h2><p>另外一个启动geth的方法是连接到一个geth节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ geth attach ipc:/some/custom/path</span><br><span class="line">$ geth attach http://191.168.1.1:8545</span><br><span class="line">$ geth attach ws://191.168.1.1:8546</span><br></pre></td></tr></table></figure><p>如连接刚刚打开的开发模式节点使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth attach ipc:testNet/geth.ipc</span><br></pre></td></tr></table></figure><p>更多内容请前往区块链技术小专栏查看<a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/">全部链接</a>。</p><p>a</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊客户端Geth命令用法-参数详解</title>
      <link href="/2018/geth_cmd_options/geth-cmd-options/"/>
      <url>/2018/geth_cmd_options/geth-cmd-options/</url>
      
        <content type="html"><![CDATA[<p>Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。<br>熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。</p><p>如果你还不知道geth是什么，请先阅读<a href="/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">入门篇：以太坊是什么</a>。<br>更多geth实战使用方法请参考<a href="">Geth控制台使用实战及Web3.js使用</a><br>以下开始正文。</p><h2 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth [选项] 命令 [命令选项] [参数…]</span><br></pre></td></tr></table></figure><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.7.3-stable</span><br></pre></td></tr></table></figure><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">account    管理账户</span><br><span class="line">attach     启动交互式JavaScript环境（连接到节点）</span><br><span class="line">bug        上报bug Issues</span><br><span class="line">console    启动交互式JavaScript环境</span><br><span class="line">copydb     从文件夹创建本地链</span><br><span class="line">dump       Dump（分析）一个特定的块存储</span><br><span class="line">dumpconfig 显示配置值</span><br><span class="line">export     导出区块链到文件</span><br><span class="line">import     导入一个区块链文件</span><br><span class="line">init       启动并初始化一个新的创世纪块</span><br><span class="line">js         执行指定的JavaScript文件(多个)</span><br><span class="line">license    显示许可信息</span><br><span class="line">makecache  生成ethash验证缓存(用于测试)</span><br><span class="line">makedag    生成ethash 挖矿DAG(用于测试)</span><br><span class="line">monitor    监控和可视化节点指标</span><br><span class="line">removedb   删除区块链和状态数据库</span><br><span class="line">version    打印版本号</span><br><span class="line">wallet     管理Ethereum预售钱包</span><br><span class="line">help,h     显示一个命令或帮助一个命令列表</span><br></pre></td></tr></table></figure><h3 id="ETHEREUM选项"><a href="#ETHEREUM选项" class="headerlink" title="ETHEREUM选项:"></a>ETHEREUM选项:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--config value          TOML 配置文件</span><br><span class="line">--datadir “xxx”         数据库和keystore密钥的数据目录</span><br><span class="line">--keystore              keystore存放目录(默认在datadir内)</span><br><span class="line">--nousb                 禁用监控和管理USB硬件钱包</span><br><span class="line">--networkid value       网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1)</span><br><span class="line">--testnet               Ropsten网络:预先配置的POW(proof-of-work)测试网络</span><br><span class="line">--rinkeby               Rinkeby网络: 预先配置的POA(proof-of-authority)测试网络</span><br><span class="line">--syncmode &quot;fast&quot;       同步模式 (&quot;fast&quot;, &quot;full&quot;, or &quot;light&quot;)</span><br><span class="line">--ethstats value        上报ethstats service  URL (nodename:secret@host:port)</span><br><span class="line">--identity value        自定义节点名</span><br><span class="line">--lightserv value       允许LES请求时间最大百分比(0 – 90)(默认值:0)</span><br><span class="line">--lightpeers value      最大LES client peers数量(默认值:20)</span><br><span class="line">--lightkdf              在KDF强度消费时降低key-derivation RAM&amp;CPU使用</span><br></pre></td></tr></table></figure><h3 id="开发者（模式）选项"><a href="#开发者（模式）选项" class="headerlink" title="开发者（模式）选项:"></a>开发者（模式）选项:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--dev               使用POA共识网络，默认预分配一个开发者账户并且会自动开启挖矿。</span><br><span class="line">--dev.period value  开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0)</span><br></pre></td></tr></table></figure><h3 id="ETHASH选项"><a href="#ETHASH选项" class="headerlink" title="ETHASH选项"></a>ETHASH选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--ethash.cachedir                        ethash验证缓存目录(默认 = datadir目录内)</span><br><span class="line">--ethash.cachesinmem value               在内存保存的最近的ethash缓存个数  (每个缓存16MB ) (默认: 2)</span><br><span class="line">--ethash.cachesondisk value              在磁盘保存的最近的ethash缓存个数 (每个缓存16MB) (默认: 3)</span><br><span class="line">--ethash.dagdir &quot;&quot;                       存ethash DAGs目录 (默认 = 用户hom目录)</span><br><span class="line">--ethash.dagsinmem value                 在内存保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 1)</span><br><span class="line">--ethash.dagsondisk value                在磁盘保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 2)</span><br></pre></td></tr></table></figure><h3 id="交易池选项"><a href="#交易池选项" class="headerlink" title="交易池选项"></a>交易池选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--txpool.nolocals            为本地提交交易禁用价格豁免</span><br><span class="line">--txpool.journal value       本地交易的磁盘日志：用于节点重启 (默认: &quot;transactions.rlp&quot;)</span><br><span class="line">--txpool.rejournal value     重新生成本地交易日志的时间间隔 (默认: 1小时)</span><br><span class="line">--txpool.pricelimit value    加入交易池的最小的gas价格限制(默认: 1)</span><br><span class="line">--txpool.pricebump value     价格波动百分比（相对之前已有交易） (默认: 10)</span><br><span class="line">--txpool.accountslots value  每个帐户保证可执行的最少交易槽数量  (默认: 16)</span><br><span class="line">--txpool.globalslots value   所有帐户可执行的最大交易槽数量 (默认: 4096)</span><br><span class="line">--txpool.accountqueue value  每个帐户允许的最多非可执行交易槽数量 (默认: 64)</span><br><span class="line">--txpool.globalqueue value   所有帐户非可执行交易最大槽数量  (默认: 1024)</span><br><span class="line">--txpool.lifetime value      非可执行交易最大入队时间(默认: 3小时)</span><br></pre></td></tr></table></figure><h3 id="性能调优选项"><a href="#性能调优选项" class="headerlink" title="性能调优选项"></a>性能调优选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--cache value                分配给内部缓存的内存MB数量，缓存值(最低16 mb /数据库强制要求)(默认:128)</span><br><span class="line">--trie-cache-gens value      保持在内存中产生的trie node数量(默认:120)</span><br></pre></td></tr></table></figure><h3 id="帐户选项"><a href="#帐户选项" class="headerlink" title="帐户选项"></a>帐户选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--unlock value              需解锁账户用逗号分隔</span><br><span class="line">--password value            用于非交互式密码输入的密码文件</span><br></pre></td></tr></table></figure><h3 id="API和控制台选项"><a href="#API和控制台选项" class="headerlink" title="API和控制台选项:"></a>API和控制台选项:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--rpc                       启用HTTP-RPC服务器</span><br><span class="line">--rpcaddr value             HTTP-RPC服务器接口地址(默认值:“localhost”)</span><br><span class="line">--rpcport value             HTTP-RPC服务器监听端口(默认值:8545)</span><br><span class="line">--rpcapi value              基于HTTP-RPC接口提供的API</span><br><span class="line">--ws                        启用WS-RPC服务器</span><br><span class="line">--wsaddr value              WS-RPC服务器监听接口地址(默认值:“localhost”)</span><br><span class="line">--wsport value              WS-RPC服务器监听端口(默认值:8546)</span><br><span class="line">--wsapi  value              基于WS-RPC的接口提供的API</span><br><span class="line">--wsorigins value           websockets请求允许的源</span><br><span class="line">--ipcdisable                禁用IPC-RPC服务器</span><br><span class="line">--ipcpath                   包含在datadir里的IPC socket/pipe文件名(转义过的显式路径)</span><br><span class="line">--rpccorsdomain value       允许跨域请求的域名列表(逗号分隔)(浏览器强制)</span><br><span class="line">--jspath loadScript         JavaScript加载脚本的根路径(默认值:“.”)</span><br><span class="line">--exec value                执行JavaScript语句(只能结合console/attach使用)</span><br><span class="line">--preload value             预加载到控制台的JavaScript文件列表(逗号分隔)</span><br></pre></td></tr></table></figure><h3 id="网络选项"><a href="#网络选项" class="headerlink" title="网络选项"></a>网络选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--bootnodes value    用于P2P发现引导的enode urls(逗号分隔)(对于light servers用v4+v5代替)</span><br><span class="line">--bootnodesv4 value  用于P2P v4发现引导的enode urls(逗号分隔) (light server, 全节点)</span><br><span class="line">--bootnodesv5 value  用于P2P v5发现引导的enode urls(逗号分隔) (light server, 轻节点)</span><br><span class="line">--port value         网卡监听端口(默认值:30303)</span><br><span class="line">--maxpeers value     最大的网络节点数量(如果设置为0，网络将被禁用)(默认值:25)</span><br><span class="line">--maxpendpeers value    最大尝试连接的数量(如果设置为0，则将使用默认值)(默认值:0)</span><br><span class="line">--nat value             NAT端口映射机制 (any|none|upnp|pmp|extip:&lt;IP&gt;) (默认: “any”)</span><br><span class="line">--nodiscover            禁用节点发现机制(手动添加节点)</span><br><span class="line">--v5disc                启用实验性的RLPx V5(Topic发现)机制</span><br><span class="line">--nodekey value         P2P节点密钥文件</span><br><span class="line">--nodekeyhex value      十六进制的P2P节点密钥(用于测试)</span><br></pre></td></tr></table></figure><h3 id="矿工选项"><a href="#矿工选项" class="headerlink" title="矿工选项"></a>矿工选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--mine                  打开挖矿</span><br><span class="line">--minerthreads value    挖矿使用的CPU线程数量(默认值:8)</span><br><span class="line">--etherbase value       挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”)</span><br><span class="line">--targetgaslimit value  目标gas限制：设置最低gas限制（低于这个不会被挖？） (默认值:“4712388”)</span><br><span class="line">--gasprice value        挖矿接受交易的最低gas价格</span><br><span class="line">--extradata value       矿工设置的额外块数据(默认=client version)</span><br></pre></td></tr></table></figure><h3 id="GAS价格选项"><a href="#GAS价格选项" class="headerlink" title="GAS价格选项"></a>GAS价格选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--gpoblocks value      用于检查gas价格的最近块的个数  (默认: 10)</span><br><span class="line">--gpopercentile value  建议gas价参考最近交易的gas价的百分位数，(默认: 50)</span><br></pre></td></tr></table></figure><h3 id="虚拟机选项"><a href="#虚拟机选项" class="headerlink" title="虚拟机选项"></a>虚拟机选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--vmdebug        记录VM及合约调试信息</span><br></pre></td></tr></table></figure><h3 id="日志和调试选项"><a href="#日志和调试选项" class="headerlink" title="日志和调试选项"></a>日志和调试选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--metrics            启用metrics收集和报告</span><br><span class="line">--fakepow            禁用proof-of-work验证</span><br><span class="line">--verbosity value    日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)</span><br><span class="line">--vmodule value      每个模块详细度:以 &lt;pattern&gt;=&lt;level&gt;的逗号分隔列表 (比如 eth/*=6,p2p=5)</span><br><span class="line">--backtrace value    请求特定日志记录堆栈跟踪 (比如 “block.go:271”)</span><br><span class="line">--debug                     突出显示调用位置日志(文件名及行号)</span><br><span class="line">--pprof                     启用pprof HTTP服务器</span><br><span class="line">--pprofaddr value           pprof HTTP服务器监听接口(默认值:127.0.0.1)</span><br><span class="line">--pprofport value           pprof HTTP服务器监听端口(默认值:6060)</span><br><span class="line">--memprofilerate value      按指定频率打开memory profiling    (默认:524288)</span><br><span class="line">--blockprofilerate value    按指定频率打开block profiling    (默认值:0)</span><br><span class="line">--cpuprofile value          将CPU profile写入指定文件</span><br><span class="line">--trace value               将execution trace写入指定文件</span><br></pre></td></tr></table></figure><h3 id="WHISPER实验选项"><a href="#WHISPER实验选项" class="headerlink" title="WHISPER实验选项"></a>WHISPER实验选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--shh                        启用Whisper</span><br><span class="line">--shh.maxmessagesize value   可接受的最大的消息大小 (默认值: 1048576)</span><br><span class="line">--shh.pow value              可接受的最小的POW (默认值: 0.2)</span><br></pre></td></tr></table></figure><h3 id="弃用选项"><a href="#弃用选项" class="headerlink" title="弃用选项"></a>弃用选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--fast     开启快速同步</span><br><span class="line">--light    启用轻客户端模式</span><br></pre></td></tr></table></figure><h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">–help, -h    显示帮助</span><br></pre></td></tr></table></figure><h3 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2013-2017 The go-ethereum Authors</span><br></pre></td></tr></table></figure><h2 id="翻译说明"><a href="#翻译说明" class="headerlink" title="翻译说明"></a>翻译说明</h2><p>有些参数翻译可能有不准确的地方，请大家指正。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约开发环境搭建及Hello World合约</title>
      <link href="/2018/init-env/init-env/"/>
      <url>/2018/init-env/init-env/</url>
      
        <content type="html"><![CDATA[<p>如果你对于以太坊智能合约开发还没有概念（本文会假设你已经知道这些概念），建议先阅读<a href="/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">入门篇</a>。<br>就先学习任何编程语言一样，入门的第一个程序都是Hello World。今天我们来一步一步从搭建以太坊智能合约开发环境开始，讲解智能合约的Hello World如何编写。</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="Solodity安装"><a href="#Solodity安装" class="headerlink" title="Solodity安装"></a>Solodity安装</h3><p>强烈建议新手使用<a href="https://ethereum.github.io/browser-solidity">Browser-Solidity</a>来进行开发。<br>Browser-Solidity是一个基于浏览器的Solidity，就可以不用安装Solidity，本文的Hello World教程也将基于Browser-Solidity来进行。</p><p>如果你想自己安装请参考<a href="https://solidity.readthedocs.io/en/develop/installing-solidity.html">Solidity安装指引</a>。</p><h3 id="geth-安装"><a href="#geth-安装" class="headerlink" title="geth 安装"></a>geth 安装</h3><p>Ubuntu下安装命令如下：其他平台参考：<a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum">geth官方安装指引</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum</span><br></pre></td></tr></table></figure><p>安装完以后，就是把geth控制台启动。</p><h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><p>在入门篇讲过，geth是一个以太坊客户端，现在利用geth启动一个以太坊（开发者）网络节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir testNet --dev console 2&gt;&gt; test.log</span><br></pre></td></tr></table></figure><p>执行命名后，会进入geth控制台，这时光标停在一个向右的箭头处，像这样：</p><p><img src="/img/open_geth_eth.jpg"></p><p>命令参数说明（更多命令详解可阅读<a href="">Geth命令用法-参数详解篇</a>）:<br>–dev 启用开发者网络（模式），开发者网络会使用POA共识，默认预分配一个开发者账户并且会自动开启挖矿。<br>–datadir 后面的参数是区块数据及秘钥存放目录。<br>第一次输入命令后，它会放在当前目录下新建一个testNet目录来存放数据。<br>console 进入控制台<br>2&gt;&gt; test.log 表示把控制台日志输出到test.log文件</p><p>为了更好的理解，建议新开一个命令行终端，实时显示日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f test.log</span><br></pre></td></tr></table></figure><h2 id="准备账户"><a href="#准备账户" class="headerlink" title="准备账户"></a>准备账户</h2><p>部署智能合约需要一个外部账户，我们先来看看分配的开发者账户，在控制台使用以下命令查看账户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br></pre></td></tr></table></figure><p>回车后，返回一个账户数组，里面有一个默认账户，如：</p><p><img src="/img/geth_accounts_1.jpg"></p><blockquote><p>也可以使用personal.listAccounts查看账户，</p></blockquote><p>再来看一下账户里的余额，使用一下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br></pre></td></tr></table></figure><p><strong>eth.accounts[0]</strong> 表示账户列表第一个账户<br>回车后，可以看到大量的余额，如：<br>1.15792089237316195423570985008687907853269… e+77</p><p>开发者账户因余额太多，如果用这个账户来部署合约时会无法看到余额变化，为了更好的体验完整的过程，这里选择创建一个新的账户。</p><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>使用以下命令创建账户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount(&quot;Juan&quot;)</span><br></pre></td></tr></table></figure><p>Juan为新账户的密码，回车后，返回一个新账户。</p><p>这时我们查看账户列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br></pre></td></tr></table></figure><p>可以看到账户数组你包含两个账户，新账户在第二个（索引为1）位置。</p><p>现在看看账户的余额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>回车后，返回的是0，新账户是0。结果如：<br><img src="/img/geth_accounts_2.jpg"></p><h3 id="给新账户转账"><a href="#给新账户转账" class="headerlink" title="给新账户转账"></a>给新账户转账</h3><p>我们知道没有余额的账户是没法部署合约的，那我们就从默认账户转1以太币给新账户，使用以下命令（请使用你自己eth.accounts对应输出的账户）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.sendTransaction(&#123;from: &#x27;0xb0ebe17ef0e96b5c525709c0a1ede347c66bd391&#x27;, to: &#x27;0xf280facfd60d61f6fd3f88c9dee4fb90d0e11dfc&#x27;, value: web3.toWei(1, &quot;ether&quot;)&#125;)</span><br></pre></td></tr></table></figure><p>在打开的tail -f test.log日志终端里，可以同时看到挖矿记录<br>再次查看新账户余额，可以新账户有1个以太币</p><p><img src="/img/geth_accounts_3.jpg"></p><h3 id="解锁账户"><a href="#解锁账户" class="headerlink" title="解锁账户"></a>解锁账户</h3><p>在部署合约前需要先解锁账户（就像银行转账要输入密码一样），使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.unlockAccount(eth.accounts[1],&quot;Juan&quot;);</span><br></pre></td></tr></table></figure><p>“Juan”是之前创建账户时的密码。<br>解锁成功后，账户就准备完毕啦，接下来就是编写合约代码。</p><h2 id="编写合约代码"><a href="#编写合约代码" class="headerlink" title="编写合约代码"></a>编写合约代码</h2><p>现在我们来开始编写第一个智能合约代码，solidity代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract hello &#123;</span><br><span class="line">    string greeting;</span><br><span class="line"></span><br><span class="line">    function hello(string _greeting) public &#123;</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function say() constant public returns (string) &#123;</span><br><span class="line">        return greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释下，我们定义了一个名为hello的合约，在合约初始化时保存了一个字符串（我们会传入hello world），每次调用say返回字符串。<br>把这段代码写(拷贝)到<a href="https://ethereum.github.io/browser-solidity">Browser-Solidity</a>，如果没有错误，点击Details获取部署代码，如：</p><p><img src="/img/eth_code_hello_step1.jpeg"></p><p>在弹出的对话框中找到WEB3DEPLOY部分，点拷贝，粘贴到编辑器后，修改初始化字符串为hello world。</p><p><img src="/img/eth_code_hello_step2.jpeg"></p><blockquote><p>solidity版本之间有可能不能兼容，这是你可以在Browser-Solidity的Settings里选择对应的编译器版本。<br>Browser-Solidity也不停的更新中，截图可能和你看到的界面不一样。</p></blockquote><h2 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h2><p>Browser-Solidity生成的代码，拷贝到编辑器里修改后的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var _greeting = &quot;Hello World&quot; ;</span><br><span class="line">var helloContract = web3.eth.contract([&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;_greeting&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;]);</span><br><span class="line">var hello = helloContract.new(</span><br><span class="line">   _greeting,</span><br><span class="line">   &#123;</span><br><span class="line">     from: web3.eth.accounts[1],</span><br><span class="line">     data: &#x27;0x6060604052341561000f57600080fd5b6040516102b83803806102b8833981016040528080518201919050508060009080519060200190610041929190610048565b50506100ed565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061008957805160ff19168380011785556100b7565b828001600101855582156100b7579182015b828111156100b657825182559160200191906001019061009b565b5b5090506100c491906100c8565b5090565b6100ea91905b808211156100e65760008160009055506001016100ce565b5090565b90565b6101bc806100fc6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063954ab4b214610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a723058204a5577bb3ad30e02f7a3bdd90eedcc682700d67fc8ed6604d38bb739c0655df90029&#x27;,</span><br><span class="line">     gas: &#x27;4700000&#x27;</span><br><span class="line">   &#125;, function (e, contract)&#123;</span><br><span class="line">    console.log(e, contract);</span><br><span class="line">    if (typeof contract.address !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">         console.log(&#x27;Contract mined! address: &#x27; + contract.address + &#x27; transactionHash: &#x27; + contract.transactionHash);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>第1行：修改字符串为Hello World<br>第2行：修改合约变量名<br>第3行：修改合约实例变量名，之后可以直接用实例调用函数。<br>第6行：修改部署账户为新账户索引，即使用新账户来部署合约。<br>第8行：准备付的gas费用，IDE已经帮我们预估好了。<br>第9行：设置部署回调函数。</p><p>拷贝回geth控制台里，回车后，看到输出如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contract mined! address: 0x79544078dcd9d560ec3f6eff0af42a9fc84c7d19 transactionHash: 0xe2caab22102e93434888a0b8013a7ae7e804b132e4a8bfd2318356f6cf0480b3</span><br></pre></td></tr></table></figure><p>说明合约已经部署成功。</p><blockquote><p>在打开的 <strong>tail -f test.log</strong> 日志终端里，可以同时看到挖矿记录</p></blockquote><p>现在我们查看下新账户的余额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br></pre></td></tr></table></figure><h2 id="运行合约"><a href="#运行合约" class="headerlink" title="运行合约"></a>运行合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello.say()</span><br><span class="line">&quot;Hello World&quot;</span><br></pre></td></tr></table></figure><p>输出Hello World，我们第一个合约Hello World，成功运行了。</p><p>运行截图如下：<br><img src="/img/init_example_show.jpg"></p><p>本文会随geth，solidity语言版本升级保持更新，查看本文原始链接：<a href="https://learnblockchain.cn/2017/11/24/init-env/">https://learnblockchain.cn/2017/11/24/init-env/</a></p><p>第一个合约的意义更重要的是体验智能合约开发流程，对于初学者一些可以选择先放弃一些细节，开发流程打通之后，可以增强信心进行下一步的学习。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊是什么 - 以太坊开发入门指南</title>
      <link href="/2018/whatiseth/index/"/>
      <url>/2018/whatiseth/index/</url>
      
        <content type="html"><![CDATA[<p>很多同学已经跃跃欲试投入到区块链开发队伍当中来，可是又感觉无从下手，本文将基于以太坊平台，以通俗的方式介绍以太坊开发中涉及的各晦涩的概念，轻松带大家入门。</p><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>阅读本文前，你应该大概了解区块链是什么，如果你还不了解，欢迎订阅专栏：<a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/">区块链技术</a><br>指引你从头开始学区块链技术。</p><h2 id="以太坊是什么"><a href="#以太坊是什么" class="headerlink" title="以太坊是什么"></a>以太坊是什么</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p><blockquote><p>对这句话不理解的同学，姑且可以理解为以太坊是区块链里的Android，它是一个开发平台，让我们就可以像基于Android Framework一样基于区块链技术写应用。</p></blockquote><p>在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。<br>以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只要专注于应用本身的开发，从而大大降低了难度。</p><blockquote><p>目前围绕以太坊已经形成了一个较为完善的开发生态圈：有社区的支持，有很多开发框架、工具可以选择。</p></blockquote><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><h3 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h3><p><strong>以太坊上的程序称之为智能合约，</strong> 它是代码和数据(状态)的集合。</p><p>智能合约可以理解为在区块链上可以自动执行的（由消息驱动的）、以代码形式编写的合同（特殊的交易）。</p><blockquote><p>智能合约英文是Smart Contract，和人工智能（ AI:Artificial Intelligence ）的智能没有关系，最早尼克萨博在95年就提出智能合约的概念，它的概念很简单，就是将法律条文写成可执行代码。当时并没有区块链，不过智能合约与区块链最配，我们知道合同都是要一式两份、三或四份，不能控制在某一方手中，这也就是去中心化。</p></blockquote><p>在<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-14-bitcoin-script.html">比特币脚本</a>中，我们讲到过比特币的交易是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，<br>而以太坊则更加完备（在计算机科学术语中，称它为是“图灵完备的”），让我们就像使用任何高级语言一样来编写几乎可以做任何事情的程序（智能合约）。</p><p>智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。<br>目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信1到3年内，各种杀手级会慢慢出现。</p><h3 id="编程语言：Solidity"><a href="#编程语言：Solidity" class="headerlink" title="编程语言：Solidity"></a>编程语言：Solidity</h3><p>智能合约的官方推荐的编程语言是Solidity，文件扩展名以.sol结尾。<br>Solidity语言和JavaScript很相似，用它来开发合约并编译成以太坊虚拟机字节代码。</p><blockquote><p>还有Viper，Serpent，LLL及Bamboo，建议大家还是使用Solidity。<br>更新：Serpent官方已经不再推荐，建议Serpent的用户转换到Viper，他们都是类Python语言。</p></blockquote><p><a href="https://ethereum.github.io/browser-solidity">Browser-Solidity</a>是一个浏览器的Solidity IDE, 大家可以点进去看看，以后我们更多文章介绍Solidity这个语言。</p><h3 id="运行环境：EVM"><a href="#运行环境：EVM" class="headerlink" title="运行环境：EVM"></a>运行环境：EVM</h3><p>EVM（Ethereum Virtual Machine）以太坊虚拟机是以太坊中智能合约的运行环境。</p><blockquote><p>Solidity之于EVM，就像之于跟JVM的关系一样，这样大家就容易理解了。<br>以太坊虚拟机是一个隔离的环境，外部无法接触到在EVM内部运行的代码。</p></blockquote><p>而EVM运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。</p><h3 id="合约的编译"><a href="#合约的编译" class="headerlink" title="合约的编译"></a>合约的编译</h3><p>以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择<a href="https://ethereum.github.io/browser-solidity">Browser-Solidity Web IDE</a>或solc编译器。</p><h3 id="合约的部署"><a href="#合约的部署" class="headerlink" title="合约的部署"></a>合约的部署</h3><p>在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？</p><h4 id="以太坊客户端（钱包）"><a href="#以太坊客户端（钱包）" class="headerlink" title="以太坊客户端（钱包）"></a>以太坊客户端（钱包）</h4><p>以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。</p><blockquote><p>EVM是由以太坊客户端提供的</p></blockquote><p><strong>Geth</strong> 是典型的开发以太坊时使用的客户端，基于Go语言开发。 Geth提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth的使用我们之后会有文章介绍，这里大家先有个概念。</p><blockquote><p>Geth控制台和Chrome浏览器开发者工具里的面的控制台是类似的，不过Geth控制台是跑在终端里。<br>相对于Geth，Mist则是图形化操作界面的以太坊客户端。</p></blockquote><h4 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h4><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。</p><blockquote><p>以太坊中有两类账户：</p><ul><li>外部账户<br>该类账户被私钥控制（由人控制），没有关联任何代码。</li><li>合约账户<br>该类账户被它们的合约代码控制且有代码与之关联。<blockquote><p>和比特币使用UTXO的设计不一样，以太坊使用更为简单的账户概念。<br>两类账户对于EVM来说是一样的。<br>外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。<br>在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。<br>只有当外部账户发出指令时，合同账户才会执行相应的操作。</p></blockquote></li></ul></blockquote><p>合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在EVM中执行了。</p><h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><p>和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对!）。<br>以太坊上用Gas机制来计费，Gas也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。<br>任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定。<br>而Gas价格由运行合约的人在提交运行合约请求的时候规定，以确定他愿意为这次交易愿意付出的费用：Gas价格（用以太币计价） * Gas数量。</p><p>Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当EVM执行交易时，Gas将按照特定规则被逐渐消耗，无论执行到什么位置，一旦Gas被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有Gas剩余，这些Gas将被返还给发送账户。</p><blockquote><p>如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。</p></blockquote><p>因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。</p><h2 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h2><p>有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式：</p><h3 id="选择以太坊官网测试网络Testnet"><a href="#选择以太坊官网测试网络Testnet" class="headerlink" title="选择以太坊官网测试网络Testnet"></a>选择以太坊官网测试网络Testnet</h3><p>测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。</p><h3 id="使用私有链"><a href="#使用私有链" class="headerlink" title="使用私有链"></a>使用私有链</h3><p>创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。<br>通过上面提到的Geth很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。</p><h3 id="使用开发者网络-模式"><a href="#使用开发者网络-模式" class="headerlink" title="使用开发者网络(模式)"></a>使用开发者网络(模式)</h3><p>相比私有链，开发者网络(模式)下，会自动分配一个有大量余额的开发者账户给我们使用。</p><h3 id="使用模拟环境"><a href="#使用模拟环境" class="headerlink" title="使用模拟环境"></a>使用模拟环境</h3><p>另一个创建测试网络的方法是使用testrpc，testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更方便快捷。而且testrpc可以在启动时帮我们创建10个存有资金的测试账户。<br>进行合约开发时，可以在testrpc中测试通过后，再部署到Geth节点中去。</p><blockquote><p>更新：testrpc 现在已经并入到Truffle 开发框架中，现在名字是Ganache CLI。</p></blockquote><h2 id="Dapp-去中心化的应用程序"><a href="#Dapp-去中心化的应用程序" class="headerlink" title="Dapp:去中心化的应用程序"></a>Dapp:去中心化的应用程序</h2><p>以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解Dapp了，一个Dapp不单单有智能合约，比如还需要有一个友好的用户界面和其他的东西。</p><h3 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h3><p>Truffle是Dapp开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码-编译-部署-测试-打包DApp这个流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用Solidity来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用Truffle框架可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用Geth或testrpc来搭建一个测试网络。</p><p>注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。</p><p>本文完，这些概念你都明白了么？现在你可以开始开发了，看看<a href="">智能合约开发环境搭建及Hello World合约</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethereum </tag>
            
            <tag> 以太坊概念 </tag>
            
            <tag> 以太坊入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是拜占庭将军问题</title>
      <link href="/2018/bitcoin-byzantine/index/"/>
      <url>/2018/bitcoin-byzantine/index/</url>
      
        <content type="html"><![CDATA[<p>接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?</p><h2 id="什么是拜占庭将军问题"><a href="#什么是拜占庭将军问题" class="headerlink" title="什么是拜占庭将军问题"></a>什么是拜占庭将军问题</h2><p>也被称为“拜占庭容错”、“拜占庭将军问题”。<br>拜占庭将军问题是Leslie Lamport（2013年的图灵讲得住）用来为描述分布式系统一致性问题（Distributed Consensus）在论文中抽象出来一个著名的例子。</p><p>这个例子大意是这样的：</p><p>拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？</p><blockquote><p>拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的.</p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下：</p><ol><li><p>先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。</p></li><li><p>再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻， 通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。</p></li></ol><blockquote><p>叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为BFT。</p></blockquote><p>相信大家已经可以明白这个问题的复杂性了。</p><h2 id="中本聪的解决方案"><a href="#中本聪的解决方案" class="headerlink" title="中本聪的解决方案"></a>中本聪的解决方案</h2><p>在出现比特币之前，解决分布式系统一致性问题主要是Lamport提出的Paxos算法或其衍生算法。Paxos类算法仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。</p><p>中本聪在比特币中创造性的引入了“工作量证明（POW : Proof of Work）”来解决这个问题，有兴趣可进一步阅读工作量证明。<br>通过工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名。<br>这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。</p><p>以上就是比特币网络中是单个区块（账本）达成共识的方法（取得一致性）。</p><p>理解了单个区块取得一致性的方法，那么整个区块链（总账本）如果达成一致也好理解。<br>我们稍微把将军问题改一下：假设攻下一个城堡需要多次的进攻，每次进攻的提议必须基于之前最多次数的胜利进攻下提出的（只有这样敌方已有损失最大，我方进攻胜利的可能性就更大），这样约定之后，将军A在收到进攻提议时，就会检查一下这个提议是不是基于最多的胜利提出的，如果不是（基于最多的胜利）将军A就不会同意这样的提议，如果是的，将军A就会把这次提议记下来。</p><p>这就是比特币网络最长链选择。</p><h2 id="经济学分析"><a href="#经济学分析" class="headerlink" title="经济学分析"></a>经济学分析</h2><p>工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。</p><p>很多人批评工作量证明造成巨大的电力浪费，促使人们去探索新的解决一致性（共识）问题的机制：权益证明机制（POS: Proof of Stake）是一个代表。在拜占庭将军问题的角度来看，它同样提高了做叛徒的成本，因为账户需要首先持有大量余额才能有更多的几率广播区块，POS不是本文重点，以后在讲。</p><blockquote><p>共识算法的核心就是解决拜占庭将军问题（分布式网络一致性问题）。</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://lamport.azurewebsites.net/pubs/byz.pdf">The Byzantine Generals Problem</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 共识协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非对称加密技术- RSA算法数学原理分析</title>
      <link href="/2018/asy-encryption/asy-encryption/"/>
      <url>/2018/asy-encryption/asy-encryption/</url>
      
        <content type="html"><![CDATA[<p>非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。</p><p>所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。<br>但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。<br>通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。</p><p>题外话:<br>本博客一直有打算写一系列文章通俗的密码学，昨天给站点上https, 因其中使用了RSA算法，就查了一下，发现现在网上介绍RSA算法的文章都写的太难理解了，反正也准备写密码学，就先写RSA算法吧，下面开始正文。</p><h2 id="RSA算法原理"><a href="#RSA算法原理" class="headerlink" title="RSA算法原理"></a>RSA算法原理</h2><p>RSA算法的基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。<br>如：有很大质数p跟q，很容易算出N，使得 N &#x3D; p * q，<br>但给出N, 比较难找p q（没有很好的方式， 只有不停的尝试）</p><blockquote><p>这其实也是单向函数的概念</p></blockquote><p>下面来看看数学演算过程：</p><pre><code>1. 选取两个大质数p，q，计算N = p q 及 φ ( N ) = φ (p) φ (q) = (p-1) * (q-1)&gt; 三个数学概念：&gt; 质数(prime numbe)：又称素数，为在大于1的自然数中，除了1和它本身以外不再有其他因数。&gt; 互质关系：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。&gt; φ(N)：叫做欧拉函数，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。&gt; 如果n是质数，则 φ(n)=n-1。&gt; 如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。2. 选择一个大于1 小于φ(N)的数e，使得 e 和 φ(N)互质&gt; e其实是1和φ(N)之前的一个质数3. 计算d，使得de=1 mod φ(N) 等价于方程式 ed-1 = k φ(N) 求一组解。&gt; d 称为e的模反元素，e 和 φ(N)互质就肯定存在d。&gt; 模反元素是指如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，则b称为a的模反元素。&gt; 可根据欧拉定理证明模反元素存在，欧拉定理是指若n,a互质，则：&gt; ![](https://fastly.jsdelivr.net/gh/quewen08/CDN-for-Blog/img/aes_mod.png)4. (N, e)封装成公钥，(N, d)封装成私钥。假设m为明文，加密就是算出密文c:m^e mod N = c (明文m用公钥e加密并和随机数N取余得到密文c)解密则是：c^d mod N = m　(密文c用密钥解密并和随机数N取余得到明文m)&gt; 私钥解密这个是可以证明的，这里不展开了。</code></pre><h2 id="加解密步骤"><a href="#加解密步骤" class="headerlink" title="加解密步骤"></a>加解密步骤</h2><p>具体还是来看看步骤，举个例子，假设Alice和Bob又要相互通信。</p><ol><li>Alice 随机取大质数P1&#x3D;53，P2&#x3D;59，那N&#x3D;53*59&#x3D;3127，φ(N)&#x3D;3016</li><li>取一个e&#x3D;3，计算出d&#x3D;2011。</li><li>只将N&#x3D;3127，e&#x3D;3 作为公钥传给Bob（公钥公开）</li><li>假设Bob需要加密的明文m&#x3D;89，c &#x3D; 89^3 mod 3127&#x3D;1394，于是Bob传回c&#x3D;1394。 （公钥加密过程）</li><li>Alice使用c^d mod N &#x3D; 1394^2011 mod 3127，就能得到明文m&#x3D;89。 （私钥解密过程）</li></ol><p>假如攻击者能截取到公钥n&#x3D;3127，e&#x3D;3及密文c&#x3D;1394，是仍然无法不通过d来进行密文解密的。</p><h2 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h2><p>那么，有无可能在已知n和e的情况下，推导出d？</p><ol><li>ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</li><li>φ(n)&#x3D;(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</li><li>n&#x3D;pq。只有将n因数分解，才能算出p和q。</li></ol><p>如果n可以被因数分解，d就可以算出，因此RSA安全性建立在N的因式分解上。大整数的因数分解，是一件非常困难的事情。<br>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。</p><h2 id="补充模运算规则"><a href="#补充模运算规则" class="headerlink" title="补充模运算规则"></a>补充模运算规则</h2><ol><li>模运算加减法:<br>(a + b) mod p &#x3D; (a mod p + b mod p) mod p<br>(a - b) mod p &#x3D; (a mod p - b mod p) mod p</li><li>模运算乘法：<br>(a b) mod p &#x3D; (a mod p b mod p) mod p</li><li>模运算幂<br>a ^ b mod p &#x3D; ((a mod p)^b) mod p</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> RSA算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币区块结构Merkle树及简单支付验证分析</title>
      <link href="/2018/merkle/merkle/"/>
      <url>/2018/merkle/merkle/</url>
      
        <content type="html"><![CDATA[<p>在比特币网络中，不是每个节点都有能力储存完整的区块链数据，受限于存储空间的的限制，很多节点是以SPV（Simplified Payment Verification简单支付验证）钱包接入比特币网络，通过简单支付验证可以在不必存储完整区块链下对交易进行验证，本文将分析区块结构Merkle树及如何进行交易验证。</p><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><p>在<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-13-bitcoin-pow.html">工作量证明</a>中出现过一个区块信息截图：</p><p><img src="/img/block_info_493050.jpg"></p><p>细心的同学一定已经在里面发现了很多未讲的其他信息，如：时间戳，版本号，交易次数，二进制哈希树根(Merkle根)等。</p><p>我们来看看一个区块结构到底是怎样的：</p><p><img src="/img/block_structure.jpeg"></p><p>如上图（下文称：区块结构图）所示：每个数据区块包含区块头和区块体。<br>区块头封装了当前版本号、前一区块哈希值、当前区块PoW要求的随机数(Nonce)、时间戳、以及Merkle根信息。<br>区块体则包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过 Merkle树的哈希过程生成唯一的Merkle根并记入区块头.</p><blockquote><p>区块哈希值实际上并不包含在区块的数据结构里，其实区块打包时只有区块头被用于计算哈希（从网络被接收时由每个节点计算出来），常说的区块哈希值实际是区块头哈希值，它可以用来唯一、明确地标识一个区块。</p></blockquote><p>区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块包含2000个交易。因此，包含完整交易的区块比区块头的4千倍还要大。<br>SPV节点只下载区块头，不下载包含在每个区块中的交易信息。这样的不含交易信息的区块链，大小只有完整区块链的几千分之1，那SPV节点是如何验证交易的呢？</p><h2 id="哈希验证"><a href="#哈希验证" class="headerlink" title="哈希验证"></a>哈希验证</h2><p>上面先留一个引子，先来回顾下哈希函数，<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-08-whatbc.html">记账原理</a>我们知道原始信息任何微小的变化都会哈希完全不同的哈希值。</p><h3 id="简单文件验证"><a href="#简单文件验证" class="headerlink" title="简单文件验证"></a>简单文件验证</h3><p>我们通常用哈希来检验下载的文件是否完整，我经常看到这样的下载页面：<br><img src="/img/ex_check_file.jpeg"></p><p>可以看到下载链接后面提供了一个MD5（MD5也是一种Hash算法），这样我们可以在下载之后对文件计算MD5，如果MD5与提供的MD5相等，说明文件有没有被损坏，这个验证过程相信大家都能理解。</p><h3 id="多点文件验证-哈希列表"><a href="#多点文件验证-哈希列表" class="headerlink" title="多点文件验证(哈希列表)"></a>多点文件验证(哈希列表)</h3><p>现在复杂度提高一点，在P2P网络中下载时，会把大文件切成小文件，同时从多个机器上下载数据，这个时候怎么验证数据呢？</p><p>以BT下载为例，在下载真正的数据之前，我们会先下载一个哈希列表的（每个下小块计算出一个哈希），如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，这时有一个问题就出现了，那么多的哈希，怎么保证它们本身(哈希列表中的哈希值)都是正确地呢？</p><p>答案是把每个小块数据的哈希值拼到一起，然后对这个长字符串在作一次哈希运算，得到哈希列表的根哈希。只要根哈希校对比一样就说明验哈希列表是正确的，再通过哈希列表校验小数据块，如果所有的小数据块验证通过则说明大文件没有被损坏。</p><h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><p>验证交易的过程和文件验证很相似，可以人为每个交易是一个小数据块，但比特币使用Merkle树的方式进行验证，相对于哈希列表，Merkle树是一种哈希二叉树，它的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，更加高效。</p><p>我们回看下上面的区块结构图，区块体就包含这样一个Merkle树,Merkle树被用来归纳一个区块中的所有交易。</p><p>每个叶子节点是每个交易信息的哈希，往上对相邻的两个哈希合并成字符串再哈希，继续类似的操作直到只剩下顶部的一个节点，即Merkle根，存入区块头。</p><p>因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。</p><h3 id="简化支付验证"><a href="#简化支付验证" class="headerlink" title="简化支付验证"></a>简化支付验证</h3><p>SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头，我们来看看它是如何对交易数据进行验证的。</p><p>假如要验证区块结构图中交易6，SPV节点会通过向相邻节点索要（通过Merkleblock消息）包括从交易6哈希值沿Merkle树上溯至区块头根哈希处的哈希序列 (即哈希节点6, 5, 56, 78, 5678, 1234 1~8 - 称为认证路径) 来确认交易的存在性和正确性。（在N个交易组成的区块中确认任一交易只需要计算log2(N)个字节的哈希值，非常快速高效）</p><p>你明白了吗？</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币脚本及交易分析 - 智能合约雏形</title>
      <link href="/2018/bitcoin-script/bitcoin-script/"/>
      <url>/2018/bitcoin-script/bitcoin-script/</url>
      
        <content type="html"><![CDATA[<p>大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。<br>在比特币区块链中，交易不是这么简单，交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。<br>本文就来分析一下交易是如何实现可编程的。</p><h2 id="未花费的交易输出-UTXO"><a href="#未花费的交易输出-UTXO" class="headerlink" title="未花费的交易输出(UTXO)"></a>未花费的交易输出(UTXO)</h2><p>先引入一个概念：未花费的交易输出——UTXO（Unspent Transaction Output）</p><p>其实比特币的交易都是基于UTXO上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。</p><blockquote><p>挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。<br>UTXO是交易的基本单元，不能再分割。<br>在比特币没有余额概念，只有分散到区块链里的UTXO</p></blockquote><p>随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样：</p><p><img src="/img/own_chain.jpeg"></p><h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>比特币交易是首先要提供一个用于解锁UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，<br>交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。</p><p>每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。</p><blockquote><p>当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真</p></blockquote><p>如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：<br><img src="/img/script.jpeg"></p><h3 id="常见交易脚本验证过程"><a href="#常见交易脚本验证过程" class="headerlink" title="常见交易脚本验证过程"></a>常见交易脚本验证过程</h3><p>比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。</p><blockquote><p>比特币脚本语言包含基本算数计算、基本逻辑(比如if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考:<a href="http://www.8btc.com/bitcoin_scripts">比特币脚本</a></p></blockquote><p>脚本语言通过从左至右地处理每个项目的方式执行脚本。</p><p>下面用两个图说明下常见类型的比特币交易脚本验证执行过程：</p><p><img src="/img/script_run1.jpeg"></p><p>上图为解锁脚本运行过程（主要是入栈）</p><p><img src="/img/script_run2.jpeg"></p><p>上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。</p><h2 id="交易分析"><a href="#交易分析" class="headerlink" title="交易分析"></a>交易分析</h2><p>实际上比特币的交易被设计为可以纳入多个输入和输出。</p><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><p>我们来看看完整的交易结构<br><img src="/img/tx_struce.jpeg"></p><blockquote><p>交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成0，用来表示立即执行。<br>如果锁定时间不是0并且小于5亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。<br>如果锁定时间大于5亿，则它被当作是一个Unix纪元时间戳（从1970年1月1日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。</p></blockquote><p>交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：</p><blockquote><p>交易费 &#x3D; 求和（所有输入） - 求和（所有输出）</p></blockquote><h3 id="交易输入结构"><a href="#交易输入结构" class="headerlink" title="交易输入结构"></a>交易输入结构</h3><p>刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：</p><p><img src="/img/tx_input_struce.jpeg"></p><p>我们结合整个交易的结构里看输入结构就是这样子：</p><p><img src="/img/tx_input_overview.jpeg"></p><h3 id="交易输出结构"><a href="#交易输出结构" class="headerlink" title="交易输出结构"></a>交易输出结构</h3><p>刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：<br><img src="/img/tx_output_struce.jpeg"></p><p>我们结合整个交易的结构里看输出结构就是这样子：</p><p><img src="/img/tx_output_overview.jpeg"></p><h3 id="交易哈希计算"><a href="#交易哈希计算" class="headerlink" title="交易哈希计算"></a>交易哈希计算</h3><p>在<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-14-merkle.html">比特币区块结构Merkle 树及简单支付验证分析</a>讲到区块结构，区块结构包含多个交易的哈希。<br>那么交易哈希是怎么计算的呢？</p><ol><li>交易结构各字段序列化为字节数组</li><li>把字节数组拼接为支付串</li><li>对支付串计算两次SHA256 得到交易hash<br>了解详情可进一步参考<a href="https://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated">如何计算交易Hash?</a>及<a href="https://bitcointalk.org/index.php?topic=54451.msg649253#msg649253">如何创建Hash?</a></li></ol><p>现在是不是对完整的交易到区块有了更清晰的认识。</p><h2 id="智能合约雏形-应用场景说明"><a href="#智能合约雏形-应用场景说明" class="headerlink" title="智能合约雏形 - 应用场景说明"></a>智能合约雏形 - 应用场景说明</h2><p>由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。</p><p>比特币的脚本目前常用的主要分为两种，一种是常见的P2PKH（支付给公钥哈希），另一种是P2SH（Pay-to-Script-Hash支付脚本哈希）。<br>P2SH支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。</p><p>这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。</p><ul><li><p>多重签名应用<br>合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。</p><p>用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。</p></li><li><p>保证合同<br>保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。</p><p>一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。</p></li><li><p>依靠预言<br>假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满18岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。</p><p>因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。</p></li></ul><p>相信随着区块链的普及，会对未来的交易模式和商业结构带来巨大的影响。不过由于比特币的脚本语言不是图灵完备的，交易模式依旧有限，以太坊就是为解决这一问题而出现，后面会有大量介绍以太坊的文章。</p><h2 id="参考文献-amp-补充阅读"><a href="#参考文献-amp-补充阅读" class="headerlink" title="参考文献 &amp; 补充阅读"></a>参考文献 &amp; 补充阅读</h2><ol><li><a href="http://book.8btc.com/master_bitcoin">精通比特币</a></li><li>廖雪峰的<a href="http://www.infoq.com/cn/articles/deep-understanding-of-bitcoin-transaction-script">深入理解比特币交易的脚本</a></li><li><a href="http://www.8btc.com/bitcoin_contracts">比特币合同</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析比特币网络：一种去中心化、点对点的网络架构</title>
      <link href="/2018/bitcoin-p2p/bitcoin-p2p/"/>
      <url>/2018/bitcoin-p2p/bitcoin-p2p/</url>
      
        <content type="html"><![CDATA[<p>比特币采用了基于互联网的点对点（P2P：peer-to-peer）分布式网络架构。<br>比特币网络可以认为是按照比特币P2P协议运行的一系列节点的集合。<br>本文来分析下比特币网络，了解它跟传统中心化网络的区别，以及比特币网络是如何发现相邻节点的。</p><h2 id="中心化网络"><a href="#中心化网络" class="headerlink" title="中心化网络"></a>中心化网络</h2><p>为了更好的理解P2P网络，我们先来看看传统的中心化模型：</p><p><img src="/img/cs_network.jpeg"></p><p>这是一种典型的星型（“中心化”）结构，我们常见B&#x2F;S及C&#x2F;S网络架构就是这种模型，C1 、C2 、C3等之间没法直接的连接，C节点如果要连接必须要通过中心化S节点做为桥梁。<br>中心化节点充当服务者、中介作用，比如我们没有办法把资金直接从一个人转移给另一个人，必须通过银行这个中介。</p><h2 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h2><p>P2P网络是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点，每个网络节点以扁平（flat）的拓扑结构相互连通。</p><p><img src="/img/p2p_network.jpeg"></p><p>对比中心化网络，在P2P网络中不存在任何服务端（server）、中央化的服务。<br>P2P网络的节点之间交互连接、协同，每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务，每个节点即是服务端又是客户端。<br>P2P网络模型除应用于比特币网络，使用广泛的BT下载就是基于P2P网络。</p><p>P2P网络不仅仅去除了中心化带来的风险（中心化可能作恶），还可以提高传输的效率。（中心化网络当能也有优点）</p><h2 id="如何发现节点"><a href="#如何发现节点" class="headerlink" title="如何发现节点"></a>如何发现节点</h2><p>既然每个网络节点都是平等的（是指在网络层面上节点是平等的，但各节点在功能上可以有不同的分工, 如钱包节点、挖矿节点等），不存在任何“特殊”中心节点，那么当新的网络节点启动后，它是如何跟其他的节点建立连接，从而加入到比特币网络呢？</p><blockquote><p>在中心化网络中，新加入的节点只要连接“特殊”的中心节点就可以加入网络。</p></blockquote><p>为了能够加入到比特币网络，比特币客户端会做一下几件事情：</p><ol><li>节点会记住它最近成功连接的网络节点，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。</li><li>节点会在失去已有连接时尝试发现新节点。</li><li>当建立一个或多个连接后，节点将一条包含自身IP地址消息发送给其相邻节点。相邻节点再将此消息依次转发给它们各自的相邻节点，从而保证节点信息被多个节点所接收、保证连接更稳定。</li><li>新接入的节点可以向它的相邻节点发送获取地址getaddr消息，要求它们返回其已知对等节点的IP地址列表。节点可以找到需连接到的对等节点。</li><li>在节点启动时，可以给节点指定一个正活跃节点IP, 如果没有，客户端也维持一个列表，列出了那些长期稳定运行的节点。这样的节点也被称为种子节点（其实和BT下载的种子文件道理是一样的），就可以通过种子节点来快速发现网络中的其他节点。</li></ol><h2 id="节点通信简述"><a href="#节点通信简述" class="headerlink" title="节点通信简述"></a>节点通信简述</h2><p>比特币节点通常采用TCP协议、使用8333端口与相邻节点建立连接, 建立连接时也会有认证“握手”的通信过程，用来确定协议版本，软件版本，节点IP，区块高度等。</p><p>当节点连接到相邻节点后，接着就开始跟相邻节点同步区块链数据（轻量级钱包应用其实不会同步所有区块数据），节点们会交换一个getblocks消息，它包含本地区块链最顶端的哈希值。如果某个节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，就说其自身的本地区块链比其他节点的区块链更长，并告诉其他节点需要补充区块，其他节点发送getdata消息来请求区块，验证后更新到本地区块链中。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币如何挖矿（挖矿原理）-工作量证明</title>
      <link href="/2018/bitcoin-pow/bitcoin-pow/"/>
      <url>/2018/bitcoin-pow/bitcoin-pow/</url>
      
        <content type="html"><![CDATA[<p>在<a href="">区块链记账原理</a>一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。<br>我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。</p><h2 id="记账工作"><a href="#记账工作" class="headerlink" title="记账工作"></a>记账工作</h2><p>由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是12.5比特币，博文写作时每个比特币是5万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：</p><ul><li>一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功</li><li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li><li>其他节点复制记账结果</li></ul><p>不过在进行工作量证明之前，记账节点会做进行如下准备工作：</p><ul><li>收集广播中还没有被记录账本的原始交易信息</li><li>检查每个交易信息中付款地址有没有足够的余额</li><li>验证交易是否有正确的签名</li><li>把验证通过的交易信息进行打包记录</li><li>添加一个奖励交易：给自己的地址增加12.5比特币</li></ul><p>如果节点争夺记账权成功的话，就可以得到12.5比特币的奖励。</p><h2 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h2><p><a href="">区块链记账原理</a>我们了解到，每次记账的时候会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash。<br>如果仅仅是这样，显然每个人都可以很轻松的完成记账。<br>为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。</p><p>用伪代码表示一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 没有难度时为：Hash(上一个Hash值，交易记录集) = 456635BCD</span><br><span class="line">Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD</span><br></pre></td></tr></table></figure><h3 id="计算量分析"><a href="#计算量分析" class="headerlink" title="计算量分析"></a>计算量分析</h3><blockquote><p>（这部分可选阅读）</p></blockquote><p>我们简单分析下记账难度有多大，<br>Hash值是由数字和大小写字母构成的字符串，每一位有62种可能性（可能为26个大写字母、26个小写字母，10个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为0的概率是1&#x2F;62（其他位出现什么字符先不管），理论上需要尝试62次Hash运算才会出现一次第一位为0的情况，如果前两2位为0，就得尝试62的平方次Hash运算，以n个0开头就需要尝试62的n次方次运算。我们结合当前实际区块#493050信息来看看：</p><p><img src="/img/block_info_493050.jpg"></p><p>注：数据来源于<a href="https://blockchain.info/">https://blockchain.info</a><br>我们可以看到Hash值以18个0开头，理论上需要尝试62的18次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，<br>目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。</p><p>从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。</p><p>题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。</p><p>如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。<br>网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。</p><p>假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。</p><p>进阶阅读<a href="https://xiaozhuanlan.com/topic/1402935768">比特币区块结构Merkle树及简单支付验证分析</a>，可以详细了解区块结构如何验证交易。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>矿工的收益其实不仅仅包含新发行的12.5比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。</p><p>有兴趣的同学可以看看图中区块都包含了那些信息，红箭头标示出的是本文涉及的信息。</p><p>本文中有提到共识协议，比特币共识协议主要是由工作量证明和最长链机制 两部分组成，请阅读<a href="https://xiaozhuanlan.com/topic/0298513746">比特币如何达成共识 - 最长链的选择</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 区块链 </tag>
            
            <tag> 工作量证明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币所有权及隐私问题-非对称加密应用</title>
      <link href="/2018/bitcoin-own/index/"/>
      <url>/2018/bitcoin-own/index/</url>
      
        <content type="html"><![CDATA[<p>比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？<br>如果你对这个问题还不是很明白，那就一起来看看吧。</p><h2 id="银行系统"><a href="#银行系统" class="headerlink" title="银行系统"></a>银行系统</h2><p>我们先来回顾下现实的银行系统：</p><ol><li>首先我们需要把我们的个人信息（如身份证）给银行，银行给我们开立相对应的账户，银行在开户的时候确立了对账户的所有权。</li><li>进行支付的时候，银行对交易双方完成转账（银行在开户的时候已经知道我们对应的账户）。<br>同时银行会对账户信息进行保密（这点其实不能保证）。</li></ol><h2 id="匿名账本"><a href="#匿名账本" class="headerlink" title="匿名账本"></a>匿名账本</h2><p>那么比特币如何在没有第三方银行的参与下，在确保隐私的同时如何确定账户所有权的呢？</p><p>实际上比特币的账户是用地址来表示，账本上不显示个人信息，转账是把比特币从一个地址转移到另一个地址。<br>转账记录如这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;付款地址&quot;</span><span class="punctuation">:</span><span class="string">&quot;2A39CBa2390FDe&quot;</span></span><br><span class="line">    <span class="attr">&quot;收款地址&quot;</span><span class="punctuation">:</span><span class="string">&quot;AAC9CBa239aFcc&quot;</span></span><br><span class="line">    <span class="attr">&quot;金额&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.2btc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来问题就变为了 谁有权用某个地址进行付款。</p><blockquote><p>支付和所有权 实际是同一个问题，如果此比特币只有我可以用来支付，那么说明我拥有所有权</p></blockquote><h2 id="地址与私钥"><a href="#地址与私钥" class="headerlink" title="地址与私钥"></a>地址与私钥</h2><p>比特币的解决方案是，谁拥有某个地址的私钥(如果完全没有加密概念的人，可以简单的把私钥当作密码)，谁就能用这个地址进行支付。（所以私钥一定保管好，如果私钥泄漏，比特币就可能丢失）</p><p>比特币地址和私钥是一个非对称的关系，私钥经过一系列运算（其中有两次Hash）之后，可以得到地址, 但是无法从地址反推得到私钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址： 2A39CBa2390FDe</span><br><span class="line">私钥： sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal</span><br><span class="line"></span><br><span class="line">Hash(Hash(fun(sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal)))  -&gt; 2A39CBa2390FDe</span><br></pre></td></tr></table></figure><blockquote><p>银行系统银行账号和密码是完全独立的，无法互相推导，转出时需要同时验证账号和密码</p></blockquote><p>还是上面交易的例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="string">&quot;付款地址&quot;</span>：<span class="string">&quot;2A39CBa2390FDe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;收款地址&quot;</span>：<span class="string">&quot;AAC9CBa239aFcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;金额&quot;</span>：<span class="string">&quot;0.2btc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>只有拥有地址2A39CBa2390FDe的私钥才能进行支付。</p><h2 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h2><p>这个时候问题就变为了，如何证明你拥有某个地址的私钥（在不泄漏私钥的情况下）。</p><h3 id="对交易信息进行签名"><a href="#对交易信息进行签名" class="headerlink" title="对交易信息进行签名"></a>对交易信息进行签名</h3><p>实际在签名之前，会先对交易信息进行Hash运算得到摘要信息，然后对摘要信息进行签名。过程大概是这样：</p><ol><li>对交易进行hash， 得到一个摘要信息（Hash值）</li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash(&#x27;</span><br><span class="line">    &#123;&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;,</span><br><span class="line">    &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;,</span><br><span class="line">    &quot;金额&quot;：&quot;0.2btc&quot;</span><br><span class="line">    &#125;&#x27;) -&gt; 8aDB23CDEA6</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>用私钥对交易摘要进行签名（付款方在安全的环境下进行，以避免私钥泄密）, 用代码表示大概是这样。</li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#参数1为交易摘要</span><br><span class="line">#参数2为私钥</span><br><span class="line">#返回签名信息</span><br><span class="line">sign(&quot;8aDB23CDEA6&quot;, &quot;J78sknJhidhLIqdngalket&quot;) -&gt; &quot;3cdferdadgadg&quot;</span><br></pre></td></tr></table></figure><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>在签名运算之后，付款节点就开始在全网进行广播：我支付了0.2btc到AAC9CBa239aFcc,签名信息是3cdferdadgadg，你们来确认一下吧。</p><p>广播过程实际上是发信息到相连的其它节点，其它节点在验证通过后再转发到与之相连的节点，这样的扩散过程。</p><p>广播的信息包含了交易原始信息和签名信息</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>其它节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去。<br>（实际还会验证付款账号有没有足够的余额，我们暂时忽略这点）<br>验证过程实际是签名过程的逆运算，用代码表示大概过程是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#参数1为签名信息</span><br><span class="line">#参数2为付款方地址</span><br><span class="line">#返回交易摘要</span><br><span class="line">verify(&quot;3cdferdadgadg&quot;, &quot;2A39CBa2390FDe&quot;) -&gt; &quot;8aDB23CDEA6&quot;</span><br></pre></td></tr></table></figure><p>如果验证输出的信息和原始交易信息的hash一致，则验证通过，记录账本，用代码表示大概是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(verify(&quot;3cdferdadgadg&quot;, &quot;2A39CBa2390FDe&quot;)</span><br><span class="line">    == hash(&#x27;&#123;&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;,</span><br><span class="line">              &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;,</span><br><span class="line">              &quot;金额&quot;：&quot;0.2btc&quot;&#125;&#x27;)) :</span><br><span class="line">    # 写入账本</span><br><span class="line">    # 广播</span><br><span class="line">else:</span><br><span class="line">   # donothing</span><br></pre></td></tr></table></figure><p>大家可以理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程(为方便大家理解，严格来讲是不准确的)。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>上面为了更好的理解，我对一些信息进行了简化。</p><p>比特币系统使用了椭圆曲线签名算法，算法的私钥由32个字节随机数组成，通过私钥可以计算出公钥，公钥经过一序列哈希算法和编码算法得到比特币地址，地址也可以理解为公钥的摘要。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 区块链 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python从零开始创建区块链</title>
      <link href="/2018/build_blockchain_by_python/index/"/>
      <url>/2018/build_blockchain_by_python/index/</url>
      
        <content type="html"><![CDATA[<p><em>本文主要内容翻译自<a href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46">Learn Blockchains by Building One</a></em></p><p>作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。</p><p>对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。</p><p>但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。</p><p>我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。</p><p>如果你还不是很了解哈希，可以查看<a href="https://learncryptography.com/hash-functions/what-are-hash-functions">这篇文章</a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>环境准备，确保已经安装Python3.6+, pip , Flask, requests<br>安装方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask==0.12.2 requests==2.18.4</span><br></pre></td></tr></table></figure><p>同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。</p><p>参考<a href="https://github.com/xilibi2003/blockchain">源代码</a></p><h2 id="开始创建Blockchain"><a href="#开始创建Blockchain" class="headerlink" title="开始创建Blockchain"></a>开始创建Blockchain</h2><p>新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码</p><h3 id="Blockchain类"><a href="#Blockchain类" class="headerlink" title="Blockchain类"></a>Blockchain类</h3><p>首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。<br>以下是Blockchain类的框架:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.chain = []</span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Creates a new Block and adds it to the chain</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_transaction</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Adds a new transaction to the list of transactions</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">block</span>):</span><br><span class="line">        <span class="comment"># Hashes a Block</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Returns the last Block in the chain</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。</p><h3 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h3><p>每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。</p><p>以下是一个区块的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">block = &#123;</span><br><span class="line">    &#x27;index&#x27;: 1,</span><br><span class="line">    &#x27;timestamp&#x27;: 1506057125.900785,</span><br><span class="line">    &#x27;transactions&#x27;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &#x27;sender&#x27;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;,</span><br><span class="line">            &#x27;recipient&#x27;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;,</span><br><span class="line">            &#x27;amount&#x27;: 5,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &#x27;proof&#x27;: 324984774000,</span><br><span class="line">    &#x27;previous_hash&#x27;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考<a href="">区块链记账原理</a></p><h3 id="加入交易"><a href="#加入交易" class="headerlink" title="加入交易"></a>加入交易</h3><p>接下来我们需要添加一个交易，来完善下new_transaction方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_transaction</span>(<span class="params">self, sender, recipient, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成新交易信息，信息将加入到下一个待挖的区块中</span></span><br><span class="line"><span class="string">        :param sender: &lt;str&gt; Address of the Sender</span></span><br><span class="line"><span class="string">        :param recipient: &lt;str&gt; Address of the Recipient</span></span><br><span class="line"><span class="string">        :param amount: &lt;int&gt; Amount</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            <span class="string">&#x27;sender&#x27;</span>: sender,</span><br><span class="line">            <span class="string">&#x27;recipient&#x27;</span>: recipient,</span><br><span class="line">            <span class="string">&#x27;amount&#x27;</span>: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_block[<span class="string">&#x27;index&#x27;</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。</p><h3 id="创建新块"><a href="#创建新块" class="headerlink" title="创建新块"></a>创建新块</h3><p>当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。<br>每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。</p><p>为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.current_transactions = []</span><br><span class="line">        self.chain = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create the genesis block</span></span><br><span class="line">        self.new_block(previous_hash=<span class="number">1</span>, proof=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_block</span>(<span class="params">self, proof, previous_hash=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成新块</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm</span></span><br><span class="line"><span class="string">        :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block</span></span><br><span class="line"><span class="string">        :return: &lt;dict&gt; New Block</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        block = &#123;</span><br><span class="line">            <span class="string">&#x27;index&#x27;</span>: <span class="built_in">len</span>(self.chain) + <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: time(),</span><br><span class="line">            <span class="string">&#x27;transactions&#x27;</span>: self.current_transactions,</span><br><span class="line">            <span class="string">&#x27;proof&#x27;</span>: proof,</span><br><span class="line">            <span class="string">&#x27;previous_hash&#x27;</span>: previous_hash <span class="keyword">or</span> self.<span class="built_in">hash</span>(self.chain[-<span class="number">1</span>]),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reset the current list of transactions</span></span><br><span class="line">        self.current_transactions = []</span><br><span class="line"></span><br><span class="line">        self.chain.append(block)</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_transaction</span>(<span class="params">self, sender, recipient, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成新交易信息，信息将加入到下一个待挖的区块中</span></span><br><span class="line"><span class="string">        :param sender: &lt;str&gt; Address of the Sender</span></span><br><span class="line"><span class="string">        :param recipient: &lt;str&gt; Address of the Recipient</span></span><br><span class="line"><span class="string">        :param amount: &lt;int&gt; Amount</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt; The index of the Block that will hold this transaction</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.current_transactions.append(&#123;</span><br><span class="line">            <span class="string">&#x27;sender&#x27;</span>: sender,</span><br><span class="line">            <span class="string">&#x27;recipient&#x27;</span>: recipient,</span><br><span class="line">            <span class="string">&#x27;amount&#x27;</span>: amount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_block[<span class="string">&#x27;index&#x27;</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.chain[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">block</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成块的 SHA-256 hash值</span></span><br><span class="line"><span class="string">        :param block: &lt;dict&gt; Block</span></span><br><span class="line"><span class="string">        :return: &lt;str&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We must make sure that the Dictionary is Ordered, or we&#x27;ll have inconsistent hashes</span></span><br><span class="line">        block_string = json.dumps(block, sort_keys=<span class="literal">True</span>).encode()</span><br><span class="line">        <span class="keyword">return</span> hashlib.sha256(block_string).hexdigest()</span><br></pre></td></tr></table></figure><p>通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。</p><h3 id="理解工作量证明"><a href="#理解工作量证明" class="headerlink" title="理解工作量证明"></a>理解工作量证明</h3><p>新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，<strong>这个数字很难计算出来，但容易验证。</strong> 这就是工作量证明的核心思想。</p><p>为了方便理解，举个例子：</p><p>假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) &#x3D; ac23dc…0。设变量 x &#x3D; 5，求 y 的值？</p><p>用Python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">0</span>  <span class="comment"># y未知</span></span><br><span class="line"><span class="keyword">while</span> sha256(<span class="string">f&#x27;<span class="subst">&#123;x*y&#125;</span>&#x27;</span>.encode()).hexdigest()[-<span class="number">1</span>] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">    y += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;The solution is y = <span class="subst">&#123;y&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果是y&#x3D;21. 因为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(5 * 21) = 1253e9373e...5e3600155e860</span><br></pre></td></tr></table></figure><p>在比特币中，使用称为<a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a>的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。<br>当然，在网络上非常容易验证这个结果。</p><h3 id="实现工作量证明"><a href="#实现工作量证明" class="headerlink" title="实现工作量证明"></a>实现工作量证明</h3><p>让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">proof_of_work</span>(<span class="params">self, last_proof</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        简单的工作量证明:</span></span><br><span class="line"><span class="string">         - 查找一个 p&#x27; 使得 hash(pp&#x27;) 以4个0开头</span></span><br><span class="line"><span class="string">         - p 是上一个块的证明,  p&#x27; 是当前的证明</span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt;</span></span><br><span class="line"><span class="string">        :return: &lt;int&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        proof = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> self.valid_proof(last_proof, proof) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            proof += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proof</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">valid_proof</span>(<span class="params">last_proof, proof</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        验证证明: 是否hash(last_proof, proof)以4个0开头?</span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt; Previous Proof</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; Current Proof</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if correct, False if not.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        guess = <span class="string">f&#x27;<span class="subst">&#123;last_proof&#125;</span><span class="subst">&#123;proof&#125;</span>&#x27;</span>.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        <span class="keyword">return</span> guess_hash[:<span class="number">4</span>] == <span class="string">&quot;0000&quot;</span></span><br></pre></td></tr></table></figure><p>衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。</p><p>现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。</p><h2 id="Blockchain作为API接口"><a href="#Blockchain作为API接口" class="headerlink" title="Blockchain作为API接口"></a>Blockchain作为API接口</h2><p>我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。</p><p>我们将创建三个接口：</p><ul><li>&#x2F;transactions&#x2F;new 创建一个交易并添加到区块</li><li>&#x2F;mine 告诉服务器去挖掘新的区块</li><li>&#x2F;chain 返回整个区块链</li></ul><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate our Node</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a globally unique address for this node</span></span><br><span class="line">node_identifier = <span class="built_in">str</span>(uuid4()).replace(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate the Blockchain</span></span><br><span class="line">blockchain = Blockchain()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/mine&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mine</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;We&#x27;ll mine a new Block&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/transactions/new&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_transaction</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;We&#x27;ll add a new transaction&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/chain&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">full_chain</span>():</span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">&#x27;chain&#x27;</span>: blockchain.chain,</span><br><span class="line">        <span class="string">&#x27;length&#x27;</span>: <span class="built_in">len</span>(blockchain.chain),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>简单的说明一下以上代码：<br>第15行: 创建一个节点.<br>第18行: 为节点创建一个随机的名字.<br>第21行: 实例Blockchain类.<br>第24–26行: 创建&#x2F;mine GET接口。<br>第28–30行: 创建&#x2F;transactions&#x2F;new POST接口,可以给接口发送交易数据.<br>第32–38行: 创建 &#x2F;chain 接口, 返回整个区块链。<br>第40–41行: 服务运行在端口5000上.</p><h3 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h3><p>发送到节点的交易数据结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;sender&quot;: &quot;my address&quot;,</span><br><span class="line"> &quot;recipient&quot;: &quot;someone else&#x27;s address&quot;,</span><br><span class="line"> &quot;amount&quot;: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前已经有添加交易的方法，基于接口来添加交易就很简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/transactions/new&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_transaction</span>():</span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check that the required fields are in the POST&#x27;ed data</span></span><br><span class="line">    required = [<span class="string">&#x27;sender&#x27;</span>, <span class="string">&#x27;recipient&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(k <span class="keyword">in</span> values <span class="keyword">for</span> k <span class="keyword">in</span> required):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Missing values&#x27;</span>, <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a new Transaction</span></span><br><span class="line">    index = blockchain.new_transaction(values[<span class="string">&#x27;sender&#x27;</span>], values[<span class="string">&#x27;recipient&#x27;</span>], values[<span class="string">&#x27;amount&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    response = &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">f&#x27;Transaction will be added to Block <span class="subst">&#123;index&#125;</span>&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">201</span></span><br></pre></td></tr></table></figure><h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>挖矿正是神奇所在，它很简单，做了一下三件事：</p><ol><li>计算工作量证明PoW</li><li>通过新增一个交易授予矿工（自己）一个币</li><li>构造新区块并将其添加到链中</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/mine&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mine</span>():</span><br><span class="line">    <span class="comment"># We run the proof of work algorithm to get the next proof...</span></span><br><span class="line">    last_block = blockchain.last_block</span><br><span class="line">    last_proof = last_block[<span class="string">&#x27;proof&#x27;</span>]</span><br><span class="line">    proof = blockchain.proof_of_work(last_proof)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给工作量证明的节点提供奖励.</span></span><br><span class="line">    <span class="comment"># 发送者为 &quot;0&quot; 表明是新挖出的币</span></span><br><span class="line">    blockchain.new_transaction(</span><br><span class="line">        sender=<span class="string">&quot;0&quot;</span>,</span><br><span class="line">        recipient=node_identifier,</span><br><span class="line">        amount=<span class="number">1</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forge the new Block by adding it to the chain</span></span><br><span class="line">    block = blockchain.new_block(proof)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">&#x27;message&#x27;</span>: <span class="string">&quot;New Block Forged&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;index&#x27;</span>: block[<span class="string">&#x27;index&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;transactions&#x27;</span>: block[<span class="string">&#x27;transactions&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;proof&#x27;</span>: block[<span class="string">&#x27;proof&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;previous_hash&#x27;</span>: block[<span class="string">&#x27;previous_hash&#x27;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br></pre></td></tr></table></figure><p>注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下</p><h2 id="运行区块链"><a href="#运行区块链" class="headerlink" title="运行区块链"></a>运行区块链</h2><p>你可以使用cURL 或Postman 去和API进行交互</p><p>启动server:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python blockchain.py</span><br><span class="line">* Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>让我们通过请求 <a href="http://localhost:5000/mine">http://localhost:5000/mine</a> 来进行挖矿</p><p><img src="/img/postman_get_mine.png"></p><p>通过post请求，添加一个新交易</p><p><img src="/img/postman_post_new.png"></p><p>如果不是使用Postman，则用一下的cURL语句也是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line"> &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;,</span><br><span class="line"> &quot;recipient&quot;: &quot;someone-other-address&quot;,</span><br><span class="line"> &quot;amount&quot;: 5</span><br><span class="line">&#125;&#x27; &quot;http://localhost:5000/transactions/new&quot;</span><br></pre></td></tr></table></figure><p>在挖了两次矿之后，就有3个块了，通过请求 <a href="http://localhost:5000/chain">http://localhost:5000/chain</a> 可以得到所有的块信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;chain&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot;: 1,</span><br><span class="line">      &quot;previous_hash&quot;: 1,</span><br><span class="line">      &quot;proof&quot;: 100,</span><br><span class="line">      &quot;timestamp&quot;: 1506280650.770839,</span><br><span class="line">      &quot;transactions&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot;: 2,</span><br><span class="line">      &quot;previous_hash&quot;: &quot;c099bc...bfb7&quot;,</span><br><span class="line">      &quot;proof&quot;: 35293,</span><br><span class="line">      &quot;timestamp&quot;: 1506280664.717925,</span><br><span class="line">      &quot;transactions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;amount&quot;: 1,</span><br><span class="line">          &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;,</span><br><span class="line">          &quot;sender&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot;: 3,</span><br><span class="line">      &quot;previous_hash&quot;: &quot;eff91a...10f2&quot;,</span><br><span class="line">      &quot;proof&quot;: 35089,</span><br><span class="line">      &quot;timestamp&quot;: 1506280666.1086972,</span><br><span class="line">      &quot;transactions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;amount&quot;: 1,</span><br><span class="line">          &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;,</span><br><span class="line">          &quot;sender&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;length&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一致性-共识"><a href="#一致性-共识" class="headerlink" title="一致性(共识)"></a>一致性(共识)</h2><p>我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。</p><h3 id="注册节点"><a href="#注册节点" class="headerlink" title="注册节点"></a>注册节点</h3><p>在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口：</p><ol><li>&#x2F;nodes&#x2F;register 接收URL形式的新节点列表</li><li>&#x2F;nodes&#x2F;resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链</li></ol><p>我们修改下Blockchain的init函数并提供一个注册节点方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        self.nodes = <span class="built_in">set</span>()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register_node</span>(<span class="params">self, address</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a new node to the list of nodes</span></span><br><span class="line"><span class="string">        :param address: &lt;str&gt; Address of node. Eg. &#x27;http://192.168.0.5:5000&#x27;</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        parsed_url = urlparse(address)</span><br><span class="line">        self.nodes.add(parsed_url.netloc)</span><br></pre></td></tr></table></figure><p>我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。</p><h3 id="实现共识算法"><a href="#实现共识算法" class="headerlink" title="实现共识算法"></a>实现共识算法</h3><p>前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。</p><p>我们使用一下的算法，来达到网络中的共识</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">valid_chain</span>(<span class="params">self, chain</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Determine if a given blockchain is valid</span></span><br><span class="line"><span class="string">        :param chain: &lt;list&gt; A blockchain</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if valid, False if not</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        last_block = chain[<span class="number">0</span>]</span><br><span class="line">        current_index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current_index &lt; <span class="built_in">len</span>(chain):</span><br><span class="line">            block = chain[current_index]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;last_block&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;block&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n-----------\n&quot;</span>)</span><br><span class="line">            <span class="comment"># Check that the hash of the block is correct</span></span><br><span class="line">            <span class="keyword">if</span> block[<span class="string">&#x27;previous_hash&#x27;</span>] != self.<span class="built_in">hash</span>(last_block):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Check that the Proof of Work is correct</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.valid_proof(last_block[<span class="string">&#x27;proof&#x27;</span>], block[<span class="string">&#x27;proof&#x27;</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            last_block = block</span><br><span class="line">            current_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_conflicts</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        共识算法解决冲突</span></span><br><span class="line"><span class="string">        使用网络中最长的链.</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True 如果链被取代, 否则为False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        neighbours = self.nodes</span><br><span class="line">        new_chain = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We&#x27;re only looking for chains longer than ours</span></span><br><span class="line">        max_length = <span class="built_in">len</span>(self.chain)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Grab and verify the chains from all the nodes in our network</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> neighbours:</span><br><span class="line">            response = requests.get(<span class="string">f&#x27;http://<span class="subst">&#123;node&#125;</span>/chain&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                length = response.json()[<span class="string">&#x27;length&#x27;</span>]</span><br><span class="line">                chain = response.json()[<span class="string">&#x27;chain&#x27;</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check if the length is longer and the chain is valid</span></span><br><span class="line">                <span class="keyword">if</span> length &gt; max_length <span class="keyword">and</span> self.valid_chain(chain):</span><br><span class="line">                    max_length = length</span><br><span class="line">                    new_chain = chain</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Replace our chain if we discovered a new, valid chain longer than ours</span></span><br><span class="line">        <span class="keyword">if</span> new_chain:</span><br><span class="line">            self.chain = new_chain</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof.</p><p>第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性，<strong>如果发现有效更长链，就替换掉自己的链</strong></p><p>让我们添加两个路由，一个用来注册节点，一个用来解决冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&#x27;/nodes/register&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def register_nodes():</span><br><span class="line">    values = request.get_json()</span><br><span class="line"></span><br><span class="line">    nodes = values.get(&#x27;nodes&#x27;)</span><br><span class="line">    if nodes is None:</span><br><span class="line">        return &quot;Error: Please supply a valid list of nodes&quot;, 400</span><br><span class="line"></span><br><span class="line">    for node in nodes:</span><br><span class="line">        blockchain.register_node(node)</span><br><span class="line"></span><br><span class="line">    response = &#123;</span><br><span class="line">        &#x27;message&#x27;: &#x27;New nodes have been added&#x27;,</span><br><span class="line">        &#x27;total_nodes&#x27;: list(blockchain.nodes),</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(response), 201</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/nodes/resolve&#x27;, methods=[&#x27;GET&#x27;])</span><br><span class="line">def consensus():</span><br><span class="line">    replaced = blockchain.resolve_conflicts()</span><br><span class="line"></span><br><span class="line">    if replaced:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &#x27;message&#x27;: &#x27;Our chain was replaced&#x27;,</span><br><span class="line">            &#x27;new_chain&#x27;: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line">    else:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &#x27;message&#x27;: &#x27;Our chain is authoritative&#x27;,</span><br><span class="line">            &#x27;chain&#x27;: blockchain.chain</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return jsonify(response), 200</span><br></pre></td></tr></table></figure><p>你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：<a href="http://localhost:5000/">http://localhost:5000</a> 和 <a href="http://localhost:5001/">http://localhost:5001</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipenv run python blockchain.py</span><br><span class="line">pipenv run python blockchain.py -p 5001</span><br></pre></td></tr></table></figure><p><img src="/img/postman_register.png"></p><p>然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口&#x2F;nodes&#x2F;resolve ,这时节点1的链会通过共识算法被节点2的链取代。</p><p><img src="/img/postman_resolve.png"></p><p>好啦，你可以邀请朋友们一起来测试你的区块链</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链记账原理</title>
      <link href="/2018/whatbc/index/"/>
      <url>/2018/whatbc/index/</url>
      
        <content type="html"><![CDATA[<p>区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。<br>通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0<br>很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。<br>本文将讲解区块链1.0技术是如何实现的。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>在讲区块链记账之前，先说明一下哈希函数。<br>哈希函数：Hash(原始信息) &#x3D; 摘要信息<br>原始信息可以是任意的信息, hash之后会得到一个简短的摘要信息</p><p>哈希函数有几个特点:</p><ul><li>同样的原始信息用同一个哈希函数总能得到相同的摘要信息</li><li>原始信息任何微小的变化都会哈希出面目全非的摘要信息</li><li>从摘要信息无法逆向推算出原始信息</li></ul><p>举例说明：<br>Hash(张三借给李四100万，利息1%，1年后还本息 …..) &#x3D; AC4635D34DEF<br>账本上记录了AC4635D34DEF这样一条记录。</p><p>可以看出哈希函数有4个作用：</p><ul><li>简化信息<br>很好理解，哈希后的信息变短了。</li><li>标识信息<br>可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。</li><li>隐匿信息<br>账本是AC4635D34DEF这样一条记录，原始信息被隐匿。</li><li>验证信息<br>假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证原始信息</li></ul><p>哈希函数的这4个作用在区块链技术里有广泛的运用。<br>（哈希函数是一组函数或算法，以后会发文章专门介绍哈希）</p><h2 id="区块链记账方法"><a href="#区块链记账方法" class="headerlink" title="区块链记账方法"></a>区块链记账方法</h2><p>假设有一个账页序号为0的账页交易记录如下:</p><table><thead><tr><th>账号</th><th>入账</th><th>出账</th><th>余额</th><th>备注说明</th></tr></thead><tbody><tr><td>王二</td><td>100</td><td></td><td>190</td><td>收到xxx货款</td></tr><tr><td>张三</td><td></td><td>100</td><td>30</td><td>xxxx</td></tr><tr><td>李四</td><td>120</td><td>90</td><td>170</td><td>xxxx</td></tr></tbody></table><p>记账时间为：2017-10-22 10:22:02</p><p>区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(序号0、记账时间、交易记录) = 787635ACD</span><br></pre></td></tr></table></figure><p>账页信息和Hash值组合在一起就构成了第一个区块。</p><blockquote><p>比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟</p></blockquote><p>在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD</span><br></pre></td></tr></table></figure><p>这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。</p><p>所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。</p><p>记账有成本，想了解节点为什么要记账，请看这篇：<a href="">在比特币如何挖矿-工作量证明</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链技术 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币是什么</title>
      <link href="/2018/whatisbitcoin/index/"/>
      <url>/2018/whatisbitcoin/index/</url>
      
        <content type="html"><![CDATA[<p>对于比特币也许一千个人有一千种理解。本文作为入门篇（写给完全没有了解过比特币概念的新手，老手可忽略），我尽量用简单易懂的语言来介绍比特币。<br>到底什么是比特币，它到底是怎么运行的呢。</p><h2 id="比特币是什么"><a href="#比特币是什么" class="headerlink" title="比特币是什么"></a>比特币是什么</h2><blockquote><p>比特币是一种基于分布式网络的数字货币。<br>比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。</p></blockquote><p>本文主要讲解狭义的比特币概念。</p><h3 id="数字货币是什么"><a href="#数字货币是什么" class="headerlink" title="数字货币是什么"></a>数字货币是什么</h3><p>凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币）</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>大家知道，在银行系统的数据库里记录着跟我们身份id对应的财产，下文称这样的记录为账本，如张三的卡10月1日转入1w, 余额10w。<br>比特币系统也同样有这样的账本，不同银行由单一的组织负责记录,比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。<br>同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从1万改为1百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。</p><p>比特币使用区块链技术来支撑整个系统的运行，有兴趣的同学，可以详细阅读下这几篇博文：</p><ul><li><a href="">区块链记账原理</a></li><li><a href="">比特币所有权问题</a></li><li><a href="">比特币如何挖矿</a></li></ul><p>还可进阶阅读：<br><a href="https://xiaozhuanlan.com/topic/1670539284">分析比特币网络：一种去中心化、点对点的网络架构</a>，可以详细了解比特币网络。<br><a href="https://xiaozhuanlan.com/topic/1402935768">比特币区块结构Merkle树及简单支付验证分析</a>，可以详细了解区块结构如何验证交易。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 区块链技术 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习区块链</title>
      <link href="/2018/learnblockchain/index/"/>
      <url>/2018/learnblockchain/index/</url>
      
        <content type="html"><![CDATA[<p>区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。<br>区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。<br>如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。</p><h2 id="确定方向"><a href="#确定方向" class="headerlink" title="确定方向"></a>确定方向</h2><p>从事区块链开发也有很多方向，如:区块链应用开发人员、区块链架构师、底层核心开发、共识算法研究等等。</p><p>方向不同，需要学习的内容就不一样，如果做基于区块链应用开发，只需要了解一门编程语言（nodejs, Go, Python, C++ 等）, 大概了解区块链的原理，不一定要深入，当能理解越深入开发应用就越顺。<br>如果做区块链基础开发，就需要了解加密算法，P2P通信，共识算法等等。</p><h2 id="投入时间学习-动手实践"><a href="#投入时间学习-动手实践" class="headerlink" title="投入时间学习-动手实践"></a>投入时间学习-动手实践</h2><p>由于区块链涉及的技术很多，可以相对各个技术有一个概念了解，再逐步深入原理。</p><p>当你在学习了解概念的时候，必定会产生很多疑问， 例如我们经常可以看到一句： 比特币的共识机制是通过工作量证明（POW）来实现的。<br>就有了新疑问:什么是工作量证明，进一步了解，它是通过验证的一个特定结果，就能确认参与者完成了相应的工作量（不理解没关系，可以简单为，张三考试考了100分，就确认张三肯定好好学习了）。<br>这时又有了新的疑问，比特币在验证什么样的结果，这时你又需要了解密码学和Hash。</p><p>逐步深入的过程也是解答疑问的过程，需要我们善用Google搜索。</p><p>如果觉得已进理解一个概念或原理时，可以尝试动手实现它，如在理解挖矿后，可以写代码模拟挖矿过程。</p><p>学习是一个长期的过期，没有捷径，必须得多读书，读代码，写代码。</p><h2 id="学习资源介绍"><a href="#学习资源介绍" class="headerlink" title="学习资源介绍"></a>学习资源介绍</h2><p>下面是一些学习资源的介绍，相信对大家有帮助</p><ul><li><p><a href="https://www.bitcoin.com/bitcoin.pdf">比特币:一种点对点的电子现金系统-英文</a></p></li><li><p><a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币:一种点对点的电子现金系统-中文</a></p></li><li><p><a href="https://github.com/ethereum/wiki/wiki/White-Paper">以太坊白皮书-英文</a></p></li><li><p><a href="http://ethfans.org/posts/ethereum-whitepaper">以太坊白皮书-中文</a></p></li><li><p><a href="https://www.gitbook.com/book/yeasy/blockchain_guide/details">区块链技术指南-电子书</a></p></li><li><p><a href="https://item.jd.com/12114753.html">区块链开发指南-纸书</a></p></li><li><p><a href="https://bitcoin.org/en/">比特币 - 官网</a></p></li><li><p><a href="https://github.com/ethereum">以太坊 - github</a></p></li><li><p><a href="https://github.com/hyperledger/hyperledger">超级账本Hyperledger</a></p></li><li><p><a href="http://ethfans.org/">ETHFANS - 社区</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习有意思！ 03》- 深度学习与卷积神经网络</title>
      <link href="/2018/funny_machine_learning_3/index/"/>
      <url>/2018/funny_machine_learning_3/index/</url>
      
        <content type="html"><![CDATA[<h1 id="《机器学习有意思！-03》-深度学习与卷积神经网络"><a href="#《机器学习有意思！-03》-深度学习与卷积神经网络" class="headerlink" title="《机器学习有意思！ 03》- 深度学习与卷积神经网络"></a>《机器学习有意思！ 03》- 深度学习与卷积神经网络</h1><blockquote><p> <em>原文：<a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721#.8owg5e1ri">Machine Learning is Fun! Part 3 – Deep Learning and Convolutional Neural Networks</a></em><br> <em>作者：Adam Geitgey</em></p></blockquote><hr><p>你是否厌倦了每天被深度学习相关的新闻轰炸却不明所以？此诚求变之机。</p><p>这一次我们将学习如何用深度学习来写程序识别图像中的物体。也可以说我们是要解释Google图片搜索背后的黑科技：Google可以通过描述搜索图片——即使图片没有事先打上标签！这是如何实现的？</p><p>就像<a href="http://blog.buerya.cn/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2018-01-09-funny_machine_learning_1.html">Part 1</a>和<a href="http://blog.buerya.cn/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2018-01-12-funny_machine_learning_2.html">Part 2</a>一样，本指南仍然面向所有对机器学习感兴趣却不知如何开始的朋友们。我们的目标是所有人都读得懂——因而势必无法照顾到每个细节。但那又如何呢？只要能让一位读者对ML感兴趣，那就是功德一件了！</p><hr><h2 id="深度学习识别物体"><a href="#深度学习识别物体" class="headerlink" title="深度学习识别物体"></a>深度学习识别物体</h2><p><img src="/img/funny_machine/10030.png"></p><blockquote><p>产品：每当一名用户拍了照片，APP应该检测他们是否在国家公园……</p></blockquote><blockquote><p>开发：当然了，不过是简单的GIS查询而已，给我几个小时。</p></blockquote><blockquote><p>产品：……以及拍的是不是一只鸟。</p></blockquote><blockquote><p>开发：那我需要一个研究小组和五年时间。</p></blockquote><blockquote><p>旁白：在计算机科学中，有时很难解释“简单”和“根本不可能”之间的区别。</p></blockquote><p>你可能已经在<a href="https://xkcd.com/1425/">xkcd</a>系列漫画中看到过了。</p><p>这里的笑点在于，三岁小孩儿都能认出鸟的照片，但是教会计算机识别物体，已经让最优秀的计算机科学家耗费了50年。</p><p>在过去的几年里，我们终于找到了物体识别的好路子，那就是深度卷积神经网络。这听起来像是从威廉·吉布森的科幻小说里捡了几个词拼起来的，不过只要分解开来细看，其原理真的很简单。</p><p>开始吧——现在就写一个能认识鸟的程序！</p><hr><h2 id="始于足下"><a href="#始于足下" class="headerlink" title="始于足下"></a>始于足下</h2><p>在我们学习如何辨别鸟的照片之前，先来学个简单得多的例子——手写数字”8”。</p><p>在Part 2中，我们已经学习了神经网络如何链接大量的神经元来解决复杂问题。我们搭建了一个迷你神经网络来基于房间数、面积、周边环境预测房价：</p><p><img src="/img/funny_machine/10031.png"></p><p>我们还知道了机器学习的思想就是重复利用相同的普适算法，根据不同的数据，解决不同的问题。下面我们修改这个神经网络来识别手写文本，并且进一步简化任务——只识别数字”8”。</p><p>机器学习只有当你有数据的时候才好使——数据越多越好，所以我们需要大量的手写”8”来开始。所幸，研究者们为了这一目的已经建立了<a href="http://yann.lecun.com/exdb/mnist/">MNIST手写数字数据集</a>。<code>MNIST</code>提供了60,000张手写数字的图片，每个尺寸都是18x18，以下是数据集里部分的”8”：</p><p><img src="/img/funny_machine/10032.jpeg" alt="MNIST数据集里的一些8"></p><p><strong>其实不过是数字</strong></p><p>Part 2里搭建的神经网络只读取3个输入（”3”间卧室,”2000”平方米等）。但是现在我们要用神经网络处理图片，不是数字怎么传入神经网络呢？</p><p>答案无比的简单。神经网络以数字为输入，对于计算机来说，图片也不过只是代表了像素明暗的数字：</p><p><img src="/img/funny_machine/10030.gif"></p><p>只要把18x18像素的图片当作324个数字组成的数组，就可以把图片输入给神经网络了。</p><p><img src="/img/funny_machine/10032.png"></p><p>要处理324个输入，我们只需让神经网络具有324个输入节点：</p><p><img src="/img/funny_machine/10033.png"></p><p>注意我们的神经网络现在有两个输出（而非之前的一个）。第一个输出是预测此图为”8”的概率，第二个为不是”8”的概率。每种类型的目标物体有了分别的输出，就可以让神经网络对物体进行分类了。</p><p>这次的神经网络比之前要大得多了（从3个输入到324），但是现代的计算机处理几百个节点的神经网络，连眼都不带眨的，甚至连手机都能轻松满足。</p><p>剩下的就是用”8”和非”8”的数字去训练神经网络以使其能够区分两者了，当我们输入一个”8”，我们告诉神经网络，此图为”8”的概率是100%，非”8”的概率是0%，反之亦反。</p><p>这是我们的训练数据：</p><p><img src="/img/funny_machine/10030.jpeg"></p><p>现在随便一个笔记本电脑，也能在几分钟之内训练完这样一个网络，训练完之后我们就拥有了能够高精度识别数字”8”的神经网络。欢迎来到（1980年代的）图像识别世界！</p><hr><h2 id="管窥"><a href="#管窥" class="headerlink" title="管窥"></a>管窥</h2><p>把像素简单地导入神经网络里一训练，就能识别图像了，感觉无比清爽。机器学习真乃魔法……也？</p><p><em>事情并不简单。</em></p><p>首先，一个好消息是，我们的识8器对于图片正中的数字，效果还是很喜人的：</p><p><img src="/img/funny_machine/10034.png"></p><p>现在坏消息来了：</p><p>当数字不是恰好居中的时候，识8器完全失效了，哪怕一丁点的位置偏差也不行：</p><p><img src="/img/funny_machine/10035.png"></p><p>这是因为，神经网络只学到了恰好居中”8”的模式，但是对于离心的”8”却一无所知，它知道且仅知道一种模式。</p><p>在现实中这就实用价值不大了，因为实际问题不可能总是那么干净简约。所以我们必须让神经网络能够处理离心的”8”。</p><h3 id="暴力方法-1-滑动窗口搜索"><a href="#暴力方法-1-滑动窗口搜索" class="headerlink" title="暴力方法 1. 滑动窗口搜索"></a>暴力方法 1. 滑动窗口搜索</h3><p>我们已经有了一个好方法，能够找到图片中心的”8”，那可不可以在图片上扫描寻找子区域里的”8”，直至找到呢？</p><p><img src="/img/funny_machine/10031.gif"></p><p>这就是滑动窗口法，一种非常暴力的解决方案。在很有限的某些例子中可行，但效率也很低。你必须一遍一遍地寻找不同尺寸的物体，我们可以比这更好。</p><h3 id="暴力方法-2-更多数据，更深网络"><a href="#暴力方法-2-更多数据，更深网络" class="headerlink" title="暴力方法 2. 更多数据，更深网络"></a>暴力方法 2. 更多数据，更深网络</h3><p>当我们在训练网络的时候，只用到了完美居中的”8”。如果我们在训练过程中就引入不同位置、不同大小的”8”，那会怎么样呢？</p><p>不需要收集更多的训练数据，我们可以写个脚本生成新的图片，图中的”8”具有不同的位置和大小：</p><p><img src="/img/funny_machine/10036.png" alt="用已有训练图片的不同视角制成的合成训练数据，这是个挺有用的技术"></p><p>应用这一技术，我们可以轻易创造出无穷多的训练数据。</p><p>更多的数据让问题变得更加复杂了，但是我们可以用更大的神经网络，那样就能学习更复杂的模式。为了扩大网络，我们简单地把节点层堆叠起来：</p><p><img src="/img/funny_machine/10037.png"></p><p>这就是“深度神经网络”，因为比传统神经网络的层数更多。这个想法在1960年代便有了，不过直至最近，训练这么大的神经网络训练还是慢得无法接受。但是自从我们发现了用3d显卡替代传统CPU来加速矩阵计算，大规模神经网络就变得可行了。你用来玩守望先锋的NVIDIA GeForce GTX 1080显卡，也可以用来训练神经网络。</p><p>然而即便我们可以用显卡很快地训练出大规模神经网络，这仍然不是解决方案的全部，我们还需要在处理图片上更加机智才行。</p><p>在暴力方法2中，把图片顶端的”8”和图片底部的”8”当作完全不同的物体，这其实是没有意义的。应该存在一种方案，让神经网络不经额外训练即知：图片不管哪个位置的”8”都是一个东西。万幸，确实是存在的！</p><hr><h2 id="答案：卷积"><a href="#答案：卷积" class="headerlink" title="答案：卷积"></a>答案：卷积</h2><p>生而为人，你可以直观地看出照片中含有层次或概念结构。考虑这张照片：</p><p><img src="/img/funny_machine/10031.jpeg" alt="作者儿子的照片"></p><p>作为一个人类，你立即就能识别出照片里的层次：</p><ul><li><p>地面覆盖了草坪</p></li><li><p>图里有个小孩儿</p></li><li><p>小孩儿骑在弹跳小马上</p></li><li><p>弹跳小马在草坪上</p></li></ul><p>更重要的是，无论小孩在什么样的表面上，我们都能认出那是个小孩儿。我们并不需要重新学习各种表面上的小孩儿。但是目前，神经网络还做不到这些，它会把不同位置的”8”当作完全不同的东西，而并不知道在图片上移动物体不会改变其实质。这意味着网络必须重新学习每个位置上的物体，太悲催了。</p><p>我们需要让神经网络明白平移不变形——“8”还是”8”，不论出现在图片的哪里。这一过程可由卷积实现，卷积的想法部分来自计算机科学，还有部分是受生物学启发（比如，疯狂科学家们真的在猫脑子里插管，以研究猫是怎么处理图像的人）。</p><hr><h2 id="卷积的作用机理"><a href="#卷积的作用机理" class="headerlink" title="卷积的作用机理"></a>卷积的作用机理</h2><p>这次我们不再把整个图片当成一个数字网格输入到神经网络，而是利用物体与位置的独立性，做得更聪明些。以下就是卷积的作用机理，一步一步来——</p><p><strong>第1步：把图片分解为重叠碎片</strong></p><p>与之前的滑动窗口法类似，这里也用一个窗口在整张原图上滑动截图，并且把截到的每一小部分单独存成一个图片：</p><p><img src="/img/funny_machine/10038.png"></p><p>如此我们便把一张大图拆成了77张等尺寸的小图。</p><p><strong>第2步：把每张小图输入小神经网络</strong></p><p>曾经我们把单张图片输入神经网络来判断其是否为”8”，这里再重复一样的工作，不过是针对每一个单独的小图片：</p><p><img src="/img/funny_machine/10039.png" alt="对每个小图片重复77次"></p><p>这里还有一大诀窍：我们将相同的<em>神经网络权重</em>应用在每一块小图上。换言之，我们平等地对待所有小图，如果某个小图里出现了我们感兴趣的内容，我们就将其标记为有趣。</p><p><strong>第3步：把每块小图的结果存入新的阵列</strong></p><p>我们并不想丢失原始小图的排列信息，所以我们要把每个小图的结果按照相同的排列重新构建原图，形式如下：</p><p><img src="/img/funny_machine/10040.png"></p><p>也可以说，我们从一张大图片开始，到小阵列结束，阵列记录了原图当中哪一部分有我们最关心的内容。</p><p><strong>第4步：下采样</strong></p><p>第3步的结果是一个阵列，反映了原图的哪一部分是我们最感兴趣的，不过这个阵列仍然很庞大：</p><p><img src="/img/funny_machine/10041.png"></p><p>为了减小阵列的尺寸，我们用<a href="https://en.wikipedia.org/wiki/Convolutional_neural_network#Pooling_layer">最大池化</a>算法进行下采样。听着很稀奇，其实完全不！</p><p>看阵列中的每个2x2方块，并且只留下最大的数字：</p><p><img src="/img/funny_machine/10042.png"></p><p>这里的主要思路就是，当我们在组成2x2方块的四个输入小图中的任意一个发现了关心的内容，就只保留我们最感兴趣的信息，这可以减小阵列规模并保留最重要的信息。</p><p><strong>最终步：预测</strong></p><p>至此，我们已经把一个巨大的图片消减成了相对较小的阵列，阵列就是一串数，所以我们可以把小阵列输入另一个神经网络，最后的这个神经网络会决定图片是否匹配。为了与卷积层相区分，我们称之为“全连接层”。从头到尾，我们的五步流水线如下图所示：</p><p><img src="/img/funny_machine/10043.png"></p><p><strong>增加更多步骤</strong></p><p>我们的图像处理流水线有一系列步骤：卷积，最大池化，全连接网络。</p><p>而在解决实际问题的时候，这些步骤可以组合起来并堆叠多次。你可以加两个，三个甚至十个卷积层，也可以在任何时候插入一个最大池化层。总之基本思路就是把一张大图，逐步分解为小图，直至我们能够获得结果。卷积层越多，网络就能学习识别越复杂的特征。</p><p>比如说，第一个卷积层可能学会了辨认锐利边缘，第二个卷积层可能根据锐边的知识学会了识别鸟喙，第三个卷积层又基于鸟喙识别出了整只鸟。以下是更贴近实践的深度卷积网络结构（学术论文里常见）：</p><p><img src="/img/funny_machine/10044.png"></p><p>在这一实例中，他们从224x224像素的图片开始，应用了：卷积，两次最大池化，三次卷积，又是两次最大池化，最后是两个全连接层。最终的结果可以将图片从1000个分类中识别出来。</p><p><strong>构建正确的网络</strong></p><p>那么我们要怎么知道什么时候该用什么层呢？诚然，你得经过大量的实践和测试才能回答，可能训练100个网络才能找到最佳的结构和参数。机器学习就是包含了大量的尝试和错误！</p><h2 id="构建鸟分类器"><a href="#构建鸟分类器" class="headerlink" title="构建鸟分类器"></a>构建鸟分类器</h2><p>如今我们已经足以写出一个程序来判断一张图上是不是鸟类。一如既往，我们需要训练数据来开始。免费的<a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR10数据集</a>包括了60,000张鸟类图片和52,000张非鸟图片。如果要更多的数据，我们还需要加入<a href="http://www.vision.caltech.edu/visipedia/CUB-200-2011.html">Caltech-UCSD Birds-200-2011</a>数据集，内含12,000张鸟类图片。</p><p>这是组合数据集的一部分鸟图：</p><p><img src="/img/funny_machine/10045.png"></p><p>以及一部分非鸟图：</p><p><img src="/img/funny_machine/10046.png"></p><p>这一数据集可以很好地满足我们的需求，不过相对于真实世界的应用而言，72,000张低分辨率图片还是太少，如果你想要达到Google级的水平，你需要上百万张高清无码大图。在机器学习中，数据多总是比算法好更重要。现在你就知道Google为什么那么乐意提供无限照片存储了，他们要的是你的数据啊，数据！</p><blockquote><p>原作者使用的是TFLearn，译注者改用了国内更流行的Keras。TFLearn代码可见作者原文。</p></blockquote><p>Keras封装了TensorFlow和Theano两个深度学习库并提供了简单易用的API，这使得开发者可以仅用几行就搭建一个卷积神经网络。</p><p>以下是定义并训练网络的代码：</p><p><strong>导入数据</strong></p><p>Keras内置了CIFAR10数据集，但是需要从网络上下载。</p><p>Keras导入CIFAR10数据集:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关库</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> toimage</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dropout</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Flatten</span><br><span class="line"><span class="keyword">from</span> keras.constraints <span class="keyword">import</span> maxnorm</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> keras.layers.convolutional <span class="keyword">import</span> Convolution2D</span><br><span class="line"><span class="keyword">from</span> keras.layers.convolutional <span class="keyword">import</span> MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练集、测试集</span></span><br><span class="line">(X_train, y_train), (X_test, y_test) = cifar10.load_data()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Datasets is ready!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预览部分图片</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    pyplot.subplot(<span class="number">330</span> + <span class="number">1</span> + i)</span><br><span class="line">    pyplot.imshow(toimage(X_train[i]))</span><br><span class="line"></span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure><p><strong>搭建神经网络</strong></p><p>下面导入其他将会用到的Keras相关模块并对数据进行预处理。Keras搭建神经网络的过程其实非常简单直观，就像搭积木一样。</p><p>首先确定网络的基本结构，这里就用最基本<code>Sequential()</code>串型拓扑，并建立网络模型对象<code>model</code>。</p><p>之后便是给<code>model</code>中一层层地添加网络，添加的方式也很简单，就是使用<code>model.add()</code>方法，逐个地把卷积层(<code>Convolution2D</code>)、池化层(<code>MaxPooling2D</code>)、全连接层(<code>Dense</code>)等插入到model里，形成整个神经网络。</p><p>Keras搭建神经网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对标签进行独热码编码</span></span><br><span class="line">y_train = np_utils.to_categorical(y_train)</span><br><span class="line">y_test = np_utils.to_categorical(y_test)</span><br><span class="line">num_classes = y_test.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置神经网络对象model</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Convolution2D(<span class="number">32</span>,<span class="number">3</span>,<span class="number">3</span>,input_shape=(<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>),</span><br><span class="line">                        border_mode=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                        W_constraint=maxnorm(<span class="number">3</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Convolution2D(<span class="number">32</span>,<span class="number">3</span>,<span class="number">3</span>,activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                    border_mode=<span class="string">&#x27;same&#x27;</span>,W_constraint=maxnorm(<span class="number">3</span>)))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">512</span>,activation=<span class="string">&#x27;relu&#x27;</span>,W_constraint=maxnorm(<span class="number">3</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(num_classes,activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Neural Network built!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>编译、训练、预测</strong></p><p>经过以上过程，我们已经有了一个神经网络的外壳，但也仅仅是外壳，你会注意到上面这个代码模块运行的很快，因为这只是根据神经网络的设置形成了一个容器，内部还是空空如也。还要经过“编译”并且导入数据进行“训练”，我们才真正拥有了“有血有肉”的神经网络。最后通过与测试集的对比，衡量神经网络的表现。</p><p>虽然数据量并不大，但是训练神经网络对于普通CPU来说，还是个比较艰巨的任务，因此训练速度可能堪忧。我们的网站后台暂时还未提供GPU接口，所以这里只能先将训练迭代次数设为1，以后我们会争取提供更强大的计算资源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定训练过程</span></span><br><span class="line">epoches = <span class="number">1</span>  <span class="comment"># 对训练集的迭代次数（这里设为最小的1）</span></span><br><span class="line">lrate = <span class="number">0.01</span> <span class="comment"># 初始学习率</span></span><br><span class="line">decay = lrate/epoches</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器设置与编译</span></span><br><span class="line">sgd = SGD(lr=lrate, momentum=<span class="number">0.9</span>, decay=decay, nesterov=<span class="literal">False</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=sgd,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(model.summary())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用训练集数据训练网络</span></span><br><span class="line">model.fit(X_train, y_train, validation_data=(X_test, y_test), nb_epoch=epoches,</span><br><span class="line">          batch_size=<span class="number">32</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出神经网络的表现</span></span><br><span class="line">scores = model.evaluate(X_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy: %.2f%%&quot;</span>) % (scores[<span class="number">1</span>]*<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>如果你有个不错的显卡和足够的显存（比如Nvidia GeForce GTX 980 Ti或以上），大概一个小时可以训练完，如果用CPU的话可能就要久的多了。</p><p>精度随着训练进程儿上升。第一轮过后，我的精度只有75.4%；经过十轮，精度已经提高到91.7%；在50轮以后，精度攀升到95.5%，再训练已经收效甚微了，因此我就此打住。</p><p>Congrats!现在我们的程序可以识别图片里的鸟了！</p><hr><h2 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h2><p>有了训练过的神经网络，是骡子是马该拉出来遛遛。<a href="https://gist.github.com/ageitgey/a40dded08e82e59724c70da23786bbf0">这一简单的脚本</a>读取一个图片文件并判断是否是鸟。</p><p>为了真正检验我们的神经网络是否有效，需要测试大批的图片。我这里用了15,000张图片作为验证集，当我把这15,000张图传递给神经网络，95%都得到了正确答案。</p><p>听起来很好，对吧？其实这可未必！</p><p><strong>95%是多准确？</strong></p><p>我们的神经网络号称有95%的准确度，但是细微之处见真章，面子上95%，里子可能千差万别。比如说，如果我们的训练图片里5%是鸟，而另外95%不是鸟，然后一个程序只输出“不是鸟”就可以达到95%的精度，但这毫无意义。</p><p>我们需要进一步细究这个数字，而不是满足于一个含糊的95%。为了判断一个分类系统的作用究竟几何，我们需要考察它是如何失效的，而不是失效的百分比。抛掉单纯的“对／错”标准，我们来把问题细分为四种分别的情况——</p><ol><li>把鸟正确地识别为鸟：<strong>True Positives</strong></li></ol><p>  <img src="/img/funny_machine/10047.png" alt="我们的网络成功地认出了很多不同的鸟类！"></p><ol start="2"><li>把不是鸟的正确地排除出去：<strong>True Negatives</strong></li></ol><p>  <img src="/img/funny_machine/10048.png" alt="马和卡车糊弄不了我们"></p><ol start="3"><li>以为是鸟，结果不是：<strong>False Positives</strong>（错杀三千）</li></ol><p>  <img src="/img/funny_machine/10049.png" alt="有些飞机也被当成鸟了"></p><ol start="4"><li>其实是鸟，以为不是：<strong>False Negative</strong>（放过一个）</li></ol><p>  <img src="/img/funny_machine/10050.png" alt="这些鸟把我们糊弄了"></p><p>根据我们这15,000张图片，以下为各种情况的统计数据：</p><p><img src="/img/funny_machine/10051.png"></p><p>为什么要这样细分结果呢？因为并非每种错误都是均等的。想象一下，如果我们在写一个根据MRI图像诊断癌症的程序，这时候宁可引入<strong>False Positive</strong>也不要带有<strong>False Negative</strong>。前者只是让患者虚惊一场，后者可就是延误治疗了。</p><p>所以出了宽泛的准确度，我们还计算<a href="https://en.wikipedia.org/wiki/Precision_and_recall">精确率和召回率</a>。精确率和召回率更加清晰地定义了分类起的效用。</p><p><img src="/img/funny_machine/10052.png"></p><p>由上表可知，当我们给出“是鸟”的猜测时，其中97%是对的。但是我们却只找出了90%的鸟，这意味着我们可能不是所有鸟都认得，但是认鸟却很准！</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习有意思！ 02》- 使用机器学习生成超级玛丽关卡</title>
      <link href="/2018/funny_machine_learning_2/index/"/>
      <url>/2018/funny_machine_learning_2/index/</url>
      
        <content type="html"><![CDATA[<h1 id="《机器学习有意思！-02》-使用机器学习生成超级玛丽关卡"><a href="#《机器学习有意思！-02》-使用机器学习生成超级玛丽关卡" class="headerlink" title="《机器学习有意思！ 02》- 使用机器学习生成超级玛丽关卡"></a>《机器学习有意思！ 02》- 使用机器学习生成超级玛丽关卡</h1><blockquote><p> <em>原文：<a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-2-a26a10b68df3#.rtiibwykm">Machine Learning is Fun! Part 2 – Using Machine Learning to generate Super Mario Maker levels</a></em><br> <em>作者：Adam Geitgey</em></p></blockquote><hr><p>在系列的*<a href="http://blog.trover.cf/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2018-01-09-funny_machine_learning_1.html">Part 1</a>*中我们已经讲过，机器学习是用普适的算法从数据中挖掘出有趣的东西，而无需针对具体问题写代码。</p><p>这次我们将见识一种普适算法的炫酷表现——创造乱真的游戏关卡。我们将建立一个神经网络，导入已有的超级马里奥数据，然后创造新的关卡。</p><p>正如Part 1一样，本系列教程适合所有对机器学习感兴趣、但却不知从何开始的读者。希望所有人都能读懂——所以难免会有些粗疏。不过但凡能把一个人带进ML的坑里，也就算没白写。</p><hr><h2 id="猜得更机智"><a href="#猜得更机智" class="headerlink" title="猜得更机智"></a>猜得更机智</h2><p>在Part 1中，我们写了一个简单的算法来根据房产的属性预测价格，数据如下表所示：</p><p><img src="/img/funny_machine/10002.png"></p><p>预测函数是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood):</span><br><span class="line">    price = 0</span><br><span class="line"></span><br><span class="line">    # 加少量配方1</span><br><span class="line">    price += num_of_bedrooms * 0.123</span><br><span class="line"></span><br><span class="line">    # 加大把配方2</span><br><span class="line">    price += sqft * 0.41</span><br><span class="line"></span><br><span class="line">    # 适量的配方3</span><br><span class="line">    price += neighborhood * 0.57</span><br><span class="line"></span><br><span class="line">    return price</span><br></pre></td></tr></table></figure><p>也就是说，房价的预测值是由每种属性乘以权重再相加得到的。用图形来表示：</p><p><img src="/img/funny_machine/100011.png"></p><blockquote><p>箭头代表函数权重</p></blockquote><p>但是这个算法只对很简单的线性问题有效，如果房价背后的真实规律没有那么简单呢？比如周边环境可能对特别大或特别小的房子影响显著，但对于中间房型则没有什么影响。如何才能捕捉到这些复杂细节呢？</p><p>为了更加的机智，我们可以用不同的权重多次执行算法，每一组权重对应不同的边界情况。</p><p><img src="/img/funny_machine/100012.png"></p><blockquote><p>尝试用4种方法解决问题</p></blockquote><p>现在我们有四个价格预测了，然后再把这4个组合成最终结果，并且也是通过加权（只是权重值变了）。</p><p><img src="/img/funny_machine/100013.png"></p><p>新的<em><strong>超级答案</strong></em>结合了四次求解尝试，所以相比于初始的简单模型，能够模拟更多的情况。</p><hr><h2 id="什么是神经网络？"><a href="#什么是神经网络？" class="headerlink" title="什么是神经网络？"></a>什么是神经网络？</h2><p>把我的四次求解尝试整合到一张大图里：</p><p><img src="/img/funny_machine/100014.png"></p><p>这就是一个神经网络！那个节点都有一组输入，执行加权计算，产生一个输出值。把这些节点串起来就能够对复杂函数进行建模了。</p><p>为了节省篇幅，这里我跳过了很多内容（比如<a href="https://en.wikipedia.org/wiki/Feature_scaling">特征缩放</a>和<a href="https://en.wikipedia.org/wiki/Activation_function">激励函数</a>），但是最重要的部分还是以下几点基本思想：</p><ul><li>我们用简单的函数，对输入进行加权获得输出，这个简单函数就叫<strong>神经元</strong>。</li><li>把许多简单的神经元链在一起，就可以对单个神经元描述不了的复杂问题进行建模。</li></ul><p>就像乐高一样，单个积木块或许做不出什么，但只要有足够多的积木，就什么都能搭建。</p><p><img src="/img/funny_machine/100015.png"></p><blockquote><p>我们的未来会如同塑料玩具一样吗？只有时间知道答案。</p></blockquote><hr><h2 id="让神经网络有记忆"><a href="#让神经网络有记忆" class="headerlink" title="让神经网络有记忆"></a>让神经网络有记忆</h2><p>给定相同的输入，此前的神经网络也会给出相同的输出，用编程术语叫<a href="https://en.wikipedia.org/wiki/State_%28computer_science%29">无状态算法(stateless algorithm)</a>。</p><p>在很多实例（比如房价预测）中，这正是我们想要的。但是这类模型无法应对数据中的时变模式。</p><p>想象一下，我给了你一个键盘，让写个故事。在开始之前，我要猜你会写哪个字母，那么我该怎么猜呢？</p><p>我可以利用我的英语知识来增加命中率，比如你写的第一个字母往往是一个单词的首字母。如果我看过你的过往文章，还可以进一步根据你的文风收缩范围。如果我有全部数据，我就可以搭建一个神经网络，来计算你写下一个字母的概率。</p><p>模型可能是这样：</p><p><img src="/img/funny_machine/100016.png"></p><p>再来看一个更有挑战的问题，随便在故事里定个位，然后我要猜你的下一个字母，这就更有意思了。</p><p>用海明威的《太阳照常升起》作为例子：</p><blockquote><p>Robert Cohn was once middleweight boxi</p></blockquote><p>下一个字母是什么？</p><p>你大概会猜’n’——这个词应该是boxing。这样的猜测是基于我们已知的常用英语单词积累。同时，’middleweight’ 也给出了额外的线索指向boxing。</p><p>下一个字母好猜，是因为我们纳入了其之前的句子，并结合已有的语言知识。</p><p>如果要用神经网络来解决这个问题，我们需要在模型中添加一个状态(state)，每次我们向神经网络询问答案的时候，还会获得一个中间计算，并在下次当作输入的一部分重复利用。如此一来，我们的模型就会根据之前的输入调整预测结果。</p><p><img src="/img/funny_machine/100017.png"></p><p>跟着状态走，虽然不能猜第一个字母，但却可以根据前面的字母猜下一个。</p><p>这就是*循环神经网络(Recurrent Neural Network)*的基本思路。每次使用，我们都是在更新网络，这就可以基于之前最常见的输入，去更新预测。只要“记忆力”足够，这就可以对数据的时变模式进行建模。</p><hr><h2 id="一个字母好干什么？"><a href="#一个字母好干什么？" class="headerlink" title="一个字母好干什么？"></a>一个字母好干什么？</h2><p>猜测故事里的下一个字母挺起来没有什么卵用，那还提这茬干嘛？</p><p>手机输入法的自动补全就是一个应用：</p><p><img src="/img/funny_machine/100018.png"></p><blockquote><p>下一个字母是”t”</p></blockquote><p>往计算情况再想想，如果我们让模型猜完一个再猜一个，如此循环往复——我们就可以让计算机自己来写个故事了！</p><h2 id="生产故事"><a href="#生产故事" class="headerlink" title="生产故事"></a>生产故事</h2><p>知道了如何猜海明威句子里的下一个字母，让我们试着产生一个完整的海明威风格故事。</p><p>我们将使用<a href="http://karpathy.github.io/about/">Andrej Karpathy</a>开发的<a href="https://github.com/karpathy/char-rnn">循环神经网络</a>。Andrej是斯坦福大学的深度学习研究者，并且他写了一个<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">极好的循环神经网络文本生成入门</a>，你可以在<a href="https://github.com/karpathy/char-rnn">GitHub</a>查看完整代码。</p><p>模型建立在《太阳照常升起》的文本数据基础上——362,239个字，84个字符（包括标点符号）。相比于实际应用，这一数据量其实小的很。为了真正搭建一个好的海明威文风的模型，至少需要若干倍的样本文字量，不过对于一个入门实例来讲，现在的就足够了。</p><p>刚开始训练RNN的时候，预测能力还不太行，这是100次训练迭代后的成果：</p><blockquote><p>hjCTCnhoofeoxelif edElobe negnk e iohehasenoldndAmdaI ayio pe e h’e btentmuhgehi bcgdltt. gey heho grpiahe.</p></blockquote><blockquote><p>Ddelnss.eelaishaner” cot AAfhB ht ltny</p></blockquote><blockquote><p>ehbih a”on bhnte ectrsnae abeahngy</p></blockquote><blockquote><p>amo k ns aeo?cdse nh a taei.rairrhelardr er deffijha</p></blockquote><p>可以看见词与词之间已经有空格了。</p><p>1000次迭代之后，明显看起来更上道了：</p><blockquote><p>hing soor ither. And the caraos, and the crowebel for figttier and ale the room of me? Streat was not to him Bill-stook of the momansbed mig out ust on the bull, out here. I been soms inick stalling that aid.</p></blockquote><blockquote><p>“Hon’t me and acrained on .Hw’s don’t you for the roed,” In’s pair.”</p></blockquote><blockquote><p>“Alough marith him.”</p></blockquote><p>模型已经识别出了基本句型模式，并且知道在句末加句号，给对话加引号，个别单词已经能读懂了，但整篇仍是一派胡言。</p><p>又经过几千次迭代之后，现在已经看起来非常好了：</p><blockquote><p>He went over to the gate of the café. It was like a country bed.</p></blockquote><blockquote><p>“Do you know it’s been me.”</p></blockquote><blockquote><p>“Damned us,” Bill said.</p></blockquote><blockquote><p>“I was dangerous,” I said. “You were she did it and think I would a fine cape you,” I said.</p></blockquote><blockquote><p>“I can’t look strange in the cab.”</p></blockquote><blockquote><p>“You know I was this is though,” Brett said.</p></blockquote><blockquote><p>“It’s a fights no matter?”</p></blockquote><blockquote><p>“It makes to do it.”</p></blockquote><blockquote><p>“You make it?”</p></blockquote><blockquote><p>“Sit down,” I said. “I wish I wasn’t do a little with the man.”</p></blockquote><blockquote><p>“You found it.”</p></blockquote><blockquote><p>“I don’t know.”</p></blockquote><blockquote><p>“You see, I’m sorry of chatches,” Bill said. “You think it’s a friend off back and make you really drunk.”</p></blockquote><p>至此，算法已经捕捉到了海明威对话短小精悍的特征，有些句子甚至已经能够达意了。</p><p>跟书中的真实文本对照一下：</p><blockquote><p>There were a few people inside at the bar, and outside, alone, sat Harvey Stone. He had a pile of saucers in front of him, and he needed a shave.</p></blockquote><blockquote><p>“Sit down,” said Harvey, “I’ve been looking for you.”</p></blockquote><blockquote><p>“What’s the matter?”</p></blockquote><blockquote><p>“Nothing. Just looking for you.”</p></blockquote><blockquote><p>“Been out to the races?”</p></blockquote><blockquote><p>“No. Not since Sunday.”</p></blockquote><blockquote><p>“What do you hear from the States?”</p></blockquote><blockquote><p>“Nothing. Absolutely nothing.”</p></blockquote><blockquote><p>“What’s the matter?”</p></blockquote><p>即便是循着单个字母的模式，我们的算法已经模仿得有鼻子有眼了，这好的很呐！</p><p>无需从零开始生成文本，我们可以提供前几个字母作为“种子”，然后让算法自己寻找后面的。</p><p>出于娱乐目的，我们来做一本假书，用”Er”,”He”,”The S”作为种子生成新的作者名字和新标题：</p><p><img src="/img/funny_machine/100019.png"></p><blockquote><p>左：真书；右：计算机生成的假书</p></blockquote><p>还不赖！</p><p>真正令人振奋的是，这一算法可以从任意数据中识别模式，能够轻易地生成以假乱真的<a href="https://gist.github.com/nylki/1efbaa36635956d35bcc">菜谱</a>和<a href="https://medium.com/@samim/obama-rnn-machine-generated-political-speeches-c8abd18a2ea0#.b4clxzrgf">假的奥巴马讲话</a>。为什么要局限在人类语言当中呢？我们大可以应用在任何内含模式的数据之中。</p><hr><h2 id="你可能玩了假的马里奥"><a href="#你可能玩了假的马里奥" class="headerlink" title="你可能玩了假的马里奥"></a>你可能玩了假的马里奥</h2><p>2015年，任天堂推出了用于Wii U游戏机的<a href="http://supermariomaker.nintendo.com/">超级马里奥编辑器</a>。</p><p><img src="/img/funny_machine/10020.png"></p><p>这个游戏让你可以自由设计超级马里奥的关卡，并且上传到网上和朋友们分享。你可以加入老游戏中的所有经典机关和敌人，简直是马里奥时代生人的虚拟乐高。</p><p>能不能用生成假海明威文字的模型，来生成假马里奥关卡呢？</p><p>首先需要准备训练数据，从1985年原版超级马里奥兄弟里提取出所有的室外关卡。游戏中共有32关，其中约70%是在室外，所以就从这下手。</p><p>为了获取每个关卡的设计，我写了一个程序从游戏中提取出关卡设计，超级马里奥已有三十多年历史，所以网上关于游戏设计的资源非常多。从老游戏中提取数据也是个很有意思的编程练习，你也可以试一试。</p><p>凑近了看，游戏关卡其实是由一组物体网格构成的：</p><p><img src="/img/funny_machine/10021.png"></p><p>我们可以用一组字符来代表这个网格，每个字符就是一个物体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--------------------------</span><br><span class="line">--------------------------</span><br><span class="line">--------------------------</span><br><span class="line">#??#----------------------</span><br><span class="line">--------------------------</span><br><span class="line">--------------------------</span><br><span class="line">--------------------------</span><br><span class="line">-##------=--=----------==-</span><br><span class="line">--------==--==--------===-</span><br><span class="line">-------===--===------====-</span><br><span class="line">------====--====----=====-</span><br><span class="line">=========================-</span><br></pre></td></tr></table></figure><p>每个物体是一个字符：</p><ul><li>‘-‘是空白</li><li>‘&#x3D;’是实心砖</li><li>‘#’是可以打破的砖</li><li>‘?’是硬币砖</li></ul><p>字符替换后的效果就是这样：</p><p><img src="/img/funny_machine/10022.png"></p><p>观察文本文件可以发现，马里奥的关卡如果逐行来看，并没有什么模式：</p><p><img src="/img/funny_machine/10023.png"></p><p>但是如果逐列来看，模式就很明显了：</p><p><img src="/img/funny_machine/10024.png"></p><blockquote><p>逐列看，模式很明显，比如每列都是以’&#x3D;’结束的</p></blockquote><p>为了让算法能够识别模式，需要逐列输入数据。从输入数据中找出最有效的表征方式（即<a href="https://en.wikipedia.org/wiki/Feature_selection">特征选择</a>）是用好机器学习算法关键。</p><p>为了训练模型，我们把文本文件反转90度，这让特征更加显而易见：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-----------=</span><br><span class="line">-------#---=</span><br><span class="line">-------#---=</span><br><span class="line">-------?---=</span><br><span class="line">-------#---=</span><br><span class="line">-----------=</span><br><span class="line">-----------=</span><br><span class="line">----------@=</span><br><span class="line">----------@=</span><br><span class="line">-----------=</span><br><span class="line">-----------=</span><br><span class="line">-----------=</span><br><span class="line">---------PP=</span><br><span class="line">---------PP=</span><br><span class="line">----------==</span><br><span class="line">---------===</span><br><span class="line">--------====</span><br><span class="line">-------=====</span><br><span class="line">------======</span><br><span class="line">-----=======</span><br><span class="line">---=========</span><br><span class="line">---=========</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>就像模仿海明威文风的例子一样，模型是越训练越好的。只经过很少量训练的结果，看起来真垃圾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------------------------</span><br><span class="line">LL+&lt;&amp;=------P-------------</span><br><span class="line">--------</span><br><span class="line">---------------------T--#--</span><br><span class="line">-----</span><br><span class="line">-=--=-=------------=-&amp;--T--------------</span><br><span class="line">--------------------</span><br><span class="line">--=------$-=#-=-_</span><br><span class="line">--------------=----=&lt;----</span><br><span class="line">-------b</span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>大概摸索出了’-‘和’&#x3D;’出现的比较多，但仅仅如此，没有真正发现什么模式。</p><p>经过几千次迭代，开始有点样子了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--</span><br><span class="line">-----------=</span><br><span class="line">----------=</span><br><span class="line">--------PP=</span><br><span class="line">--------PP=</span><br><span class="line">-----------=</span><br><span class="line">-----------=</span><br><span class="line">-----------=</span><br><span class="line">-------?---=</span><br><span class="line">-----------=</span><br><span class="line">-----------=</span><br></pre></td></tr></table></figure><p>模型已经基本知道了每行的长度应该一致，并且也开始发现了游戏中的一些特点：管子总是两块宽、至少两块长，所以”P”以2X2的小组出现，这很不错！</p><p>在更多的训练之后，模型已经生成了很多有效的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--------PP=</span><br><span class="line">--------PP=</span><br><span class="line">----------=</span><br><span class="line">----------=</span><br><span class="line">----------=</span><br><span class="line">---PPP=---=</span><br><span class="line">---PPP=---=</span><br><span class="line">----------=</span><br></pre></td></tr></table></figure><p>来看看模型生成的完整关卡（转回横版）：</p><p><img src="/img/funny_machine/10025.png"></p><p>看起来相当好！有几个亮点值得注意：</p><ul><li><p>开始有一个<a href="http://www.mariowiki.com/lakitu">Lakitu</a>（空中浮游怪）在天上——就像真实的马里奥关卡一样。</p></li><li><p>空中的管子必须底部有砖块，而不能孤立地飘在半空。</p></li><li><p>怪物的分布比较合理。</p></li><li><p>不会出现组织玩家前进的死路。</p></li><li><p>感觉上确实很像一个真实的关卡。</p></li></ul><p><img src="/img/funny_machine/100020.jpeg"></p><p>如果你有超级马里奥编辑器的话，你可以通过<a href="https://supermariomakerbookmark.nintendo.net/courses/4AC9-0000-0157-F3C3">bookmarking it online</a>或者查找代码<a href="https://supermariomakerbookmark.nintendo.net/courses/4AC9-0000-0157-F3C3">4AC9-0000-0157-F3C3</a>来玩这一关卡。</p><hr><h2 id="玩具和真货"><a href="#玩具和真货" class="headerlink" title="玩具和真货"></a>玩具和真货</h2><p>我们用来训练模型的循环神经网络算法，跟现实世界里很多公司用来解决难题（如语音识别，机器翻译）的算法是一样的。但我们的模型只建立在很少的数据量之上，所以只能算是一种“玩具”而不能动真格的。原版超级马里奥游戏里的关卡数不足以训练出一个真正好的模型。</p><p>如果我们能像任天堂一样，拿到数以十万计的玩家自制关卡数据，我们就可以做个更强的模型了。不过任天堂不会坐视其发生的，大公司都不会免费开放数据。</p><p>随着机器学习在很多行业里越来越重要，好程序和坏程序的差别越来越多地体现在，训练模型的数据量。这就是为什么Google和Facebook等公司如此需要你的数据。</p><p>比如Google最近开源了用于搭建大规模机器学习应用的软件包<a href="https://www.tensorflow.org/">TensorFlow</a>，Google免费开放了如此重要而强力的技术，引起了巨大反响，而TensorFlow正是支撑Google Translate的后台。</p><p>但如如果没有Google在每种语言上留下的海量数据宝藏，你也不可能做出Google Translate的对手，数据才是Google真正的杀手锏。下次当你打开<a href="https://maps.google.com/locationhistory/b/0">Google Maps Location History</a>或<a href="https://www.facebook.com/help/1026190460827516">Facebook Location History</a>的时候，留意它们记录了你的一切所到之处。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstraintLayout 完全解析</title>
      <link href="/2018/android_constraintlayout/index/"/>
      <url>/2018/android_constraintlayout/index/</url>
      
        <content type="html"><![CDATA[<h1 id="ConstraintLayout-完全解析"><a href="#ConstraintLayout-完全解析" class="headerlink" title="ConstraintLayout 完全解析"></a>ConstraintLayout 完全解析</h1><blockquote><p>原文链接：<a href="http://blog.csdn.net/lmj623565791/article/details/78011599">ConstraintLayout 完全解析 快来优化你的布局吧</a></p></blockquote><blockquote><p>作者：张鸿洋</p></blockquote><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>ConstraintLayout出现有一段时间了，不过一直没有特别去关注，也多多少少看了一些文字介绍，多数都是对使用可视化布局拖拽，个人对拖拽一直不看好，直到前段时间看到该文：</p><ul><li><a href="https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ">解析ConstraintLayout的性能优势</a></li></ul><p>非常详尽的介绍了ConstraintLayout的性能优势，于是乎开始学习了一下ConstraintLayout。</p><p>本文的重点不在与可视化界面的学习，而在于如何手写各类约束布局属性。对于可视化界面学习推荐：</p><ul><li><a href="http://blog.csdn.net/guolin_blog/article/details/53122387">Android新特性介绍，ConstraintLayout完全解析</a></li></ul><p>下面开始进入正题，大家都知道，当布局嵌套深入比较深的时候，往往会伴随着一些性能问题。所以很多时候我们建议使用RelativeLayout或者GridLayout来简化掉布局的深度。</p><p>而对于简化布局深度，ConstraintLayout几乎可以做到极致，接下来我们通过实例来尽可能将所有常见的属性一步步的介绍清楚。</p><p>首先需要引入我们的ConstraintLayout，在build.gradle中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.android.support.constraint:constraint-layout:1.0.2&#x27;</span><br></pre></td></tr></table></figure><h2 id="二、来编写一个Feed-Item"><a href="#二、来编写一个Feed-Item" class="headerlink" title="二、来编写一个Feed Item"></a>二、来编写一个Feed Item</h2><p>我们先看一个简单的新闻列表中常见的feed item。<br><img src="/img/constraint/10001.jpeg"></p><p>看到这样的布局，大家条件反射应该就是使用RelativeLayout来做，当然了，本案例我们使用ConstraintLayout来写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/activity_main&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#11ff0000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.zhy.constrantlayout_learn.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;140dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;86dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#fd3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;马云:一年交税170多亿马云:一年交税170多亿马云:一年交税170多亿&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#000000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@id/tv1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/tv1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;8分钟前&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#333&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@id/tv1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;@id/tv1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看上面的布局，我们好像看到了几个模式的属性：</p><p>首先是tv1，有两个没见过的属性：</p><ul><li>app:layout_constraintLeft_toLeftOf&#x3D;”parent”</li></ul><p>从字面上看，指的是让该控件的左侧与父布局对齐，当我们希望控件A与控件B左侧对齐时，就可以使用该属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintLeft_toLeftOf=&quot;@id/viewB&quot;</span><br></pre></td></tr></table></figure><p>类似的还有个相似的属性为：</p><ul><li>app:layout_constraintLeft_toRightOf</li></ul><p>很好理解，即当前属性的左侧在谁的右侧，当我们希望控件A在控件B的右侧时，可以设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintLeft_toRightOf=&quot;@id/viewB&quot;</span><br></pre></td></tr></table></figure><p>与之类似的还有几个属性：</p><ul><li>layout_constraintRight_toLeftOf</li><li>layout_constraintRight_toRightOf</li><li>layout_constraintTop_toTopOf</li><li>layout_constraintTop_toBottomOf</li><li>layout_constraintBottom_toTopOf</li><li>layout_constraintBottom_toBottomOf</li><li>layout_constraintBaseline_toBaselineOf</li></ul><p>类推就可以了。</p><p>现在在头看刚才的布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tv1设置了：</span><br><span class="line"></span><br><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line"></span><br><span class="line">tv2设置了：</span><br><span class="line"></span><br><span class="line">app:layout_constraintLeft_toRightOf=&quot;@id/tv1&quot;</span><br><span class="line">app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;@id/tv1&quot;</span><br><span class="line"></span><br><span class="line">tv3设置了：</span><br><span class="line"></span><br><span class="line">app:layout_constraintLeft_toRightOf=&quot;@id/tv1&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;@id/tv1&quot;</span><br></pre></td></tr></table></figure><p>按照我们刚才的理解，再次的解读下：</p><p>tv1应该是在父布局的左上角；</p><p>tv2在tv1的右侧，tv2的右侧和父布局对其，tv2和tv1顶部对齐；</p><p>tv3在tv1的右侧，tv3和tv1底部对其。</p><p>到这里，大家可以看到，目前我们已经可以控制任何一个控件与其他控件间的相对位置了，以及与parent间的相对位置。</p><h2 id="和RL的差异"><a href="#和RL的差异" class="headerlink" title="和RL的差异"></a>和RL的差异</h2><p>大家是不是觉得目前来看和RelativeLayout特别像？</p><p>其实还是有很明显的区别的，我们通过一个例子来看一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/id_btn01&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Btn01&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@id/id_btn01&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Btn02&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/constraint/10002.jpeg"></p><p>那么经过我们刚才的学习，把：</p><blockquote><p>layout_toRightOf&#x3D;”@id&#x2F;id_btn01”<br>layout_alignParentRight&#x3D;”true”</p></blockquote><p>分别替换为：</p><blockquote><p>app:layout_constraintLeft_toRightOf&#x3D;”@id&#x2F;id_btn01”<br>app:layout_constraintRight_toRightOf&#x3D;”parent”</p></blockquote><p>是不是觉得so easy ，但是我们看一下效果图：</p><p><img src="/img/constraint/10003.jpeg"></p><p>是不是和预期有一定的区别，假设你将Btn02的宽度设置的非常大，你会发现更加诡异的事情：</p><p><img src="/img/constraint/10004.jpeg"></p><p>你会发现Btn02，好像疯了一样，我们设置的在btn01右侧，和与parent右侧对齐完全失效了！！！</p><p>别怕，接下来就让你认识到为什么这个控件叫做“Constraint”Layout。</p><p>在当控件有自己设置的宽度，例如warp_content、固定值时，我们为控件添加的都是约束“Constraint”，这个约束有点像橡皮筋一样会拉这个控件，但是并不会改变控件的尺寸（RL很明显不是这样的）。</p><p>例如上例，当btn02的宽度较小时，我们为其左侧设置了一个约束（btn01右侧），右侧设置了一个约束（parent右侧对其），当两个约束同时生效的时候（你可以认为两边都是相同的一个拉力），btn02会居中。</p><p>当btn02特别大的时候，依然是这两个力，那么会发生什么？会造成左侧和右侧超出的距离一样大。</p><p>那么现在大家肯定有些疑问：</p><ul><li>怎么样才能和上面的RL一样，宽度刚好占据剩下的距离呢（btn01右侧到屏幕右侧的距离）？</li></ul><p>这个问题，问得很好，我们刚才所有的尝试都是在控件自身拥有特定的宽度情况下执行的；那么如果希望控件的宽度根据由约束来控件，不妨去掉这个特定的宽度，即设置为0试试？</p><p>对！当我们将btn02的宽度设置为0时，一切又变得很完美。</p><p><img src="/img/constraint/10005.jpeg"></p><p>那么这里，你可能会问0值是什么含义，其实在ConstraintLayout中0代表：MATCH_CONSTRAINT，看到这个常量，是不是瞬间觉得好理解了一点。</p><ul><li>最后一个问题，MATCH_PARENT哪去了?</li></ul><p>看官网的解释：</p><blockquote><p>Important: <code>MATCH_PARENT</code> is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using <code>MATCH_CONSTRAINT</code> with the corresponding left&#x2F;right or top&#x2F;bottom constraints being set to “parent”.&#96;</p></blockquote><p>所以你可以认为：在ConstraintLayout中已经不支持<code>MATCH_PARENT</code>这个值了，你可以通过<code>MATCH_CONSTRAINT</code>配合约束实现类似的效果。</p><h2 id="三、增加一个banner"><a href="#三、增加一个banner" class="headerlink" title="三、增加一个banner"></a>三、增加一个banner</h2><p>我们现在以往在这个feed item顶部添加一个banner，宽度为占据整个屏幕，宽高比为16：6。</p><p>这里尴尬了，在之前的做法，很难在布局中设置宽高比，一般我们都需要在代码中显示的去操作，那么如果你用了ConstraintLayout，它就支持。</p><p>看一眼如何支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.zhy.constrantlayout_learn.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/banner&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#765&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Banner&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">&quot;H,16:6&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/banner&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line">&lt;/...&gt;</span><br></pre></td></tr></table></figure><p>我们添加了一个banner，还记得我们刚才所说的么，不要使用match_parent了，而是设置match_contraint，即0，让约束来控制布局宽高。</p><p>所以我们设置了宽、高都是<code>match_contraint</code>，然后这两个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br></pre></td></tr></table></figure><p>让我们的宽度充满整个父布局，在添加一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintDimensionRatio=&quot;16:6&quot;</span><br></pre></td></tr></table></figure><p>该属性指的是宽高比，所以16：6就可以完成我们的需求。</p><p>好了看下效果图：</p><p><img src="/img/constraint/10006.jpeg"></p><p>这个宽高比属性，还支持这样的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintDimensionRatio=&quot;W,16:6&quot;</span><br><span class="line">app:layout_constraintDimensionRatio=&quot;H,16:6&quot;</span><br></pre></td></tr></table></figure><p>可以自己试验下。</p><p>好了，到这里，我们又新增了一个属性，还是个非常实用的属性。</p><p>那么，我们继续，再看一个似曾相识的功能。</p><h2 id="四、增加几个Tab"><a href="#四、增加几个Tab" class="headerlink" title="四、增加几个Tab"></a>四、增加几个Tab</h2><p>现在我们希望在底部增加3个tab，均分。是不是想到了LinearLayout和weight。</p><p>没错！ConstraintLayout也支持类似的属性。</p><p>虽然我知道，但是写到这我还是有点小惊喜~~</p><p>看下如何实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tab1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#f67&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Tab1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">&quot;@+id/tab2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tab2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#A67&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Tab2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@id/tab1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">&quot;@+id/tab3&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tab3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#767&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Tab3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@id/tab2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们增加3个textview来冒充tab。我们看横向的依赖，3个tab两两设置了约束（即你在我们的左边，我在你的右边），最外层的设置了parent约束；再加上我们把宽度都设置为了match_constraint，so，这样我们就完成了3个tab等分。</p><p>看一眼效果图：</p><p><img src="/img/constraint/10007.jpeg"></p><p>你可能会说，LL配合weight更加灵活，可以单个设置占据的比例。</p><p>对，没错，我们也支持，我不是还没说完么。</p><p>现在我们可以给每个tab设置一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintHorizontal_weight</span><br></pre></td></tr></table></figure><p>看到这个名字，应该就明白了吧，假设我们分别设置值为2，1，1。</p><p>效果图为：</p><p><img src="/img/constraint/10008.jpeg"></p><p>是不是很惊喜，别急，刚才你说我不如LL，现在我要让你再看一些LL配合weight做不到的。</p><p>这里需要借助几张官网上的图了：</p><p>刚才我们说了，3个tab两两设置了依赖，即类似下图：</p><p><img src="/img/constraint/10009.jpeg"></p><p>横向的相当于组成了一个链(Chains)。在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果：</p><p>该属性为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_chainStyle</span><br></pre></td></tr></table></figure><p>我们已经见过一种效果了，即按照<code>weight</code>等分，可以成为<code>weighted chain</code>。设置条件为：<code>chainStyle=”spread”</code>，所有控件宽度设置为<code>match_constraint</code>，因为默认就是<code>spread</code>，所以我们没有显示设置。</p><p>其取值还可以为：</p><ul><li>packed</li><li>spread_inside</li></ul><p>我还是分别显示一下吧：</p><ol><li>spread + 宽度为0，且可以通过weight控制分配比例</li></ol><p>  <img src="/img/constraint/10010.jpeg"></p><ol start="2"><li>spread_inside + 宽度非0</li></ol><p>  <img src="/img/constraint/10011.jpeg"></p><ol start="3"><li>packed + 宽度非0</li></ol><p>  <img src="/img/constraint/10012.jpeg"></p><p>好了，差不多了，我们可以在横向或者纵向组成一个Chain，然后在Chain head设置chainStyle来搞一些事情。</p><p>官网有个图：</p><p><img src="/img/constraint/10013.jpeg"></p><p>前四个我们都演示了，最后一个设计到一个新的bias属性，别急，咱们慢慢说~~</p><p>好了，到这里，我们再次见证了ConstraintLayout的强大。</p><p>我们最后再看一个例子。</p><h2 id="五、增加浮动按钮"><a href="#五、增加浮动按钮" class="headerlink" title="五、增加浮动按钮"></a>五、增加浮动按钮</h2><p>一个很常见的功能，我们现在希望在右下角增加一个浮动按钮。</p><p>看下如何实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.zhy.constrantlayout_learn.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#612&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.9&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.9&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/....&gt;</span><br></pre></td></tr></table></figure><p>我们在最后追加一个TextView冒充我们的浮动按钮。可以看到我们设置了固定值，被设置约束为右下角。</p><p>正常情况我们可以通过margin来设置与右侧与底部的距离。</p><p>但是这里我们尝试使用量个新的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_bias</span><br><span class="line">layout_constraintVertical_bias</span><br></pre></td></tr></table></figure><p>即设置上下两侧间隙比例分别为90%与10%。这个很好理解，我们之前说了，再没有bias这个属性的时候，这两侧的拉力大小是一样的，但是你可以通过bias来控制哪一侧的力要大一些~~明白了么~</p><p>所以，该属性可以用于约束之前，控制两侧的“拉力”。</p><p>我们看一下效果图：</p><p><img src="/img/constraint/10014.jpeg"></p><p>那么到这里，ConstraintLayout的属性我们基本上介绍完了：</p><p>我们看一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintLeft_toLeftOf</span><br><span class="line">layout_constraintLeft_toRightOf</span><br><span class="line">layout_constraintRight_toLeftOf</span><br><span class="line">layout_constraintRight_toRightOf</span><br><span class="line">layout_constraintTop_toTopOf</span><br><span class="line">layout_constraintTop_toBottomOf</span><br><span class="line">layout_constraintBottom_toTopOf</span><br><span class="line">layout_constraintBottom_toBottomOf</span><br><span class="line"></span><br><span class="line"># 即文章的baseline对齐</span><br><span class="line">layout_constraintBaseline_toBaselineOf</span><br><span class="line"></span><br><span class="line"># 与left,right类似</span><br><span class="line">layout_constraintStart_toEndOf</span><br><span class="line">layout_constraintStart_toStartOf</span><br><span class="line">layout_constraintEnd_toStartOf</span><br><span class="line">layout_constraintEnd_toEndOf</span><br><span class="line"></span><br><span class="line"># margin不需要解释</span><br><span class="line">android:layout_marginStart</span><br><span class="line">android:layout_marginEnd</span><br><span class="line">android:layout_marginLeft</span><br><span class="line">android:layout_marginTop</span><br><span class="line">android:layout_marginRight</span><br><span class="line">android:layout_marginBottom</span><br><span class="line"></span><br><span class="line">layout_constraintHorizontal_bias</span><br><span class="line">layout_constraintVertical_bias</span><br><span class="line"></span><br><span class="line">layout_constraintHorizontal_chainStyle</span><br><span class="line">layout_constraintVertical_chainStyle</span><br><span class="line"></span><br><span class="line">layout_constraintVertical_weight</span><br><span class="line"></span><br><span class="line">Guideline</span><br></pre></td></tr></table></figure><p>好像，还有个比较特殊的，叫Guideline。</p><p>好吧，继续~</p><h2 id="六、尝试使用Guideline"><a href="#六、尝试使用Guideline" class="headerlink" title="六、尝试使用Guideline"></a>六、尝试使用Guideline</h2><p><code>android.support.constraint.Guideline</code>该类比较简单，主要用于辅助布局，即类似为辅助线，横向的、纵向的。该布局是不会显示到界面上的。</p><p>所以其有个属性为：</p><p><code>android:orientation</code>取值为<code>”vertical”</code>和<code>”horizontal”</code>.</p><p>除此以外，还差个属性，决定该辅助线的位置：</p><ul><li><code>layout_constraintGuide_begin</code></li><li><code>layout_constraintGuide_end</code></li><li><code>layout_constraintGuide_percent</code></li></ul><p>可以通过上面3个属性其中之一来确定属性值位置。</p><p>begin&#x3D;30dp，即可认为距离顶部30dp的地方有个辅助线，根据orientation来决定是横向还是纵向。</p><p>end&#x3D;30dp，即为距离底部。<br>percent&#x3D;0.8即为距离顶部80%。</p><p>好了，下面看一个例子，刚才我们的浮点按钮，我决定通过两根辅助线来定位，一根横向距离底部80%，一个纵向距离顶部80%，浮点按钮就定位在他们交叉的地方。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.zhy.constrantlayout_learn.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.constraint.Guideline</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline_h&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.constraint.Guideline</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline_w&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#612&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@id/guideline_w&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/guideline_h&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/....&gt;</span><br></pre></td></tr></table></figure><p>我感觉都不用解释了~~看眼效果图吧：</p><p><img src="/img/constraint/10015.jpeg"></p><p>到此，属性基本上讲完啦~</p><p>可以看到，上述相当复杂的一个布局，在ConstraintLayout中完全没有嵌套！</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文通过实际的按钮，基本上介绍了ConstraintLayout所支持的所有的属性，全文没有提及拖拽，因为当界面复杂之后，想要完美的拖拽实在是太难了，而且谁也不期望，看不懂拖拽完成后的布局属性吧~</p><p>所以，我建议还是尽可能手写，通过本文这样一个流程，虽然支持的属性有20多个，但是分类后并不难记，难记也可以拿出本文翻一翻~</p><p>好了，思考了半天，如何通过一个案例介绍完所有的属性，总体来说还是完成了，给自己点个赞。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> Android </category>
          
          <category> ConstraintLayout </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Android </tag>
            
            <tag> ConstraintLayout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习有意思！ 01》- 世界上最简单的机器学习入门</title>
      <link href="/2018/funny_machine_learning_1/index/"/>
      <url>/2018/funny_machine_learning_1/index/</url>
      
        <content type="html"><![CDATA[<h1 id="《机器学习有意思！-01》-世界上最简单的机器学习入门"><a href="#《机器学习有意思！-01》-世界上最简单的机器学习入门" class="headerlink" title="《机器学习有意思！ 01》- 世界上最简单的机器学习入门"></a>《机器学习有意思！ 01》- 世界上最简单的机器学习入门</h1><blockquote><p> <em>原文：<a href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471#.gk1w0ndz3">Machine Learning is Fun! Part 1 —— The world’s easiest introduction to Machine Learning</a></em><br> <em>作者：Adam Geitgey</em></p></blockquote><hr><p><em>你是否也曾听人们谈起机器学习但是只有一个朦胧的概念？你是否厌倦了在同事的高谈阔论中颓然欲睡？此诚求变之机。</em></p><hr><p>本教程适合所有对机器学习感到好奇，却不知从何下手的读者。我想应该有很多人试着读了维基百科页面，然后愈发迷惘、沉沦，盼望着有人能够提供一个high-level的解释，那你找对地方了。</p><p>我们的目标是让所有人都能读懂——这就难免有些泛泛而谈。但是无妨，但凡本文能让一个人真正对机器学习感兴趣，那么目的就算达到了。</p><h2 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h2><p>机器学习的核心思想是创造一种普适的算法，它能从数据中挖掘出有趣的东西，而不需要针对某个问题去写代码。你需要做的只是把数据“投喂”给普适算法，然后它会在数据上建立自己的逻辑。</p><p>比如说有一种算法，叫分类算法，它可以把数据分到不同的组别当中。一个识别手写数字的分类算法，也可以用作判断垃圾邮件，而无需修改一行代码。算法是同一个算法，只是输入了不同的训练数据，便有了不同的分类逻辑。</p><p><img src="/img/funny_machine/10000.png"></p><blockquote><p>机器学习算法是个黑盒，且可以在不同分类问题中重复利用。</p></blockquote><p>“机器学习”是个筐，什么普适算法都往里装。</p><hr><h2 id="两种机器学习算法"><a href="#两种机器学习算法" class="headerlink" title="两种机器学习算法"></a>两种机器学习算法</h2><p>机器学习主要分为两类——有监督学习和无监督学习，区别很简单，却很关键。</p><ul><li><h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><p>想想你是一家房产中介。你的业务正在增长，所以雇了一帮实习销售来助拳。那么问题来了——身经百战的你，一眼就看穿一栋房子价值几何，但是实习生可没有这样丰富的人生经验，所以摸不准行情。</p><p>为了辅助实习生（以便解放自己度个假），你决定做个小程序，基于面积、周边环境、相似房产成交价等等，来预估本地的房价。</p><p>所以你把3个月来本市的每一笔交易都拿小本本记了下来。对每处房产都整理了一大堆细节——房间数、面积、周边环境等等，当然最重要的是，最终成交价：</p><p><img src="/img/funny_machine/10001.png"></p><blockquote><p>这就是我们的“训练数据”</p></blockquote><p>有了训练数据，我们就想搞个程序去预估其他的房价：</p><p><img src="/img/funny_machine/10002.png"></p><blockquote><p>用训练数据去预测别的房屋价格</p></blockquote><p>这就是<strong>有监督学习</strong>。你是知道每处房产到底卖多少的，换言之，问题的答案是已知的，逻辑是可以反推的。</p><p>为了开发小程序，把每处房产的训练数据导进机器学习算法里，算法试图摸索出其中的数学规律。</p><p>这有点像是去掉了符号的算术题答案：</p><p><img src="/img/funny_machine/10003.png">无监督学习</p><blockquote><p>Oh no!一个熊孩子把参考答案里的运算符号给涂没了！</p></blockquote><p>根据上图，你能否推算出这些题目的原貌呢？显然，我们需要对这些数字“动点手脚”，以使等式成立。</p><p>在<strong>有监督学习</strong>中，我们做的实际上就是让电脑代替人来让等式成立。一旦你学会了解决某一类问题，那么这类问题里的任何子问题都就迎刃而解了！</p></li><li><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>回到最开始那个卖房地产的例子。如果我们不知道具体每处房产的价格可咋整？即使仅知道面积、位置等信息，你也依然可以搞点动静出来，这就叫<strong>无监督学习</strong>。</p><p><img src="/img/funny_machine/10004.png"></p><blockquote><p>即使不预测未知数（比如房价），机器学习也能带来有趣的结论</p></blockquote><p>这就好比有人给你一张纸，上面写着一串数字，然后说“我也不知道啥意思，你可以猜猜这是什么套路——好运！”</p><p>这些数据我们能做什么呢？对于新手来讲，可以得到一个算法—，从数据中自动辨识出细分的市场定位。可能你会发现，当地大学附近的购房者偏好多卧室的小房子，而郊区的购房者则倾向于大套三。了解到不同类型消费者的存在可以指导市场行为。</p><p>另一个可以做的就是自动识别出那些少有相似点的特异房产。可能这些特异房产是豪华公馆，那么就可以调配最好的销售人员专门负责这些大买卖。</p><p>后文主要专注于有监督学习，但并非因为无监督学习的作用小或者趣味少。实际上无监督学习的重要性与日俱增且发展迅速，因为不需要事先对正确答案对应的数据加标签。</p><hr><blockquote><p>注：还有很多其他种类的机器学习算法，不过建议从这些基础算法入手。</p></blockquote><hr></li></ul><h2 id="哎哟不错，但是真的有可能“学习”到真实的房价吗？"><a href="#哎哟不错，但是真的有可能“学习”到真实的房价吗？" class="headerlink" title="哎哟不错，但是真的有可能“学习”到真实的房价吗？"></a>哎哟不错，但是真的有可能“学习”到真实的房价吗？</h2><p>作为一个人类，你的大脑可以面对各种形势，并且在无明确指导的情况下自主学习如何应对。如果你卖了很久的房子，就会慢慢地对房价、对销售策略、对观察客户等问题产生一种“感觉”。强人工智能研究的目的就在于让计算机掌握这种能力。</p><p>但是当前的机器学习算法还没那么厉害——它们只能对很具体、有限的问题生效。或许这里的“学习”更应该定义为“基于样本数据得出解决具体问题的等式”。</p><p>不幸的是，“让机器基于样本数据得出解决具体问题的等式”不是个好名字，所以我们还是回到了“机器学习”。</p><p>当然如果你在50年后，强人工智能都普及了时候看到本文，会觉得全文都很“古典”。别看了，让你的机器人给你拿个包子吃，未来人类。</p><h2 id="放码过来！"><a href="#放码过来！" class="headerlink" title="放码过来！"></a>放码过来！</h2><p>然，上面例子里的预测房价程序应该怎么写呢？思考一秒，然后接着看。</p><p>如果你对机器学习一无所知，可能会尝试依照预测房价的基本规律，写出如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood):</span><br><span class="line">    price = 0</span><br><span class="line"></span><br><span class="line">    # 这一片的均价是200美元一平米</span><br><span class="line">    price_per_sqft = 200</span><br><span class="line"></span><br><span class="line">    if neighborhood == &quot;hipsterton&quot;:</span><br><span class="line">        # 有的区更贵</span><br><span class="line">        price_per_sqft = 400</span><br><span class="line"></span><br><span class="line">    elif neighborhood == &quot;skid row&quot;:</span><br><span class="line">        # 有的区便宜</span><br><span class="line">        price_per_sqft = 100</span><br><span class="line"></span><br><span class="line">    # 根据基准价和面积预测实际价格</span><br><span class="line">    price = price_per_sqft * sqft</span><br><span class="line"></span><br><span class="line">    # 根据房间数调整预测</span><br><span class="line">    if num_of_bedrooms == 0:</span><br><span class="line"></span><br><span class="line">        # 公寓稍微便宜点</span><br><span class="line">        price = price — 20000</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        # 卧室多的房子贵</span><br><span class="line">        price = price + (num_of_bedrooms * 1000)</span><br><span class="line"></span><br><span class="line">    return price</span><br></pre></td></tr></table></figure><p>如果顺着写上几个小时，或许也能得到一个能跑的程序。但势必存在隐患，而且无法应对价格变化。</p><p>如果计算机能自己发现如何应用这些方程，那岂不是好得多？只要能得到正确的数字，谁管具体方程是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood):</span><br><span class="line">    price = 贾维斯，帮我算一下</span><br><span class="line"></span><br><span class="line">    return price</span><br></pre></td></tr></table></figure><p>这个问题可以想象成：<strong>价格</strong>是道炖菜，配方是<strong>卧室数量</strong>，<strong>面积</strong>和<strong>周边环境</strong>。如果你能算出每种成分对最终价格的影响是多少，或许那就是配方“搅合”最终价格的确切权重。</p><p>这可以使原程序（满是if&#x2F;else）变得简单如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood):</span><br><span class="line">    price = 0</span><br><span class="line"></span><br><span class="line">    # 加少许配方1</span><br><span class="line">    price += num_of_bedrooms * .841231951398213</span><br><span class="line"></span><br><span class="line">    # 加大把配方2</span><br><span class="line">    price += sqft * 1231.1231231</span><br><span class="line"></span><br><span class="line">    # 适量的配方3</span><br><span class="line">    price += neighborhood * 2.3242341421</span><br><span class="line"></span><br><span class="line">    # 最后来点盐</span><br><span class="line">    price += 201.23432095</span><br><span class="line"></span><br><span class="line">    return price</span><br></pre></td></tr></table></figure><p>注意这些奇妙深刻的加粗数字——**.841231951398213<strong>、 <strong>1231.1231231</strong>、</strong>2.3242341421<strong>和</strong>201.23432095<strong>，这就是我们的</strong>权重**。只要我们能找到准确的权重，那就可以预测房价了。</p><p>一个比较粗暴的权重计算方法大致如下：</p><p><strong>第一步</strong></p><p>把所有权重都设为<strong>1.0</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood):</span><br><span class="line">    price = 0</span><br><span class="line"></span><br><span class="line">    # 加少许配方1</span><br><span class="line">    price += num_of_bedrooms * 1.0</span><br><span class="line"></span><br><span class="line">    # 加大把配方2</span><br><span class="line">    price += sqft * 1.0</span><br><span class="line"></span><br><span class="line">    # 适量的配方3</span><br><span class="line">    price += neighborhood * 1.0</span><br><span class="line"></span><br><span class="line">    # 最后来点盐</span><br><span class="line">    price += 1.0</span><br><span class="line"></span><br><span class="line">    return price</span><br></pre></td></tr></table></figure><p><strong>第二步</strong></p><p>把每个房产的参数代入公式，计算预测结果和实际价格的误差：</p><p><img src="/img/funny_machine/10005.png"></p><blockquote><p>用你的方程来猜房价</p></blockquote><p>比如第一个房子实际卖了250,000，但是你的方程却预测的是178,000，但这一个房子就少了72,000。</p><p>现在把每个房子对应误差的平方加起来，比方你有500单交易，那么误差的平方和就有$86,123,373，可谓谬以千里。再把平方和除以500得到平均每个房子的误差，这一平均误差值就是方程的代价（即最小二乘法，平方是为了防止误差正负相抵）。</p><p>如果我们能通过调整权重将代价降为零，那方程就完美了。这表示在所有例子中，方程都准确无误地基于输入数据猜中了房价。这就是我们的目标——尝试不同的权重，让代价尽量低。</p><p><strong>第3步：</strong></p><p>不断地重复第2步，尝试每一种可能的权重值组合。哪个组合能让代价最接近于0就选哪一组。找到那一组权重，就解决了问题！</p><hr><h2 id="脑洞时间"><a href="#脑洞时间" class="headerlink" title="脑洞时间"></a>脑洞时间</h2><p>挺简单的对吧？回想一下刚才的所做，拿到一些数据，填进三个普适的、简单的步骤里，然后得到一个能猜房价的方程。Zillow（美国房价预测网站）面临着严重的威胁！</p><p>但是有这么几个激动人心的事实：</p><ol><li><p>过去40年里，很多领域（如语言学&#x2F;翻译学）的研究已经表明，“搅合数字炖菜”（作者自己打的比方）的普适性学习算法已经超越了那些，由真人尝试自己发现显式规律的人方法。机器学习的“暴力”方法最终击败了人类专家。</p></li><li><p>刚才得出的方程其实是很笨的。它并不知道“平方米”和“卧室”到底是什么，它只知道“搅拌”多少数字可以得到正确答案。</p></li><li><p>你大概并不知道为什么某一组权重就是好的，而只是写了一个自己都不明白的方程，但却证明是好用的。</p></li><li><p>假设我们不用“平方米”和”卧室数“这些参数，而是读入一个数列。比方说每个数字代表的是”从车顶上拍的照片的某一像素的亮度”，然后我们预测的结果也不是“房价”了，而是“方向盘转过的角度”。<strong>这就是一个人自动驾驶的风方程了？</strong></p></li></ol><p>疯了，对吧？</p><h2 id="第3步的“尝试每个数字”"><a href="#第3步的“尝试每个数字”" class="headerlink" title="第3步的“尝试每个数字”"></a>第3步的“尝试每个数字”</h2><p>当然你不可能真的尝试每一种可能权重组合来寻找最优解，实际情况是永远尝试不完。</p><p>为了避免这一情况，数学家们发现了很多机智办法来尽快找到一个不错的结果。以下就是其中一种：</p><p>第一，写一个能够代表上面“第2步”的方程：</p><p><img src="/img/funny_machine/10006.png"></p><blockquote><p>这就是代价函数</p></blockquote><p>然后用机器学习界的黑话（暂时可以忽略）重新写一遍：</p><p><img src="/img/funny_machine/10007.png"></p><blockquote><p>θ代表当前权重。J(θ)是当前权重的代价值。</p></blockquote><p>这个等式代表了在当前的权重组合下，我们的价格预测有多么离谱。</p><p>如果把房间数和平方米所有可能权重值可视化，可以得到类似下图的图像：</p><p><img src="/img/funny_machine/10008.png"></p><blockquote><p>代价函数的图像像个碗。竖直轴表示代价。</p></blockquote><p>这个图里的蓝色最低点就是代价的最低点——方程误差最小处，最高点即是最离谱的情况。所以如果我们找到一组权重值，使得方程对应最低点，那就是答案！</p><p><img src="/img/funny_machine/10008.png"></p><p>所以我们只需要以“下山”的方式来调整权重，逼近最低点。如果每一次微小的调整都向着最低点进发，那迟早能够到达。</p><p>函数的导数就是切线的斜率，换句话说，这告诉我们哪条路可以“下山”。</p><p>因此如果计算代价函数对每个权重的偏微分，然后再从权重里减去这个值，这可以让我们离谷底更近。重复执行，最终我们会到达谷底并获得权重的最优解（如果没看懂，不要担心，继续看）。</p><p>这是一种寻找方程最佳权重方式的高度概括，叫作批梯度下降(batch gradient descent)。如果你对此感兴趣，不要害怕，<a href="http://hbfs.wordpress.com/2012/04/24/introduction-to-gradient-descent/">了解更多细节</a>。</p><p>当你使用机器学习库来解决实际问题的时候，这些都会自动完成，但是了解究竟发生了什么还是很有用的。</p><hr><h2 id="还略过了什么？"><a href="#还略过了什么？" class="headerlink" title="还略过了什么？"></a>还略过了什么？</h2><p>上述的三步算法即是<strong>多变量线性回归</strong>，针对一条穿过房产数据的直线来进行预测目标等式，并用这一等式去猜测此前未曾见过的房屋价格，解决实际问题的时候这非常行之有效。</p><p>但是以上方法或许只对特别简单的例子好使，并非万金油。其中一个原因就是房价不总是简单到能用一条连续直线来代表。</p><p>好在另有很多方法解决，很多机器学习算法可以处理非线性数据（如神经网络 或 有核 的支持向量机)。同样也有算法是以更加聪明的方式使用线性回归以拟合更复杂的直线。但不论哪一方法，最根本的思想都是找到最佳的权重。</p><p>并且我忽略了过拟合问题。对于已有的原始数据，找到一组很棒的权重值不难，但是却有可能对训练集以外新的房子不适用。有很多方法可以避免这一现象（如正则化和使用交叉验证数据集），这是成功应用机器学习算法的关键命题。</p><p>尽管基本概念很简单，但是要用机器学习取得有用的结果，还是需要技巧和经验的。不过这些技巧是每一个开发者，都能够学会的！</p><hr><h2 id="机器学习是魔法吗？"><a href="#机器学习是魔法吗？" class="headerlink" title="机器学习是魔法吗？"></a>机器学习是魔法吗？</h2><p>看到机器学习技术如此轻易就解决了看起来非常困难的问题（如手写识别），你可能会感觉只要有足够多的数据，什么问题都不是问题了。导入数据，然后等着计算机变出一个适合数据的式子！</p><p>但需要记住的事，机器学习要想生效，必须满足一个条件，就是目标问题对已有数据确实是可解的。</p><p>比如建立一个模型，根据房子里种的植物种类预测房价，这肯定不管用。因为房里的植物和售价本来就没有关系，不管再怎么试，计算机还是无法找出这种关系。</p><p><img src="/img/funny_machine/100010.png"></p><blockquote><p>只有实际存在的关系才能建模</p></blockquote><p>所以如果一位人类专家不能用数据解决某个问题，计算机也不行。相反，计算机的优势在于，对于人类能解决的问题，计算机可以更快地完成。</p><hr><h2 id="如何学习更多机器学习"><a href="#如何学习更多机器学习" class="headerlink" title="如何学习更多机器学习"></a>如何学习更多机器学习</h2><p>在我看来，机器学习目前最大的问题在于其主要还是存在于学术界，对于广大只是想稍微了解、而并非想成为专家的人们，通俗易懂的材料还是不够丰富，当然这一情况已经在好转。</p><p>吴恩达的<a href="https://www.coursera.org/course/ml">Machine Learning class on Coursera</a>相当惊艳，我强烈推荐从这里开始。对于CS专业的人，只要还记得一丁点数学，就可以学。</p><p>你也可以通过下载安装<a href="http://scikit-learn.org/stable/">Scikit-learn</a>，来自己尝试海量的机器学习算法，这是一个提供“黑盒”版标准算法的Python框架。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链技术学习指引</title>
      <link href="/2018/blockchain_guide/index/"/>
      <url>/2018/blockchain_guide/index/</url>
      
        <content type="html"><![CDATA[<p>本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>给迷失在如何学习区块链技术的同学一个指引，区块链技术是随比特币诞生，因此要搞明白区块链技术，应该先了解下比特币。<br>但区块链技术不单应用于比特币，还有非常多的现实应用场景，想做区块链应用开发，可进一步阅读以太坊系列。</p><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>如果你是还不知比特币是什么，那就看看<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">比特币是什么</a></p><h3 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h3><p>接下来可以通过下面这几篇文章了解比特币大概的运行原理：</p><ul><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-08-whatbc.html">区块链记账原理</a><br>通过这篇可以了解到区块链是一个怎样的结构</li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-12-bitcoin-own.html">比特币所有权及隐私问题</a><br>通过这篇可以了解到地址私钥 非对称加密应用 等概念</li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-13-bitcoin-pow.html">比特币如何挖矿</a><br>通过这篇了解工作量证明</li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/2018-03-03-bitcoin-sonsensus.html">比特币如何达成共识 - 最长链的选择</a><br>通过这篇可以了解共识机制。</li></ul><h4 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h4><ul><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/2018-01-01-bitcoin-byzantine.html">什么是拜占庭将军问题</a></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>在基础入门之后，可以进一步阅读以下几篇，理解分布式网络，交易验证。</p><ul><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-13-bitcoin-p2p.html">分析比特币网络：一种去中心化、点对点的网络架构</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-14-merkle.html">比特币区块结构 Merkle 树及简单支付验证分析</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-14-bitcoin-script.html">比特币脚本及交易分析 - 智能合约雏形</a></li></ul><p>看完上面这些，区块链应该理解差不多了，就可以尝试实现一个简单的区块链了。参考这篇<a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/2018-02-09-build_blockchain_by_python.html">用Python从零开始创建区块链</a>。</p><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上，去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。</p><ul><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-22-whatiseth.html">以太坊开发入门</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/2018-02-24-init-env.html">智能合约开发环境搭建及Hello World合约</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/geth/2018-02-24-geth_cmd_options.html">以太坊客户端Geth命令用法-参数详解</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/geth/2018-02-25-geth_cmd_short.html">Geth控制台使用实战及Web3.js使用</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E7%A7%81%E6%9C%89%E9%93%BE/2018-03-18-create_private_blockchain.html">如何搭建以太坊私有链</a></li></ul><h3 id="智能合约及应用开发"><a href="#智能合约及应用开发" class="headerlink" title="智能合约及应用开发"></a>智能合约及应用开发</h3><ul><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Dapp/2018-02-25-first-dapp.html">一步步教你开发、部署第一个Dapp应用</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-08-create_token.html">一步步教你创建自己的数字货币（代币）进行ICO</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-10-create-token2.html">实现一个可管理、增发、兑换、冻结等高级功能的代币</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-14-ico-crowdsale.html">如何通过以太坊智能合约来进行众筹（ICO）</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/2018-03-23-token-erc721.html">剖析非同质化代币ERC721–全面解析ERC721标准</a></li></ul><h3 id="Solidity语言教程"><a href="#Solidity语言教程" class="headerlink" title="Solidity语言教程"></a>Solidity语言教程</h3><ul><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-01-solidity1.html">Solidity 教程系列1 - 类型介绍</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-05-solidity2.html">Solidity 教程系列2 - 地址类型介绍</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-09-solidity_func.html">Solidity 教程系列3 - 函数类型介绍</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-12-solidity_reftype_datalocation.html">Solidity 教程系列4 - 数据存储位置分析</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-13-solidity-arrays.html">Solidity 教程系列5 - 数组介绍</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-13-solidity-structs.html">Solidity 教程系列6 - 结构体与映射</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-15-solidity-unit.html">Solidity 教程系列7 - 以太单位及时间单位</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Solidity/2018-03-15-solidity-api.html">Solidity 教程系列8 - Solidity API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】先搞懂这八大基础概念，再谈机器学习入门</title>
      <link href="/2017/machine_learning_base/index/"/>
      <url>/2017/machine_learning_base/index/</url>
      
        <content type="html"><![CDATA[<h3 id="【机器学习】先搞懂这八大基础概念，再谈机器学习入门"><a href="#【机器学习】先搞懂这八大基础概念，再谈机器学习入门" class="headerlink" title="【机器学习】先搞懂这八大基础概念，再谈机器学习入门"></a>【机器学习】先搞懂这八大基础概念，再谈机器学习入门</h3><hr><p>  准备好开始AI了吗？可能你已经开始了在机器学习领域的实践学习，但是依然想要扩展你的知识并进一步了解那些你听过却没有时间了解的话题。</p><p>  这些机器学习的专业术语能够简要地介绍最重要的机器学习概念—包括商业界和科技界都感兴趣的话题。在你遇到一位AI指导者之前，这是一份不详尽，但清楚易懂又方便在工作、面试前快速浏览的内容。</p><h6 id="概览："><a href="#概览：" class="headerlink" title="概览："></a>概览：</h6><ul><li><p>自然语言处理</p></li><li><p>数据库</p></li><li><p>计算机视觉</p></li><li><p>监督学习</p></li><li><p>无监督学习</p></li><li><p>强化学习</p></li><li><p>神经网络###### 概览：</p></li><li><p>过拟合</p></li></ul><hr><h4 id="1-自然语言处理"><a href="#1-自然语言处理" class="headerlink" title="1. 自然语言处理"></a>1. 自然语言处理</h4><p>自然语言处理对于许多机器学习方法来说是一个常用的概念，它使得计算机理解并使用人所读或所写的语言来执行操作成为了可能。</p><p><img src="/img/base_machine/640.png"><br>自然语言处理最重要的最有用的实例：</p><ul><li><p>文本分类和排序</p><p>这项任务的目标是对一个文本进行预测标签(类别)或对列表中相关联的文本进行排序。它能够用于过滤垃圾邮件(预测一封电子邮件是否是垃圾邮件)，或进行文本内容分类(从网络上筛选出那些与你的竞争者相关的文章)。</p></li><li><p>情感分析</p><p>句子分析是为了确定一个人对某个主题的看法或情感反应，如正面或负面情绪，生气，讽刺等。它广泛应用于用户满意度调查(如对产品的评论进行分析)。</p></li><li><p>文件摘要</p><p>文件摘要是用一些方法来得到长文本(如文档，研究论文)短且达意的描述。对自然语言处理方向感兴趣吗？请进一步阅读人工智能关于自然语言处理方向的文章：<a href="https://sigmoidal.io/boosting-your-solutions-with-nlp/">https://sigmoidal.io/boosting-your-solutions-with-nlp/</a></p></li><li><p>命名实体识别</p><p>命名实体识别算法是用于处理一系列杂乱的文本并识别目标(实体)预定义的类别，如人，公司名称，日期，价格，标题等等。它能够将杂乱的文本信息转换成规则的类表的格式，来实现文本的快速分析。</p></li><li><p>语音识别</p><p>语音识别技术是用于得到人所讲的一段语音信号的文本表达。你可能听说过Siri助手？这就是语音识别应用的一个最好的例子。</p></li><li><p>自然语言的理解和生成</p><p>自然语言的理解是通过计算机，将人类生成的文本转换成更正式的表达。反过来，自然语言生成技术是将一些正式又有逻辑性的表达转换成类人的生成文本。如今，自然语言理解和生成主要用于聊天机器人和报告的自动生成。</p><p>从概念上来说，它与实体命名识别任务是相反的。</p></li><li><p>机器翻译</p><p>机器翻译是将一段文本或语音自动从一种语言翻译成另一种语言的一项任务。请见：<a href="https://youtu.be/Io0VfObzntA">https://youtu.be/Io0VfObzntA</a></p></li></ul><h4 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h4><p>数据库是机器学习一个必要的组成部分。如果你想构建一个机器学习系统，你要么可以从公众资源中得到数据，要么需要自己收集数据。所有的用于构建和测试机器学习模型的数据集合成为数据库。基本上，数据科学家会将数据划分为三个部分：</p><ul><li><p>训练数据：训练数据是用于训练模型。这意味着机器学习模型需要认识并通过学习得到数据的模式以及确定预测过程中最重要的数据特征。</p></li><li><p>验证数据：验证数据是用于微调模型参数和比较不同模型来确定最优的模型。验证数据应该不同于训练数据，且不能用于训练阶段。否则，模型将出现过拟合现象，且对新的数据泛化不佳。</p></li><li><p>测试数据：这看起来似乎有些单调，但这通常是第三个也是最后的测试集(经常也被称为对抗数据)。一旦最终的模型确定，它就用于测试模型在从未见过的数据集上的表现，如这些数据从未在构建模型或确定模型时使用过。</p></li></ul><p><img src="/img/base_machine/641.png"></p><p>图像：混合使用t-SNE和Jonker-Volgenant算法得到的MNIST数据库的可视化结果。T-SNE是一种广泛使用的降维算法，通过压缩数据的表达来得到更好的可视化和进一步处理。</p><h4 id="3-计算机视觉"><a href="#3-计算机视觉" class="headerlink" title="3. 计算机视觉"></a>3. 计算机视觉</h4><p>计算机视觉是一个专注于分析并深层次理解图像和视频数据的人工智能领域。计算机视觉领域最常见的问题包括：</p><ul><li><p>图像分类</p><p>图像分类是教模型去识别给定的图像的一种计算机视觉任务。例如，训练一个模型去识别公共场景下的多个物体(这可以应用于自动驾驶)。</p></li><li><p>目标检测</p><p>目标检测是教模型从一系列预定义的类别中检测出某一类别的实例，并用矩形框框注出来的一种计算机视觉任务。例如，利用目标检测来构建人脸识别系统。模型可以在图片中检测出每张脸并画出对应的矩形框(顺便说下，图像分类系统只能识别出一张图片中是否有脸的存在，而不能检测出脸的位置，而目标检测系统就可以)。<br><img src="/img/base_machine/642.png"></p></li><li><p>图像分割</p><p>图像分割是训练模型去标注类的每一个像素值，并能大致确定给定像素所属的预定义类别的一种计算机视觉任务。</p><p><img src="/img/base_machine/643.png"></p><p>显著性检测</p><p>显著性检测是训练模型产生最显著区域的一种计算机视觉任务。这可以用于确定视频中广告牌的位置。需要详细了解计算机视觉？请阅读 <a href="https://sigmoidal.io/dl-computer-vision-beyond-classification/">https://sigmoidal.io/dl-computer-vision-beyond-classification/</a></p></li></ul><h4 id="4-监督学习"><a href="#4-监督学习" class="headerlink" title="4. 监督学习"></a>4. 监督学习</h4><p>监督学习是用实例来教模型学习的一类机器学习模型集合。这意味着用于监督学习任务的数据需要被标注(指定正确的，真实类别)。例如，如果我们想要构建一个机器学习模型用于识别一个给定的文本是否被标记过的，我们需要给模型提供一个标记过的样本集 (文本+信息，是否该文本被标记过)。给定一个新的，未见过的例子，模型能够预测它的目标，例如，规定样本的标签，1表示标记过的而0表示未标记的。</p><h4 id="5-无监督学习"><a href="#5-无监督学习" class="headerlink" title="5. 无监督学习"></a>5. 无监督学习</h4><p>相比于监督学习，无监督学习模型是通过观察来进行自我学习。算法所用的数据是未标记过的(即提供给算法的是没有真实标签值的数据)。无监督学习模型能够发现不同输入之间的相关关系。最重要的无监督学习技术是聚类方法。对于给定的数据，模型能够得到输入的不同聚类(对于相似的数据聚合在同一类中)，并能将新的、未见过的输入归入到相似的聚类中。</p><p><img src="/img/base_machine/644.png"></p><h4 id="6-强化学习"><a href="#6-强化学习" class="headerlink" title="6. 强化学习"></a>6. 强化学习</h4><p>强化学习区别于先前我们提到的那些方法。强化学习算法一种“游戏”的过程,其目标是最大化 “游戏奖励”。该算法通过反复的实验来尝试确定不同的 “走法”，并查看哪种方式能够最大化 “游戏收益”</p><p>最广为人知的强化学习例子就是教计算机来解决魔方问题或下象棋，但是强化学习能解决的问题不仅只有游戏。最近，强化学习大量地应用于实时竞价，其模型负责为一个广告竞拍价格而它的报酬是用户的转换率。</p><p>想要学习人工智能在实时竞价和程序化广告中的应用吗？详见：<a href="https://sigmoidal.io/ai-for-advertising/">https://sigmoidal.io/ai-for-advertising/</a></p><h4 id="7-神经网络"><a href="#7-神经网络" class="headerlink" title="7. 神经网络"></a>7. 神经网络</h4><p>神经网络是一个非常广泛的机器学习模型集合。它的主要思想是模拟人类大脑的行为来处理数据。就像大脑中真实神经元之间相互连接形成的网络一样，人工神经网络由多层组成。每层都是一系列神经元的集合，这些神经元负责检测不同的食物。一个神经网络能够连续地处理数据，这意味着只有第一层才与输入直接相连，随着模型层数的增加，模型将学到越来越复杂的数据结构。当层数大量地增加，模型通常就是一个所谓的深度学习模型。很难给一个深度网络确定一个特定的网络层数，10年前通常3层神经网络就可谓深，而如今通常需要20层。</p><p><img src="/img/base_machine/640.jpeg"></p><p>神经网络有许许多多不同的变体，最常用的是：</p><p>卷积神经网络—它给计算机视觉任务带来了巨大的突破(而如今，它同样对于解决自然语言处理问题有很大帮助)。</p><p><img src="/img/base_machine/641.jpeg"></p><p>循环神经网络—被设计为处理具有序列特征的数据，如文本或股票票价。这是个相对古老的神经网络，但随着过去20年现代计算机计算能力的突飞猛进，使得它的训练变得容易并在很多时候得以应用。</p><p>全连接神经网络—这是处理静态&#x2F;表格式数据最简单的模型。</p><h4 id="8-过拟合"><a href="#8-过拟合" class="headerlink" title="8. 过拟合"></a>8. 过拟合</h4><p>当模型从不充分的数据中学习会产生偏差，这对模型会有负面的影响。这是个很常见，也很重要的问题。</p><p>当你在不同的时间进入一个面包坊，而每一次所剩下的蛋糕都没有你喜欢的，那么你可能会对这个面包坊失望，即使有很多其他的顾客可能会对剩下的蛋糕满意。如果你是个机器学习模型，可以说你对这一小数量样本产生了过拟合现象—要构建一个具有偏置量的模型，其得到的表示才不会过度拟合真实数据。</p><p>当过拟合现象发生，它通常意味着模型将随机噪声当作数据，并作为一个重要的信号去拟合它，这就是为什么模型在新数据上的表现会出现退化(噪声也有差异)。这在一些非常复杂的模型如神经网络或加速梯度模型上是很常见的。</p><p>想象构建一个模型来检测文章中出现的有关奥运的特定体育项目。由于所用的训练集与文章是由偏差的，模型可能学习到诸如 “奥运”这样词的特征，而无法检测到那些未包含该词的文章。</p><p><img src="/img/base_machine/642.jpeg"></p><p>这就是所有的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows + Ubuntu 双系统安装图解教程</title>
      <link href="/2017/ubuntu-install/index/"/>
      <url>/2017/ubuntu-install/index/</url>
      
        <content type="html"><![CDATA[<hr><p>终于，自己想起来自己也要写点什么了。。。(宛如一个智障&#x3D;_&#x3D;)。很早就有个想法，自己写点什么，但是怕是懒吧，一直不想写，或者说一直不知道写点什么。现在这个blog搭建的终于是让我满意了。那么，接下来就需要使劲写，把这个空的框架填起来，就像吹气球一样咯。加油！ps:暂时不打算放图片辣<del>(≧▽≦)&#x2F;</del></p><hr><h4 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h4><hr><p>U盘一个（请提前备份U盘里面的资料，因为后面操作要格式化U盘）</p><ul><li>Ubuntu 16.04LTS（长期支持版） 镜像：</li></ul><p>　　　　- 下载地址：<a href="http://www.ubuntu.com/download/desktop" title="Ubuntu下载地址">http://www.ubuntu.com/download/desktop</a></p><p>　　　　-Ubuntu中国下载地址：<a href="http://cn.ubuntu.com/download/" title="Ubuntu中国下载地址">http://cn.ubuntu.com/download/</a></p><ul><li>ultraiso  可以免费试用，地址百度一堆呢</li></ul><h5 id="硬盘做好分区，一般40G左右就够了。"><a href="#硬盘做好分区，一般40G左右就够了。" class="headerlink" title="硬盘做好分区，一般40G左右就够了。"></a>硬盘做好分区，一般40G左右就够了。</h5><p><img src="/img/fenqu.png" alt="分区"><br>__ <em>绿色框中是留给Ubuntu的空间</em> __</p><blockquote><p>注意：</p><p>（1）如果想学习Linux的话，留给Ubuntu使用的空间建议大于40G。</p><p>（2）这里是一整个未分配空间，这样可以在安装Ubuntu的时候直接选择和Windows共存安装，自动分配空间，不用自己再给系统分区设置大小了。</p></blockquote><h5 id="使用ultraiso做U盘启动-老电脑记得使用MBR-，或者在Windows中用cmd命令制作启动盘。"><a href="#使用ultraiso做U盘启动-老电脑记得使用MBR-，或者在Windows中用cmd命令制作启动盘。" class="headerlink" title="使用ultraiso做U盘启动(老电脑记得使用MBR)，或者在Windows中用cmd命令制作启动盘。"></a>使用ultraiso做U盘启动(老电脑记得使用MBR)，或者在Windows中用cmd命令制作启动盘。</h5><ol><li><p>插入用来制作启动盘的U盘（会被格式化，请备份好重要文件），打开UltraISO刻录软件（免费无限期试用）。<img src="/img/UlstraISO.png" alt="UltraISO制作启动盘"></p></li><li><p>选择“文件(F)”-&gt;“打开”，找到“Ubuntu-16.04-desktop-amd64.iso”镜像文件，然后点击“打开”。<img src="/img/UlstraISO1.png" alt="UltraISO制作启动盘"></p></li><li><p>选择“启动(B)”-&gt;“写入硬盘映像”，打开启动盘制作界面。<img src="/img/UlstraISO2.png" alt="UltraISO制作启动盘"></p></li><li><p>然后点击下方的“写入”，会弹出警告提示，确定后，就会开始制作启动盘。写入完成后关闭UltraISO软件即可。<img src="/img/UlstraISO3.png" alt="UltraISO制作启动盘"></p><blockquote><p>建议：USB3.0的U盘写入速度大约是USB2.0的10倍，推荐使用USB3.0接口的U盘。</p></blockquote></li></ol><h5 id="【BIOS设置】"><a href="#【BIOS设置】" class="headerlink" title="【BIOS设置】"></a>【BIOS设置】</h5><ol><li>关机，重新打开电脑，进入BIOS，关闭Windows系统的快速启动（Fast Boot）选项，即设置为Disable状态。<img src="/img/Bios.png" alt="关闭BIOS快速启动"></li><li>在BIOS中设置U盘为第一启动项，关闭电脑。<blockquote><p>这一步也可以省略，有些电脑在开机时可以通过按F12 或者Esc选择启动方式，看个人电脑配置吧。</p></blockquote></li></ol><h5 id="【安装Ubuntu-16-04】"><a href="#【安装Ubuntu-16-04】" class="headerlink" title="【安装Ubuntu 16.04】"></a>【安装Ubuntu 16.04】</h5><ol><li><p>从U盘启动，进入刻录到U盘的Ubuntu系统中。</p><blockquote><p>一般选择Try ubuntu，你不喜欢直接用桌面系统的话也可以直接选择Install Ubuntu.</p></blockquote></li><li><p>选择试用Ubuntu，稍等一会，进入Ubuntu Desktop。<img src="/img/Deskop.png" alt="Ubuntu 桌面"></p></li><li><p>双击左上角的”Install Ubuntu 16.04LTS“，打开安装界面。（安装过程比较简单，根据提示输入一些信息即可）</p></li></ol><ul><li>在左侧语言栏选择安装语言，然后点击“继续”。<img src="/img/install1.png" alt="Ubuntu 安装"></li><li>如果网速比较快，可以勾选“安装Ubuntu时下载更新”。（如果选择的语言是中文，这里在更新的时候会自动安装中文输入法，当然也可以安装完成后安装搜狗拼音输入法Linux版）<img src="/img/install2.png" alt="Ubuntu 安装"><blockquote><p>点击继续</p></blockquote></li><li>在硬盘中Ubuntu检测到有Windows系统存在，所以会默认使用未分配的那部分空间安装Ubuntu。<img src="/img/install3.png" alt="Ubuntu 安装"><blockquote><p>注意：千万别选第一个选项，我就被坑过一次，导致Windows系统也要重装T_T</p></blockquote></li><li>选择这一项，然后点击继续<img src="/img/install3.jpg" alt="Ubuntu 安装"></li><li>进入分区界面后，可以看到&#x2F;dev&#x2F;sda这块磁盘已安装好windows10系统，而我们将要安装的&#x2F;dev&#x2F;sdb还处于空闲状态。<img src="/img/install4.jpg" alt="Ubuntu 安装"></li><li>下面我们将进行分区，网上很多教程都说要单独将_&#x2F;boot_挂载，其实也可以不用这样。一般情况下只用挂载_&#x2F;根目录 ,&#x2F;home用户目录, swap交换分区_三个目录就行了，我这里因为在使用中有部分数据需要存在&#x2F;var目录下，所以就将&#x2F;var也进行了单独的挂载。 <img src="/img/install5.jpg" alt="Ubuntu 安装"><blockquote><p>注意，要将安装的启动引导器(grub2)设备选择在efi分区上也就是我们安装windows时设置的分区。</p></blockquote>  接下来会有提示信息。<img src="/img/install5.png" alt="Ubuntu 安装"></li><li>输入自己的位置以配置时区。<img src="/img/install7.png" alt="Ubuntu 安装"></li><li>键盘布局默认就可以。<img src="/img/install8.png" alt="Ubuntu 安装"></li><li>输入账户信息和密码。<img src="/img/install9.png" alt="Ubuntu 安装"></li><li>接下来下载更新，自动安装。<br>  <img src="/img/install10.png" alt="Ubuntu 安装"><br>  <img src="/img/install11.png" alt="Ubuntu 安装"></li><li>安装完成之后重启。<img src="/img/install12.png" alt="Ubuntu 安装"></li><li>下面就是正常的复制文件开始安装了，安装好重启系统，就会出现grub2引导器的选择界面了。从图中可以看到第一个是ubuntu系统，第三个就是window10系统。<img src="/img/install6.jpg" alt="Ubuntu 安装"></li></ul><blockquote><p>安装后的配置请见下一篇</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Windows </tag>
            
            <tag> 双系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你如何远离盗号和诈骗</title>
      <link href="/2017/165/165/"/>
      <url>/2017/165/165/</url>
      
        <content type="html"><![CDATA[<p>摘要：其实大部分安全隐患都是我们自己上网习惯不当而造成的，如果我们能养成良好的上网习惯，就可以最大限度的避免电脑被木马感染，防止QQ\网游\网银等账号被盗、财产被骗。总结了以下十点，希望能够帮助每一位网友最大限度地远离病毒木马侵害。</p><p>许多人都觉得安全上网不就是花钱买个杀毒软件安装上就可以了，其实不然，再强的杀毒软件也无法保证100%安全。根据统计数据显示，即使安装有杀毒软件的电脑用户仍有20%的机器会被木马&#x2F;病毒感染而无法检查出来，从各大知名安全厂商的监控数据也可以看到，每日有上百万用户机器被新木马&#x2F;病毒感染，其中网络游戏盗号类木马更是占到80%左右。</p><p>看到了如此可怕的数据可想而知我们每天上网都要面临多大的安全隐患，其实大部分安全隐患都是我们自己上网习惯不当而造成的，如果我们能养成良好的上网习惯，就可以最大限度的避免电脑被木马感染，防止QQ\网游\网银等账号被盗、财产被骗。总结了以下十点，希望能够帮助每一位网友最大限度地远离病毒木马侵害。</p><span id="more"></span><h2 id="一、重装系统后立即打补丁"><a href="#一、重装系统后立即打补丁" class="headerlink" title="一、重装系统后立即打补丁"></a>一、重装系统后立即打补丁</h2><p>重装完系统后的第一件事就是为系统打补丁。不打补丁就上网而不中毒的概率与跳到粪坑里却一尘不染差不多。打补丁最好用金山清理专家、瑞星卡卡等专业打补丁工具。这些工具一次打完补丁后会在硬盘上留存一份，下次再打补丁就不必下载了，还可以做到离线打补丁。最好这次把补丁备份好了，下次重装系统之后先拔网线，把补丁全部打完了再上网安全系统迅速提高。</p><h2 id="二、良好的软件安装习惯"><a href="#二、良好的软件安装习惯" class="headerlink" title="二、良好的软件安装习惯"></a>二、良好的软件安装习惯</h2><p>找软件一定要去官方网站和正规知名的下载站寻找，现在很多流氓下载站，本身甚至不提供任何好软件下载，只是通过搜索优化得到比较好的百度谷歌排名，当大家在网上搜索软件的时候，不太在意就容易进入这些站点。点击下载软件的时候，很可能是在下载木马。还有一些下载站甚至把广告位卖给木马制造者，这样更容易眼花了一不小心就点到有害的下载按钮。</p><p>所以大家如果不好分辨哪个是官方网站的话，一定要到一些网友口碑较好的知名网站，使用他们的站内搜索寻找这样下载到木马的几率自然就是非常少了。</p><h2 id="三、好奇心不要太重，防诈防骗很重要"><a href="#三、好奇心不要太重，防诈防骗很重要" class="headerlink" title="三、好奇心不要太重，防诈防骗很重要"></a>三、好奇心不要太重，防诈防骗很重要</h2><p>如今的恶意网站层出不穷，上个网还要学会防骗，真是时刻都在考验大家。随着网民参与互联网活动的日益频繁，网络上的诈骗案件数量也呈上升的趋势，并且花样繁多、防不胜防。欺诈者往往利用高额现金或丰厚奖品诱骗用户，这里劝大家一定要有一颗平常心了，天上不会掉馅饼，如果真有那个命每天中一台笔记本或者几万块钱，还不如支持一下中国的福彩事业。</p><h2 id="四、不要相信任何人发来的文件"><a href="#四、不要相信任何人发来的文件" class="headerlink" title="四、不要相信任何人发来的文件"></a>四、不要相信任何人发来的文件</h2><p>既然要安全那就要做到六亲不认，管他是七大姑八大姨，只要违反安全原则一概不信。首先，不要随意点击电子邮件或者QQ接收到的陌生链接，除非你明确的知道这个链接没问题，因为这有可能是病毒使用你好友的身份来骗你点击的恶意链接。其次，QQ陌生人发送给你的附件一律直接删除，没什么可好奇的。熟人发来的邮件最好先另存到本地，打开之前使用杀毒软件先检查一番。</p><p>另外，电脑接入U盘要当心，带毒的U盘只要一插入电脑不需要任何操作就可能中毒。因为Windows操作系统中有一个“自作聪明”的自动播放功能，一旦发现有U盘插入后，Windows就会主动把U盘上的病毒程序执行了。所以一般情况下，建议大家都设置禁止U盘自动播放，自己手动打开U盘更安全。当发现U盘有毒但手头又没有杀毒软件却又不得不使用其中的文件时，右键点击U盘，在菜单里选择“资源管理器”，实验证明这样操作文件不容易触发病毒。</p><h2 id="五、不要去访问低俗网站"><a href="#五、不要去访问低俗网站" class="headerlink" title="五、不要去访问低俗网站"></a>五、不要去访问低俗网站</h2><p>Windows有一个设置是隐藏文件的扩展名，许多病毒通过这个设置隐藏自己。比如：一个病毒名字是：“艳照门竟然有她.jpg.exe”，同时把图标改成图片的样子，诱使大家点击。解决此问题的办法是显示文件扩展名，操作如下：我的电脑&#x2F;工具&#x2F;文件夹选项&#x2F;查看&#x2F;隐藏已知文件类型的扩展名，把这一项勾选取消即可。同时对扩展名不了解的朋友一定要更小心，天下没有免费的午餐，美女是容易吸引人眼球，但也会让人忽略了安全这一说。来历不明的文件运行前一定先查毒，查看其真实扩展名。</p><h2 id="六、不要使用外挂玩网游"><a href="#六、不要使用外挂玩网游" class="headerlink" title="六、不要使用外挂玩网游"></a>六、不要使用外挂玩网游</h2><p>常听一些玩家说，十个外挂九个毒，特别是免费外挂，天下没有免费的午餐，为什么如此之多的人热衷为大家打造外挂，他们的收入哪里来?仔细想想吧!更有甚者仿冒外挂插件网站直接提供含木马的外挂下载。公平游戏，谢绝外挂。如果一定要用建议还是使用老牌收费外挂，并一定要从其官网下载。</p><h2 id="七、能在家里上网尽量不去网吧"><a href="#七、能在家里上网尽量不去网吧" class="headerlink" title="七、能在家里上网尽量不去网吧"></a>七、能在家里上网尽量不去网吧</h2><p>网吧人员混杂，很难保证你QQ、网游账号的安全，能在家上网尽量不要出去。如果要去网吧也最好留意机器上是否安装有重启系统还原的网吧上网，每次上网前重启一下电脑，如果还是不放心可以立即使用免费贝壳在线(beike.cn)杀木马快速检测一下机器。</p><h2 id="八、设置账号密码学问大"><a href="#八、设置账号密码学问大" class="headerlink" title="八、设置账号密码学问大"></a>八、设置账号密码学问大</h2><p>“IP\IC\IQ卡，通通告诉我密码”，众所周知，对于网民来说最重要的是什么?当然是各类互联网服务的账号密码。在黑客千方百计想要知道我们密码的今天如何才能保证账号的安全呢?请参考以下几项建议：</p><ol><li><p>设置复杂的密码：通常在黑客无法控制你电脑的情况下会暴力破解密码。不要使用诸如123456，123321…等等的弱口令作为自己重要账号的密码。</p></li><li><p>设置密码保护：在忘记账号密码后，都可以通过此功能来寻回密码。所以在账号创立之初就应当重视并记录该设置，防患于未然。</p></li><li><p>输入密码前验证该网站是否为官方提供：黑客通过仿造网站，软件，使用高相似度的域名迷惑网民使其自然填入真实的账号密码。一句话，别看广告，看真实网址域名。</p></li><li><p>在密码丢失后立即设置新的密码：盗号者可不会只光顾一次，可能你的木马已经被清除但密码已经被盗号者牢记啦!使用一些安全软件进行全面的系统扫描后，再对密码进行重新设定!</p></li></ol><h2 id="九、注意个人隐私安全"><a href="#九、注意个人隐私安全" class="headerlink" title="九、注意个人隐私安全"></a>九、注意个人隐私安全</h2><p>3.15晚会上曾经爆出了互联网上有人大量出售网友个人信息给一些公司，并揭露了垃圾短信的源头黑幕信息。这对于贩卖个人资料者来说，是一笔巨大的财富，但对于各位网民来说，更像是一场噩梦!你可能每天会接到骚扰电话、短信。你总不希望有一天你的电话被人冒用出现在各交友信息网站吧。所以在上网过程中请谨慎应对需要你填写真实信息的网站，以防个人信息被第三方轻易窃取!</p><h2 id="十、安装安全软件以及各种防御措施"><a href="#十、安装安全软件以及各种防御措施" class="headerlink" title="十、安装安全软件以及各种防御措施"></a>十、安装安全软件以及各种防御措施</h2><p>最后，强烈建议大家安装市场上正规厂商的知名安全防护软件。当前的互联网上的“黑客”甚至可以使用“批量生产”这个词来形容了，在各种病毒木马漫网飞的时代，一款强悍好用的安全软件能够为大家构筑一道绿色防线拦截各种网络威胁。安全软件要保护用户帐号安全，关键不在于能查杀多少数量的木马，积累了多少病毒特征，关键在于当一款盗号木马出现了，要多久才能被消灭。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>归根究底保持良好的上网习惯才是保护账户密码安全的根本，只要大家平时上网都做到了以上几点，相信你的电脑和账号都将会最大程度的得到安全的保证</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种教程分享</title>
      <link href="/2017/resources01/index/"/>
      <url>/2017/resources01/index/</url>
      
        <content type="html"><![CDATA[<hr><ul><li><a href="http://pan.baidu.com/share/link?shareid=141723&uk=3054038186" title="调音">调音</a></li><li><a href="http://pan.baidu.com/share/link?shareid=141724&uk=3054038186" title="节拍器">节拍器</a></li></ul><hr><p>3Dmax资料:</p><ul><li><a href="http://pan.baidu.com/s/1eQ6fQBg" title="600个3D光域网">600个3D光域网</a>  密码: 9d3n</li><li><a href="http://pan.baidu.com/s/1qW0vNWg" title="光域网灯光文件">光域网灯光文件</a> 密码：av8m</li></ul><hr><p>AI资料:</p><ul><li>AI CC安装软件MAC版 链接: <a href="http://pan.baidu.com/s/1kTu0t7p">http://pan.baidu.com/s/1kTu0t7p</a> 密码: fauj</li><li>AI CS6安装软件MAC版 链接: <a href="http://pan.baidu.com/s/1mgADwIO">http://pan.baidu.com/s/1mgADwIO</a> 密码: cvrh</li><li>AI CC官方原版 链接: <a href="http://pan.baidu.com/s/1eQtUAOy">http://pan.baidu.com/s/1eQtUAOy</a> 密码: 2gjc</li><li>AI CS5官方原版 链接: <a href="http://pan.baidu.com/s/1gd7zLkv">http://pan.baidu.com/s/1gd7zLkv</a> 密码: s6gr</li><li>AI CS6官方原版 链接: <a href="http://pan.baidu.com/s/1gd7zLkB">http://pan.baidu.com/s/1gd7zLkB</a> 密码: d6vv</li><li>AI CS4标准视频教程 链接: <a href="http://pan.baidu.com/s/1ptafs">http://pan.baidu.com/s/1ptafs</a> 密码: hfii</li><li>AI CS4高级实战讲解123集 链接: <a href="http://pan.baidu.com/s/1dD6hUXb">http://pan.baidu.com/s/1dD6hUXb</a> 密码: nzps</li><li>AI CS4平面设计与制作标准教程 链接: <a href="http://pan.baidu.com/s/1hqyAoFq">http://pan.baidu.com/s/1hqyAoFq</a> 密码: 253u</li><li>AI CS4特效设计与制作实例精讲 链接: <a href="http://pan.baidu.com/s/1sjsmnEX">http://pan.baidu.com/s/1sjsmnEX</a> 密码: tamn</li><li>AI CS5多媒体实例教程74讲 链接: <a href="http://pan.baidu.com/s/1qWDndm8">http://pan.baidu.com/s/1qWDndm8</a> 密码: 7s5g</li><li>AI CS5基础入门工具使用教程135集 链接: <a href="http://pan.baidu.com/s/1sjsSkwP">http://pan.baidu.com/s/1sjsSkwP</a> 密码: df4p</li><li>AI CS5平面广告创意108招 链接: <a href="http://pan.baidu.com/s/1qWHqMPQ">http://pan.baidu.com/s/1qWHqMPQ</a> 密码: 7gyn</li><li>AI CS5入门到精通视频教程 链接: <a href="http://pan.baidu.com/s/1qEULo">http://pan.baidu.com/s/1qEULo</a> 密码: 2grd</li><li>AI CS5实战从入门到精通200例 链接: <a href="http://pan.baidu.com/s/1kTouGYV">http://pan.baidu.com/s/1kTouGYV</a> 密码: ye2z</li><li>AI CS6地产广告设计20集 链接: <a href="http://pan.baidu.com/s/1ntzLUA1">http://pan.baidu.com/s/1ntzLUA1</a> 密码: 8xu8</li><li>AI CS6入门平面创意设计实例视频222集 链接: <a href="http://pan.baidu.com/s/1kTKOLN5">http://pan.baidu.com/s/1kTKOLN5</a> 密码: m5ky</li><li>AI CS6矢量绘图滤镜商业设计48集 链接: <a href="http://pan.baidu.com/s/1dDfJ7sl">http://pan.baidu.com/s/1dDfJ7sl</a> 密码: 76nj</li><li>AI插画与包装设计循序渐进400例 链接: <a href="http://pan.baidu.com/s/1ntoWBB7">http://pan.baidu.com/s/1ntoWBB7</a> 密码: mgnw</li><li>AI创意绘图与典型设计120例 链接: <a href="http://pan.baidu.com/s/1dDk3ksT">http://pan.baidu.com/s/1dDk3ksT</a> 密码: 55mq</li><li>AI素材 VI文件模板元素 链接: <a href="http://pan.baidu.com/s/1c0B9D4W">http://pan.baidu.com/s/1c0B9D4W</a> 密码: fve8</li></ul><hr><p>CAD资料:</p><ul><li>CAD2004安装软件 链接: <a href="http://pan.baidu.com/s/1qWoQ6dQ">http://pan.baidu.com/s/1qWoQ6dQ</a> 密码: bcc6</li><li>CAD2005安装软件 链接: <a href="http://pan.baidu.com/s/1hq5vNWo">http://pan.baidu.com/s/1hq5vNWo</a> 密码: x3me</li><li>CAD2006安装软件 链接: <a href="http://pan.baidu.com/s/1bnnpiO3">http://pan.baidu.com/s/1bnnpiO3</a> 密码: 7crs</li><li>CAD2007安装软件 链接: <a href="http://pan.baidu.com/s/1jG1nZc6">http://pan.baidu.com/s/1jG1nZc6</a> 密码: 14eb</li><li>CAD2008安装软件 链接: <a href="http://pan.baidu.com/s/1eQ5zSB4">http://pan.baidu.com/s/1eQ5zSB4</a> 密码: a8kf</li><li>CAD2009安装软件 链接: <a href="http://pan.baidu.com/s/1hq6HIPQ">http://pan.baidu.com/s/1hq6HIPQ</a> 密码: x1ge</li><li>CAD2010安装软件 链接: <a href="http://pan.baidu.com/s/1jG5XJqY">http://pan.baidu.com/s/1jG5XJqY</a> 密码: tuvz</li><li>CAD2011安装软件 链接: <a href="http://pan.baidu.com/s/1dD30cBv">http://pan.baidu.com/s/1dD30cBv</a> 密码: svus</li><li>CAD2012安装软件 链接: <a href="http://pan.baidu.com/s/1i3laZYX">http://pan.baidu.com/s/1i3laZYX</a> 密码: esft</li><li>CAD2013安装软件 链接: <a href="http://pan.baidu.com/s/1pJNy207">http://pan.baidu.com/s/1pJNy207</a> 密码: 98s9</li><li>CAD2014安装软件 链接: <a href="http://pan.baidu.com/s/1eQCl6DW">http://pan.baidu.com/s/1eQCl6DW</a> 密码: vywp</li><li>AutoCAD快捷键 链接: <a href="http://pan.baidu.com/s/1jG5XJro">http://pan.baidu.com/s/1jG5XJro</a> 密码: t2p7</li><li>CAD超级图库王 链接: <a href="http://pan.baidu.com/s/1dDhfy8p">http://pan.baidu.com/s/1dDhfy8p</a> 密码: 3aia</li><li>CAD家装施工图带实景照和效果图153套 链接: <a href="http://pan.baidu.com/s/1pJFWT5L">http://pan.baidu.com/s/1pJFWT5L</a> 密码: gzfy</li><li>CAD节点大样图详图129套剖面图立面图 链接: <a href="http://pan.baidu.com/s/1hqInf8o">http://pan.baidu.com/s/1hqInf8o</a> 密码: 919f</li><li>CAD镂空雕花图库 链接: <a href="http://pan.baidu.com/s/1dDfJ74d">http://pan.baidu.com/s/1dDfJ74d</a> 密码: 3qh1</li><li>CAD图案花纹大全 链接: <a href="http://pan.baidu.com/s/1kTqwC55">http://pan.baidu.com/s/1kTqwC55</a> 密码: tr4t</li><li>CAD图库大集合中欧式建筑室内家具 链接: <a href="http://pan.baidu.com/s/16oba2">http://pan.baidu.com/s/16oba2</a> 密码: zgea</li><li>CAD习题图库命令表 链接: <a href="http://pan.baidu.com/s/1gdu86jD">http://pan.baidu.com/s/1gdu86jD</a> 密码: u2t3</li><li>CAD最全CAD字体2485种 链接: <a href="http://pan.baidu.com/s/1eQCR3UU">http://pan.baidu.com/s/1eQCR3UU</a> 密码: qg16</li><li>梁志天施工图140套 链接: <a href="http://pan.baidu.com/s/1kT6BEy7">http://pan.baidu.com/s/1kT6BEy7</a> 密码: fb8m</li><li>CAD特殊符号输入法 链接: <a href="http://pan.baidu.com/s/1gdIpf6F">http://pan.baidu.com/s/1gdIpf6F</a> 密码: ikuy</li><li>CAD运用技巧 链接: <a href="http://pan.baidu.com/s/1i3D1uhn">http://pan.baidu.com/s/1i3D1uhn</a> 密码: ej82</li><li>十年CAD经验分享 链接: <a href="http://pan.baidu.com/s/1dDsAGvv">http://pan.baidu.com/s/1dDsAGvv</a> 密码: hf9f</li><li>CAD2006标准教程 链接: <a href="http://pan.baidu.com/s/1jGnaQ0Y">http://pan.baidu.com/s/1jGnaQ0Y</a> 密码: u3pt</li><li>CAD2007从零开始基础培训百例 链接: <a href="http://pan.baidu.com/s/1eQGprHK">http://pan.baidu.com/s/1eQGprHK</a> 密码: dvp8</li><li>CAD2007机械制图教程 链接: <a href="http://pan.baidu.com/s/1dD0crQx">http://pan.baidu.com/s/1dD0crQx</a> 密码: pzui</li><li>CAD2007建筑设计实例教程 链接: <a href="http://pan.baidu.com/s/1mgHyWI0">http://pan.baidu.com/s/1mgHyWI0</a> 密码: k39s</li><li>CAD2007视频教程SWF格式 链接: <a href="http://pan.baidu.com/s/1pJiMUbL">http://pan.baidu.com/s/1pJiMUbL</a> 密码: n66y</li><li>CAD2007视频教学录像 链接: <a href="http://pan.baidu.com/s/12kn5k">http://pan.baidu.com/s/12kn5k</a> 密码: s2px</li><li>CAD2007室内设计教程 链接: <a href="http://pan.baidu.com/s/1eQHBk0E">http://pan.baidu.com/s/1eQHBk0E</a> 密码: jhy3</li><li>CAD2007应用基础教程 链接: <a href="http://pan.baidu.com/s/1i3y8kK1">http://pan.baidu.com/s/1i3y8kK1</a> 密码: 4ggt</li><li>CAD2007职业应用教程 链接: <a href="http://pan.baidu.com/s/1c0ffCze">http://pan.baidu.com/s/1c0ffCze</a> 密码: z64c</li><li>CAD2007装修设计完全自学手册 链接: <a href="http://pan.baidu.com/s/1qWFoUC0">http://pan.baidu.com/s/1qWFoUC0</a> 密码: t4v3</li><li>CAD2007自学成才 链接: <a href="http://pan.baidu.com/s/1sjuUjYd">http://pan.baidu.com/s/1sjuUjYd</a> 密码: sixm</li><li>CAD2008标准教程 链接: <a href="http://pan.baidu.com/s/1o6mSGBo">http://pan.baidu.com/s/1o6mSGBo</a> 密码: fzjw</li><li>CAD2008电气设计基础与典型范例 链接: <a href="http://pan.baidu.com/s/1dD95Gy9">http://pan.baidu.com/s/1dD95Gy9</a> 密码: zwqh</li><li>CAD2008跟我学 链接: <a href="http://pan.baidu.com/s/1dDAlEPN">http://pan.baidu.com/s/1dDAlEPN</a> 密码: 1pdp</li><li>CAD2008机械设计典型案例 链接: <a href="http://pan.baidu.com/s/1dDfd8IH">http://pan.baidu.com/s/1dDfd8IH</a> 密码: a8ns</li><li>CAD2008机械制图基础教程 链接: <a href="http://pan.baidu.com/s/1i3xSl7J">http://pan.baidu.com/s/1i3xSl7J</a> 密码: ud2v</li><li>CAD2008实用教程机械设计 链接: <a href="http://pan.baidu.com/s/1mg5T9QK">http://pan.baidu.com/s/1mg5T9QK</a> 密码: ipaj</li><li>CAD2008完全掌握机械篇 链接: <a href="http://pan.baidu.com/s/1o6ssxS2">http://pan.baidu.com/s/1o6ssxS2</a> 密码: v48w</li><li>CAD2008完全掌握综合篇 链接: <a href="http://pan.baidu.com/s/1qW0vOnE">http://pan.baidu.com/s/1qW0vOnE</a> 密码: fjse</li><li>CAD2008无敌课堂 链接: <a href="http://pan.baidu.com/s/1sj7fvRn">http://pan.baidu.com/s/1sj7fvRn</a> 密码: 69gt</li><li>CAD2008新概念教程 链接: <a href="http://pan.baidu.com/s/1dDk3kAl">http://pan.baidu.com/s/1dDk3kAl</a> 密码: 58hu</li><li>CAD2008应用基础教程 链接: <a href="http://pan.baidu.com/s/1eQD70d0">http://pan.baidu.com/s/1eQD70d0</a> 密码: wkvw</li><li>CAD2009电气设计详解 链接: <a href="http://pan.baidu.com/s/1nth5dPZ">http://pan.baidu.com/s/1nth5dPZ</a> 密码: mm4e</li><li>CAD2009机械图形设计 链接: <a href="http://pan.baidu.com/s/1eQAP9XS">http://pan.baidu.com/s/1eQAP9XS</a> 密码: hhqw</li><li>CAD2009机械图学基础 链接: <a href="http://pan.baidu.com/s/1o6j4SNC">http://pan.baidu.com/s/1o6j4SNC</a> 密码: 1trh</li><li>CAD2009建筑电气工程制图实例精解 链接: <a href="http://pan.baidu.com/s/1ntBrsed">http://pan.baidu.com/s/1ntBrsed</a> 密码: kkj4</li><li>CAD2009建筑设计实战从入门到精通 链接: <a href="http://pan.baidu.com/s/1sjQIjrn">http://pan.baidu.com/s/1sjQIjrn</a> 密码: 94jc</li><li>CAD2009建筑图学基础 链接: <a href="http://pan.baidu.com/s/1sjBjgaL">http://pan.baidu.com/s/1sjBjgaL</a> 密码: w5v9</li><li>CAD2009室内装潢设计完美技法 链接: <a href="http://pan.baidu.com/s/1gdvUykj">http://pan.baidu.com/s/1gdvUykj</a> 密码: mjq3</li><li>CAD2009完全实战学习手册 链接: <a href="http://pan.baidu.com/s/1hqInfAc">http://pan.baidu.com/s/1hqInfAc</a> 密码: 5x2a</li><li>CAD2010电气设计实例教程 链接: <a href="http://pan.baidu.com/s/1kTjBenl">http://pan.baidu.com/s/1kTjBenl</a> 密码: psd7</li><li>CAD2010辅助绘图从入门到精通 链接: <a href="http://pan.baidu.com/s/1kTqwC7P">http://pan.baidu.com/s/1kTqwC7P</a> 密码: 5hps</li><li>CAD2010辅助设计经典实录228例 链接: <a href="http://pan.baidu.com/s/1gdF7qDX">http://pan.baidu.com/s/1gdF7qDX</a> 密码: 6xhw</li><li>CAD2010基础教程 链接: <a href="http://pan.baidu.com/s/1nt7T4DF">http://pan.baidu.com/s/1nt7T4DF</a> 密码: gh5n</li><li>CAD2010基础与实例全科教程 链接: <a href="http://pan.baidu.com/s/1i3w6rLb">http://pan.baidu.com/s/1i3w6rLb</a> 密码: fx96</li><li>CAD2010建筑设计绘图基础入门与范例精通 链接: <a href="http://pan.baidu.com/s/1c0lllIw">http://pan.baidu.com/s/1c0lllIw</a> 密码: 7fdr</li><li>CAD2010建筑设计经典208例 链接: <a href="http://pan.baidu.com/s/1i3xSl9b">http://pan.baidu.com/s/1i3xSl9b</a> 密码: ehqc</li><li>CAD2010建筑设计经典案例指导教程 链接: <a href="http://pan.baidu.com/s/1sjoi6kt">http://pan.baidu.com/s/1sjoi6kt</a> 密码: evbg</li><li>CAD2010建筑水暖电设计从入门到精通 链接: <a href="http://pan.baidu.com/s/1hqo0RnI">http://pan.baidu.com/s/1hqo0RnI</a> 密码: xwfv</li><li>CAD2010建筑图形设计 链接: <a href="http://pan.baidu.com/s/1eQ3ycRg">http://pan.baidu.com/s/1eQ3ycRg</a> 密码: 46vu</li><li>CAD2010快捷命令一册通 链接: <a href="http://pan.baidu.com/s/1hqpMJKo">http://pan.baidu.com/s/1hqpMJKo</a> 密码: gvrt</li><li>CAD2010入门与精通教程 链接: <a href="http://pan.baidu.com/s/1gdhHtcR">http://pan.baidu.com/s/1gdhHtcR</a> 密码: jjci</li><li>CAD2010视频教程 链接: <a href="http://pan.baidu.com/s/1gdixoPH">http://pan.baidu.com/s/1gdixoPH</a> 密码: gbmj</li><li>CAD2010室内设计视频教程 链接: <a href="http://pan.baidu.com/s/1nt7T4EX">http://pan.baidu.com/s/1nt7T4EX</a> 密码: kq92</li><li>CAD2010室内装潢设计从入门到精通 链接: <a href="http://pan.baidu.com/s/1jGre9Zw">http://pan.baidu.com/s/1jGre9Zw</a> 密码: 8868</li><li>CAD2010手把手教你学教程 链接: <a href="http://pan.baidu.com/s/1jGhBkB8">http://pan.baidu.com/s/1jGhBkB8</a> 密码: pg9p</li><li>CAD2010园林设计实践案例与练习 链接: <a href="http://pan.baidu.com/s/1mgBttjE">http://pan.baidu.com/s/1mgBttjE</a> 密码: w9a4</li><li>CAD2011电气设计教程 链接: <a href="http://pan.baidu.com/s/1kTpGD6n">http://pan.baidu.com/s/1kTpGD6n</a> 密码: rqib</li><li>CAD2011工程制图 链接: <a href="http://pan.baidu.com/s/1pJmkKGz">http://pan.baidu.com/s/1pJmkKGz</a> 密码: 79cm</li><li>CAD2011机械绘图实例教程 链接: <a href="http://pan.baidu.com/s/1ntoqGvZ">http://pan.baidu.com/s/1ntoqGvZ</a> 密码: j7wr</li><li>CAD2011机械设计经典208例 链接: <a href="http://pan.baidu.com/s/136k2q">http://pan.baidu.com/s/136k2q</a> 密码: yepr</li><li>CAD2011机械设计实战从入门到精通 链接: <a href="http://pan.baidu.com/s/1i3ENpsx">http://pan.baidu.com/s/1i3ENpsx</a> 密码: uz47</li><li>CAD2011机械制图快速入门实例教程 链接: <a href="http://pan.baidu.com/s/1c0dJDWs">http://pan.baidu.com/s/1c0dJDWs</a> 密码: yniq</li><li>CAD2011建筑图形设计 链接: <a href="http://pan.baidu.com/s/1i3F3l2l">http://pan.baidu.com/s/1i3F3l2l</a> 密码: caef</li><li>CAD2012 7天精通视频教程 链接: <a href="http://pan.baidu.com/s/1dDIZfX3">http://pan.baidu.com/s/1dDIZfX3</a> 密码: 638x</li><li>CAD2012从入门到精通 链接: <a href="http://pan.baidu.com/s/1mgmWL1e">http://pan.baidu.com/s/1mgmWL1e</a> 密码: app8</li><li>CAD2012机械设计绘图入门与精通 链接: <a href="http://pan.baidu.com/s/1o6oUB4A">http://pan.baidu.com/s/1o6oUB4A</a> 密码: cvek</li><li>CAD2012机械设计完全学习手册 链接: <a href="http://pan.baidu.com/s/1Fb4cA">http://pan.baidu.com/s/1Fb4cA</a> 密码: 9qfh</li><li>CAD2012基础教程30章 链接: <a href="http://pan.baidu.com/s/1mgkUUE0">http://pan.baidu.com/s/1mgkUUE0</a> 密码: tjq3</li><li>CAD2012建筑设计从入门到精通 链接: <a href="http://pan.baidu.com/s/1gdu86or">http://pan.baidu.com/s/1gdu86or</a> 密码: dims</li><li>CAD2012建筑与土木工程制图快速入门实例教程 链接: <a href="http://pan.baidu.com/s/1eQtUBhK%E5%AF%86%E7%A0%81">http://pan.baidu.com/s/1eQtUBhK密码</a>: u3xb</li><li>CAD2012经典实例教程15章 链接: <a href="http://pan.baidu.com/s/1o6qq2EY">http://pan.baidu.com/s/1o6qq2EY</a> 密码: iwk3</li><li>CAD2012精彩百例与解析 链接: <a href="http://pan.baidu.com/s/1eQ4JWPG">http://pan.baidu.com/s/1eQ4JWPG</a> 密码: 5za3</li><li>CAD2012入门教程9章 链接: <a href="http://pan.baidu.com/s/1bnwIApp">http://pan.baidu.com/s/1bnwIApp</a> 密码: mu9f</li><li>CAD2012三维造型实例教程 链接: <a href="http://pan.baidu.com/s/1pJJuLcf">http://pan.baidu.com/s/1pJJuLcf</a> 密码: 7gdw</li><li>CAD2012实战教程14章 链接: <a href="http://pan.baidu.com/s/1fjGcu">http://pan.baidu.com/s/1fjGcu</a> 密码: 3cut</li><li>CAD2012室内装潢设计标准实例教程 链接: <a href="http://pan.baidu.com/s/1mgGJd12">http://pan.baidu.com/s/1mgGJd12</a> 密码: y2b9</li><li>CAD2012室内装潢设计从入门到精通 链接: <a href="http://pan.baidu.com/s/1c0ATJ0k">http://pan.baidu.com/s/1c0ATJ0k</a> 密码: 8yre</li><li>CAD2012图形设计教程 链接: <a href="http://pan.baidu.com/s/1x09YY">http://pan.baidu.com/s/1x09YY</a> 密码: uujf</li><li>CAD2012应用完全学习手册 链接: <a href="http://pan.baidu.com/s/1c075Uec">http://pan.baidu.com/s/1c075Uec</a> 密码: u19m</li><li>CAD2013高手140集案例视频教程 链接: <a href="http://pan.baidu.com/s/1c0ffFpA">http://pan.baidu.com/s/1c0ffFpA</a> 密码: r5u5</li><li>CAD2013全套机械设计图纸绘图技法精讲 链接: <a href="http://pan.baidu.com/s/1mgADzQw">http://pan.baidu.com/s/1mgADzQw</a> 密码: i3y2</li><li>CAD2013入门到精通视频教程 链接: <a href="http://pan.baidu.com/s/1o65jDuM">http://pan.baidu.com/s/1o65jDuM</a> 密码: 5krf</li><li>CAD电气系统图与给排水图绘制教程 链接: <a href="http://pan.baidu.com/s/1nt3PMrv">http://pan.baidu.com/s/1nt3PMrv</a> 密码: mhcj</li><li>CAD给排水暖通空调·建筑电气设计与工程项目实战 链接: <a href="http://pan.baidu.com/s/1dD4Maop">http://pan.baidu.com/s/1dD4Maop</a> 密码: uew4</li><li>CAD模具设计排位教程 链接: <a href="http://pan.baidu.com/s/1i36FIjN">http://pan.baidu.com/s/1i36FIjN</a> 密码: 5pj6</li><li>CAD室内外施工图绘制视频教程 链接: <a href="http://pan.baidu.com/s/1bnwIAon">http://pan.baidu.com/s/1bnwIAon</a> 密码: 4r5a</li><li>CAD天正建筑视频教程演示全套29讲 链接: <a href="http://pan.baidu.com/s/1gds6EAJ">http://pan.baidu.com/s/1gds6EAJ</a> 密码: bjg7</li><li>CAD制图规范最新施工图标 链接: <a href="http://pan.baidu.com/s/1bnjRtWr">http://pan.baidu.com/s/1bnjRtWr</a> 密码: ue7h</li></ul><hr><p>CDR资料:</p><ul><li>CDR X4安装软件 链接: <a href="http://pan.baidu.com/s/1gdGTp6b">http://pan.baidu.com/s/1gdGTp6b</a> 密码: g99f</li><li>CDR X5安装软件 链接: <a href="http://pan.baidu.com/s/1kTipiEN">http://pan.baidu.com/s/1kTipiEN</a> 密码: uvgz</li><li>CDR X6安装软件 链接: <a href="http://pan.baidu.com/s/1dDCT7UD">http://pan.baidu.com/s/1dDCT7UD</a> 密码: n649</li><li>CDR X7安装软件 链接: <a href="http://pan.baidu.com/s/1ntnAJpf">http://pan.baidu.com/s/1ntnAJpf</a> 密码: r5gf</li><li>CDR X4案例实战从入门到精通 链接: <a href="http://pan.baidu.com/s/1ntkSXrN">http://pan.baidu.com/s/1ntkSXrN</a> 密码: 9vdb</li><li>CDR X4入门与提高基础自学视频教程 链接: <a href="http://pan.baidu.com/s/1c0DB8eW">http://pan.baidu.com/s/1c0DB8eW</a> 密码: xd27</li><li>CDR X4实例教学视频教程 链接: <a href="http://pan.baidu.com/s/1jGmuXSi">http://pan.baidu.com/s/1jGmuXSi</a> 密码: ak8r</li><li>CDR X5产品包装设计入门到精通教程 链接: <a href="http://pan.baidu.com/s/1o6j4VFk">http://pan.baidu.com/s/1o6j4VFk</a> 密码: qpy5</li><li>CDR广告设计高级教程 链接: <a href="http://pan.baidu.com/s/1c054cWK">http://pan.baidu.com/s/1c054cWK</a> 密码: qf83</li></ul><hr><p>Office资料:</p><ul><li>Excel_2003视频教程 链接: <a href="http://pan.baidu.com/s/1sjFmVQP">http://pan.baidu.com/s/1sjFmVQP</a> 密码: s8h2</li><li>Excel_2007视频教程 链接: <a href="http://pan.baidu.com/s/1i30AgW9">http://pan.baidu.com/s/1i30AgW9</a> 密码: 9g8r</li><li>Excel_2007循序渐进视频教程 链接: <a href="http://pan.baidu.com/s/1o6Drk6m">http://pan.baidu.com/s/1o6Drk6m</a> 密码: rskk</li><li>Excel_2010视频教程 链接: <a href="http://pan.baidu.com/s/1CtHRg">http://pan.baidu.com/s/1CtHRg</a> 密码: 3u9c</li><li>Excel_2010数据透视表教程 链接: <a href="http://pan.baidu.com/s/1o6j4VFG">http://pan.baidu.com/s/1o6j4VFG</a> 密码: bcsm</li><li>Excel_2010完全自学教程 链接: <a href="http://pan.baidu.com/s/1kTnEOuj">http://pan.baidu.com/s/1kTnEOuj</a> 密码: gk5d</li><li>Excel_2013视频教程 链接: <a href="http://pan.baidu.com/s/1eQq6Nya">http://pan.baidu.com/s/1eQq6Nya</a> 密码: 9eh3</li><li>Excel常用表格模板120个 链接: <a href="http://pan.baidu.com/s/1nt892oL">http://pan.baidu.com/s/1nt892oL</a> 密码: 8dzi</li><li>Excel函数查询手册1000页 链接: <a href="http://pan.baidu.com/s/1hqH7kDA">http://pan.baidu.com/s/1hqH7kDA</a> 密码: 54uc</li><li>Excel快捷键查询手册 链接: <a href="http://pan.baidu.com/s/1o6656jC">http://pan.baidu.com/s/1o6656jC</a> 密码: 3pti</li><li>OneNote_2010视频教程 链接: <a href="http://pan.baidu.com/s/1pJsWw5P">http://pan.baidu.com/s/1pJsWw5P</a> 密码: h53p</li><li>Outlook_2010视频教程 链接: <a href="http://pan.baidu.com/s/1ntGHckL">http://pan.baidu.com/s/1ntGHckL</a> 密码: 2xvx</li><li>PPT_2003视频教程 链接: <a href="http://pan.baidu.com/s/1hqs4BWw">http://pan.baidu.com/s/1hqs4BWw</a> 密码: vjuz</li><li>PPT_2007视频教程 链接: <a href="http://pan.baidu.com/s/1gdKqZDL">http://pan.baidu.com/s/1gdKqZDL</a> 密码: psc3</li><li>PPT_2010从入门到精通 链接: <a href="http://pan.baidu.com/s/1o6qW2UI">http://pan.baidu.com/s/1o6qW2UI</a> 密码: ppg3</li><li>PPT_2010视频教程 链接: <a href="http://pan.baidu.com/s/1o67l30Q">http://pan.baidu.com/s/1o67l30Q</a> 密码: fsft</li><li>PPT_2013视频教程 链接: <a href="http://pan.baidu.com/s/1gdkznpx">http://pan.baidu.com/s/1gdkznpx</a> 密码: y4ea</li><li>PPT常用图片素材 链接: <a href="http://pan.baidu.com/s/1jGELqPS">http://pan.baidu.com/s/1jGELqPS</a> 密码: 9rre</li><li>PPT地产策划方案146个 链接: <a href="http://pan.baidu.com/s/1gdxqyfp">http://pan.baidu.com/s/1gdxqyfp</a> 密码: vd3c</li><li>PPT模板大全设计素材 链接: <a href="http://pan.baidu.com/s/1hqAL424">http://pan.baidu.com/s/1hqAL424</a> 密码: kj5x</li><li>PPT视频教程全套27课 链接: <a href="http://pan.baidu.com/s/1jGCduGQ">http://pan.baidu.com/s/1jGCduGQ</a> 密码: 13ta</li><li>PPT最常用的字库集 链接: <a href="http://pan.baidu.com/s/1pJusoZp">http://pan.baidu.com/s/1pJusoZp</a> 密码: ebsx</li><li>Publisher_2010视频教程 链接: <a href="http://pan.baidu.com/s/1dDGrxCl">http://pan.baidu.com/s/1dDGrxCl</a> 密码: cuq7</li><li>SharePoint和Workspace_2010视频教程 链接: <a href="http://pan.baidu.com/s/1gdvU1NX">http://pan.baidu.com/s/1gdvU1NX</a> 密码: 3vun</li><li>Word_2003视频教程 链接: <a href="http://pan.baidu.com/s/1twNro">http://pan.baidu.com/s/1twNro</a> 密码: ig6i</li><li>Word_2007视频教程 链接: <a href="http://pan.baidu.com/s/1gdCj73P">http://pan.baidu.com/s/1gdCj73P</a> 密码: 9spk</li><li>Word_2010教学用PPT文档20章 链接: <a href="http://pan.baidu.com/s/1FH53C">http://pan.baidu.com/s/1FH53C</a> 密码: 9xh6</li><li>Word_2010视频教程 链接: <a href="http://pan.baidu.com/s/1i3s292P">http://pan.baidu.com/s/1i3s292P</a> 密码: q8xy</li><li>Word_2010中文版完全自学手册 链接: <a href="http://pan.baidu.com/s/1Gx1ee">http://pan.baidu.com/s/1Gx1ee</a> 密码: czcn</li><li>Word_2013视频教程 链接: <a href="http://pan.baidu.com/s/1nttayLz">http://pan.baidu.com/s/1nttayLz</a> 密码: nwwv</li><li>Word常用快捷键查询手册261个 链接: <a href="http://pan.baidu.com/s/1jGhBons">http://pan.baidu.com/s/1jGhBons</a> 密码: v85g</li><li>Word常用文书模板150个 链接: <a href="http://pan.baidu.com/s/1qWsotju">http://pan.baidu.com/s/1qWsotju</a> 密码: mia5</li></ul><hr><p>PS资料:</p><ul><li>PS CS4安装软件PC版 链接: <a href="http://pan.baidu.com/s/1dDtWFct">http://pan.baidu.com/s/1dDtWFct</a> 密码: 2baf</li><li>PS CS5安装软件PC版 链接: <a href="http://pan.baidu.com/s/1hqH7lxa">http://pan.baidu.com/s/1hqH7lxa</a> 密码: x3qd</li><li>PS CS6安装软件MAC版 链接: <a href="http://pan.baidu.com/s/1jGowM4u">http://pan.baidu.com/s/1jGowM4u</a> 密码: jh7y</li><li>PS CS6安装软件PC版 链接: <a href="http://pan.baidu.com/s/1gdKqZGB">http://pan.baidu.com/s/1gdKqZGB</a> 密码: u35b</li><li>PS CS2李涛主讲视频教程24集 链接: <a href="http://pan.baidu.com/s/1nt3PNeD">http://pan.baidu.com/s/1nt3PNeD</a> 密码: qpy4</li><li>PS CS2中文学习教程9章 链接: <a href="http://pan.baidu.com/s/1gdrkJpL">http://pan.baidu.com/s/1gdrkJpL</a> 密码: hvcu</li><li>PS CS3完全自学教程 链接: <a href="http://pan.baidu.com/s/1kT5VFEn">http://pan.baidu.com/s/1kT5VFEn</a> 密码: ecgz</li><li>PS CS3中文版视频教程100集 链接: <a href="http://pan.baidu.com/s/1i3BzzBv">http://pan.baidu.com/s/1i3BzzBv</a> 密码: fzrw</li><li>PS CS4时尚杂志婚纱设计 链接: <a href="http://pan.baidu.com/s/1eQxs2n4">http://pan.baidu.com/s/1eQxs2n4</a> 密码: npsv</li><li>PS CS4数码照片处理与精修完全学习手册 链接: <a href="http://pan.baidu.com/s/1dDcvKzv">http://pan.baidu.com/s/1dDcvKzv</a> 密码: v9ne</li><li>PS CS4特效创意视频教程 链接: <a href="http://pan.baidu.com/s/1mg3lRYg">http://pan.baidu.com/s/1mg3lRYg</a> 密码: pazm</li><li>PS CS4完全自学教程54课 链接: <a href="http://pan.baidu.com/s/1ntilew5">http://pan.baidu.com/s/1ntilew5</a> 密码: sav2</li><li>PS CS4影楼数码照片色彩处理技法25课 链接: <a href="http://pan.baidu.com/s/1i3EhvLz">http://pan.baidu.com/s/1i3EhvLz</a> 密码: wy3p</li><li>PS CS5经典案例视频教程95集 链接: <a href="http://pan.baidu.com/s/1o6sY2jo">http://pan.baidu.com/s/1o6sY2jo</a> 密码: uxdr</li><li>PS CS5实例视频195集 链接: <a href="http://pan.baidu.com/s/1vyJgE">http://pan.baidu.com/s/1vyJgE</a> 密码: nw6z</li><li>PS CS5完全自学教程(超值版) 链接: <a href="http://pan.baidu.com/s/1c0nThzq">http://pan.baidu.com/s/1c0nThzq</a> 密码: y42t</li><li>PS CS5完全自学教程-实例视频19章 链接: <a href="http://pan.baidu.com/s/1qWuqsxQ">http://pan.baidu.com/s/1qWuqsxQ</a> 密码: x96t</li><li>PS CS5综合实例视频教学50例 链接: <a href="http://pan.baidu.com/s/1hqJ9cnM">http://pan.baidu.com/s/1hqJ9cnM</a> 密码: yfj4</li><li>PS CS6案例视频教程 链接: <a href="http://pan.baidu.com/s/1dDItm1N">http://pan.baidu.com/s/1dDItm1N</a> 密码: anb2</li><li>PS CS6基础视频教程51课 链接: <a href="http://pan.baidu.com/s/1c0wG9vM">http://pan.baidu.com/s/1c0wG9vM</a> 密码: rqq4</li><li>PS大师之路基础视频教程15章 链接: <a href="http://pan.baidu.com/s/1sjBjj1F">http://pan.baidu.com/s/1sjBjj1F</a> 密码: ixhj</li><li>PS电脑美术绘画教程 链接: <a href="http://pan.baidu.com/s/1o60zTF0">http://pan.baidu.com/s/1o60zTF0</a> 密码: 9g3s</li><li>PS工具栏巧妙运用技巧94集 链接: <a href="http://pan.baidu.com/s/1bne1KXT">http://pan.baidu.com/s/1bne1KXT</a> 密码: kxc8</li><li>PS和CDR平面设计入门进阶与提高 链接: <a href="http://pan.baidu.com/s/1c0CV9IC">http://pan.baidu.com/s/1c0CV9IC</a> 密码: ht9m</li><li>PS婚纱与写真实用技术精粹 链接: <a href="http://pan.baidu.com/s/1jG1UbKq">http://pan.baidu.com/s/1jG1UbKq</a> 密码: 493x</li><li>PS经典实例1000例 链接: <a href="http://pan.baidu.com/s/1mg3RNYS">http://pan.baidu.com/s/1mg3RNYS</a> 密码: m7fz</li><li>PS经典文字教程集合 链接: <a href="http://pan.baidu.com/s/1hqrOExQ">http://pan.baidu.com/s/1hqrOExQ</a> 密码: sr6q</li><li>PS经典效果289例 链接: <a href="http://pan.baidu.com/s/1dDhf2gD">http://pan.baidu.com/s/1dDhf2gD</a> 密码: ndjd</li><li>PS经典效果视频教程100例 链接: <a href="http://pan.baidu.com/s/1mBs8e">http://pan.baidu.com/s/1mBs8e</a> 密码: vrqb</li><li>PS滤镜详解视频教程 链接: <a href="http://pan.baidu.com/s/1kT5pJ2R">http://pan.baidu.com/s/1kT5pJ2R</a> 密码: wpjh</li><li>PS巧夺天工入门与进阶实例教程 链接: <a href="http://pan.baidu.com/s/16oghw">http://pan.baidu.com/s/16oghw</a> 密码: be92</li><li>PS人物数码照片处理实战36集 链接: <a href="http://pan.baidu.com/s/1ntKeM05">http://pan.baidu.com/s/1ntKeM05</a> 密码: bnhy</li><li>PS入门基础教程92课 链接: <a href="http://pan.baidu.com/s/1qWqS1Xy">http://pan.baidu.com/s/1qWqS1Xy</a> 密码: 2z9k</li><li>PS摄影后期调色技法32例 链接: <a href="http://pan.baidu.com/s/1bnAVN6B">http://pan.baidu.com/s/1bnAVN6B</a> 密码: d5zj</li><li>PS深度学习不同抠图技巧70集 链接: <a href="http://pan.baidu.com/s/1pJ3fLBd">http://pan.baidu.com/s/1pJ3fLBd</a> 密码: ke62</li><li>PS实战前沿3章 链接: <a href="http://pan.baidu.com/s/1dD6NWfZ">http://pan.baidu.com/s/1dD6NWfZ</a> 密码: 42bk</li><li>PS视频教程106集 链接: <a href="http://pan.baidu.com/s/1pJKaJph">http://pan.baidu.com/s/1pJKaJph</a> 密码: 7d4c</li><li>PS数码照片处理经典13章 链接: <a href="http://pan.baidu.com/s/1c0uEEQ0">http://pan.baidu.com/s/1c0uEEQ0</a> 密码: 3xbk</li><li>PS文字特效教程3辑 链接: <a href="http://pan.baidu.com/s/1dD2ekwh">http://pan.baidu.com/s/1dD2ekwh</a> 密码: qqax</li><li>PS文字艺术效果100例 链接: <a href="http://pan.baidu.com/s/1pJtCyAR">http://pan.baidu.com/s/1pJtCyAR</a> 密码: iwhq</li><li>PS终极人像修饰教程3章 链接: <a href="http://pan.baidu.com/s/1i3grwfb">http://pan.baidu.com/s/1i3grwfb</a> 密码: 6bcm</li><li>PS字体设计视频8章 链接: <a href="http://pan.baidu.com/s/1pJC9no3">http://pan.baidu.com/s/1pJC9no3</a> 密码: srfe</li><li>150款photoshop形状 链接: <a href="http://pan.baidu.com/s/1mgxgmPa">http://pan.baidu.com/s/1mgxgmPa</a> 密码: y8zr</li><li>18套漂亮宝宝字体PSD模版 链接: <a href="http://pan.baidu.com/s/1jGnaVrw">http://pan.baidu.com/s/1jGnaVrw</a> 密码: ar8b</li><li>2000个photoshop动作 链接: <a href="http://pan.baidu.com/s/1i3ncVZ3">http://pan.baidu.com/s/1i3ncVZ3</a> 密码: kusm</li><li>26款photoshop常用极品滤镜 链接: <a href="http://pan.baidu.com/s/1pJOK0UB">http://pan.baidu.com/s/1pJOK0UB</a> 密码: 5rqi</li><li>47套影楼美工字体PSD模版 链接: <a href="http://pan.baidu.com/s/1ntta0kD">http://pan.baidu.com/s/1ntta0kD</a> 密码: ynyx</li><li>500个photoshop渐变 链接: <a href="http://pan.baidu.com/s/1dDo7dT3">http://pan.baidu.com/s/1dDo7dT3</a> 密码: thvm</li><li>6套漂亮婚纱字体PSD模版 链接: <a href="http://pan.baidu.com/s/1ntBXtbj">http://pan.baidu.com/s/1ntBXtbj</a> 密码: v7bd</li><li>8套可爱动物字体PSD模版 链接: <a href="http://pan.baidu.com/s/1o6xIg6A">http://pan.baidu.com/s/1o6xIg6A</a> 密码: grfb</li><li>9套可爱英文字体PSD模版 链接: <a href="http://pan.baidu.com/s/1pJKaJpD">http://pan.baidu.com/s/1pJKaJpD</a> 密码: g5a9</li><li>PSD韩国时尚花纹图案 链接: <a href="http://pan.baidu.com/s/1mg3lTqS">http://pan.baidu.com/s/1mg3lTqS</a> 密码: 7nue</li><li>PS画笔笔刷2000款 链接: <a href="http://pan.baidu.com/s/1i3iZo9J">http://pan.baidu.com/s/1i3iZo9J</a> 密码: gmzd</li><li>PS图层样式100款 链接: <a href="http://pan.baidu.com/s/1i3ittjB">http://pan.baidu.com/s/1i3ittjB</a> 密码: dr5v</li><li>韩国风尚写真PSD模板 链接: <a href="http://pan.baidu.com/s/1o6uuwlk">http://pan.baidu.com/s/1o6uuwlk</a> 密码: ahtb</li><li>韩国设计素材psd模板 链接: <a href="http://pan.baidu.com/s/1o69Twcq">http://pan.baidu.com/s/1o69Twcq</a> 密码: mg8j</li><li>婚纱PSD素材37例 链接: <a href="http://pan.baidu.com/s/1qWA5pVY">http://pan.baidu.com/s/1qWA5pVY</a> 密码: hbbb</li><li>经典高贵风格婚纱模板psd素材 链接: <a href="http://pan.baidu.com/s/1kTMQHGN">http://pan.baidu.com/s/1kTMQHGN</a> 密码: bqvq</li><li>平面广告PSD分层素材 链接: <a href="http://pan.baidu.com/s/1mgvetZy">http://pan.baidu.com/s/1mgvetZy</a> 密码: art7</li><li>人物相册图片后期处理psd模板 链接: <a href="http://pan.baidu.com/s/1bnoBeuN">http://pan.baidu.com/s/1bnoBeuN</a> 密码: vixq</li><li>台湾婚纱模板珍藏psd模板 链接: <a href="http://pan.baidu.com/s/1kTlCZOz">http://pan.baidu.com/s/1kTlCZOz</a> 密码: hv4a</li></ul><hr><p>服装资料:</p><ul><li>服装搭配教程 链接: <a href="http://pan.baidu.com/s/1qWokBSg">http://pan.baidu.com/s/1qWokBSg</a> 密码: smau</li><li>看图学艺图解童装纸样设计 链接: <a href="http://pan.baidu.com/s/1dD6NWwL">http://pan.baidu.com/s/1dD6NWwL</a> 密码: 3utu</li></ul><hr><p>美容化妆:</p><ul><li>常用美发男发修剪教程 链接: <a href="http://pan.baidu.com/s/1ntCDrMp">http://pan.baidu.com/s/1ntCDrMp</a> 密码: 8bn8</li><li>儿童发型编发视频教程 链接: <a href="http://pan.baidu.com/s/1ntDZhDB">http://pan.baidu.com/s/1ntDZhDB</a> 密码: xra8</li><li>巧编儿童发辫发型65例 链接: <a href="http://pan.baidu.com/s/1qWMG9Ww">http://pan.baidu.com/s/1qWMG9Ww</a> 密码: 4i33</li><li>发型搭配文字教程集合 链接: <a href="http://pan.baidu.com/s/1kTqwH99">http://pan.baidu.com/s/1kTqwH99</a> 密码: 453s</li><li>韩国专业发型视频教程 链接: <a href="http://pan.baidu.com/s/1mgmWQ3u">http://pan.baidu.com/s/1mgmWQ3u</a> 密码: kgv2</li><li>流行美经典盘发视频教程 链接: <a href="http://pan.baidu.com/s/1i3ittkx">http://pan.baidu.com/s/1i3ittkx</a> 密码: hchn</li><li>日常时尚发型视频教程 链接: <a href="http://pan.baidu.com/s/1o6rC4aA">http://pan.baidu.com/s/1o6rC4aA</a> 密码: pivh</li><li>小P老师主讲发型视频教程 链接: <a href="http://pan.baidu.com/s/1hq0Cndy">http://pan.baidu.com/s/1hq0Cndy</a> 密码: 76hb</li><li>新天地影楼发型技法 链接: <a href="http://pan.baidu.com/s/1i3mxa2h">http://pan.baidu.com/s/1i3mxa2h</a> 密码: nkwx</li><li>百变彩妆视频教程29集 链接: <a href="http://pan.baidu.com/s/1pJBnpIb">http://pan.baidu.com/s/1pJBnpIb</a> 密码: 5d3g</li><li>彩妆常识视频教程46集 链接: <a href="http://pan.baidu.com/s/1dDB7GWh">http://pan.baidu.com/s/1dDB7GWh</a> 密码: h3fw</li><li>韩版妆化妆技巧视频教程 链接: <a href="http://pan.baidu.com/s/1i34DRd7">http://pan.baidu.com/s/1i34DRd7</a> 密码: pm2u</li><li>韩国化妆方法视频教程 链接: <a href="http://pan.baidu.com/s/1eQhJyLk">http://pan.baidu.com/s/1eQhJyLk</a> 密码: 3r2d</li><li>化妆方法一学就会视频教程 链接: <a href="http://pan.baidu.com/s/1hqAL6fy">http://pan.baidu.com/s/1hqAL6fy</a> 密码: ja5n</li><li>化妆方面文字教程集合 链接: <a href="http://pan.baidu.com/s/1sjyXUmp">http://pan.baidu.com/s/1sjyXUmp</a> 密码: x9vg</li><li>化妆技巧视频教程50集 链接: <a href="http://pan.baidu.com/s/1mggRnGs">http://pan.baidu.com/s/1mggRnGs</a> 密码: ia4k</li><li>睫毛嫁接视频教程 链接: <a href="http://pan.baidu.com/s/1sjwqh8D">http://pan.baidu.com/s/1sjwqh8D</a> 密码: r6en</li><li>美容化妆400问PDF教程 链接: <a href="http://pan.baidu.com/s/1dDjhyJB">http://pan.baidu.com/s/1dDjhyJB</a> 密码: wmdc</li><li>新增化妆视频教程19集 链接: <a href="http://pan.baidu.com/s/1hqxov8S">http://pan.baidu.com/s/1hqxov8S</a> 密码: etf7</li><li>学做化妆师技能培训讲座 链接: <a href="http://pan.baidu.com/s/1eQ8NMOq">http://pan.baidu.com/s/1eQ8NMOq</a> 密码: 67mb</li><li>自我美容彩妆技巧视频教程 链接: <a href="http://pan.baidu.com/s/1ntKeMJf">http://pan.baidu.com/s/1ntKeMJf</a> 密码: vytr</li><li>3D水晶甲视频教程 链接: <a href="http://pan.baidu.com/s/1dDwE8Jf">http://pan.baidu.com/s/1dDwE8Jf</a> 密码: uqy6</li><li>法式水晶甲视频教程 链接: <a href="http://pan.baidu.com/s/1kT7rEy7">http://pan.baidu.com/s/1kT7rEy7</a> 密码: jrah</li><li>花式水晶甲视频教程 链接: <a href="http://pan.baidu.com/s/1hqH7nd6">http://pan.baidu.com/s/1hqH7nd6</a> 密码: gm5m</li><li>镭射法式光疗甲视频教程 链接: <a href="http://pan.baidu.com/s/1sGRU2">http://pan.baidu.com/s/1sGRU2</a> 密码: rhs3</li><li>美甲彩绘视频教程 链接: <a href="http://pan.baidu.com/s/1eQ1wlG2">http://pan.baidu.com/s/1eQ1wlG2</a> 密码: ujrs</li><li>美甲技巧视频教程 链接: <a href="http://pan.baidu.com/s/1eQEn13k">http://pan.baidu.com/s/1eQEn13k</a> 密码: rg2w</li><li>民间彩绘视频教程 链接: <a href="http://pan.baidu.com/s/1c0AnNSc">http://pan.baidu.com/s/1c0AnNSc</a> 密码: qc7k</li><li>双色花艺术彩绘视频教程 链接: <a href="http://pan.baidu.com/s/1c010p4O">http://pan.baidu.com/s/1c010p4O</a> 密码: gqba</li><li>水晶指甲制作视频教程 链接: <a href="http://pan.baidu.com/s/1o6mmQQu">http://pan.baidu.com/s/1o6mmQQu</a> 密码: kf72</li><li>五指美甲机VCD简视频 链接: <a href="http://pan.baidu.com/s/1eQ6fWUQ">http://pan.baidu.com/s/1eQ6fWUQ</a> 密码: dftc</li><li>炫彩美甲视频教程 链接: <a href="http://pan.baidu.com/s/1dD95Mt7">http://pan.baidu.com/s/1dD95Mt7</a> 密码: a7gb</li><li>艺术彩绘视频教程 链接: <a href="http://pan.baidu.com/s/1c0dJJS8">http://pan.baidu.com/s/1c0dJJS8</a> 密码: ukbx</li><li>指甲护理视频教程 链接: <a href="http://pan.baidu.com/s/1mgj9grI">http://pan.baidu.com/s/1mgj9grI</a> 密码: pcd6</li><li>指甲画花视频教程 链接: <a href="http://pan.baidu.com/s/1dDlPmI9">http://pan.baidu.com/s/1dDlPmI9</a> 密码: n5b7</li></ul><hr><p>美术资料:</p><ul><li>白衣女子肖像 链接: <a href="http://pan.baidu.com/s/1o6BptP4">http://pan.baidu.com/s/1o6BptP4</a> 密码: p41p</li><li>北京的静物创作示范 链接: <a href="http://pan.baidu.com/s/1eQuACzo">http://pan.baidu.com/s/1eQuACzo</a> 密码: hea3</li><li>高考色彩静物 蔬菜视频教程 链接: <a href="http://pan.baidu.com/s/1sjsSqAh">http://pan.baidu.com/s/1sjsSqAh</a> 密码: 8fqs</li><li>宫崎骏 链接: <a href="http://pan.baidu.com/s/1i3CL1o5">http://pan.baidu.com/s/1i3CL1o5</a> 密码: h6u7</li><li>海量名师作品集 链接: <a href="http://pan.baidu.com/s/1gdhb3KB">http://pan.baidu.com/s/1gdhb3KB</a> 密码: gi8z</li><li>花间美人古风CG插画技法 链接: <a href="http://pan.baidu.com/s/1ntIITWd">http://pan.baidu.com/s/1ntIITWd</a> 密码: d2c6</li><li>绘画色彩基础视频教程 链接: <a href="http://pan.baidu.com/s/1jGH3hQY">http://pan.baidu.com/s/1jGH3hQY</a> 密码: 83e4</li><li>绘画透视应用技法视频教程 链接: <a href="http://pan.baidu.com/s/1pJsWyON">http://pan.baidu.com/s/1pJsWyON</a> 密码: 3b6n</li><li>暴走漫画表情素材 链接: <a href="http://pan.baidu.com/s/1jGGhmx4">http://pan.baidu.com/s/1jGGhmx4</a> 密码: 9q75</li><li>漫画人物五官手脚画法 链接: <a href="http://pan.baidu.com/s/1hqEPwjE">http://pan.baidu.com/s/1hqEPwjE</a> 密码: sgp7</li><li>美术基础训练视频教程 链接: <a href="http://pan.baidu.com/s/1hqo0Xc4">http://pan.baidu.com/s/1hqo0Xc4</a> 密码: i84h</li><li>名画欣赏技法分析视频教程 链接: <a href="http://pan.baidu.com/s/1i3peSj7">http://pan.baidu.com/s/1i3peSj7</a> 密码: 3css</li><li>人体结构设计资料 链接: <a href="http://pan.baidu.com/s/1bn6mfxX">http://pan.baidu.com/s/1bn6mfxX</a> 密码: aya4</li><li>日式造型巨可爱游戏原画素材 链接: <a href="http://pan.baidu.com/s/1sjoiCmL">http://pan.baidu.com/s/1sjoiCmL</a> 密码: scpu</li><li>沙画学习视频教程 链接: <a href="http://pan.baidu.com/s/1pJkiTM7">http://pan.baidu.com/s/1pJkiTM7</a> 密码: u5cf</li><li>适合新手临摹练习的Q版图集 链接: <a href="http://pan.baidu.com/s/1c054gfu">http://pan.baidu.com/s/1c054gfu</a> 密码: dqru</li><li>工装设计手绘效果图 链接: <a href="http://pan.baidu.com/s/1pJ41GGN">http://pan.baidu.com/s/1pJ41GGN</a> 密码: ytyf</li><li>建筑大师手绘表现图 链接: <a href="http://pan.baidu.com/s/1c0Er54G">http://pan.baidu.com/s/1c0Er54G</a> 密码: 2cci</li><li>建筑基础手绘教程 链接: <a href="http://pan.baidu.com/s/1bnHHv59">http://pan.baidu.com/s/1bnHHv59</a> 密码: ans9</li><li>景观设计手绘表现图 链接: <a href="http://pan.baidu.com/s/1o69TwQu">http://pan.baidu.com/s/1o69TwQu</a> 密码: kkgg</li><li>庐山手绘视频教程 链接: <a href="http://pan.baidu.com/s/1sjn2GUh">http://pan.baidu.com/s/1sjn2GUh</a> 密码: x4vw</li><li>汽车手绘表现图 链接: <a href="http://pan.baidu.com/s/1qWsUvak">http://pan.baidu.com/s/1qWsUvak</a> 密码: 3ium</li><li>人物手绘表现图 链接: <a href="http://pan.baidu.com/s/1dDEp6ut">http://pan.baidu.com/s/1dDEp6ut</a> 密码: 7ym1</li><li>设计手绘表达教程 链接: <a href="http://pan.baidu.com/s/1bnrYVCV">http://pan.baidu.com/s/1bnrYVCV</a> 密码: 3c5q</li><li>室内设计手绘表现图 链接: <a href="http://pan.baidu.com/s/1c0ddL8c">http://pan.baidu.com/s/1c0ddL8c</a> 密码: e3ip</li><li>手绘设计方案36套 链接: <a href="http://pan.baidu.com/s/1jG9vCMi">http://pan.baidu.com/s/1jG9vCMi</a> 密码: 6ija</li><li>外景手绘细节表现图 链接: <a href="http://pan.baidu.com/s/1hqgt0xe">http://pan.baidu.com/s/1hqgt0xe</a> 密码: 2x4h</li><li>色彩静物视频教程 链接: <a href="http://pan.baidu.com/s/1c0Gt0nm">http://pan.baidu.com/s/1c0Gt0nm</a> 密码: 5z25</li><li>色彩学习视频教程 链接: <a href="http://pan.baidu.com/s/1dD8jS1V">http://pan.baidu.com/s/1dD8jS1V</a> 密码: 42tc</li><li>水彩静物视频教程 链接: <a href="http://pan.baidu.com/s/1gdtSCoz">http://pan.baidu.com/s/1gdtSCoz</a> 密码: 5ewy</li><li>静物素描视频教程 链接: <a href="http://pan.baidu.com/s/1dDvYAsT">http://pan.baidu.com/s/1dDvYAsT</a> 密码: gnkt</li><li>素描基础训练视频教程 链接: <a href="http://pan.baidu.com/s/1jGqyOdS">http://pan.baidu.com/s/1jGqyOdS</a> 密码: yhyu</li><li>素描几何体视频教程 链接: <a href="http://pan.baidu.com/s/1jGIPedC">http://pan.baidu.com/s/1jGIPedC</a> 密码: 8dfk</li><li>素描男人体视频教程 链接: <a href="http://pan.baidu.com/s/1pJqU3FH">http://pan.baidu.com/s/1pJqU3FH</a> 密码: syne</li><li>素描男头像视频教程 链接: <a href="http://pan.baidu.com/s/1jn1UY">http://pan.baidu.com/s/1jn1UY</a> 密码: u6dv</li><li>素描男肖像视频教程 链接: <a href="http://pan.baidu.com/s/1eQm3hRW">http://pan.baidu.com/s/1eQm3hRW</a> 密码: egj8</li><li>素描女人体视频教程 链接: <a href="http://pan.baidu.com/s/1c0rqU44">http://pan.baidu.com/s/1c0rqU44</a> 密码: ga36</li><li>素描女肖像视频教程 链接: <a href="http://pan.baidu.com/s/1c0yc7za">http://pan.baidu.com/s/1c0yc7za</a> 密码: p74t</li><li>素描石膏视频教程 链接: <a href="http://pan.baidu.com/s/1dD4Mdup">http://pan.baidu.com/s/1dD4Mdup</a> 密码: 5tb2</li><li>速写学习视频教程 链接: <a href="http://pan.baidu.com/s/1nt7TAC5">http://pan.baidu.com/s/1nt7TAC5</a> 密码: 8equ</li><li>写意人物画技法视频教程 链接: <a href="http://pan.baidu.com/s/1nt23TMT">http://pan.baidu.com/s/1nt23TMT</a> 密码: jhmj</li><li>艾轩油画西藏女孩 链接: <a href="http://pan.baidu.com/s/1i31WeYp">http://pan.baidu.com/s/1i31WeYp</a> 密码: 3fp3</li><li>古典油画肖像技法视频教程 链接: <a href="http://pan.baidu.com/s/1hq7xNlq">http://pan.baidu.com/s/1hq7xNlq</a> 密码: a9cn</li><li>静物油画技法视频教程 链接: <a href="http://pan.baidu.com/s/1sjvAhBn">http://pan.baidu.com/s/1sjvAhBn</a> 密码: dmsx</li><li>油画风景写生视频教程 链接: <a href="http://pan.baidu.com/s/1gd2ah5h">http://pan.baidu.com/s/1gd2ah5h</a> 密码: iiaq</li><li>油画钢琴姑娘视频教程 链接: <a href="http://pan.baidu.com/s/1bnpXbyB">http://pan.baidu.com/s/1bnpXbyB</a> 密码: 5qeh</li><li>油画静物与肖像视频教程 链接: <a href="http://pan.baidu.com/s/1o6ijeDO">http://pan.baidu.com/s/1o6ijeDO</a> 密码: 3ymu</li><li>油画男肖像视频教程 链接: <a href="http://pan.baidu.com/s/1ntuwvMT">http://pan.baidu.com/s/1ntuwvMT</a> 密码: zddq</li><li>油画女人体视频教程 链接: <a href="http://pan.baidu.com/s/1kT5VIbP">http://pan.baidu.com/s/1kT5VIbP</a> 密码: 237n</li><li>油画女肖像视频教程 链接: <a href="http://pan.baidu.com/s/1o6DXk4y">http://pan.baidu.com/s/1o6DXk4y</a> 密码: 7yvq</li><li>油画人物视频教程 链接: <a href="http://pan.baidu.com/s/1dDyG269">http://pan.baidu.com/s/1dDyG269</a> 密码: 3xa9</li><li>油画手部描绘视频教程 链接: <a href="http://pan.baidu.com/s/1o6pACMA">http://pan.baidu.com/s/1o6pACMA</a> 密码: 9f3s</li><li>勒尚谊 链接: <a href="http://pan.baidu.com/s/1gdpiU3p">http://pan.baidu.com/s/1gdpiU3p</a> 密码: f63x</li><li>美术电子书：</li><li>POP 链接: <a href="http://pan.baidu.com/s/1gdfF5o3">http://pan.baidu.com/s/1gdfF5o3</a> 密码: sicb</li><li>插画 链接: <a href="http://pan.baidu.com/s/1c1TF4">http://pan.baidu.com/s/1c1TF4</a> 密码: 2hxk</li><li>动物类画技 链接: <a href="http://pan.baidu.com/s/1pJJuNWZ">http://pan.baidu.com/s/1pJJuNWZ</a> 密码: wjpd</li><li>卡通 链接: <a href="http://pan.baidu.com/s/1mgmWRlY">http://pan.baidu.com/s/1mgmWRlY</a> 密码: 11dg</li><li>漫画 链接: <a href="http://pan.baidu.com/s/1sjOGyF7">http://pan.baidu.com/s/1sjOGyF7</a> 密码: xzi3</li><li>其他 链接: <a href="http://pan.baidu.com/s/1hqrOGDI">http://pan.baidu.com/s/1hqrOGDI</a> 密码: pv6v</li><li>铅笔画 链接: <a href="http://pan.baidu.com/s/1o6N0BiE">http://pan.baidu.com/s/1o6N0BiE</a> 密码: 6fup</li><li>手绘 链接: <a href="http://pan.baidu.com/s/1o6sY446">http://pan.baidu.com/s/1o6sY446</a> 密码: 2rve</li><li>水彩 链接: <a href="http://pan.baidu.com/s/1eQ6LWtk">http://pan.baidu.com/s/1eQ6LWtk</a> 密码: ekp5</li><li>素描 链接: <a href="http://pan.baidu.com/s/1kTMQIyV">http://pan.baidu.com/s/1kTMQIyV</a> 密码: wc3j</li><li>速写 链接: <a href="http://pan.baidu.com/s/1jGrKG66">http://pan.baidu.com/s/1jGrKG66</a> 密码: vj34</li><li>油画 链接: <a href="http://pan.baidu.com/s/1c0FD4Og">http://pan.baidu.com/s/1c0FD4Og</a> 密码: sris</li></ul><hr><p>其他资料:</p><ul><li>打毛衣文字教程资料 链接: <a href="http://pan.baidu.com/s/1bnk7w79">http://pan.baidu.com/s/1bnk7w79</a> 密码: hmuk</li><li>工作求职简历模板 链接: <a href="http://pan.baidu.com/s/1qW9jtBA">http://pan.baidu.com/s/1qW9jtBA</a> 密码: 1t8f</li><li>广告制作技术资料 链接: <a href="http://pan.baidu.com/s/1o6N0BlK">http://pan.baidu.com/s/1o6N0BlK</a> 密码: hmx8</li><li>蝴蝶结发饰教程 链接: <a href="http://pan.baidu.com/s/1c0g19uw">http://pan.baidu.com/s/1c0g19uw</a> 密码: s9m6</li><li>皮艺皮具设计制作教程 链接: <a href="http://pan.baidu.com/s/1qWMa8Ss">http://pan.baidu.com/s/1qWMa8Ss</a> 密码: uhdb</li><li>生活百科健康养生资料收集（值得收藏）链接: <a href="http://pan.baidu.com/s/1mgmqVES">http://pan.baidu.com/s/1mgmqVES</a> 密码: hiyg</li><li>绳结技法教程 链接: <a href="http://pan.baidu.com/s/1sjBPinr">http://pan.baidu.com/s/1sjBPinr</a> 密码: cqqx</li><li>童话故事 链接: <a href="http://pan.baidu.com/s/1bnhj9mR">http://pan.baidu.com/s/1bnhj9mR</a> 密码: cwpa</li></ul><hr><p>棋牌资料:</p><ul><li>国际象棋 链接: <a href="http://pan.baidu.com/s/1c0FD4Q0">http://pan.baidu.com/s/1c0FD4Q0</a> 密码: etq9</li><li>麻将电子书 链接: <a href="http://pan.baidu.com/s/1bn6ScpD">http://pan.baidu.com/s/1bn6ScpD</a> 密码: 48m5</li><li>麻将视频教学 链接: <a href="http://pan.baidu.com/s/1mgxMnFU">http://pan.baidu.com/s/1mgxMnFU</a> 密码: wzc1</li><li>扑克牌 链接: <a href="http://pan.baidu.com/s/1mgy2jhu">http://pan.baidu.com/s/1mgy2jhu</a> 密码: yd7z</li><li>围棋 链接: <a href="http://pan.baidu.com/s/1sjyXUZ7">http://pan.baidu.com/s/1sjyXUZ7</a> 密码: aptz</li><li>中国象棋初中高级教程 链接: <a href="http://pan.baidu.com/s/1ntGHeB3">http://pan.baidu.com/s/1ntGHeB3</a> 密码: x2vv</li><li>中国象棋实战攻防 链接: <a href="http://pan.baidu.com/s/1ntoWHGt">http://pan.baidu.com/s/1ntoWHGt</a> 密码: pjte</li></ul><hr><p>球类资料:</p><ul><li>高尔夫初学视频教程 链接: <a href="http://pan.baidu.com/s/1jGf9ymy">http://pan.baidu.com/s/1jGf9ymy</a> 密码: a3tt</li><li>Better Basketball篮球教学视频教程 链接: <a href="http://pan.baidu.com/s/1o6rC4Oy">http://pan.baidu.com/s/1o6rC4Oy</a> 密码: tu14</li><li>NBA篮球教学视频 链接: <a href="http://pan.baidu.com/s/1bnfhIEV">http://pan.baidu.com/s/1bnfhIEV</a> 密码: qaa5</li><li>NBA十大过人高手百大过人 链接: <a href="http://pan.baidu.com/s/1kTte5AB">http://pan.baidu.com/s/1kTte5AB</a> 密码: 248x</li><li>加农贝克篮球训练视频教程 链接: <a href="http://pan.baidu.com/s/16ohjC">http://pan.baidu.com/s/16ohjC</a> 密码: 1jrd</li><li>街头篮球视频教程 链接: <a href="http://pan.baidu.com/s/1sj0ZPpj">http://pan.baidu.com/s/1sj0ZPpj</a> 密码: n9u1</li><li>科比门徒全集 链接: <a href="http://pan.baidu.com/s/1nt9p1Mx">http://pan.baidu.com/s/1nt9p1Mx</a> 密码: egir</li><li>篮球基础与实战技巧视频教程 链接: <a href="http://pan.baidu.com/s/1fjJie">http://pan.baidu.com/s/1fjJie</a> 密码: cw2q</li><li>篮球教学视频教程50集 链接: <a href="http://pan.baidu.com/s/1sjvAhC5">http://pan.baidu.com/s/1sjvAhC5</a> 密码: a4sf</li><li>五虎篮球教学视频教程 链接: <a href="http://pan.baidu.com/s/1ntL0MSh">http://pan.baidu.com/s/1ntL0MSh</a> 密码: ed4n</li><li>约翰逊篮球防守训练视频教程 链接: <a href="http://pan.baidu.com/s/1mgHzcFY">http://pan.baidu.com/s/1mgHzcFY</a> 密码: djb9</li><li>张卫平篮球教学视频教程 链接: <a href="http://pan.baidu.com/s/1i36FLtF">http://pan.baidu.com/s/1i36FLtF</a> 密码: 6ag7</li><li>乒乓球教学视频教程 链接: <a href="http://pan.baidu.com/s/1bndLOuF">http://pan.baidu.com/s/1bndLOuF</a> 密码: xdk7</li><li>巴尼台球视频教程 链接: <a href="http://pan.baidu.com/s/1qW1HMva">http://pan.baidu.com/s/1qW1HMva</a> 密码: ewft</li><li>和尚台球系列专题教学 链接: <a href="http://pan.baidu.com/s/1qWkgSfM">http://pan.baidu.com/s/1qWkgSfM</a> 密码: fr93</li><li>经验一枪台球视频教学 链接: <a href="http://pan.baidu.com/s/1pJBTpaz">http://pan.baidu.com/s/1pJBTpaz</a> 密码: 2xkj</li><li>刘新臣斯诺克教程 链接: <a href="http://pan.baidu.com/s/1gdeZ6Wr">http://pan.baidu.com/s/1gdeZ6Wr</a> 密码: nur7</li><li>罗建宇入门斯诺克台球教程 链接: <a href="http://pan.baidu.com/s/1o6JwPgY">http://pan.baidu.com/s/1o6JwPgY</a> 密码: kpcp</li><li>斯诺克北京刘军台球教学 链接: <a href="http://pan.baidu.com/s/1g5Eiy">http://pan.baidu.com/s/1g5Eiy</a> 密码: ra77</li><li>唐建军台球视频教程 链接: <a href="http://pan.baidu.com/s/1c0AnOAW">http://pan.baidu.com/s/1c0AnOAW</a> 密码: hfr4</li><li>张东涛斯诺克基础教程 链接: <a href="http://pan.baidu.com/s/1kTzkhF5">http://pan.baidu.com/s/1kTzkhF5</a> 密码: q21g</li><li>陈伟华羽毛球视频教程 链接: <a href="http://pan.baidu.com/s/1o65jG98">http://pan.baidu.com/s/1o65jG98</a> 密码: v83h</li><li>惠程俊羽毛球教学视频 链接: <a href="http://pan.baidu.com/s/1pJC9oxX">http://pan.baidu.com/s/1pJC9oxX</a> 密码: yktp</li><li>李玲蔚羽毛球视频教程 链接: <a href="http://pan.baidu.com/s/1mgGJgDi">http://pan.baidu.com/s/1mgGJgDi</a> 密码: u4ay</li><li>李在福羽毛球视频教程 链接: <a href="http://pan.baidu.com/s/1kT7rFnD">http://pan.baidu.com/s/1kT7rFnD</a> 密码: 8rke</li><li>刘瑞豪羽毛球新手教学 链接: <a href="http://pan.baidu.com/s/1dDxu6Vf">http://pan.baidu.com/s/1dDxu6Vf</a> 密码: pvsa</li><li>肖杰学打羽毛球视频教程 链接: <a href="http://pan.baidu.com/s/1pJGCXYj">http://pan.baidu.com/s/1pJGCXYj</a> 密码: jsyk</li><li>肖杰赵剑华羽毛球专家把脉 链接: <a href="http://pan.baidu.com/s/1i3J7bPb">http://pan.baidu.com/s/1i3J7bPb</a> 密码: p5hq</li><li>熊国宝羽毛球技术教学 链接: <a href="http://pan.baidu.com/s/1qWE9dU0">http://pan.baidu.com/s/1qWE9dU0</a> 密码: dwgc</li><li>DAY城市运动KE足球教学 链接: <a href="http://pan.baidu.com/s/1qWokCJ6">http://pan.baidu.com/s/1qWokCJ6</a> 密码: cmmz</li><li>TBALLER街头足球教学 链接: <a href="http://pan.baidu.com/s/1c0m7r0W">http://pan.baidu.com/s/1c0m7r0W</a> 密码: kgn6</li><li>贝克汉姆20大绝妙助攻 链接: <a href="http://pan.baidu.com/s/1ygCzk">http://pan.baidu.com/s/1ygCzk</a> 密码: qkvq</li><li>贝克汉姆30大经典进球 链接: <a href="http://pan.baidu.com/s/1o6IaWRK">http://pan.baidu.com/s/1o6IaWRK</a> 密码: qsgq</li><li>比利温格罗夫教你玩街头足球 链接: <a href="http://pan.baidu.com/s/1ntOi8Il">http://pan.baidu.com/s/1ntOi8Il</a> 密码: u6tm</li><li>顶级实战足球教程STR足训 链接: <a href="http://pan.baidu.com/s/1kTmYWp5">http://pan.baidu.com/s/1kTmYWp5</a> 密码: ypii</li><li>跟我踢足球教程 链接: <a href="http://pan.baidu.com/s/1qWBRlCw">http://pan.baidu.com/s/1qWBRlCw</a> 密码: dth4</li><li>冠军俱乐部足球教学 链接: <a href="http://pan.baidu.com/s/1kTnER3p">http://pan.baidu.com/s/1kTnER3p</a> 密码: n64e</li><li>科化足球视频教程 链接: <a href="http://pan.baidu.com/s/1eQrmOdO">http://pan.baidu.com/s/1eQrmOdO</a> 密码: xtgu</li><li>像贝克汉姆一样踢球 链接: <a href="http://pan.baidu.com/s/1i3ENvsL">http://pan.baidu.com/s/1i3ENvsL</a> 密码: wp6t</li><li>学踢足球入门教程 链接: <a href="http://pan.baidu.com/s/1gd4HYMn">http://pan.baidu.com/s/1gd4HYMn</a> 密码: q9wu</li><li>英国足球视频教程 链接: <a href="http://pan.baidu.com/s/1bnnpoOR">http://pan.baidu.com/s/1bnnpoOR</a> 密码: 4hxw</li><li>足球50大技巧 链接: <a href="http://pan.baidu.com/s/1bn8TUCB">http://pan.baidu.com/s/1bn8TUCB</a> 密码: 5dwx</li><li>足球训练技巧教程 链接: <a href="http://pan.baidu.com/s/1qW2xJp6">http://pan.baidu.com/s/1qW2xJp6</a> 密码: bfr8</li></ul><hr><p>室内设计:</p><ul><li>家居与室内设计风水视频教程 链接: <a href="http://pan.baidu.com/s/1pJ5NBHx">http://pan.baidu.com/s/1pJ5NBHx</a> 密码: fd7k</li><li>室内表现行业视频 链接: <a href="http://pan.baidu.com/s/1c1TKy">http://pan.baidu.com/s/1c1TKy</a> 密码: upst</li><li>室内设计CAD常用图库 链接: <a href="http://pan.baidu.com/s/1dD0cxLf">http://pan.baidu.com/s/1dD0cxLf</a> 密码: ez1j</li><li>室内设计《7000个装饰材料价格》 链接: <a href="http://pan.baidu.com/s/1i3IRg1J">http://pan.baidu.com/s/1i3IRg1J</a> 密码: 54xx</li><li>室内设计《工艺工法》 链接: <a href="http://pan.baidu.com/s/1o6kQWAI">http://pan.baidu.com/s/1o6kQWAI</a> 密码: vd7e</li><li>室内设计《家装风水大全》风水知识 链接: <a href="http://pan.baidu.com/s/1jGBx4ge">http://pan.baidu.com/s/1jGBx4ge</a> 密码: nkm8</li><li>室内设计《设计师理论参考资料:》理论设计常识 链接: <a href="http://pan.baidu.com/s/1nt7TAFv">http://pan.baidu.com/s/1nt7TAFv</a> 密码: 23dn</li><li>室内设计《施工工艺宝典》 链接: <a href="http://pan.baidu.com/s/1ntKeN9n">http://pan.baidu.com/s/1ntKeN9n</a> 密码: dten</li><li>室内设计《施工工艺视频》 链接: <a href="http://pan.baidu.com/s/1mgy2jkk">http://pan.baidu.com/s/1mgy2jkk</a> 密码: xre4</li><li>室内设计《室内设计常用尺寸表》人体工程学 链接: <a href="http://pan.baidu.com/s/1qWNw8pu">http://pan.baidu.com/s/1qWNw8pu</a> 密码: hads</li><li>室内设计视频教程 链接: <a href="http://pan.baidu.com/s/1c0nTjW0">http://pan.baidu.com/s/1c0nTjW0</a> 密码: riif</li></ul><hr><p>外语资料:</p><ul><li>大学德语高教版本mp3格式 链接: <a href="http://pan.baidu.com/s/1kTpaKab">http://pan.baidu.com/s/1kTpaKab</a> 密码: 7cnw</li><li>基础德语入门教程mp3格式 链接: <a href="http://pan.baidu.com/s/1sj5J6YL">http://pan.baidu.com/s/1sj5J6YL</a> 密码: yajk</li><li>新东方德语入门一月通 链接: <a href="http://pan.baidu.com/s/1pJGCXZH">http://pan.baidu.com/s/1pJGCXZH</a> 密码: mcvn</li><li>俄语小故事175集MP3格式 链接: <a href="http://pan.baidu.com/s/1bnCXGkf">http://pan.baidu.com/s/1bnCXGkf</a> 密码: nis4</li><li>实用商务俄语口语王全集MP3格式 链接: <a href="http://pan.baidu.com/s/1gd6dTC3">http://pan.baidu.com/s/1gd6dTC3</a> 密码: enen</li><li>法语零基础入门音标语音 链接: <a href="http://pan.baidu.com/s/1gdIVj1L">http://pan.baidu.com/s/1gdIVj1L</a> 密码: ivtg</li><li>法语入门走遍法国第一册上通关班 链接: <a href="http://pan.baidu.com/s/1jG5XPuY">http://pan.baidu.com/s/1jG5XPuY</a> 密码: 5xje</li><li>新东方法语入门一月通 链接: <a href="http://pan.baidu.com/s/1bnm9odT">http://pan.baidu.com/s/1bnm9odT</a> 密码: j27n</li><li>走遍法国语音教程MP3格式 链接: <a href="http://pan.baidu.com/s/1bndfORH">http://pan.baidu.com/s/1bndfORH</a> 密码: 5jfq</li><li>阿里郎电视台韩语视频教学 链接: <a href="http://pan.baidu.com/s/1i3nITM1">http://pan.baidu.com/s/1i3nITM1</a> 密码: 941a</li><li>标准韩语基础会话 链接: <a href="http://pan.baidu.com/s/1hqxowvE">http://pan.baidu.com/s/1hqxowvE</a> 密码: mfs8</li><li>标准韩语语音入门 链接: <a href="http://pan.baidu.com/s/1o6KcOzS">http://pan.baidu.com/s/1o6KcOzS</a> 密码: cmai</li><li>崔羲秀初级韩国语 链接: <a href="http://pan.baidu.com/s/1c0cxOLq">http://pan.baidu.com/s/1c0cxOLq</a> 密码: 4uiu</li><li>韩国高手会“踢的革命”教学片 链接: <a href="http://pan.baidu.com/s/1hqpgXTU">http://pan.baidu.com/s/1hqpgXTU</a> 密码: h6df</li><li>韩国会话3月通 链接: <a href="http://pan.baidu.com/s/1qW616Pm">http://pan.baidu.com/s/1qW616Pm</a> 密码: zsc6</li><li>韩国外国语大学《韩国语教程》 链接: <a href="http://pan.baidu.com/s/1mgmWRrE">http://pan.baidu.com/s/1mgmWRrE</a> 密码: 2u4y</li><li>韩国语课堂旅游基础会话 链接: <a href="http://pan.baidu.com/s/1mgtI0Jm">http://pan.baidu.com/s/1mgtI0Jm</a> 密码: mdpf</li><li>韩语口语8000字mp3格式 链接: <a href="http://pan.baidu.com/s/1bnApR5P">http://pan.baidu.com/s/1bnApR5P</a> 密码: xwu4</li><li>韩语口语900句mp3音频 链接: <a href="http://pan.baidu.com/s/1c010qru">http://pan.baidu.com/s/1c010qru</a> 密码: cdsu</li><li>韩语自学视频教程 链接: <a href="http://pan.baidu.com/s/1hqAL6TI">http://pan.baidu.com/s/1hqAL6TI</a> 密码: ic27</li><li>老版Let’sSpeakKorean视频教学 链接: <a href="http://pan.baidu.com/s/1pJ63AUR">http://pan.baidu.com/s/1pJ63AUR</a> 密码: pqnk</li><li>临时急需要马上说韩语 链接: <a href="http://pan.baidu.com/s/1sjJWInF">http://pan.baidu.com/s/1sjJWInF</a> 密码: 8q5p</li><li>零起点韩语口语入门 链接: <a href="http://pan.baidu.com/s/1pJ9RvHx">http://pan.baidu.com/s/1pJ9RvHx</a> 密码: gbhk</li><li>零起点韩语口语入门王视频 链接: <a href="http://pan.baidu.com/s/1gd5xVhD">http://pan.baidu.com/s/1gd5xVhD</a> 密码: h7p8</li><li>民族出版社韩国语MP3格式 链接: <a href="http://pan.baidu.com/s/1i3Gjn9N">http://pan.baidu.com/s/1i3Gjn9N</a> 密码: w7i7</li><li>实用初级韩国语教程 链接: <a href="http://pan.baidu.com/s/1mg9r5lY">http://pan.baidu.com/s/1mg9r5lY</a> 密码: dx2z</li><li>实用韩国语教程 链接: <a href="http://pan.baidu.com/s/1mgtI0JI">http://pan.baidu.com/s/1mgtI0JI</a> 密码: fi3r</li><li>实用韩语单词500个 链接: <a href="http://pan.baidu.com/s/1qW9jtDU">http://pan.baidu.com/s/1qW9jtDU</a> 密码: 4eyk</li><li>我为韩语狂入门篇 链接: <a href="http://pan.baidu.com/s/1qWn4Hmk">http://pan.baidu.com/s/1qWn4Hmk</a> 密码: ty7w</li><li>无师自通韩国语视频教程 链接: <a href="http://pan.baidu.com/s/1i3H5hhN">http://pan.baidu.com/s/1i3H5hhN</a> 密码: 6mhy</li><li>新版Let’sSpeakKorean 260集视频 链接: <a href="http://pan.baidu.com/s/1mgAD3eC">http://pan.baidu.com/s/1mgAD3eC</a> 密码: rd7r</li><li>新编中级韩国语MP3格式 链接: <a href="http://pan.baidu.com/s/1dD0cxNj">http://pan.baidu.com/s/1dD0cxNj</a> 密码: ysxp</li><li>新东方韩语入门一月通 链接: <a href="http://pan.baidu.com/s/1c06kchE">http://pan.baidu.com/s/1c06kchE</a> 密码: ng25</li><li>新概念韩国语视频 链接: <a href="http://pan.baidu.com/s/1kTpaKbd">http://pan.baidu.com/s/1kTpaKbd</a> 密码: kpbh</li><li>中韩交流标准韩国语 链接: <a href="http://pan.baidu.com/s/1qW5fBTq">http://pan.baidu.com/s/1qW5fBTq</a> 密码: sxqi</li><li>中韩交流实用韩国语 链接: <a href="http://pan.baidu.com/s/1pJusrNH">http://pan.baidu.com/s/1pJusrNH</a> 密码: ft8u</li><li>Erin挑战！学会日语视频25讲 链接: <a href="http://pan.baidu.com/s/1ntIcYnf">http://pan.baidu.com/s/1ntIcYnf</a> 密码: m9bn</li><li>Go Go Japan第一季8集 链接: <a href="http://pan.baidu.com/s/1bnCXGAV">http://pan.baidu.com/s/1bnCXGAV</a> 密码: h6p8</li><li>北海道漫游记 链接: <a href="http://pan.baidu.com/s/1bnrsWl5">http://pan.baidu.com/s/1bnrsWl5</a> 密码: 1xa5</li><li>标准日本语 链接: <a href="http://pan.baidu.com/s/1ntABznz">http://pan.baidu.com/s/1ntABznz</a> 密码: bsgv</li><li>标准日语初级教程 链接: <a href="http://pan.baidu.com/s/1bn4kmfl">http://pan.baidu.com/s/1bn4kmfl</a> 密码: ckji</li><li>别笑！我是日语学习书MP3格式 链接: <a href="http://pan.baidu.com/s/1pJOK2uB">http://pan.baidu.com/s/1pJOK2uB</a> 密码: 4h5p</li><li>超简单-手绘旅游日语MP3格式 链接: <a href="http://pan.baidu.com/s/1ntoqMTF">http://pan.baidu.com/s/1ntoqMTF</a> 密码: sjrg</li><li>从日本中小学课本学日文 链接: <a href="http://pan.baidu.com/s/1jG2AaA6">http://pan.baidu.com/s/1jG2AaA6</a> 密码: v1db</li><li>大家的日本语(1-2册)MP3格式 链接: <a href="http://pan.baidu.com/s/1qWoQC8k">http://pan.baidu.com/s/1qWoQC8k</a> 密码: 3g8k</li><li>大学日语专业四级轻松过级一点通mp3格式 链接: <a href="http://pan.baidu.com/s/1kTDxt3L">http://pan.baidu.com/s/1kTDxt3L</a> 密码: mppu</li><li>蛋蛋动漫日语学堂70讲 链接: <a href="http://pan.baidu.com/s/1gd2aibx">http://pan.baidu.com/s/1gd2aibx</a> 密码: jxn9</li><li>东京印象 链接: <a href="http://pan.baidu.com/s/1o6rC5rc">http://pan.baidu.com/s/1o6rC5rc</a> 密码: k98i</li><li>读唐诗学日语汉字MP3格式 链接: <a href="http://pan.baidu.com/s/1mg3lUNQ">http://pan.baidu.com/s/1mg3lUNQ</a> 密码: 4a2r</li><li>短期掌握日本语能力测试N1级 链接: <a href="http://pan.baidu.com/s/1sjFSWwt">http://pan.baidu.com/s/1sjFSWwt</a> 密码: b74a</li><li>疯狂日语MP3版7讲 链接: <a href="http://pan.baidu.com/s/1sjA3rAl">http://pan.baidu.com/s/1sjA3rAl</a> 密码: sqvk</li><li>跟NHK学简明日语 链接: <a href="http://pan.baidu.com/s/1qW9Pw3y">http://pan.baidu.com/s/1qW9Pw3y</a> 密码: gt9k</li><li>沪江日语 链接: <a href="http://pan.baidu.com/s/1pJ0xUTP">http://pan.baidu.com/s/1pJ0xUTP</a> 密码: 9xi3</li><li>环游日本学日语 链接: <a href="http://pan.baidu.com/s/1fPIZc">http://pan.baidu.com/s/1fPIZc</a> 密码: fete</li><li>叫醒耳朵日语会话通3000句日常日语句型 链接: <a href="http://pan.baidu.com/s/1pJiNaqf">http://pan.baidu.com/s/1pJiNaqf</a> 密码: 71yd</li><li>口语及短句888个4讲MP3格式 链接: <a href="http://pan.baidu.com/s/18pZXG">http://pan.baidu.com/s/18pZXG</a> 密码: div3</li><li>来去日本第二季17集 链接: <a href="http://pan.baidu.com/s/1sjn2H1V">http://pan.baidu.com/s/1sjn2H1V</a> 密码: 23ve</li><li>赖户内海心动之旅5集 链接: <a href="http://pan.baidu.com/s/1qWzFUI4">http://pan.baidu.com/s/1qWzFUI4</a> 密码: 9feh</li><li>老外最想与你聊的100日语话题 链接: <a href="http://pan.baidu.com/s/1bfYUU">http://pan.baidu.com/s/1bfYUU</a> 密码: xu45</li><li>日本九州北部之旅5集 链接: <a href="http://pan.baidu.com/s/1kTnERVD">http://pan.baidu.com/s/1kTnERVD</a> 密码: 817r</li><li>日本语能力测试1234级词汇背诵手册MP3版 链接: <a href="http://pan.baidu.com/s/1gdCP8zD">http://pan.baidu.com/s/1gdCP8zD</a> 密码: w42w</li><li>日英双解辞典 链接: <a href="http://pan.baidu.com/s/1ntwyoZJ">http://pan.baidu.com/s/1ntwyoZJ</a> 密码: 7jnd</li><li>日语300句 链接: <a href="http://pan.baidu.com/s/1pJ3LK3T">http://pan.baidu.com/s/1pJ3LK3T</a> 密码: 7vgd</li><li>日语初级1-24集MP3格式 链接: <a href="http://pan.baidu.com/s/1mgBtz2g">http://pan.baidu.com/s/1mgBtz2g</a> 密码: 8x7r</li><li>日语基础中央广播电视大学教学视频40集 链接: <a href="http://pan.baidu.com/s/1c054gBQ">http://pan.baidu.com/s/1c054gBQ</a> 密码: egjr</li><li>日语口译综合能力（二级）mp3格式 链接: <a href="http://pan.baidu.com/s/1sjsSriH">http://pan.baidu.com/s/1sjsSriH</a> 密码: uj4r</li><li>日语口语900句音频教程 链接: <a href="http://pan.baidu.com/s/1jGxQqfs">http://pan.baidu.com/s/1jGxQqfs</a> 密码: q83c</li><li>日语口语王想说就说mp3格式 链接: <a href="http://pan.baidu.com/s/1eQ2cjse">http://pan.baidu.com/s/1eQ2cjse</a> 密码: gyk1</li><li>日语能力考试2级听力模拟训练DOC文本MP3格式 链接: <a href="http://pan.baidu.com/s/1sjt8qC1%E5%AF%86%E7%A0%81">http://pan.baidu.com/s/1sjt8qC1密码</a>: ce8h</li><li>日语能力考试二级听力模拟训练MP3格式 链接: <a href="http://pan.baidu.com/s/1hqhFz1a">http://pan.baidu.com/s/1hqhFz1a</a> 密码: gbxm</li><li>日语一月通全套教程合集 链接: <a href="http://pan.baidu.com/s/1ntl8WpN">http://pan.baidu.com/s/1ntl8WpN</a> 密码: 6v1u</li><li>商务日语教程 链接: <a href="http://pan.baidu.com/s/1i3pKT4D">http://pan.baidu.com/s/1i3pKT4D</a> 密码: mn42</li><li>上外新编日语答疑解难视频 链接: <a href="http://pan.baidu.com/s/1o6zJZN8">http://pan.baidu.com/s/1o6zJZN8</a> 密码: n3v4</li><li>生活日语半日通 链接: <a href="http://pan.baidu.com/s/1c0tsMFA">http://pan.baidu.com/s/1c0tsMFA</a> 密码: 8ukk</li><li>实用初级日语视频教程32讲 链接: <a href="http://pan.baidu.com/s/1fPIZO">http://pan.baidu.com/s/1fPIZO</a> 密码: ev2w</li><li>实用日语口语句典MP3格式 链接: <a href="http://pan.baidu.com/s/1sj2vHST">http://pan.baidu.com/s/1sj2vHST</a> 密码: 6bmh</li><li>哇!原来这句日语这样说! 链接: <a href="http://pan.baidu.com/s/1o67l6no">http://pan.baidu.com/s/1o67l6no</a> 密码: zmpq</li><li>无师自通日本语口语MP3格式 链接: <a href="http://pan.baidu.com/s/1ntCDtd3">http://pan.baidu.com/s/1ntCDtd3</a> 密码: 5sya</li><li>现在就说日语 链接: <a href="http://pan.baidu.com/s/1c0lRrfq">http://pan.baidu.com/s/1c0lRrfq</a> 密码: tc69</li><li>新版标准日本语 链接: <a href="http://pan.baidu.com/s/1sj0ZPMX">http://pan.baidu.com/s/1sj0ZPMX</a> 密码: fmgr</li><li>新编日语1-4册MP3格式全套 链接: <a href="http://pan.baidu.com/s/1kT3nVIB">http://pan.baidu.com/s/1kT3nVIB</a> 密码: eurw</li><li>新编日语教程1-5册MP3格式 链接: <a href="http://pan.baidu.com/s/1qWOI1Uc">http://pan.baidu.com/s/1qWOI1Uc</a> 密码: gxs5</li><li>新编日语修订本mp3格式4册 链接: <a href="http://pan.baidu.com/s/1kTzQh3x">http://pan.baidu.com/s/1kTzQh3x</a> 密码: 861q</li><li>新编生活日语视频25讲 链接: <a href="http://pan.baidu.com/s/1qWFUUq4">http://pan.baidu.com/s/1qWFUUq4</a> 密码: 7ipe</li><li>新东方日语讲义 链接: <a href="http://pan.baidu.com/s/1mgy2jA4">http://pan.baidu.com/s/1mgy2jA4</a> 密码: jfjc</li><li>新东方日语入门一月通 链接: <a href="http://pan.baidu.com/s/1gdvo8bL">http://pan.baidu.com/s/1gdvo8bL</a> 密码: 2v9w</li><li>新东方日语一级讲座视频教程 链接: <a href="http://pan.baidu.com/s/1qWBlnC4">http://pan.baidu.com/s/1qWBlnC4</a> 密码: mrtv</li><li>新概念日语视频教学15集 链接: <a href="http://pan.baidu.com/s/1g5ECe">http://pan.baidu.com/s/1g5ECe</a> 密码: hn7j</li><li>新日本语能力测试N3词汇背诵手册mp3版 链接: <a href="http://pan.baidu.com/s/1o6A9vPS">http://pan.baidu.com/s/1o6A9vPS</a> 密码: xw5p</li><li>学日语高手系列-流行口语及短句888个 链接: <a href="http://pan.baidu.com/s/1c0Er5WO">http://pan.baidu.com/s/1c0Er5WO</a> 密码: 6xkt</li><li>樱花日语多媒体课程12级别 链接: <a href="http://pan.baidu.com/s/1o6qq9cu">http://pan.baidu.com/s/1o6qq9cu</a> 密码: 2hfg</li><li>原来日语这样说MP3格式71讲 链接: <a href="http://pan.baidu.com/s/1dDItprb">http://pan.baidu.com/s/1dDItprb</a> 密码: epxa</li><li>张向荣日语教程 链接: <a href="http://pan.baidu.com/s/1kTlDbbL">http://pan.baidu.com/s/1kTlDbbL</a> 密码: ann5</li><li>中日交流标准日本语 链接: <a href="http://pan.baidu.com/s/1mgsw65U">http://pan.baidu.com/s/1mgsw65U</a> 密码: 6dav</li><li>走遍日本教程 链接: <a href="http://pan.baidu.com/s/1o60zW9s">http://pan.baidu.com/s/1o60zW9s</a> 密码: axh3</li><li>大学泰语听力教程 链接: <a href="http://pan.baidu.com/s/1eQ2cjvk">http://pan.baidu.com/s/1eQ2cjvk</a> 密码: 43v7</li><li>基础泰语MP3格式 链接: <a href="http://pan.baidu.com/s/1eQ8NOiu">http://pan.baidu.com/s/1eQ8NOiu</a> 密码: yhdx</li><li>实用初级泰国语视频教学 链接: <a href="http://pan.baidu.com/s/1o6zee3g">http://pan.baidu.com/s/1o6zee3g</a> 密码: n33g</li><li>泰语入门基础课程文字教程 链接: <a href="http://pan.baidu.com/s/1o6j4Znc">http://pan.baidu.com/s/1o6j4Znc</a> 密码: kfam</li><li>新东方西班牙语入门一月通 链接: <a href="http://pan.baidu.com/s/1hqyAvuW">http://pan.baidu.com/s/1hqyAvuW</a> 密码: j7kb</li><li>新东方新概念英语1-4册 链接: <a href="http://pan.baidu.com/s/1o6MKDPC">http://pan.baidu.com/s/1o6MKDPC</a> 密码: 3ay4</li><li>新概念英语1-4册视频教程 链接: <a href="http://pan.baidu.com/s/1jGAH7JC">http://pan.baidu.com/s/1jGAH7JC</a> 密码: wrsu</li><li>新概念英语精品课堂mp3格式 链接: <a href="http://pan.baidu.com/s/1bnbJUe7">http://pan.baidu.com/s/1bnbJUe7</a> 密码: 3ara</li><li>365天英语口语大全 链接: <a href="http://pan.baidu.com/s/1dhTF4">http://pan.baidu.com/s/1dhTF4</a> 密码: eu3w</li><li>9小时快学国际音标 链接: <a href="http://pan.baidu.com/s/1gdEl1BX">http://pan.baidu.com/s/1gdEl1BX</a> 密码: ba37</li><li>海伦从零开始英语音标 链接: <a href="http://pan.baidu.com/s/1ntkTbb7">http://pan.baidu.com/s/1ntkTbb7</a> 密码: x12k</li><li>新东方4+1课堂教程 链接: <a href="http://pan.baidu.com/s/1mgxgosg">http://pan.baidu.com/s/1mgxgosg</a> 密码: 69tq</li><li>新东方王强口语全集 链接: <a href="http://pan.baidu.com/s/1sjC5hmt">http://pan.baidu.com/s/1sjC5hmt</a> 密码: au3a</li><li>英语口音纠正课程 链接: <a href="http://pan.baidu.com/s/1ucP3o">http://pan.baidu.com/s/1ucP3o</a> 密码: ygcn</li><li>英语口语8000句 链接: <a href="http://pan.baidu.com/s/1kTCHsI7">http://pan.baidu.com/s/1kTCHsI7</a> 密码: 9qqr</li><li>英语口语900句系列 链接: <a href="http://pan.baidu.com/s/1qWMa9u0">http://pan.baidu.com/s/1qWMa9u0</a> 密码: 2t3t</li></ul><hr><p>网店资料:</p><ul><li>(176套)宝贝描述模板 链接: <a href="http://pan.baidu.com/s/1jGxktzo">http://pan.baidu.com/s/1jGxktzo</a> 密码: dgk6</li><li>(2442款)促销水印模板 链接: <a href="http://pan.baidu.com/s/1dDtWHQp">http://pan.baidu.com/s/1dDtWHQp</a> 密码: 6uxh</li><li>(2864款)店铺装修漂亮素材 链接: <a href="http://pan.baidu.com/s/1jGowPym">http://pan.baidu.com/s/1jGowPym</a> 密码: 2tfr</li><li>(45套)宝贝团购模板 链接: <a href="http://pan.baidu.com/s/1dDrUQjB">http://pan.baidu.com/s/1dDrUQjB</a> 密码: wgb6</li><li>2000多款网店轮播海报 链接: <a href="http://pan.baidu.com/s/1qWmiNqk">http://pan.baidu.com/s/1qWmiNqk</a> 密码: 5nij</li><li>200多款服装宝贝描述模板 链接: <a href="http://pan.baidu.com/s/1jGowPwE">http://pan.baidu.com/s/1jGowPwE</a> 密码: zi3w</li><li>200多款首页装修PSD模板 链接: <a href="http://pan.baidu.com/s/1eQvW6CM">http://pan.baidu.com/s/1eQvW6CM</a> 密码: s63a</li><li>600多款宝贝描述模板 链接: <a href="http://pan.baidu.com/s/1jGBx4Bc">http://pan.baidu.com/s/1jGBx4Bc</a> 密码: 9dsn</li><li>700多款直通车广告图 链接: <a href="http://pan.baidu.com/s/1kTIhd9H">http://pan.baidu.com/s/1kTIhd9H</a> 密码: eaaz</li><li>淘宝教程 链接: <a href="http://pan.baidu.com/s/1ntknbVN">http://pan.baidu.com/s/1ntknbVN</a> 密码: 7t7p</li></ul><hr><p>维修资料:</p><ul><li>摩托车维修技术 链接: <a href="http://pan.baidu.com/s/1FH8vG">http://pan.baidu.com/s/1FH8vG</a> 密码: driv</li><li>奥迪A6电喷系统的原理与检测 链接: <a href="http://pan.baidu.com/s/1ntmoRTR">http://pan.baidu.com/s/1ntmoRTR</a> 密码: 5cbx</li><li>电喷系统结构原理及故障诊断 链接: <a href="http://pan.baidu.com/s/1kT7rFIv">http://pan.baidu.com/s/1kT7rFIv</a> 密码: mmp5</li><li>都市先锋-捷达王-捷达轿车电喷系统检修 链接: <a href="http://pan.baidu.com/s/1sjNu6z7">http://pan.baidu.com/s/1sjNu6z7</a> 密码: x9ft</li><li>富康轿车电喷系统检测与维修 链接: <a href="http://pan.baidu.com/s/1qWDTfZ2">http://pan.baidu.com/s/1qWDTfZ2</a> 密码: yg1v</li><li>捷达电喷系统检测与维修 链接: <a href="http://pan.baidu.com/s/1c0llsmW">http://pan.baidu.com/s/1c0llsmW</a> 密码: rsk6</li><li>桑塔纳2000GSI电喷系统检测与维修 链接: <a href="http://pan.baidu.com/s/1jGgVsNW">http://pan.baidu.com/s/1jGgVsNW</a> 密码: pfr1</li><li>雅阁电喷系统检测与维修 链接: <a href="http://pan.baidu.com/s/1bnDDATD">http://pan.baidu.com/s/1bnDDATD</a> 密码: trhq</li><li>电控发动机波形分析视频教程 链接: <a href="http://pan.baidu.com/s/1jG6DKCA">http://pan.baidu.com/s/1jG6DKCA</a> 密码: 7c8x</li><li>魏俊强电控发动机故障诊断高级讲解 链接: <a href="http://pan.baidu.com/s/1qWp68pA">http://pan.baidu.com/s/1qWp68pA</a> 密码: sy4b</li><li>朱军电控发动机波形分析 链接: <a href="http://pan.baidu.com/s/1qFbmI">http://pan.baidu.com/s/1qFbmI</a> 密码: zpq6</li><li>朱军电控发动机原理与诊断 链接: <a href="http://pan.baidu.com/s/1sjLYArN">http://pan.baidu.com/s/1sjLYArN</a> 密码: 1peg</li><li>东风牌D6114型柴油机使用技巧 链接: <a href="http://pan.baidu.com/s/1gdfF5QV">http://pan.baidu.com/s/1gdfF5QV</a> 密码: nsub</li><li>丰田普锐斯原厂技术培训视频(英文) 链接: <a href="http://pan.baidu.com/s/1c02MnW8">http://pan.baidu.com/s/1c02MnW8</a> 密码: vekr</li><li>跟我学汽车养护 链接: <a href="http://pan.baidu.com/s/1dDAlLxZ">http://pan.baidu.com/s/1dDAlLxZ</a> 密码: 5g67</li><li>金奔腾汽车电脑解码器使用方法 链接: <a href="http://pan.baidu.com/s/1bn99TYR">http://pan.baidu.com/s/1bn99TYR</a> 密码: gjif</li><li>汽车必需设施的安装 链接: <a href="http://pan.baidu.com/s/1dDvsB9f">http://pan.baidu.com/s/1dDvsB9f</a> 密码: a8ej</li><li>汽车电器与电子控制技术 链接: <a href="http://pan.baidu.com/s/1hqivuMo">http://pan.baidu.com/s/1hqivuMo</a> 密码: 68ji</li><li>汽车电子技术与检测仪器的应用 链接: <a href="http://pan.baidu.com/s/1bnoBfFh">http://pan.baidu.com/s/1bnoBfFh</a> 密码: 5haq</li><li>汽车各部件工作原理视频 链接: <a href="http://pan.baidu.com/s/1qW3JIt2">http://pan.baidu.com/s/1qW3JIt2</a> 密码: jkwf</li><li>汽车故障高级诊断技术 链接: <a href="http://pan.baidu.com/s/1eQjLvns">http://pan.baidu.com/s/1eQjLvns</a> 密码: e4tr</li><li>汽车故障诊断基本思路 链接: <a href="http://pan.baidu.com/s/1c0sCR0c">http://pan.baidu.com/s/1c0sCR0c</a> 密码: v6g4</li><li>汽车驾驶学习技巧 链接: <a href="http://pan.baidu.com/s/1i3grxHV">http://pan.baidu.com/s/1i3grxHV</a> 密码: hmda</li><li>汽车喷漆涂装技术 链接: <a href="http://pan.baidu.com/s/1qWxEbMk">http://pan.baidu.com/s/1qWxEbMk</a> 密码: 6tnd</li><li>汽车音响防盗 气囊修复 仪表芯片解密 链接: <a href="http://pan.baidu.com/s/1sjyXV8h">http://pan.baidu.com/s/1sjyXV8h</a> 密码: 7gej</li><li>汽车在途中常见故障应急修理 链接: <a href="http://pan.baidu.com/s/1gdjJqp1">http://pan.baidu.com/s/1gdjJqp1</a> 密码: rbsc</li><li>汽车专业英语视频教程 链接: <a href="http://pan.baidu.com/s/1gdjJqpH">http://pan.baidu.com/s/1gdjJqpH</a> 密码: mt6e</li><li>数据流分析方法视频教程 链接: <a href="http://pan.baidu.com/s/1kTEJqUr">http://pan.baidu.com/s/1kTEJqUr</a> 密码: zjkq</li><li>现代汽车电控系统诊断新理念 链接: <a href="http://pan.baidu.com/s/1mgFxmbA">http://pan.baidu.com/s/1mgFxmbA</a> 密码: mnkr</li><li>蓄电池修理技术视频教程 链接: <a href="http://pan.baidu.com/s/1mg04cFQ">http://pan.baidu.com/s/1mg04cFQ</a> 密码: 2yn3</li><li>玉林YC4110ZQ柴油机装配工艺 链接: <a href="http://pan.baidu.com/s/1sjG8P21">http://pan.baidu.com/s/1sjG8P21</a> 密码: 7pct</li><li>朱军自动变速器原理与诊断 链接: <a href="http://pan.baidu.com/s/1i3grxIH">http://pan.baidu.com/s/1i3grxIH</a> 密码: x95p</li><li>自动变速器结构原理与检修 链接: <a href="http://pan.baidu.com/s/1ygCV0">http://pan.baidu.com/s/1ygCV0</a> 密码: 37k4</li><li>跟我学汽车美容 链接: <a href="http://pan.baidu.com/s/1jGMmNUu">http://pan.baidu.com/s/1jGMmNUu</a> 密码: 5efm</li><li>汽车美容视频教程 链接: <a href="http://pan.baidu.com/s/1dDo7fBN">http://pan.baidu.com/s/1dDo7fBN</a> 密码: pjuh</li><li>汽车美容与装饰 链接: <a href="http://pan.baidu.com/s/1dD1yorn">http://pan.baidu.com/s/1dD1yorn</a> 密码: meg7</li><li>汽车内外饰物的安装 链接: <a href="http://pan.baidu.com/s/1qWyZY3M">http://pan.baidu.com/s/1qWyZY3M</a> 密码: zdeu</li><li>本田汽车维修视频 链接: <a href="http://pan.baidu.com/s/1dDEp6Xr">http://pan.baidu.com/s/1dDEp6Xr</a> 密码: 7n9i</li><li>大众汽车维修视频 链接: <a href="http://pan.baidu.com/s/1hqvm7Ta">http://pan.baidu.com/s/1hqvm7Ta</a> 密码: 2vz2</li><li>大众自动变速器构造原理与维修 链接: <a href="http://pan.baidu.com/s/1gdlflBl">http://pan.baidu.com/s/1gdlflBl</a> 密码: hu7c</li><li>国产轿车维修跟我学 链接: <a href="http://pan.baidu.com/s/1qWxEbMG">http://pan.baidu.com/s/1qWxEbMG</a> 密码: faf1</li><li>机修技师中高级视频教程 链接: <a href="http://pan.baidu.com/s/1eQfHAlO">http://pan.baidu.com/s/1eQfHAlO</a> 密码: vg7w</li><li>轿车维修文字教程 链接: <a href="http://pan.baidu.com/s/1ntwypg1">http://pan.baidu.com/s/1ntwypg1</a> 密码: ehuc</li><li>捷达车系维修技术 链接: <a href="http://pan.baidu.com/s/1nt3jRjb">http://pan.baidu.com/s/1nt3jRjb</a> 密码: 983y</li><li>汽车车身修复教程 链接: <a href="http://pan.baidu.com/s/1c032kvu">http://pan.baidu.com/s/1c032kvu</a> 密码: yfnb</li><li>汽车电脑工作原理与检修 链接: <a href="http://pan.baidu.com/s/1c0cxPrM">http://pan.baidu.com/s/1c0cxPrM</a> 密码: 94dt</li><li>汽车机修教学视频教程 链接: <a href="http://pan.baidu.com/s/1mgosNk0">http://pan.baidu.com/s/1mgosNk0</a> 密码: m3ge</li><li>汽车维修高级工培训视频教程 链接: <a href="http://pan.baidu.com/s/1pJwujcn">http://pan.baidu.com/s/1pJwujcn</a> 密码: wbj1</li><li>汽车维修工中高级视频教程 链接: <a href="http://pan.baidu.com/s/1c0pUY0C">http://pan.baidu.com/s/1c0pUY0C</a> 密码: un2m</li><li>汽车维修技师技能训练教程 链接: <a href="http://pan.baidu.com/s/1ntpCDZV">http://pan.baidu.com/s/1ntpCDZV</a> 密码: jqyd</li><li>汽车维修技术视频教程 链接: <a href="http://pan.baidu.com/s/1c00ewNY">http://pan.baidu.com/s/1c00ewNY</a> 密码: tmd4</li><li>汽车维修职业技能培训教材 链接: <a href="http://pan.baidu.com/s/1pJ1dRMr">http://pan.baidu.com/s/1pJ1dRMr</a> 密码: 88vs</li><li>汽车维修自学通视频教程 链接: <a href="http://pan.baidu.com/s/1eQB5FvO">http://pan.baidu.com/s/1eQB5FvO</a> 密码: cc2b</li><li>汽修电工视频教程 链接: <a href="http://pan.baidu.com/s/1pJNy9cv">http://pan.baidu.com/s/1pJNy9cv</a> 密码: s1ry</li><li>汽修手册文字资料 链接: <a href="http://pan.baidu.com/s/1pJmQMBT">http://pan.baidu.com/s/1pJmQMBT</a> 密码: 24nq</li><li>汽修专家讲汽修视频教程 链接: <a href="http://pan.baidu.com/s/1jGELtTc">http://pan.baidu.com/s/1jGELtTc</a> 密码: rqe1</li><li>通用五菱汽车维修视频 链接: <a href="http://pan.baidu.com/s/1mgMOHks">http://pan.baidu.com/s/1mgMOHks</a> 密码: fxgj</li><li>现代伊兰特维修视频 链接: <a href="http://pan.baidu.com/s/1gd4HZt5">http://pan.baidu.com/s/1gd4HZt5</a> 密码: 82ry</li><li>新编电动自行车维修速成 链接: <a href="http://pan.baidu.com/s/1o6tEwS6">http://pan.baidu.com/s/1o6tEwS6</a> 密码: u354</li><li>玉林YC6105柴油机的装拆与维修 链接: <a href="http://pan.baidu.com/s/1sjHUOMh">http://pan.baidu.com/s/1sjHUOMh</a> 密码: 8wrc</li><li>自动变速箱维修视频教程 链接: <a href="http://pan.baidu.com/s/1kTKiXrp">http://pan.baidu.com/s/1kTKiXrp</a> 密码: tem3</li><li>液晶电视维修教程 链接: <a href="http://pan.baidu.com/s/1i37vKxv">http://pan.baidu.com/s/1i37vKxv</a> 密码: nms4</li><li>电动车维修视频教程 链接: <a href="http://pan.baidu.com/s/1mgxMox6">http://pan.baidu.com/s/1mgxMox6</a> 密码: i648</li></ul><hr><p>本文永久地址：<a href="http://blog.itrover.cf/?p=215" title="http://blog.itrover.cf/?p=215">http://blog.itrover.cf/?p=215</a> 转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个孤独的人</title>
      <link href="/2017/diary06-25/index/"/>
      <url>/2017/diary06-25/index/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ul><li><p>你好，听说你很神奇，我现在一个人，不知道要干什么，该干什么。</p></li><li><p>很孤独，很难过。</p></li><li><p>我想去到一个没有人认识的地方。</p></li><li><p>我不想跟别人聊天，就真的没有人跟我聊天。</p></li><li><p>很多事，我就想一个失败者。</p></li><li><p>我现在每天活的好像一个行尸走肉，没有目的。</p></li><li><p>自己都不知道自己在干什么。</p></li><li><p>我想要抓住什么稻草，客户说没有什么可以让我抓。</p></li><li><p>我更难过</p></li><li><p>真的是失败，失败者。</p></li><li><p>好希望有人能来解救我。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日记心事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记心事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 11种基本语法</title>
      <link href="/2017/markdown/index/"/>
      <url>/2017/markdown/index/</url>
      
        <content type="html"><![CDATA[<h2 id="现在是我在学习MARKDOWN时做的笔记。学完这些MARKDOWN的基本使用已经不成问题。"><a href="#现在是我在学习MARKDOWN时做的笔记。学完这些MARKDOWN的基本使用已经不成问题。" class="headerlink" title="现在是我在学习MARKDOWN时做的笔记。学完这些MARKDOWN的基本使用已经不成问题。"></a><strong>现在是我在学习MARKDOWN时做的笔记。学完这些MARKDOWN的基本使用已经不成问题。</strong></h2><h3 id="标题设置（让字体变大，和word的标题意思一样）"><a href="#标题设置（让字体变大，和word的标题意思一样）" class="headerlink" title="标题设置（让字体变大，和word的标题意思一样）"></a>标题设置（让字体变大，和word的标题意思一样）</h3><p>在Markdown当中设置标题，有两种方式：<br>第一种：通过在文字下方添加“&#x3D;”和“-”，他们分别表示一级标题和二级标题。<br>第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</p><h3 id="块注释（blockquote）"><a href="#块注释（blockquote）" class="headerlink" title="块注释（blockquote）"></a>块注释（blockquote）</h3><p>通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。）</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>在文字开头添加(<em>, +, and -)实现无序列表。但是要注意在(</em>, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字后面跟上句号。（还要有空格）</p><h3 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h3><p>Markdown中有两种方式，实现链接，分别为内联方式和引用方式。<br>内联方式：This is an [example link](<a href="http://example.com/">http://example.com/</a>).<br>引用方式：<br>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].<br>[1]: <a href="http://google.com/">http://google.com/</a>        “Google”<br>[2]: <a href="http://search.yahoo.com/">http://search.yahoo.com/</a>  “Yahoo Search”<br>[3]: <a href="http://search.msn.com/">http://search.msn.com/</a>    “MSN Search”</p><h3 id="图片（Images）"><a href="#图片（Images）" class="headerlink" title="图片（Images）"></a>图片（Images）</h3><p>图片的处理方式和链接的处理方式，非常的类似。<br>内联方式：![alt text] (&#x2F;path&#x2F;to&#x2F;img.jpg “Title”)<br>引用方式：<br>![alt text] [id]<br>[id]: &#x2F;path&#x2F;to&#x2F;img.jpg “Title”</p><h3 id="代码（HTML中所谓的Code）"><a href="#代码（HTML中所谓的Code）" class="headerlink" title="代码（HTML中所谓的Code）"></a>代码（HTML中所谓的Code）</h3><blockquote><p>实现方式有两种：<br>第一种：简单文字出现一个代码框。使用<code> &lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~，数字1左边的按键</code>）<br>第二种：大片文字需要实现代码框。使用Tab和四个空格。</p></blockquote><h3 id="脚注（footnote）"><a href="#脚注（footnote）" class="headerlink" title="脚注（footnote）"></a>脚注（footnote）</h3><p>实现方式如下：<br>hello[^hello]<br>[^hello]: hi</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）</p><h3 id="References："><a href="#References：" class="headerlink" title="References："></a>References：</h3><p>以上内容根据官方文档基本文档进行整理。<a href="http://daringfireball.net/projects/markdown/basics">http://daringfireball.net/projects/markdown/basics</a><br>Markdown官方网站：<a href="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a></p><p>推荐一款在线的Markdown编辑器：<a href="https://stackedit.io/">https://stackedit.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程分享 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown语法 </tag>
            
            <tag> 教程分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业季</title>
      <link href="/2017/graduation/index/"/>
      <url>/2017/graduation/index/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/baim-hanif-89800.jpg"></p><span id="more"></span><p><strong>自以为是不会恋旧的人。</strong><br><strong>教室里弥漫着诡异的气息，</strong><br><strong>有人叠起了纸飞机，</strong><br><strong>然后去争抢那三尺宽的阳台，</strong><br><strong>飞机飞向对面的楼顶。</strong><br><strong>就像蚂蚱到了秋天，</strong><br><strong>原本平行线上的两个人有了交集，</strong><br><strong>连暧昧都变得明显。</strong><br><strong>十一点，</strong><br><strong>手机照亮出门的路，</strong><br><strong>风扇一晚上没有休息，</strong><br><strong>喇叭里音乐孤独地响，</strong><br><strong>橘黄的路灯奄奄一息。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日记心事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记心事 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
